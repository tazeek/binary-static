/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var exportAllFunctions = function exportAllFunctions(obj) {
	    Object.keys(obj).forEach(function (key) {
	        window[key] = obj[key];
	    });
	};

	window.$ = window.jQuery = __webpack_require__(1);

	__webpack_require__(2);
	__webpack_require__(299);

	// created for handling global onclick
	exportAllFunctions(__webpack_require__(302));
	// used by gtm to update page after a new release
	exportAllFunctions(__webpack_require__(468));

	__webpack_require__(469);
	__webpack_require__(470);
	__webpack_require__(471);
	__webpack_require__(472);

	__webpack_require__(473);

	var BinaryLoader = __webpack_require__(474);

	$(window).on('load', BinaryLoader.init);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.2.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-05-20T17:23Z
	 */

	(function( global, factory ) {

		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];

	var document = window.document;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};



	var
		version = "2.2.4",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?

				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :

				// Return all the elements in a clean array
				slice.call( this );
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {

			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
		},

		isPlainObject: function( obj ) {
			var key;

			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}

			// Not own constructor property must be Object
			if ( obj.constructor &&
					!hasOwn.call( obj, "constructor" ) &&
					!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for ( key in obj ) {}

			return key === undefined || hasOwn.call( obj, key );
		},

		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;

			code = jQuery.trim( code );

			if ( code ) {

				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf( "use strict" ) === 1 ) {
					script = document.createElement( "script" );
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {

					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval

					indirect( code );
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	/* jshint ignore: end */

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.1
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-10-17
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,
		rescape = /'|\\/g,

		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, nidselect, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rescape, "\\$&" );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
						while ( i-- ) {
							groups[i] = nidselect + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");

		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( (parent = document.defaultView) && parent.top !== parent ) {
			// Support: IE 11
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( document.createComment("") );
			return !div.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					return m ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];

			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},

			"disabled": function( elem ) {
				return elem.disabled === true;
			},

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( (oldCache = uniqueCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ dir ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;



	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			} );

		}

		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );

		}

		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}

			qualifier = jQuery.filter( qualifier, elements );
		}

		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {

							// Inject the element directly into the jQuery object
							this.length = 1;
							this[ 0 ] = elem;
						}

						this.context = document;
						this.selector = selector;
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;

			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( pos ?
						pos.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnotwhite = ( /\S+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this === promise ? newDefer.promise() : this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];

				// promise[ done | fail | progress ] = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add( function() {

						// state = [ resolved | rejected ]
						state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}

				// deferred[ resolve | reject | notify ]
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,

				// the count of uncompleted subordinates
				remaining = length !== 1 ||
					( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

				// the master Deferred.
				// If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},

				progressValues, progressContexts, resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.progress( updateFunc( i, progressContexts, progressValues ) )
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject );
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}

			return deferred.promise();
		}
	} );


	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function( fn ) {

		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	} );

	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if ( document.readyState === "complete" ||
				( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout( jQuery.ready );

			} else {

				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed );

				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed );
			}
		}
		return readyList.promise( obj );
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		register: function( owner, initial ) {
			var value = initial || {};

			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if ( owner.nodeType ) {
				owner[ this.expando ] = value;

			// Otherwise secure it in a non-enumerable, non-writable property
			// configurability must be true to allow the property to be
			// deleted with the delete operator
			} else {
				Object.defineProperty( owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				} );
			}
			return owner[ this.expando ];
		},
		cache: function( owner ) {

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( !acceptData( owner ) ) {
				return {};
			}

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
				owner[ this.expando ] && owner[ this.expando ][ key ];
		},
		access: function( owner, key, value ) {
			var stored;

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				stored = this.get( owner, key );

				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase( key ) );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key === undefined ) {
				this.register( owner );

			} else {

				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {

					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );

					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}

				i = name.length;

				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :

						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data, camelKey;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get( elem, key ) ||

						// Try to find dashed key if it exists (gh-2779)
						// This is for 2.2.x only
						dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

					if ( data !== undefined ) {
						return data;
					}

					camelKey = jQuery.camelCase( key );

					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				camelKey = jQuery.camelCase( key );
				this.each( function() {

					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get( this, camelKey );

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set( this, camelKey, value );

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
						dataUser.set( this, key, value );
					}
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHidden = function( elem, el ) {

			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" ||
				!jQuery.contains( elem.ownerDocument, elem );
		};



	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() { return tween.cur(); } :
				function() { return jQuery.css( elem, prop, "" ); },
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );

			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([\w:-]+)/ );

	var rscriptType = ( /^$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ?
				context.getElementsByTagName( tag || "*" ) :
				typeof context.querySelectorAll !== "undefined" ?
					context.querySelectorAll( tag || "*" ) :
				[];

		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();


	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( event ) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );

			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if ( delegateCount && cur.nodeType &&
				( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push( { elem: cur, handlers: matches } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
			"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split( " " ),
			filter: function( event, original ) {

				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
				"screenX screenY toElement" ).split( " " ),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX +
						( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
						( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY +
						( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
						( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}

				return event;
			}
		},

		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];

			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

			event = new jQuery.Event( originalEvent );

			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

		// Support: IE 10-11, Edge 10240+
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

			elem.getElementsByTagName( "tbody" )[ 0 ] ||
				elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
			elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {

		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,

		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );


	var iframe,
		elemdisplay = {

			// Support: Firefox
			// We have to pre-define these values for FF (#10227)
			HTML: "block",
			BODY: "block"
		};

	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */

	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

			display = jQuery.css( elem[ 0 ], "display" );

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];

		if ( !display ) {
			display = actualDisplay( nodeName, doc );

			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {

				// Use the already-created iframe if possible
				iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
					.appendTo( doc.documentElement );

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}

		return display;
	}
	var rmargin = ( /^margin/ );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};


	var documentElement = document.documentElement;



	( function() {
		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =

				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild( container );
		}

		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {

				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {

				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if ( boxSizingReliableVal == null ) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =

					// Support: Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;box-sizing:content-box;" +
					"display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

				documentElement.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE9-11+
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,

		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?

			// If we already have the right measurement, avoid augmentation
			4 :

			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,

			val = 0;

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {

				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;

		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			values[ index ] = dataPriv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = dataPriv.access(
						elem,
						"olddisplay",
						defaultDisplay( elem.nodeName )
					);
				}
			} else {
				hidden = isHidden( elem );

				if ( display !== "none" || !hidden ) {
					dataPriv.set(
						elem,
						"olddisplay",
						hidden ? display : jQuery.css( elem, "display" )
					);
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					style[ name ] = value;
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
						elem.offsetWidth === 0 ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", {} );
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done( function() {
					jQuery( elem ).hide();
				} );
			}
			anim.done( function() {
				var prop;

				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
			style.display = display;
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length ; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnotwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
			opt.duration : opt.duration in jQuery.fx.speeds ?
				jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		window.clearInterval( timerId );

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					propName = jQuery.propFix[ name ] || name;

					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {

						// Set corresponding property to false
						elem[ propName ] = false;
					}

					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					return tabindex ?
						parseInt( tabindex, 10 ) :
						rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) && elem.href ?
								0 :
								-1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




	var rclass = /[\t\r\n\f]/g;

	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnotwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &&
						( " " + curValue + " " ).replace( rclass, " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( type === "string" ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnotwhite ) || [];

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + getClass( elem ) + " " ).replace( rclass, " " )
						.indexOf( className ) > -1
				) {
					return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g,
		rspaces = /[\x20\t\r\n\f]+/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

						// Handle most common string cases
						ret.replace( rreturn, "" ) :

						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ?
									!option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	support.focusin = "onfocusin" in window;


	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = ( /\?/ );



	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};


	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE9
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

			if ( jQuery.isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// The jqXHR state
				state = 0,

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {

									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?

						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :

						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( state === 2 ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );

					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Called once
				if ( state === 2 ) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapAll( html.call( this, i ) );
				} );
			}

			if ( this[ 0 ] ) {

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function() {
			return this.parent().each( function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			} ).end();
		}
	} );


	jQuery.expr.filters.hidden = function( elem ) {
		return !jQuery.expr.filters.visible( elem );
	};
	jQuery.expr.filters.visible = function( elem ) {

		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};




	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {

				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );

					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}

		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;

			if ( !doc ) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}

			box = elem.getBoundingClientRect();
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {

						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		} );
	} );


	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		},
		size: function() {
			return this.length;
		}
	} );

	jQuery.fn.andSelf = jQuery.fn.addBack;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}



	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
	}));


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	__webpack_require__(3);

	__webpack_require__(294);

	__webpack_require__(296);

	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;

	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}

	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);

	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(53);
	__webpack_require__(54);
	__webpack_require__(55);
	__webpack_require__(56);
	__webpack_require__(58);
	__webpack_require__(61);
	__webpack_require__(62);
	__webpack_require__(63);
	__webpack_require__(64);
	__webpack_require__(65);
	__webpack_require__(66);
	__webpack_require__(67);
	__webpack_require__(68);
	__webpack_require__(69);
	__webpack_require__(71);
	__webpack_require__(73);
	__webpack_require__(75);
	__webpack_require__(77);
	__webpack_require__(80);
	__webpack_require__(81);
	__webpack_require__(82);
	__webpack_require__(86);
	__webpack_require__(88);
	__webpack_require__(90);
	__webpack_require__(93);
	__webpack_require__(94);
	__webpack_require__(95);
	__webpack_require__(96);
	__webpack_require__(98);
	__webpack_require__(99);
	__webpack_require__(100);
	__webpack_require__(101);
	__webpack_require__(102);
	__webpack_require__(103);
	__webpack_require__(104);
	__webpack_require__(106);
	__webpack_require__(107);
	__webpack_require__(108);
	__webpack_require__(110);
	__webpack_require__(111);
	__webpack_require__(112);
	__webpack_require__(114);
	__webpack_require__(115);
	__webpack_require__(116);
	__webpack_require__(117);
	__webpack_require__(118);
	__webpack_require__(119);
	__webpack_require__(120);
	__webpack_require__(121);
	__webpack_require__(122);
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(125);
	__webpack_require__(126);
	__webpack_require__(127);
	__webpack_require__(132);
	__webpack_require__(133);
	__webpack_require__(137);
	__webpack_require__(138);
	__webpack_require__(139);
	__webpack_require__(140);
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(148);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(153);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(156);
	__webpack_require__(157);
	__webpack_require__(158);
	__webpack_require__(160);
	__webpack_require__(161);
	__webpack_require__(167);
	__webpack_require__(168);
	__webpack_require__(170);
	__webpack_require__(171);
	__webpack_require__(172);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(180);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(188);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(194);
	__webpack_require__(196);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(200);
	__webpack_require__(202);
	__webpack_require__(203);
	__webpack_require__(204);
	__webpack_require__(205);
	__webpack_require__(212);
	__webpack_require__(215);
	__webpack_require__(216);
	__webpack_require__(218);
	__webpack_require__(219);
	__webpack_require__(222);
	__webpack_require__(223);
	__webpack_require__(225);
	__webpack_require__(226);
	__webpack_require__(227);
	__webpack_require__(228);
	__webpack_require__(229);
	__webpack_require__(230);
	__webpack_require__(231);
	__webpack_require__(232);
	__webpack_require__(233);
	__webpack_require__(234);
	__webpack_require__(235);
	__webpack_require__(236);
	__webpack_require__(237);
	__webpack_require__(238);
	__webpack_require__(239);
	__webpack_require__(240);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(243);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(248);
	__webpack_require__(249);
	__webpack_require__(250);
	__webpack_require__(252);
	__webpack_require__(253);
	__webpack_require__(254);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(258);
	__webpack_require__(259);
	__webpack_require__(261);
	__webpack_require__(262);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(267);
	__webpack_require__(270);
	__webpack_require__(271);
	__webpack_require__(272);
	__webpack_require__(273);
	__webpack_require__(274);
	__webpack_require__(275);
	__webpack_require__(276);
	__webpack_require__(277);
	__webpack_require__(279);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(282);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(285);
	__webpack_require__(286);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(289);
	__webpack_require__(292);
	__webpack_require__(293);
	module.exports = __webpack_require__(10);

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(5)
	  , has            = __webpack_require__(6)
	  , DESCRIPTORS    = __webpack_require__(7)
	  , $export        = __webpack_require__(9)
	  , redefine       = __webpack_require__(19)
	  , META           = __webpack_require__(23).KEY
	  , $fails         = __webpack_require__(8)
	  , shared         = __webpack_require__(24)
	  , setToStringTag = __webpack_require__(25)
	  , uid            = __webpack_require__(20)
	  , wks            = __webpack_require__(26)
	  , wksExt         = __webpack_require__(27)
	  , wksDefine      = __webpack_require__(28)
	  , keyOf          = __webpack_require__(30)
	  , enumKeys       = __webpack_require__(43)
	  , isArray        = __webpack_require__(46)
	  , anObject       = __webpack_require__(13)
	  , toIObject      = __webpack_require__(33)
	  , toPrimitive    = __webpack_require__(17)
	  , createDesc     = __webpack_require__(18)
	  , _create        = __webpack_require__(47)
	  , gOPNExt        = __webpack_require__(50)
	  , $GOPD          = __webpack_require__(52)
	  , $DP            = __webpack_require__(12)
	  , $keys          = __webpack_require__(31)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;

	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });

	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(51).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(45).f  = $propertyIsEnumerable;
	  __webpack_require__(44).f = $getOwnPropertySymbols;

	  if(DESCRIPTORS && !__webpack_require__(29)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});

	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 5 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 6 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(8)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(5)
	  , core      = __webpack_require__(10)
	  , hide      = __webpack_require__(11)
	  , redefine  = __webpack_require__(19)
	  , ctx       = __webpack_require__(21)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 10 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(12)
	  , createDesc = __webpack_require__(18);
	module.exports = __webpack_require__(7) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(13)
	  , IE8_DOM_DEFINE = __webpack_require__(15)
	  , toPrimitive    = __webpack_require__(17)
	  , dP             = Object.defineProperty;

	exports.f = __webpack_require__(7) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(7) && !__webpack_require__(8)(function(){
	  return Object.defineProperty(__webpack_require__(16)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14)
	  , document = __webpack_require__(5).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(14);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 18 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(5)
	  , hide      = __webpack_require__(11)
	  , has       = __webpack_require__(6)
	  , SRC       = __webpack_require__(20)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);

	__webpack_require__(10).inspectSource = function(it){
	  return $toString.call(it);
	};

	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 20 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(22);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 22 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(20)('meta')
	  , isObject = __webpack_require__(14)
	  , has      = __webpack_require__(6)
	  , setDesc  = __webpack_require__(12).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(8)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(5)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(12).f
	  , has = __webpack_require__(6)
	  , TAG = __webpack_require__(26)('toStringTag');

	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(24)('wks')
	  , uid        = __webpack_require__(20)
	  , Symbol     = __webpack_require__(5).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

	$exports.store = store;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(26);

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(5)
	  , core           = __webpack_require__(10)
	  , LIBRARY        = __webpack_require__(29)
	  , wksExt         = __webpack_require__(27)
	  , defineProperty = __webpack_require__(12).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(31)
	  , toIObject = __webpack_require__(33);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(32)
	  , enumBugKeys = __webpack_require__(42);

	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(6)
	  , toIObject    = __webpack_require__(33)
	  , arrayIndexOf = __webpack_require__(37)(false)
	  , IE_PROTO     = __webpack_require__(41)('IE_PROTO');

	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(34)
	  , defined = __webpack_require__(36);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(35);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(33)
	  , toLength  = __webpack_require__(38)
	  , toIndex   = __webpack_require__(40);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(39)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 39 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(39)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(24)('keys')
	  , uid    = __webpack_require__(20);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 42 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(31)
	  , gOPS    = __webpack_require__(44)
	  , pIE     = __webpack_require__(45);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 44 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 45 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(35);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(13)
	  , dPs         = __webpack_require__(48)
	  , enumBugKeys = __webpack_require__(42)
	  , IE_PROTO    = __webpack_require__(41)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(16)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(49).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};

	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(12)
	  , anObject = __webpack_require__(13)
	  , getKeys  = __webpack_require__(31);

	module.exports = __webpack_require__(7) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(5).document && document.documentElement;

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(33)
	  , gOPN      = __webpack_require__(51).f
	  , toString  = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};

	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(32)
	  , hiddenKeys = __webpack_require__(42).concat('length', 'prototype');

	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(45)
	  , createDesc     = __webpack_require__(18)
	  , toIObject      = __webpack_require__(33)
	  , toPrimitive    = __webpack_require__(17)
	  , has            = __webpack_require__(6)
	  , IE8_DOM_DEFINE = __webpack_require__(15)
	  , gOPD           = Object.getOwnPropertyDescriptor;

	exports.f = __webpack_require__(7) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(47)});

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(7), 'Object', {defineProperty: __webpack_require__(12).f});

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(7), 'Object', {defineProperties: __webpack_require__(48)});

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(33)
	  , $getOwnPropertyDescriptor = __webpack_require__(52).f;

	__webpack_require__(57)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(9)
	  , core    = __webpack_require__(10)
	  , fails   = __webpack_require__(8);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(59)
	  , $getPrototypeOf = __webpack_require__(60);

	__webpack_require__(57)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(36);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(6)
	  , toObject    = __webpack_require__(59)
	  , IE_PROTO    = __webpack_require__(41)('IE_PROTO')
	  , ObjectProto = Object.prototype;

	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(59)
	  , $keys    = __webpack_require__(31);

	__webpack_require__(57)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(57)('getOwnPropertyNames', function(){
	  return __webpack_require__(50).f;
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(14)
	  , meta     = __webpack_require__(23).onFreeze;

	__webpack_require__(57)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(14)
	  , meta     = __webpack_require__(23).onFreeze;

	__webpack_require__(57)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(14)
	  , meta     = __webpack_require__(23).onFreeze;

	__webpack_require__(57)('preventExtensions', function($preventExtensions){
	  return function preventExtensions(it){
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(14);

	__webpack_require__(57)('isFrozen', function($isFrozen){
	  return function isFrozen(it){
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(14);

	__webpack_require__(57)('isSealed', function($isSealed){
	  return function isSealed(it){
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(14);

	__webpack_require__(57)('isExtensible', function($isExtensible){
	  return function isExtensible(it){
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(9);

	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(70)});

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(31)
	  , gOPS     = __webpack_require__(44)
	  , pIE      = __webpack_require__(45)
	  , toObject = __webpack_require__(59)
	  , IObject  = __webpack_require__(34)
	  , $assign  = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(8)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(9);
	$export($export.S, 'Object', {is: __webpack_require__(72)});

/***/ },
/* 72 */
/***/ function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(9);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(74).set});

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(14)
	  , anObject = __webpack_require__(13);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(21)(Function.call, __webpack_require__(52).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(76)
	  , test    = {};
	test[__webpack_require__(26)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(19)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(35)
	  , TAG = __webpack_require__(26)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};

	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(9);

	$export($export.P, 'Function', {bind: __webpack_require__(78)});

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var aFunction  = __webpack_require__(22)
	  , isObject   = __webpack_require__(14)
	  , invoke     = __webpack_require__(79)
	  , arraySlice = [].slice
	  , factories  = {};

	var construct = function(F, len, args){
	  if(!(len in factories)){
	    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};

	module.exports = Function.bind || function bind(that /*, args... */){
	  var fn       = aFunction(this)
	    , partArgs = arraySlice.call(arguments, 1);
	  var bound = function(/* args... */){
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if(isObject(fn.prototype))bound.prototype = fn.prototype;
	  return bound;
	};

/***/ },
/* 79 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(12).f
	  , createDesc = __webpack_require__(18)
	  , has        = __webpack_require__(6)
	  , FProto     = Function.prototype
	  , nameRE     = /^\s*function ([^ (]*)/
	  , NAME       = 'name';

	var isExtensible = Object.isExtensible || function(){
	  return true;
	};

	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(7) && dP(FProto, NAME, {
	  configurable: true,
	  get: function(){
	    try {
	      var that = this
	        , name = ('' + that).match(nameRE)[1];
	      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
	      return name;
	    } catch(e){
	      return '';
	    }
	  }
	});

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObject       = __webpack_require__(14)
	  , getPrototypeOf = __webpack_require__(60)
	  , HAS_INSTANCE   = __webpack_require__(26)('hasInstance')
	  , FunctionProto  = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if(!(HAS_INSTANCE in FunctionProto))__webpack_require__(12).f(FunctionProto, HAS_INSTANCE, {value: function(O){
	  if(typeof this != 'function' || !isObject(O))return false;
	  if(!isObject(this.prototype))return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
	  return false;
	}});

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(9)
	  , $parseInt = __webpack_require__(83);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(5).parseInt
	  , $trim     = __webpack_require__(84).trim
	  , ws        = __webpack_require__(85)
	  , hex       = /^[\-+]?0[xX]/;

	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9)
	  , defined = __webpack_require__(36)
	  , fails   = __webpack_require__(8)
	  , spaces  = __webpack_require__(85)
	  , space   = '[' + spaces + ']'
	  , non     = '\u200b\u0085'
	  , ltrim   = RegExp('^' + space + space + '*')
	  , rtrim   = RegExp(space + space + '*$');

	var exporter = function(KEY, exec, ALIAS){
	  var exp   = {};
	  var FORCE = fails(function(){
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if(ALIAS)exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};

	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function(string, TYPE){
	  string = String(defined(string));
	  if(TYPE & 1)string = string.replace(ltrim, '');
	  if(TYPE & 2)string = string.replace(rtrim, '');
	  return string;
	};

	module.exports = exporter;

/***/ },
/* 85 */
/***/ function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(9)
	  , $parseFloat = __webpack_require__(87);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(5).parseFloat
	  , $trim       = __webpack_require__(84).trim;

	module.exports = 1 / $parseFloat(__webpack_require__(85) + '-0') !== -Infinity ? function parseFloat(str){
	  var string = $trim(String(str), 3)
	    , result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(5)
	  , has               = __webpack_require__(6)
	  , cof               = __webpack_require__(35)
	  , inheritIfRequired = __webpack_require__(89)
	  , toPrimitive       = __webpack_require__(17)
	  , fails             = __webpack_require__(8)
	  , gOPN              = __webpack_require__(51).f
	  , gOPD              = __webpack_require__(52).f
	  , dP                = __webpack_require__(12).f
	  , $trim             = __webpack_require__(84).trim
	  , NUMBER            = 'Number'
	  , $Number           = global[NUMBER]
	  , Base              = $Number
	  , proto             = $Number.prototype
	  // Opera ~12 has broken Object#toString
	  , BROKEN_COF        = cof(__webpack_require__(47)(proto)) == NUMBER
	  , TRIM              = 'trim' in String.prototype;

	// 7.1.3 ToNumber(argument)
	var toNumber = function(argument){
	  var it = toPrimitive(argument, false);
	  if(typeof it == 'string' && it.length > 2){
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0)
	      , third, radix, maxCode;
	    if(first === 43 || first === 45){
	      third = it.charCodeAt(2);
	      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if(first === 48){
	      switch(it.charCodeAt(1)){
	        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default : return +it;
	      }
	      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if(code < 48 || code > maxCode)return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};

	if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
	  $Number = function Number(value){
	    var it = arguments.length < 1 ? 0 : value
	      , that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for(var keys = __webpack_require__(7) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++){
	    if(has(Base, key = keys[j]) && !has($Number, key)){
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(19)(global, NUMBER, $Number);
	}

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var isObject       = __webpack_require__(14)
	  , setPrototypeOf = __webpack_require__(74).set;
	module.exports = function(that, target, C){
	  var P, S = target.constructor;
	  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
	    setPrototypeOf(that, P);
	  } return that;
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(9)
	  , toInteger    = __webpack_require__(39)
	  , aNumberValue = __webpack_require__(91)
	  , repeat       = __webpack_require__(92)
	  , $toFixed     = 1..toFixed
	  , floor        = Math.floor
	  , data         = [0, 0, 0, 0, 0, 0]
	  , ERROR        = 'Number.toFixed: incorrect invocation!'
	  , ZERO         = '0';

	var multiply = function(n, c){
	  var i  = -1
	    , c2 = c;
	  while(++i < 6){
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function(n){
	  var i = 6
	    , c = 0;
	  while(--i >= 0){
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function(){
	  var i = 6
	    , s = '';
	  while(--i >= 0){
	    if(s !== '' || i === 0 || data[i] !== 0){
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function(x, n, acc){
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function(x){
	  var n  = 0
	    , x2 = x;
	  while(x2 >= 4096){
	    n += 12;
	    x2 /= 4096;
	  }
	  while(x2 >= 2){
	    n  += 1;
	    x2 /= 2;
	  } return n;
	};

	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128..toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(8)(function(){
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits){
	    var x = aNumberValue(this, ERROR)
	      , f = toInteger(fractionDigits)
	      , s = ''
	      , m = ZERO
	      , e, z, j, k;
	    if(f < 0 || f > 20)throw RangeError(ERROR);
	    if(x != x)return 'NaN';
	    if(x <= -1e21 || x >= 1e21)return String(x);
	    if(x < 0){
	      s = '-';
	      x = -x;
	    }
	    if(x > 1e-21){
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if(e > 0){
	        multiply(0, z);
	        j = f;
	        while(j >= 7){
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while(j >= 23){
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if(f > 0){
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(35);
	module.exports = function(it, msg){
	  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
	  return +it;
	};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(39)
	  , defined   = __webpack_require__(36);

	module.exports = function repeat(count){
	  var str = String(defined(this))
	    , res = ''
	    , n   = toInteger(count);
	  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
	  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
	  return res;
	};

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(9)
	  , $fails       = __webpack_require__(8)
	  , aNumberValue = __webpack_require__(91)
	  , $toPrecision = 1..toPrecision;

	$export($export.P + $export.F * ($fails(function(){
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function(){
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision){
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
	  }
	});

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(9);

	$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export   = __webpack_require__(9)
	  , _isFinite = __webpack_require__(5).isFinite;

	$export($export.S, 'Number', {
	  isFinite: function isFinite(it){
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(9);

	$export($export.S, 'Number', {isInteger: __webpack_require__(97)});

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(14)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(9);

	$export($export.S, 'Number', {
	  isNaN: function isNaN(number){
	    return number != number;
	  }
	});

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export   = __webpack_require__(9)
	  , isInteger = __webpack_require__(97)
	  , abs       = Math.abs;

	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number){
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(9);

	$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(9);

	$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(9)
	  , $parseFloat = __webpack_require__(87);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(9)
	  , $parseInt = __webpack_require__(83);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(9)
	  , log1p   = __webpack_require__(105)
	  , sqrt    = Math.sqrt
	  , $acosh  = Math.acosh;

	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x){
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

/***/ },
/* 105 */
/***/ function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x){
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(9)
	  , $asinh  = Math.asinh;

	function asinh(x){
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}

	// Tor Browser bug: Math.asinh(0) -> -0 
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(9)
	  , $atanh  = Math.atanh;

	// Tor Browser bug: Math.atanh(-0) -> 0 
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x){
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(9)
	  , sign    = __webpack_require__(109);

	$export($export.S, 'Math', {
	  cbrt: function cbrt(x){
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

/***/ },
/* 109 */
/***/ function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x){
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(9);

	$export($export.S, 'Math', {
	  clz32: function clz32(x){
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(9)
	  , exp     = Math.exp;

	$export($export.S, 'Math', {
	  cosh: function cosh(x){
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(9)
	  , $expm1  = __webpack_require__(113);

	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});

/***/ },
/* 113 */
/***/ function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x){
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export   = __webpack_require__(9)
	  , sign      = __webpack_require__(109)
	  , pow       = Math.pow
	  , EPSILON   = pow(2, -52)
	  , EPSILON32 = pow(2, -23)
	  , MAX32     = pow(2, 127) * (2 - EPSILON32)
	  , MIN32     = pow(2, -126);

	var roundTiesToEven = function(n){
	  return n + 1 / EPSILON - 1 / EPSILON;
	};


	$export($export.S, 'Math', {
	  fround: function fround(x){
	    var $abs  = Math.abs(x)
	      , $sign = sign(x)
	      , a, result;
	    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if(result > MAX32 || result != result)return $sign * Infinity;
	    return $sign * result;
	  }
	});

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
	var $export = __webpack_require__(9)
	  , abs     = Math.abs;

	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
	    var sum  = 0
	      , i    = 0
	      , aLen = arguments.length
	      , larg = 0
	      , arg, div;
	    while(i < aLen){
	      arg = abs(arguments[i++]);
	      if(larg < arg){
	        div  = larg / arg;
	        sum  = sum * div * div + 1;
	        larg = arg;
	      } else if(arg > 0){
	        div  = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(9)
	  , $imul   = Math.imul;

	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(8)(function(){
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y){
	    var UINT16 = 0xffff
	      , xn = +x
	      , yn = +y
	      , xl = UINT16 & xn
	      , yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(9);

	$export($export.S, 'Math', {
	  log10: function log10(x){
	    return Math.log(x) / Math.LN10;
	  }
	});

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(9);

	$export($export.S, 'Math', {log1p: __webpack_require__(105)});

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(9);

	$export($export.S, 'Math', {
	  log2: function log2(x){
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(9);

	$export($export.S, 'Math', {sign: __webpack_require__(109)});

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(9)
	  , expm1   = __webpack_require__(113)
	  , exp     = Math.exp;

	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(8)(function(){
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x){
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(9)
	  , expm1   = __webpack_require__(113)
	  , exp     = Math.exp;

	$export($export.S, 'Math', {
	  tanh: function tanh(x){
	    var a = expm1(x = +x)
	      , b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(9);

	$export($export.S, 'Math', {
	  trunc: function trunc(it){
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var $export        = __webpack_require__(9)
	  , toIndex        = __webpack_require__(40)
	  , fromCharCode   = String.fromCharCode
	  , $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
	    var res  = []
	      , aLen = arguments.length
	      , i    = 0
	      , code;
	    while(aLen > i){
	      code = +arguments[i++];
	      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(9)
	  , toIObject = __webpack_require__(33)
	  , toLength  = __webpack_require__(38);

	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite){
	    var tpl  = toIObject(callSite.raw)
	      , len  = toLength(tpl.length)
	      , aLen = arguments.length
	      , res  = []
	      , i    = 0;
	    while(len > i){
	      res.push(String(tpl[i++]));
	      if(i < aLen)res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(84)('trim', function($trim){
	  return function trim(){
	    return $trim(this, 3);
	  };
	});

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(128)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(129)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(39)
	  , defined   = __webpack_require__(36);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(29)
	  , $export        = __webpack_require__(9)
	  , redefine       = __webpack_require__(19)
	  , hide           = __webpack_require__(11)
	  , has            = __webpack_require__(6)
	  , Iterators      = __webpack_require__(130)
	  , $iterCreate    = __webpack_require__(131)
	  , setToStringTag = __webpack_require__(25)
	  , getPrototypeOf = __webpack_require__(60)
	  , ITERATOR       = __webpack_require__(26)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';

	var returnThis = function(){ return this; };

	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 130 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(47)
	  , descriptor     = __webpack_require__(18)
	  , setToStringTag = __webpack_require__(25)
	  , IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(11)(IteratorPrototype, __webpack_require__(26)('iterator'), function(){ return this; });

	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9)
	  , $at     = __webpack_require__(128)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export   = __webpack_require__(9)
	  , toLength  = __webpack_require__(38)
	  , context   = __webpack_require__(134)
	  , ENDS_WITH = 'endsWith'
	  , $endsWith = ''[ENDS_WITH];

	$export($export.P + $export.F * __webpack_require__(136)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /*, endPosition = @length */){
	    var that = context(this, searchString, ENDS_WITH)
	      , endPosition = arguments.length > 1 ? arguments[1] : undefined
	      , len    = toLength(that.length)
	      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
	      , search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(135)
	  , defined  = __webpack_require__(36);

	module.exports = function(that, searchString, NAME){
	  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(14)
	  , cof      = __webpack_require__(35)
	  , MATCH    = __webpack_require__(26)('match');
	module.exports = function(it){
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(26)('match');
	module.exports = function(KEY){
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch(e){
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch(f){ /* empty */ }
	  } return true;
	};

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export  = __webpack_require__(9)
	  , context  = __webpack_require__(134)
	  , INCLUDES = 'includes';

	$export($export.P + $export.F * __webpack_require__(136)(INCLUDES), 'String', {
	  includes: function includes(searchString /*, position = 0 */){
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);

	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(92)
	});

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export     = __webpack_require__(9)
	  , toLength    = __webpack_require__(38)
	  , context     = __webpack_require__(134)
	  , STARTS_WITH = 'startsWith'
	  , $startsWith = ''[STARTS_WITH];

	$export($export.P + $export.F * __webpack_require__(136)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /*, position = 0 */){
	    var that   = context(this, searchString, STARTS_WITH)
	      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
	      , search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(141)('anchor', function(createHTML){
	  return function anchor(name){
	    return createHTML(this, 'a', 'name', name);
	  }
	});

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9)
	  , fails   = __webpack_require__(8)
	  , defined = __webpack_require__(36)
	  , quot    = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function(string, tag, attribute, value) {
	  var S  = String(defined(string))
	    , p1 = '<' + tag;
	  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function(NAME, exec){
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function(){
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	__webpack_require__(141)('big', function(createHTML){
	  return function big(){
	    return createHTML(this, 'big', '', '');
	  }
	});

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	__webpack_require__(141)('blink', function(createHTML){
	  return function blink(){
	    return createHTML(this, 'blink', '', '');
	  }
	});

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	__webpack_require__(141)('bold', function(createHTML){
	  return function bold(){
	    return createHTML(this, 'b', '', '');
	  }
	});

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(141)('fixed', function(createHTML){
	  return function fixed(){
	    return createHTML(this, 'tt', '', '');
	  }
	});

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(141)('fontcolor', function(createHTML){
	  return function fontcolor(color){
	    return createHTML(this, 'font', 'color', color);
	  }
	});

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(141)('fontsize', function(createHTML){
	  return function fontsize(size){
	    return createHTML(this, 'font', 'size', size);
	  }
	});

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	__webpack_require__(141)('italics', function(createHTML){
	  return function italics(){
	    return createHTML(this, 'i', '', '');
	  }
	});

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(141)('link', function(createHTML){
	  return function link(url){
	    return createHTML(this, 'a', 'href', url);
	  }
	});

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	__webpack_require__(141)('small', function(createHTML){
	  return function small(){
	    return createHTML(this, 'small', '', '');
	  }
	});

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	__webpack_require__(141)('strike', function(createHTML){
	  return function strike(){
	    return createHTML(this, 'strike', '', '');
	  }
	});

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	__webpack_require__(141)('sub', function(createHTML){
	  return function sub(){
	    return createHTML(this, 'sub', '', '');
	  }
	});

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	__webpack_require__(141)('sup', function(createHTML){
	  return function sup(){
	    return createHTML(this, 'sup', '', '');
	  }
	});

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(9);

	$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export     = __webpack_require__(9)
	  , toObject    = __webpack_require__(59)
	  , toPrimitive = __webpack_require__(17);

	$export($export.P + $export.F * __webpack_require__(8)(function(){
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(9)
	  , fails   = __webpack_require__(8)
	  , getTime = Date.prototype.getTime;

	var lz = function(num){
	  return num > 9 ? num : '0' + num;
	};

	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (fails(function(){
	  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
	}) || !fails(function(){
	  new Date(NaN).toISOString();
	})), 'Date', {
	  toISOString: function toISOString(){
	    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
	    var d = this
	      , y = d.getUTCFullYear()
	      , m = d.getUTCMilliseconds()
	      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
	    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	  }
	});

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var DateProto    = Date.prototype
	  , INVALID_DATE = 'Invalid Date'
	  , TO_STRING    = 'toString'
	  , $toString    = DateProto[TO_STRING]
	  , getTime      = DateProto.getTime;
	if(new Date(NaN) + '' != INVALID_DATE){
	  __webpack_require__(19)(DateProto, TO_STRING, function toString(){
	    var value = getTime.call(this);
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(26)('toPrimitive')
	  , proto        = Date.prototype;

	if(!(TO_PRIMITIVE in proto))__webpack_require__(11)(proto, TO_PRIMITIVE, __webpack_require__(159));

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var anObject    = __webpack_require__(13)
	  , toPrimitive = __webpack_require__(17)
	  , NUMBER      = 'number';

	module.exports = function(hint){
	  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(9);

	$export($export.S, 'Array', {isArray: __webpack_require__(46)});

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(21)
	  , $export        = __webpack_require__(9)
	  , toObject       = __webpack_require__(59)
	  , call           = __webpack_require__(162)
	  , isArrayIter    = __webpack_require__(163)
	  , toLength       = __webpack_require__(38)
	  , createProperty = __webpack_require__(164)
	  , getIterFn      = __webpack_require__(165);

	$export($export.S + $export.F * !__webpack_require__(166)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(13);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(130)
	  , ITERATOR   = __webpack_require__(26)('iterator')
	  , ArrayProto = Array.prototype;

	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(12)
	  , createDesc      = __webpack_require__(18);

	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(76)
	  , ITERATOR  = __webpack_require__(26)('iterator')
	  , Iterators = __webpack_require__(130);
	module.exports = __webpack_require__(10).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(26)('iterator')
	  , SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }

	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export        = __webpack_require__(9)
	  , createProperty = __webpack_require__(164);

	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(8)(function(){
	  function F(){}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */){
	    var index  = 0
	      , aLen   = arguments.length
	      , result = new (typeof this == 'function' ? this : Array)(aLen);
	    while(aLen > index)createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	var $export   = __webpack_require__(9)
	  , toIObject = __webpack_require__(33)
	  , arrayJoin = [].join;

	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(34) != Object || !__webpack_require__(169)(arrayJoin)), 'Array', {
	  join: function join(separator){
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	var fails = __webpack_require__(8);

	module.exports = function(method, arg){
	  return !!method && fails(function(){
	    arg ? method.call(null, function(){}, 1) : method.call(null);
	  });
	};

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export    = __webpack_require__(9)
	  , html       = __webpack_require__(49)
	  , cof        = __webpack_require__(35)
	  , toIndex    = __webpack_require__(40)
	  , toLength   = __webpack_require__(38)
	  , arraySlice = [].slice;

	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(8)(function(){
	  if(html)arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end){
	    var len   = toLength(this.length)
	      , klass = cof(this);
	    end = end === undefined ? len : end;
	    if(klass == 'Array')return arraySlice.call(this, begin, end);
	    var start  = toIndex(begin, len)
	      , upTo   = toIndex(end, len)
	      , size   = toLength(upTo - start)
	      , cloned = Array(size)
	      , i      = 0;
	    for(; i < size; i++)cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export   = __webpack_require__(9)
	  , aFunction = __webpack_require__(22)
	  , toObject  = __webpack_require__(59)
	  , fails     = __webpack_require__(8)
	  , $sort     = [].sort
	  , test      = [1, 2, 3];

	$export($export.P + $export.F * (fails(function(){
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function(){
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(169)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn){
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export  = __webpack_require__(9)
	  , $forEach = __webpack_require__(173)(0)
	  , STRICT   = __webpack_require__(169)([].forEach, true);

	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */){
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(21)
	  , IObject  = __webpack_require__(34)
	  , toObject = __webpack_require__(59)
	  , toLength = __webpack_require__(38)
	  , asc      = __webpack_require__(174);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(175);

	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14)
	  , isArray  = __webpack_require__(46)
	  , SPECIES  = __webpack_require__(26)('species');

	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9)
	  , $map    = __webpack_require__(173)(1);

	$export($export.P + $export.F * !__webpack_require__(169)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */){
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9)
	  , $filter = __webpack_require__(173)(2);

	$export($export.P + $export.F * !__webpack_require__(169)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */){
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9)
	  , $some   = __webpack_require__(173)(3);

	$export($export.P + $export.F * !__webpack_require__(169)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */){
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9)
	  , $every  = __webpack_require__(173)(4);

	$export($export.P + $export.F * !__webpack_require__(169)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */){
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9)
	  , $reduce = __webpack_require__(181);

	$export($export.P + $export.F * !__webpack_require__(169)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(22)
	  , toObject  = __webpack_require__(59)
	  , IObject   = __webpack_require__(34)
	  , toLength  = __webpack_require__(38);

	module.exports = function(that, callbackfn, aLen, memo, isRight){
	  aFunction(callbackfn);
	  var O      = toObject(that)
	    , self   = IObject(O)
	    , length = toLength(O.length)
	    , index  = isRight ? length - 1 : 0
	    , i      = isRight ? -1 : 1;
	  if(aLen < 2)for(;;){
	    if(index in self){
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if(isRight ? index < 0 : length <= index){
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9)
	  , $reduce = __webpack_require__(181);

	$export($export.P + $export.F * !__webpack_require__(169)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(9)
	  , $indexOf      = __webpack_require__(37)(false)
	  , $native       = [].indexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(169)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(9)
	  , toIObject     = __webpack_require__(33)
	  , toInteger     = __webpack_require__(39)
	  , toLength      = __webpack_require__(38)
	  , $native       = [].lastIndexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(169)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
	    // convert -0 to +0
	    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
	    var O      = toIObject(this)
	      , length = toLength(O.length)
	      , index  = length - 1;
	    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
	    if(index < 0)index = length + index;
	    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
	    return -1;
	  }
	});

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(9);

	$export($export.P, 'Array', {copyWithin: __webpack_require__(186)});

	__webpack_require__(187)('copyWithin');

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(59)
	  , toIndex  = __webpack_require__(40)
	  , toLength = __webpack_require__(38);

	module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
	  var O     = toObject(this)
	    , len   = toLength(O.length)
	    , to    = toIndex(target, len)
	    , from  = toIndex(start, len)
	    , end   = arguments.length > 2 ? arguments[2] : undefined
	    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
	    , inc   = 1;
	  if(from < to && to < from + count){
	    inc  = -1;
	    from += count - 1;
	    to   += count - 1;
	  }
	  while(count-- > 0){
	    if(from in O)O[to] = O[from];
	    else delete O[to];
	    to   += inc;
	    from += inc;
	  } return O;
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(26)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(11)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(9);

	$export($export.P, 'Array', {fill: __webpack_require__(189)});

	__webpack_require__(187)('fill');

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(59)
	  , toIndex  = __webpack_require__(40)
	  , toLength = __webpack_require__(38);
	module.exports = function fill(value /*, start = 0, end = @length */){
	  var O      = toObject(this)
	    , length = toLength(O.length)
	    , aLen   = arguments.length
	    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
	    , end    = aLen > 2 ? arguments[2] : undefined
	    , endPos = end === undefined ? length : toIndex(end, length);
	  while(endPos > index)O[index++] = value;
	  return O;
	};

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(9)
	  , $find   = __webpack_require__(173)(5)
	  , KEY     = 'find'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(187)(KEY);

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(9)
	  , $find   = __webpack_require__(173)(6)
	  , KEY     = 'findIndex'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(187)(KEY);

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(193)('Array');

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(5)
	  , dP          = __webpack_require__(12)
	  , DESCRIPTORS = __webpack_require__(7)
	  , SPECIES     = __webpack_require__(26)('species');

	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(187)
	  , step             = __webpack_require__(195)
	  , Iterators        = __webpack_require__(130)
	  , toIObject        = __webpack_require__(33);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(129)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 195 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var global            = __webpack_require__(5)
	  , inheritIfRequired = __webpack_require__(89)
	  , dP                = __webpack_require__(12).f
	  , gOPN              = __webpack_require__(51).f
	  , isRegExp          = __webpack_require__(135)
	  , $flags            = __webpack_require__(197)
	  , $RegExp           = global.RegExp
	  , Base              = $RegExp
	  , proto             = $RegExp.prototype
	  , re1               = /a/g
	  , re2               = /a/g
	  // "new" creates a new object, old webkit buggy here
	  , CORRECT_NEW       = new $RegExp(re1) !== re1;

	if(__webpack_require__(7) && (!CORRECT_NEW || __webpack_require__(8)(function(){
	  re2[__webpack_require__(26)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))){
	  $RegExp = function RegExp(p, f){
	    var tiRE = this instanceof $RegExp
	      , piRE = isRegExp(p)
	      , fiU  = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function(key){
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function(){ return Base[key]; },
	      set: function(it){ Base[key] = it; }
	    });
	  };
	  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(19)(global, 'RegExp', $RegExp);
	}

	__webpack_require__(193)('RegExp');

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(13);
	module.exports = function(){
	  var that   = anObject(this)
	    , result = '';
	  if(that.global)     result += 'g';
	  if(that.ignoreCase) result += 'i';
	  if(that.multiline)  result += 'm';
	  if(that.unicode)    result += 'u';
	  if(that.sticky)     result += 'y';
	  return result;
	};

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(199);
	var anObject    = __webpack_require__(13)
	  , $flags      = __webpack_require__(197)
	  , DESCRIPTORS = __webpack_require__(7)
	  , TO_STRING   = 'toString'
	  , $toString   = /./[TO_STRING];

	var define = function(fn){
	  __webpack_require__(19)(RegExp.prototype, TO_STRING, fn, true);
	};

	// 21.2.5.14 RegExp.prototype.toString()
	if(__webpack_require__(8)(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
	  define(function toString(){
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if($toString.name != TO_STRING){
	  define(function toString(){
	    return $toString.call(this);
	  });
	}

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if(__webpack_require__(7) && /./g.flags != 'g')__webpack_require__(12).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(197)
	});

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(201)('match', 1, function(defined, MATCH, $match){
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide     = __webpack_require__(11)
	  , redefine = __webpack_require__(19)
	  , fails    = __webpack_require__(8)
	  , defined  = __webpack_require__(36)
	  , wks      = __webpack_require__(26);

	module.exports = function(KEY, length, exec){
	  var SYMBOL   = wks(KEY)
	    , fns      = exec(defined, SYMBOL, ''[KEY])
	    , strfn    = fns[0]
	    , rxfn     = fns[1];
	  if(fails(function(){
	    var O = {};
	    O[SYMBOL] = function(){ return 7; };
	    return ''[KEY](O) != 7;
	  })){
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function(string, arg){ return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function(string){ return rxfn.call(string, this); }
	    );
	  }
	};

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(201)('replace', 2, function(defined, REPLACE, $replace){
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue){
	    'use strict';
	    var O  = defined(this)
	      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(201)('search', 1, function(defined, SEARCH, $search){
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(201)('split', 2, function(defined, SPLIT, $split){
	  'use strict';
	  var isRegExp   = __webpack_require__(135)
	    , _split     = $split
	    , $push      = [].push
	    , $SPLIT     = 'split'
	    , LENGTH     = 'length'
	    , LAST_INDEX = 'lastIndex';
	  if(
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ){
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function(separator, limit){
	      var string = String(this);
	      if(separator === undefined && limit === 0)return [];
	      // If `separator` is not a regex, use native split
	      if(!isRegExp(separator))return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while(match = separatorCopy.exec(string)){
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if(lastIndex > lastLastIndex){
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
	            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
	          });
	          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if(output[LENGTH] >= splitLimit)break;
	        }
	        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if(lastLastIndex === string[LENGTH]){
	        if(lastLength || !separatorCopy.test(''))output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
	    $split = function(separator, limit){
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit){
	    var O  = defined(this)
	      , fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(29)
	  , global             = __webpack_require__(5)
	  , ctx                = __webpack_require__(21)
	  , classof            = __webpack_require__(76)
	  , $export            = __webpack_require__(9)
	  , isObject           = __webpack_require__(14)
	  , aFunction          = __webpack_require__(22)
	  , anInstance         = __webpack_require__(206)
	  , forOf              = __webpack_require__(207)
	  , speciesConstructor = __webpack_require__(208)
	  , task               = __webpack_require__(209).set
	  , microtask          = __webpack_require__(210)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;

	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(26)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();

	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};

	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(211)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(25)($Promise, PROMISE);
	__webpack_require__(193)(PROMISE);
	Wrapper = __webpack_require__(10)[PROMISE];

	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(166)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 206 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(21)
	  , call        = __webpack_require__(162)
	  , isArrayIter = __webpack_require__(163)
	  , anObject    = __webpack_require__(13)
	  , toLength    = __webpack_require__(38)
	  , getIterFn   = __webpack_require__(165)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(13)
	  , aFunction = __webpack_require__(22)
	  , SPECIES   = __webpack_require__(26)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(21)
	  , invoke             = __webpack_require__(79)
	  , html               = __webpack_require__(49)
	  , cel                = __webpack_require__(16)
	  , global             = __webpack_require__(5)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(35)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(5)
	  , macrotask = __webpack_require__(209).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(35)(process) == 'process';

	module.exports = function(){
	  var head, last, notify;

	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };

	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }

	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(19);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(213);

	// 23.1 Map Objects
	module.exports = __webpack_require__(214)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(12).f
	  , create      = __webpack_require__(47)
	  , redefineAll = __webpack_require__(211)
	  , ctx         = __webpack_require__(21)
	  , anInstance  = __webpack_require__(206)
	  , defined     = __webpack_require__(36)
	  , forOf       = __webpack_require__(207)
	  , $iterDefine = __webpack_require__(129)
	  , step        = __webpack_require__(195)
	  , setSpecies  = __webpack_require__(193)
	  , DESCRIPTORS = __webpack_require__(7)
	  , fastKey     = __webpack_require__(23).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';

	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};

	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(5)
	  , $export           = __webpack_require__(9)
	  , redefine          = __webpack_require__(19)
	  , redefineAll       = __webpack_require__(211)
	  , meta              = __webpack_require__(23)
	  , forOf             = __webpack_require__(207)
	  , anInstance        = __webpack_require__(206)
	  , isObject          = __webpack_require__(14)
	  , fails             = __webpack_require__(8)
	  , $iterDetect       = __webpack_require__(166)
	  , setToStringTag    = __webpack_require__(25)
	  , inheritIfRequired = __webpack_require__(89);

	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  var fixMethod = function(KEY){
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a){
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance             = new C
	      // early implementations not supports chaining
	      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
	      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
	      // most early implementations doesn't supports iterables, most modern - not close it correctly
	      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
	      // for early implementations -0 and +0 not the same
	      , BUGGY_ZERO = !IS_WEAK && fails(function(){
	        // V8 ~ Chromium 42- fails only with 5+ elements
	        var $instance = new C()
	          , index     = 5;
	        while(index--)$instance[ADDER](index, index);
	        return !$instance.has(-0);
	      });
	    if(!ACCEPT_ITERABLES){ 
	      C = wrapper(function(target, iterable){
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base, target, C);
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if(IS_WEAK && proto.clear)delete proto.clear;
	  }

	  setToStringTag(C, NAME);

	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);

	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

	  return C;
	};

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(213);

	// 23.2 Set Objects
	module.exports = __webpack_require__(214)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var each         = __webpack_require__(173)(0)
	  , redefine     = __webpack_require__(19)
	  , meta         = __webpack_require__(23)
	  , assign       = __webpack_require__(70)
	  , weak         = __webpack_require__(217)
	  , isObject     = __webpack_require__(14)
	  , getWeak      = meta.getWeak
	  , isExtensible = Object.isExtensible
	  , uncaughtFrozenStore = weak.ufstore
	  , tmp          = {}
	  , InternalMap;

	var wrapper = function(get){
	  return function WeakMap(){
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};

	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      var data = getWeak(key);
	      if(data === true)return uncaughtFrozenStore(this).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	};

	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(214)('WeakMap', wrapper, methods, weak, true, true);

	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  InternalMap = weak.getConstructor(wrapper);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    redefine(proto, key, function(a, b){
	      // store frozen objects on internal weakmap shim
	      if(isObject(a) && !isExtensible(a)){
	        if(!this._f)this._f = new InternalMap;
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll       = __webpack_require__(211)
	  , getWeak           = __webpack_require__(23).getWeak
	  , anObject          = __webpack_require__(13)
	  , isObject          = __webpack_require__(14)
	  , anInstance        = __webpack_require__(206)
	  , forOf             = __webpack_require__(207)
	  , createArrayMethod = __webpack_require__(173)
	  , $has              = __webpack_require__(6)
	  , arrayFind         = createArrayMethod(5)
	  , arrayFindIndex    = createArrayMethod(6)
	  , id                = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function(that){
	  return that._l || (that._l = new UncaughtFrozenStore);
	};
	var UncaughtFrozenStore = function(){
	  this.a = [];
	};
	var findUncaughtFrozen = function(store, key){
	  return arrayFind(store.a, function(it){
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function(key){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = arrayFindIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};

	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var data = getWeak(anObject(key), true);
	    if(data === true)uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(217);

	// 23.4 WeakSet Objects
	__webpack_require__(214)('WeakSet', function(get){
	  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value){
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(9)
	  , $typed       = __webpack_require__(220)
	  , buffer       = __webpack_require__(221)
	  , anObject     = __webpack_require__(13)
	  , toIndex      = __webpack_require__(40)
	  , toLength     = __webpack_require__(38)
	  , isObject     = __webpack_require__(14)
	  , ArrayBuffer  = __webpack_require__(5).ArrayBuffer
	  , speciesConstructor = __webpack_require__(208)
	  , $ArrayBuffer = buffer.ArrayBuffer
	  , $DataView    = buffer.DataView
	  , $isView      = $typed.ABV && ArrayBuffer.isView
	  , $slice       = $ArrayBuffer.prototype.slice
	  , VIEW         = $typed.VIEW
	  , ARRAY_BUFFER = 'ArrayBuffer';

	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});

	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it){
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});

	$export($export.P + $export.U + $export.F * __webpack_require__(8)(function(){
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end){
	    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
	    var len    = anObject(this).byteLength
	      , first  = toIndex(start, len)
	      , final  = toIndex(end === undefined ? len : end, len)
	      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
	      , viewS  = new $DataView(this)
	      , viewT  = new $DataView(result)
	      , index  = 0;
	    while(first < final){
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});

	__webpack_require__(193)(ARRAY_BUFFER);

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(5)
	  , hide   = __webpack_require__(11)
	  , uid    = __webpack_require__(20)
	  , TYPED  = uid('typed_array')
	  , VIEW   = uid('view')
	  , ABV    = !!(global.ArrayBuffer && global.DataView)
	  , CONSTR = ABV
	  , i = 0, l = 9, Typed;

	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');

	while(i < l){
	  if(Typed = global[TypedArrayConstructors[i++]]){
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}

	module.exports = {
	  ABV:    ABV,
	  CONSTR: CONSTR,
	  TYPED:  TYPED,
	  VIEW:   VIEW
	};

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(5)
	  , DESCRIPTORS    = __webpack_require__(7)
	  , LIBRARY        = __webpack_require__(29)
	  , $typed         = __webpack_require__(220)
	  , hide           = __webpack_require__(11)
	  , redefineAll    = __webpack_require__(211)
	  , fails          = __webpack_require__(8)
	  , anInstance     = __webpack_require__(206)
	  , toInteger      = __webpack_require__(39)
	  , toLength       = __webpack_require__(38)
	  , gOPN           = __webpack_require__(51).f
	  , dP             = __webpack_require__(12).f
	  , arrayFill      = __webpack_require__(189)
	  , setToStringTag = __webpack_require__(25)
	  , ARRAY_BUFFER   = 'ArrayBuffer'
	  , DATA_VIEW      = 'DataView'
	  , PROTOTYPE      = 'prototype'
	  , WRONG_LENGTH   = 'Wrong length!'
	  , WRONG_INDEX    = 'Wrong index!'
	  , $ArrayBuffer   = global[ARRAY_BUFFER]
	  , $DataView      = global[DATA_VIEW]
	  , Math           = global.Math
	  , RangeError     = global.RangeError
	  , Infinity       = global.Infinity
	  , BaseBuffer     = $ArrayBuffer
	  , abs            = Math.abs
	  , pow            = Math.pow
	  , floor          = Math.floor
	  , log            = Math.log
	  , LN2            = Math.LN2
	  , BUFFER         = 'buffer'
	  , BYTE_LENGTH    = 'byteLength'
	  , BYTE_OFFSET    = 'byteOffset'
	  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
	  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
	  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;

	// IEEE754 conversions based on https://github.com/feross/ieee754
	var packIEEE754 = function(value, mLen, nBytes){
	  var buffer = Array(nBytes)
	    , eLen   = nBytes * 8 - mLen - 1
	    , eMax   = (1 << eLen) - 1
	    , eBias  = eMax >> 1
	    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
	    , i      = 0
	    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
	    , e, m, c;
	  value = abs(value)
	  if(value != value || value === Infinity){
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if(value * (c = pow(2, -e)) < 1){
	      e--;
	      c *= 2;
	    }
	    if(e + eBias >= 1){
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if(value * c >= 2){
	      e++;
	      c /= 2;
	    }
	    if(e + eBias >= eMax){
	      m = 0;
	      e = eMax;
	    } else if(e + eBias >= 1){
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	};
	var unpackIEEE754 = function(buffer, mLen, nBytes){
	  var eLen  = nBytes * 8 - mLen - 1
	    , eMax  = (1 << eLen) - 1
	    , eBias = eMax >> 1
	    , nBits = eLen - 7
	    , i     = nBytes - 1
	    , s     = buffer[i--]
	    , e     = s & 127
	    , m;
	  s >>= 7;
	  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if(e === 0){
	    e = 1 - eBias;
	  } else if(e === eMax){
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	};

	var unpackI32 = function(bytes){
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	};
	var packI8 = function(it){
	  return [it & 0xff];
	};
	var packI16 = function(it){
	  return [it & 0xff, it >> 8 & 0xff];
	};
	var packI32 = function(it){
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	};
	var packF64 = function(it){
	  return packIEEE754(it, 52, 8);
	};
	var packF32 = function(it){
	  return packIEEE754(it, 23, 4);
	};

	var addGetter = function(C, key, internal){
	  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
	};

	var get = function(view, bytes, index, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	};
	var set = function(view, bytes, index, conversion, value, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = conversion(+value);
	  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	};

	var validateArrayBufferArguments = function(that, length){
	  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
	  var numberLength = +length
	    , byteLength   = toLength(numberLength);
	  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
	  return byteLength;
	};

	if(!$typed.ABV){
	  $ArrayBuffer = function ArrayBuffer(length){
	    var byteLength = validateArrayBufferArguments(this, length);
	    this._b       = arrayFill.call(Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };

	  $DataView = function DataView(buffer, byteOffset, byteLength){
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH]
	      , offset       = toInteger(byteOffset);
	    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };

	  if(DESCRIPTORS){
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }

	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset){
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset){
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if(!fails(function(){
	    new $ArrayBuffer;     // eslint-disable-line no-new
	  }) || !fails(function(){
	    new $ArrayBuffer(.5); // eslint-disable-line no-new
	  })){
	    $ArrayBuffer = function ArrayBuffer(length){
	      return new BaseBuffer(validateArrayBufferArguments(this, length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
	      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
	    };
	    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2))
	    , $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	$export($export.G + $export.W + $export.F * !__webpack_require__(220).ABV, {
	  DataView: __webpack_require__(221).DataView
	});

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(224)('Int8', 1, function(init){
	  return function Int8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	if(__webpack_require__(7)){
	  var LIBRARY             = __webpack_require__(29)
	    , global              = __webpack_require__(5)
	    , fails               = __webpack_require__(8)
	    , $export             = __webpack_require__(9)
	    , $typed              = __webpack_require__(220)
	    , $buffer             = __webpack_require__(221)
	    , ctx                 = __webpack_require__(21)
	    , anInstance          = __webpack_require__(206)
	    , propertyDesc        = __webpack_require__(18)
	    , hide                = __webpack_require__(11)
	    , redefineAll         = __webpack_require__(211)
	    , toInteger           = __webpack_require__(39)
	    , toLength            = __webpack_require__(38)
	    , toIndex             = __webpack_require__(40)
	    , toPrimitive         = __webpack_require__(17)
	    , has                 = __webpack_require__(6)
	    , same                = __webpack_require__(72)
	    , classof             = __webpack_require__(76)
	    , isObject            = __webpack_require__(14)
	    , toObject            = __webpack_require__(59)
	    , isArrayIter         = __webpack_require__(163)
	    , create              = __webpack_require__(47)
	    , getPrototypeOf      = __webpack_require__(60)
	    , gOPN                = __webpack_require__(51).f
	    , getIterFn           = __webpack_require__(165)
	    , uid                 = __webpack_require__(20)
	    , wks                 = __webpack_require__(26)
	    , createArrayMethod   = __webpack_require__(173)
	    , createArrayIncludes = __webpack_require__(37)
	    , speciesConstructor  = __webpack_require__(208)
	    , ArrayIterators      = __webpack_require__(194)
	    , Iterators           = __webpack_require__(130)
	    , $iterDetect         = __webpack_require__(166)
	    , setSpecies          = __webpack_require__(193)
	    , arrayFill           = __webpack_require__(189)
	    , arrayCopyWithin     = __webpack_require__(186)
	    , $DP                 = __webpack_require__(12)
	    , $GOPD               = __webpack_require__(52)
	    , dP                  = $DP.f
	    , gOPD                = $GOPD.f
	    , RangeError          = global.RangeError
	    , TypeError           = global.TypeError
	    , Uint8Array          = global.Uint8Array
	    , ARRAY_BUFFER        = 'ArrayBuffer'
	    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
	    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
	    , PROTOTYPE           = 'prototype'
	    , ArrayProto          = Array[PROTOTYPE]
	    , $ArrayBuffer        = $buffer.ArrayBuffer
	    , $DataView           = $buffer.DataView
	    , arrayForEach        = createArrayMethod(0)
	    , arrayFilter         = createArrayMethod(2)
	    , arraySome           = createArrayMethod(3)
	    , arrayEvery          = createArrayMethod(4)
	    , arrayFind           = createArrayMethod(5)
	    , arrayFindIndex      = createArrayMethod(6)
	    , arrayIncludes       = createArrayIncludes(true)
	    , arrayIndexOf        = createArrayIncludes(false)
	    , arrayValues         = ArrayIterators.values
	    , arrayKeys           = ArrayIterators.keys
	    , arrayEntries        = ArrayIterators.entries
	    , arrayLastIndexOf    = ArrayProto.lastIndexOf
	    , arrayReduce         = ArrayProto.reduce
	    , arrayReduceRight    = ArrayProto.reduceRight
	    , arrayJoin           = ArrayProto.join
	    , arraySort           = ArrayProto.sort
	    , arraySlice          = ArrayProto.slice
	    , arrayToString       = ArrayProto.toString
	    , arrayToLocaleString = ArrayProto.toLocaleString
	    , ITERATOR            = wks('iterator')
	    , TAG                 = wks('toStringTag')
	    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
	    , DEF_CONSTRUCTOR     = uid('def_constructor')
	    , ALL_CONSTRUCTORS    = $typed.CONSTR
	    , TYPED_ARRAY         = $typed.TYPED
	    , VIEW                = $typed.VIEW
	    , WRONG_LENGTH        = 'Wrong length!';

	  var $map = createArrayMethod(1, function(O, length){
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });

	  var LITTLE_ENDIAN = fails(function(){
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });

	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
	    new Uint8Array(1).set({});
	  });

	  var strictToLength = function(it, SAME){
	    if(it === undefined)throw TypeError(WRONG_LENGTH);
	    var number = +it
	      , length = toLength(it);
	    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
	    return length;
	  };

	  var toOffset = function(it, BYTES){
	    var offset = toInteger(it);
	    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
	    return offset;
	  };

	  var validate = function(it){
	    if(isObject(it) && TYPED_ARRAY in it)return it;
	    throw TypeError(it + ' is not a typed array!');
	  };

	  var allocate = function(C, length){
	    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };

	  var speciesFromList = function(O, list){
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };

	  var fromList = function(C, list){
	    var index  = 0
	      , length = list.length
	      , result = allocate(C, length);
	    while(length > index)result[index] = list[index++];
	    return result;
	  };

	  var addGetter = function(it, key, internal){
	    dP(it, key, {get: function(){ return this._d[internal]; }});
	  };

	  var $from = function from(source /*, mapfn, thisArg */){
	    var O       = toObject(source)
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , iterFn  = getIterFn(O)
	      , i, length, values, result, step, iterator;
	    if(iterFn != undefined && !isArrayIter(iterFn)){
	      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
	        values.push(step.value);
	      } O = values;
	    }
	    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
	    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };

	  var $of = function of(/*...items*/){
	    var index  = 0
	      , length = arguments.length
	      , result = allocate(this, length);
	    while(length > index)result[index] = arguments[index++];
	    return result;
	  };

	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });

	  var $toLocaleString = function toLocaleString(){
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };

	  var proto = {
	    copyWithin: function copyWithin(target, start /*, end */){
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /*, thisArg */){
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /*, thisArg */){
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /*, thisArg */){
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /*, thisArg */){
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /*, thisArg */){
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /*, fromIndex */){
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /*, fromIndex */){
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator){ // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /*, thisArg */){
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse(){
	      var that   = this
	        , length = validate(that).length
	        , middle = Math.floor(length / 2)
	        , index  = 0
	        , value;
	      while(index < middle){
	        value         = that[index];
	        that[index++] = that[--length];
	        that[length]  = value;
	      } return that;
	    },
	    some: function some(callbackfn /*, thisArg */){
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn){
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end){
	      var O      = validate(this)
	        , length = O.length
	        , $begin = toIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
	      );
	    }
	  };

	  var $slice = function slice(start, end){
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };

	  var $set = function set(arrayLike /*, offset */){
	    validate(this);
	    var offset = toOffset(arguments[1], 1)
	      , length = this.length
	      , src    = toObject(arrayLike)
	      , len    = toLength(src.length)
	      , index  = 0;
	    if(len + offset > length)throw RangeError(WRONG_LENGTH);
	    while(index < len)this[offset + index] = src[index++];
	  };

	  var $iterators = {
	    entries: function entries(){
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys(){
	      return arrayKeys.call(validate(this));
	    },
	    values: function values(){
	      return arrayValues.call(validate(this));
	    }
	  };

	  var isTAIndex = function(target, key){
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key){
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc){
	    if(isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ){
	      target[key] = desc.value;
	      return target;
	    } else return dP(target, key, desc);
	  };

	  if(!ALL_CONSTRUCTORS){
	    $GOPD.f = $getDesc;
	    $DP.f   = $setDesc;
	  }

	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty:           $setDesc
	  });

	  if(fails(function(){ arrayToString.call({}); })){
	    arrayToString = arrayToLocaleString = function toString(){
	      return arrayJoin.call(this);
	    }
	  }

	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice:          $slice,
	    set:            $set,
	    constructor:    function(){ /* noop */ },
	    toString:       arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function(){ return this[TYPED_ARRAY]; }
	  });

	  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
	    CLAMPED = !!CLAMPED;
	    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
	      , ISNT_UINT8 = NAME != 'Uint8Array'
	      , GETTER     = 'get' + KEY
	      , SETTER     = 'set' + KEY
	      , TypedArray = global[NAME]
	      , Base       = TypedArray || {}
	      , TAC        = TypedArray && getPrototypeOf(TypedArray)
	      , FORCED     = !TypedArray || !$typed.ABV
	      , O          = {}
	      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function(that, index){
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function(that, index, value){
	      var data = that._d;
	      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function(that, index){
	      dP(that, index, {
	        get: function(){
	          return getter(this, index);
	        },
	        set: function(value){
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if(FORCED){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME, '_d');
	        var index  = 0
	          , offset = 0
	          , buffer, byteLength, length, klass;
	        if(!isObject(data)){
	          length     = strictToLength(data, true)
	          byteLength = length * BYTES;
	          buffer     = new $ArrayBuffer(byteLength);
	        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if($length === undefined){
	            if($len % BYTES)throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if(TYPED_ARRAY in data){
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while(index < length)addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if(!$iterDetect(function(iter){
	      // V8 works with iterators, but fails in many other cases
	      // https://code.google.com/p/v8/issues/detail?id=4552
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
	        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
	        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
	      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
	      , $iterator         = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

	    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
	      dP(TypedArrayPrototype, TAG, {
	        get: function(){ return NAME; }
	      });
	    }

	    O[NAME] = TypedArray;

	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES,
	      from: $from,
	      of: $of
	    });

	    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

	    $export($export.P, NAME, proto);

	    setSpecies(NAME);

	    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});

	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

	    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});

	    $export($export.P + $export.F * fails(function(){
	      new TypedArray(1).slice();
	    }), NAME, {slice: $slice});

	    $export($export.P + $export.F * (fails(function(){
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
	    }) || !fails(function(){
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, {toLocaleString: $toLocaleString});

	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function(){ /* empty */ };

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(224)('Uint8', 1, function(init){
	  return function Uint8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(224)('Uint8', 1, function(init){
	  return function Uint8ClampedArray(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	}, true);

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(224)('Int16', 2, function(init){
	  return function Int16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(224)('Uint16', 2, function(init){
	  return function Uint16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(224)('Int32', 4, function(init){
	  return function Int32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(224)('Uint32', 4, function(init){
	  return function Uint32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(224)('Float32', 4, function(init){
	  return function Float32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(224)('Float64', 8, function(init){
	  return function Float64Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export   = __webpack_require__(9)
	  , aFunction = __webpack_require__(22)
	  , anObject  = __webpack_require__(13)
	  , rApply    = (__webpack_require__(5).Reflect || {}).apply
	  , fApply    = Function.apply;
	// MS Edge argumentsList argument is optional
	$export($export.S + $export.F * !__webpack_require__(8)(function(){
	  rApply(function(){});
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList){
	    var T = aFunction(target)
	      , L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export    = __webpack_require__(9)
	  , create     = __webpack_require__(47)
	  , aFunction  = __webpack_require__(22)
	  , anObject   = __webpack_require__(13)
	  , isObject   = __webpack_require__(14)
	  , fails      = __webpack_require__(8)
	  , bind       = __webpack_require__(78)
	  , rConstruct = (__webpack_require__(5).Reflect || {}).construct;

	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function(){
	  function F(){}
	  return !(rConstruct(function(){}, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function(){
	  rConstruct(function(){});
	});

	$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /*, newTarget*/){
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
	    if(Target == newTarget){
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch(args.length){
	        case 0: return new Target;
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args));
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto    = newTarget.prototype
	      , instance = create(isObject(proto) ? proto : Object.prototype)
	      , result   = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP          = __webpack_require__(12)
	  , $export     = __webpack_require__(9)
	  , anObject    = __webpack_require__(13)
	  , toPrimitive = __webpack_require__(17);

	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(8)(function(){
	  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes){
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export  = __webpack_require__(9)
	  , gOPD     = __webpack_require__(52).f
	  , anObject = __webpack_require__(13);

	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey){
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export  = __webpack_require__(9)
	  , anObject = __webpack_require__(13);
	var Enumerate = function(iterated){
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = []       // keys
	    , key;
	  for(key in iterated)keys.push(key);
	};
	__webpack_require__(131)(Enumerate, 'Object', function(){
	  var that = this
	    , keys = that._k
	    , key;
	  do {
	    if(that._i >= keys.length)return {value: undefined, done: true};
	  } while(!((key = keys[that._i++]) in that._t));
	  return {value: key, done: false};
	});

	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target){
	    return new Enumerate(target);
	  }
	});

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD           = __webpack_require__(52)
	  , getPrototypeOf = __webpack_require__(60)
	  , has            = __webpack_require__(6)
	  , $export        = __webpack_require__(9)
	  , isObject       = __webpack_require__(14)
	  , anObject       = __webpack_require__(13);

	function get(target, propertyKey/*, receiver*/){
	  var receiver = arguments.length < 3 ? target : arguments[2]
	    , desc, proto;
	  if(anObject(target) === receiver)return target[propertyKey];
	  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
	}

	$export($export.S, 'Reflect', {get: get});

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD     = __webpack_require__(52)
	  , $export  = __webpack_require__(9)
	  , anObject = __webpack_require__(13);

	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export  = __webpack_require__(9)
	  , getProto = __webpack_require__(60)
	  , anObject = __webpack_require__(13);

	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target){
	    return getProto(anObject(target));
	  }
	});

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(9);

	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey){
	    return propertyKey in target;
	  }
	});

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export       = __webpack_require__(9)
	  , anObject      = __webpack_require__(13)
	  , $isExtensible = Object.isExtensible;

	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target){
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(9);

	$export($export.S, 'Reflect', {ownKeys: __webpack_require__(244)});

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN     = __webpack_require__(51)
	  , gOPS     = __webpack_require__(44)
	  , anObject = __webpack_require__(13)
	  , Reflect  = __webpack_require__(5).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
	  var keys       = gOPN.f(anObject(it))
	    , getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export            = __webpack_require__(9)
	  , anObject           = __webpack_require__(13)
	  , $preventExtensions = Object.preventExtensions;

	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target){
	    anObject(target);
	    try {
	      if($preventExtensions)$preventExtensions(target);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP             = __webpack_require__(12)
	  , gOPD           = __webpack_require__(52)
	  , getPrototypeOf = __webpack_require__(60)
	  , has            = __webpack_require__(6)
	  , $export        = __webpack_require__(9)
	  , createDesc     = __webpack_require__(18)
	  , anObject       = __webpack_require__(13)
	  , isObject       = __webpack_require__(14);

	function set(target, propertyKey, V/*, receiver*/){
	  var receiver = arguments.length < 4 ? target : arguments[3]
	    , ownDesc  = gOPD.f(anObject(target), propertyKey)
	    , existingDescriptor, proto;
	  if(!ownDesc){
	    if(isObject(proto = getPrototypeOf(target))){
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if(has(ownDesc, 'value')){
	    if(ownDesc.writable === false || !isObject(receiver))return false;
	    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    dP.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}

	$export($export.S, 'Reflect', {set: set});

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export  = __webpack_require__(9)
	  , setProto = __webpack_require__(74);

	if(setProto)$export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto){
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	var $export   = __webpack_require__(9)
	  , $includes = __webpack_require__(37)(true);

	$export($export.P, 'Array', {
	  includes: function includes(el /*, fromIndex = 0 */){
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	__webpack_require__(187)('includes');

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(9)
	  , $at     = __webpack_require__(128)(true);

	$export($export.P, 'String', {
	  at: function at(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(9)
	  , $pad    = __webpack_require__(251);

	$export($export.P, 'String', {
	  padStart: function padStart(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(38)
	  , repeat   = __webpack_require__(92)
	  , defined  = __webpack_require__(36);

	module.exports = function(that, maxLength, fillString, left){
	  var S            = String(defined(that))
	    , stringLength = S.length
	    , fillStr      = fillString === undefined ? ' ' : String(fillString)
	    , intMaxLength = toLength(maxLength);
	  if(intMaxLength <= stringLength || fillStr == '')return S;
	  var fillLen = intMaxLength - stringLength
	    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(9)
	  , $pad    = __webpack_require__(251);

	$export($export.P, 'String', {
	  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(84)('trimLeft', function($trim){
	  return function trimLeft(){
	    return $trim(this, 1);
	  };
	}, 'trimStart');

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(84)('trimRight', function($trim){
	  return function trimRight(){
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	var $export     = __webpack_require__(9)
	  , defined     = __webpack_require__(36)
	  , toLength    = __webpack_require__(38)
	  , isRegExp    = __webpack_require__(135)
	  , getFlags    = __webpack_require__(197)
	  , RegExpProto = RegExp.prototype;

	var $RegExpStringIterator = function(regexp, string){
	  this._r = regexp;
	  this._s = string;
	};

	__webpack_require__(131)($RegExpStringIterator, 'RegExp String', function next(){
	  var match = this._r.exec(this._s);
	  return {value: match, done: match === null};
	});

	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp){
	    defined(this);
	    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
	    var S     = String(this)
	      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
	      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(28)('asyncIterator');

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(28)('observable');

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export        = __webpack_require__(9)
	  , ownKeys        = __webpack_require__(244)
	  , toIObject      = __webpack_require__(33)
	  , gOPD           = __webpack_require__(52)
	  , createProperty = __webpack_require__(164);

	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
	    var O       = toIObject(object)
	      , getDesc = gOPD.f
	      , keys    = ownKeys(O)
	      , result  = {}
	      , i       = 0
	      , key;
	    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
	    return result;
	  }
	});

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(9)
	  , $values = __webpack_require__(260)(false);

	$export($export.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(31)
	  , toIObject = __webpack_require__(33)
	  , isEnum    = __webpack_require__(45).f;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export  = __webpack_require__(9)
	  , $entries = __webpack_require__(260)(true);

	$export($export.S, 'Object', {
	  entries: function entries(it){
	    return $entries(it);
	  }
	});

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(9)
	  , toObject        = __webpack_require__(59)
	  , aFunction       = __webpack_require__(22)
	  , $defineProperty = __webpack_require__(12);

	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(7) && $export($export.P + __webpack_require__(263), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter){
	    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(29)|| !__webpack_require__(8)(function(){
	  var K = Math.random();
	  // In FF throws only define methods
	  __defineSetter__.call(null, K, function(){ /* empty */});
	  delete __webpack_require__(5)[K];
	});

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(9)
	  , toObject        = __webpack_require__(59)
	  , aFunction       = __webpack_require__(22)
	  , $defineProperty = __webpack_require__(12);

	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(7) && $export($export.P + __webpack_require__(263), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter){
	    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(9)
	  , toObject                 = __webpack_require__(59)
	  , toPrimitive              = __webpack_require__(17)
	  , getPrototypeOf           = __webpack_require__(60)
	  , getOwnPropertyDescriptor = __webpack_require__(52).f;

	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(7) && $export($export.P + __webpack_require__(263), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.get;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(9)
	  , toObject                 = __webpack_require__(59)
	  , toPrimitive              = __webpack_require__(17)
	  , getPrototypeOf           = __webpack_require__(60)
	  , getOwnPropertyDescriptor = __webpack_require__(52).f;

	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(7) && $export($export.P + __webpack_require__(263), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.set;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(9);

	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(268)('Map')});

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(76)
	  , from    = __webpack_require__(269);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(207);

	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(9);

	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(268)('Set')});

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-global
	var $export = __webpack_require__(9);

	$export($export.S, 'System', {global: __webpack_require__(5)});

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(9)
	  , cof     = __webpack_require__(35);

	$export($export.S, 'Error', {
	  isError: function isError(it){
	    return cof(it) === 'Error';
	  }
	});

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(9);

	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(9);

	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(9);

	$export($export.S, 'Math', {
	  imulh: function imulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >> 16
	      , v1 = $v >> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(9);

	$export($export.S, 'Math', {
	  umulh: function umulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >>> 16
	      , v1 = $v >>> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(278)
	  , anObject                  = __webpack_require__(13)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;

	metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	}});

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	var Map     = __webpack_require__(212)
	  , $export = __webpack_require__(9)
	  , shared  = __webpack_require__(24)('metadata')
	  , store   = shared.store || (shared.store = new (__webpack_require__(216)));

	var getOrCreateMetadataMap = function(target, targetKey, create){
	  var targetMetadata = store.get(target);
	  if(!targetMetadata){
	    if(!create)return undefined;
	    store.set(target, targetMetadata = new Map);
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if(!keyMetadata){
	    if(!create)return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map);
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function(target, targetKey){
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
	    , keys        = [];
	  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
	  return keys;
	};
	var toMetaKey = function(it){
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function(O){
	  $export($export.S, 'Reflect', O);
	};

	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(13)
	  , toMetaKey              = metadata.key
	  , getOrCreateMetadataMap = metadata.map
	  , store                  = metadata.store;

	metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
	  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
	    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
	  if(metadataMap.size)return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	}});

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(13)
	  , getPrototypeOf         = __webpack_require__(60)
	  , ordinaryHasOwnMetadata = metadata.has
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;

	var ordinaryGetMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};

	metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var Set                     = __webpack_require__(215)
	  , from                    = __webpack_require__(269)
	  , metadata                = __webpack_require__(278)
	  , anObject                = __webpack_require__(13)
	  , getPrototypeOf          = __webpack_require__(60)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;

	var ordinaryMetadataKeys = function(O, P){
	  var oKeys  = ordinaryOwnMetadataKeys(O, P)
	    , parent = getPrototypeOf(O);
	  if(parent === null)return oKeys;
	  var pKeys  = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};

	metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(13)
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;

	metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                = __webpack_require__(278)
	  , anObject                = __webpack_require__(13)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;

	metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(13)
	  , getPrototypeOf         = __webpack_require__(60)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;

	var ordinaryHasMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};

	metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(278)
	  , anObject               = __webpack_require__(13)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;

	metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(278)
	  , anObject                  = __webpack_require__(13)
	  , aFunction                 = __webpack_require__(22)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;

	metadata.exp({metadata: function metadata(metadataKey, metadataValue){
	  return function decorator(target, targetKey){
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	}});

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export   = __webpack_require__(9)
	  , microtask = __webpack_require__(210)()
	  , process   = __webpack_require__(5).process
	  , isNode    = __webpack_require__(35)(process) == 'process';

	$export($export.G, {
	  asap: function asap(fn){
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	var $export     = __webpack_require__(9)
	  , global      = __webpack_require__(5)
	  , core        = __webpack_require__(10)
	  , microtask   = __webpack_require__(210)()
	  , OBSERVABLE  = __webpack_require__(26)('observable')
	  , aFunction   = __webpack_require__(22)
	  , anObject    = __webpack_require__(13)
	  , anInstance  = __webpack_require__(206)
	  , redefineAll = __webpack_require__(211)
	  , hide        = __webpack_require__(11)
	  , forOf       = __webpack_require__(207)
	  , RETURN      = forOf.RETURN;

	var getMethod = function(fn){
	  return fn == null ? undefined : aFunction(fn);
	};

	var cleanupSubscription = function(subscription){
	  var cleanup = subscription._c;
	  if(cleanup){
	    subscription._c = undefined;
	    cleanup();
	  }
	};

	var subscriptionClosed = function(subscription){
	  return subscription._o === undefined;
	};

	var closeSubscription = function(subscription){
	  if(!subscriptionClosed(subscription)){
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};

	var Subscription = function(observer, subscriber){
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup      = subscriber(observer)
	      , subscription = cleanup;
	    if(cleanup != null){
	      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch(e){
	    observer.error(e);
	    return;
	  } if(subscriptionClosed(this))cleanupSubscription(this);
	};

	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe(){ closeSubscription(this); }
	});

	var SubscriptionObserver = function(subscription){
	  this._s = subscription;
	};

	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if(m)return m.call(observer, value);
	      } catch(e){
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value){
	    var subscription = this._s;
	    if(subscriptionClosed(subscription))throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if(!m)throw value;
	      value = m.call(observer, value);
	    } catch(e){
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch(e){
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});

	var $Observable = function Observable(subscriber){
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};

	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer){
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn){
	    var that = this;
	    return new (core.Promise || global.Promise)(function(resolve, reject){
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next : function(value){
	          try {
	            return fn(value);
	          } catch(e){
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});

	redefineAll($Observable, {
	  from: function from(x){
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if(method){
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function(observer){
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          try {
	            if(forOf(x, false, function(it){
	              observer.next(it);
	              if(done)return RETURN;
	            }) === RETURN)return;
	          } catch(e){
	            if(done)throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  },
	  of: function of(){
	    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          for(var i = 0; i < items.length; ++i){
	            observer.next(items[i]);
	            if(done)return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  }
	});

	hide($Observable.prototype, OBSERVABLE, function(){ return this; });

	$export($export.G, {Observable: $Observable});

	__webpack_require__(193)('Observable');

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global     = __webpack_require__(5)
	  , $export    = __webpack_require__(9)
	  , invoke     = __webpack_require__(79)
	  , partial    = __webpack_require__(290)
	  , navigator  = global.navigator
	  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	var wrap = function(set){
	  return MSIE ? function(fn, time /*, ...args */){
	    return set(invoke(
	      partial,
	      [].slice.call(arguments, 2),
	      typeof fn == 'function' ? fn : Function(fn)
	    ), time);
	  } : set;
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout:  wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path      = __webpack_require__(291)
	  , invoke    = __webpack_require__(79)
	  , aFunction = __webpack_require__(22);
	module.exports = function(/* ...pargs */){
	  var fn     = aFunction(this)
	    , length = arguments.length
	    , pargs  = Array(length)
	    , i      = 0
	    , _      = path._
	    , holder = false;
	  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
	  return function(/* ...args */){
	    var that = this
	      , aLen = arguments.length
	      , j = 0, k = 0, args;
	    if(!holder && !aLen)return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
	    while(aLen > k)args.push(arguments[k++]);
	    return invoke(fn, args, that);
	  };
	};

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(5);

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9)
	  , $task   = __webpack_require__(209);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	var $iterators    = __webpack_require__(194)
	  , redefine      = __webpack_require__(19)
	  , global        = __webpack_require__(5)
	  , hide          = __webpack_require__(11)
	  , Iterators     = __webpack_require__(130)
	  , wks           = __webpack_require__(26)
	  , ITERATOR      = wks('iterator')
	  , TO_STRING_TAG = wks('toStringTag')
	  , ArrayValues   = Iterators.Array;

	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype
	    , key;
	  if(proto){
	    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
	    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
	  }
	}

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */

	!(function(global) {
	  "use strict";

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }

	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  runtime.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }

	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  runtime.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        if (delegate.iterator.return) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[toStringTagSymbol] = "Generator";

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;

	  function doneResult() {
	    return { value: undefined, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined;
	      }

	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(295)))

/***/ },
/* 295 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(297);
	module.exports = __webpack_require__(10).RegExp.escape;

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(9)
	  , $re     = __webpack_require__(298)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

	$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ },
/* 298 */
/***/ function(module, exports) {

	module.exports = function(regExp, replace){
	  var replacer = replace === Object(replace) ? function(part){
	    return replace[part];
	  } : replace;
	  return function(it){
	    return String(it).replace(regExp, replacer);
	  };
	};

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {(function (root) {

	  // Store setTimeout reference so promise-polyfill will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var setTimeoutFunc = setTimeout;

	  function noop() {}
	  
	  // Polyfill for Function.prototype.bind
	  function bind(fn, thisArg) {
	    return function () {
	      fn.apply(thisArg, arguments);
	    };
	  }

	  function Promise(fn) {
	    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
	    if (typeof fn !== 'function') throw new TypeError('not a function');
	    this._state = 0;
	    this._handled = false;
	    this._value = undefined;
	    this._deferreds = [];

	    doResolve(fn, this);
	  }

	  function handle(self, deferred) {
	    while (self._state === 3) {
	      self = self._value;
	    }
	    if (self._state === 0) {
	      self._deferreds.push(deferred);
	      return;
	    }
	    self._handled = true;
	    Promise._immediateFn(function () {
	      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
	      if (cb === null) {
	        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
	        return;
	      }
	      var ret;
	      try {
	        ret = cb(self._value);
	      } catch (e) {
	        reject(deferred.promise, e);
	        return;
	      }
	      resolve(deferred.promise, ret);
	    });
	  }

	  function resolve(self, newValue) {
	    try {
	      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
	      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
	        var then = newValue.then;
	        if (newValue instanceof Promise) {
	          self._state = 3;
	          self._value = newValue;
	          finale(self);
	          return;
	        } else if (typeof then === 'function') {
	          doResolve(bind(then, newValue), self);
	          return;
	        }
	      }
	      self._state = 1;
	      self._value = newValue;
	      finale(self);
	    } catch (e) {
	      reject(self, e);
	    }
	  }

	  function reject(self, newValue) {
	    self._state = 2;
	    self._value = newValue;
	    finale(self);
	  }

	  function finale(self) {
	    if (self._state === 2 && self._deferreds.length === 0) {
	      Promise._immediateFn(function() {
	        if (!self._handled) {
	          Promise._unhandledRejectionFn(self._value);
	        }
	      });
	    }

	    for (var i = 0, len = self._deferreds.length; i < len; i++) {
	      handle(self, self._deferreds[i]);
	    }
	    self._deferreds = null;
	  }

	  function Handler(onFulfilled, onRejected, promise) {
	    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	    this.promise = promise;
	  }

	  /**
	   * Take a potentially misbehaving resolver function and make sure
	   * onFulfilled and onRejected are only called once.
	   *
	   * Makes no guarantees about asynchrony.
	   */
	  function doResolve(fn, self) {
	    var done = false;
	    try {
	      fn(function (value) {
	        if (done) return;
	        done = true;
	        resolve(self, value);
	      }, function (reason) {
	        if (done) return;
	        done = true;
	        reject(self, reason);
	      });
	    } catch (ex) {
	      if (done) return;
	      done = true;
	      reject(self, ex);
	    }
	  }

	  Promise.prototype['catch'] = function (onRejected) {
	    return this.then(null, onRejected);
	  };

	  Promise.prototype.then = function (onFulfilled, onRejected) {
	    var prom = new (this.constructor)(noop);

	    handle(this, new Handler(onFulfilled, onRejected, prom));
	    return prom;
	  };

	  Promise.all = function (arr) {
	    var args = Array.prototype.slice.call(arr);

	    return new Promise(function (resolve, reject) {
	      if (args.length === 0) return resolve([]);
	      var remaining = args.length;

	      function res(i, val) {
	        try {
	          if (val && (typeof val === 'object' || typeof val === 'function')) {
	            var then = val.then;
	            if (typeof then === 'function') {
	              then.call(val, function (val) {
	                res(i, val);
	              }, reject);
	              return;
	            }
	          }
	          args[i] = val;
	          if (--remaining === 0) {
	            resolve(args);
	          }
	        } catch (ex) {
	          reject(ex);
	        }
	      }

	      for (var i = 0; i < args.length; i++) {
	        res(i, args[i]);
	      }
	    });
	  };

	  Promise.resolve = function (value) {
	    if (value && typeof value === 'object' && value.constructor === Promise) {
	      return value;
	    }

	    return new Promise(function (resolve) {
	      resolve(value);
	    });
	  };

	  Promise.reject = function (value) {
	    return new Promise(function (resolve, reject) {
	      reject(value);
	    });
	  };

	  Promise.race = function (values) {
	    return new Promise(function (resolve, reject) {
	      for (var i = 0, len = values.length; i < len; i++) {
	        values[i].then(resolve, reject);
	      }
	    });
	  };

	  // Use polyfill for setImmediate for performance gains
	  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
	    function (fn) {
	      setTimeoutFunc(fn, 0);
	    };

	  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
	    if (typeof console !== 'undefined' && console) {
	      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
	    }
	  };

	  /**
	   * Set the immediate function to execute callbacks
	   * @param fn {function} Function to execute
	   * @deprecated
	   */
	  Promise._setImmediateFn = function _setImmediateFn(fn) {
	    Promise._immediateFn = fn;
	  };

	  /**
	   * Change the function to execute on unhandled rejection
	   * @param {function} fn Function to execute on unhandled rejection
	   * @deprecated
	   */
	  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
	    Promise._unhandledRejectionFn = fn;
	  };
	  
	  if (typeof module !== 'undefined' && module.exports) {
	    module.exports = Promise;
	  } else if (!root.Promise) {
	    root.Promise = Promise;
	  }

	})(this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(300).setImmediate))

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	var apply = Function.prototype.apply;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// setimmediate attaches itself to the global object
	__webpack_require__(301);
	exports.setImmediate = setImmediate;
	exports.clearImmediate = clearImmediate;


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";

	    if (global.setImmediate) {
	        return;
	    }

	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;

	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }

	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }

	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }

	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }

	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }

	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }

	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };

	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }

	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }

	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };

	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }

	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }

	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }

	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();

	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();

	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();

	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();

	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }

	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(295)))

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var MBPrice = __webpack_require__(303);
	var CashierJP = __webpack_require__(466);

	var HandleClick = function HandleClick(param) {
	    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        values[_key - 1] = arguments[_key];
	    }

	    switch (param) {
	        case 'CashierJP':
	            return CashierJP.errorHandler();
	        case 'MBPrice':
	            return values && MBPrice.processBuy(values[0], values[1]);
	        // no default
	    }
	    return function () {
	        return null;
	    };
	};

	module.exports = {
	    HandleClick: HandleClick
	};

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var MBContract = __webpack_require__(304);
	var MBDefaults = __webpack_require__(416);
	var MBNotifications = __webpack_require__(434);
	var BinarySocket = __webpack_require__(427);
	var ViewPopup = __webpack_require__(435);
	var Client = __webpack_require__(420);
	var GTM = __webpack_require__(464);
	var localize = __webpack_require__(428).localize;
	var getPropertyValue = __webpack_require__(417).getPropertyValue;
	var isEmptyObject = __webpack_require__(417).isEmptyObject;
	var elementInnerHtml = __webpack_require__(430).elementInnerHtml;
	var jpClient = __webpack_require__(425).jpClient;
	var formatMoney = __webpack_require__(433).formatMoney;

	/*
	 * Price object handles all the functions we need to display prices
	 *
	 * We create Price proposal that we need to send to server to get price,
	 * longcode and all other information that we need to get the price for
	 * current contract
	 *
	 */

	var MBPrice = function () {
	    'use strict';

	    var price_selector = '.prices-wrapper .price-rows';
	    var prices = {},
	        contract_types = {},
	        barriers = [],
	        req_id = 0,
	        res_count = 0,
	        is_displayed = false,
	        is_unwelcome = false,
	        $tables = void 0;

	    var addPriceObj = function addPriceObj(req) {
	        req.barriers.forEach(function (barrier_obj) {
	            var barrier = makeBarrier(barrier_obj);
	            if (!prices[barrier]) {
	                prices[barrier] = {};
	            }
	            req.contract_type.forEach(function (c_type) {
	                prices[barrier][c_type] = {};
	                if (!contract_types[c_type]) {
	                    contract_types[c_type] = MBContract.getTemplate(c_type);
	                }
	            });
	        });
	    };

	    var makeBarrier = function makeBarrier(barrier_obj) {
	        if (!barrier_obj.barrier && barrier_obj.error) barrier_obj = barrier_obj.error.details;
	        return (barrier_obj.barrier2 ? barrier_obj.barrier2 + '_' : '') + barrier_obj.barrier;
	    };

	    var display = function display(response) {
	        Object.keys(response.proposal_array.proposals).forEach(function (contract_type) {
	            response.proposal_array.proposals[contract_type].forEach(function (proposal) {
	                var barrier = makeBarrier(proposal);
	                var prev_proposal = $.extend({}, prices[barrier][contract_type]);
	                prices[barrier][contract_type] = $.extend({ echo_req: response.echo_req }, proposal);

	                if (isEmptyObject(prev_proposal)) {
	                    res_count++;
	                }

	                // update previous ask_price to use in price movement
	                if (!isEmptyObject(prev_proposal) && !prev_proposal.error) {
	                    prices[barrier][contract_type].prev_price = prev_proposal.ask_price;
	                }
	            });

	            // populate table if all proposals received
	            if (!is_displayed && res_count === Object.keys(prices).length * 2) {
	                populateTable();
	            } else {
	                updatePrice(contract_type);
	            }
	        });
	    };

	    var populateTable = function populateTable() {
	        if (!$tables) {
	            $tables = $(price_selector);
	        }
	        if (!barriers.length) {
	            barriers = Object.keys(prices).sort(function (a, b) {
	                return +b.split('_')[0] - +a.split('_')[0];
	            });
	        }

	        BinarySocket.wait('get_account_status').then(function (response) {
	            is_unwelcome = /unwelcome/.test(response.get_account_status.status);
	            if (is_unwelcome) {
	                MBNotifications.show({
	                    text: localize('Sorry, your account is not authorised for any further contract purchases.'),
	                    uid: 'UNWELCOME',
	                    dismissible: false
	                });
	            }
	        });

	        barriers.forEach(function (barrier) {
	            Object.keys(contract_types).forEach(function (contract_type) {
	                $($tables[+contract_types[contract_type].order]).append(makePriceRow(getValues(prices[barrier][contract_type], contract_type)));
	            });
	        });

	        MBPrice.hidePriceOverlay();
	        MBNotifications.hideSpinnerShowTrading();
	        is_displayed = true;
	    };

	    var updatePrice = function updatePrice(contract_type) {
	        barriers.forEach(function (barrier) {
	            var proposal = prices[barrier][contract_type],
	                price_rows = document.querySelectorAll(price_selector + ' div[data-barrier="' + makeBarrier(proposal) + '"]');

	            if (!price_rows.length) return;

	            var contract_info = contract_types[contract_type];
	            var contract_info_opp = contract_types[contract_info.opposite];
	            var values = getValues(proposal, contract_type);
	            var values_opp = getValues(prices[barrier][contract_info.opposite], contract_info.opposite);

	            elementInnerHtml(price_rows[+contract_info.order], makePriceRow(values, true));
	            elementInnerHtml(price_rows[+contract_info_opp.order], makePriceRow(values_opp, true));
	        });
	    };

	    var getValues = function getValues(proposal, contract_type) {
	        var barrier = makeBarrier(proposal);
	        var payout = proposal.echo_req.amount;
	        var proposal_opp = prices[barrier][contract_types[contract_type].opposite];
	        return {
	            contract_type: contract_type,
	            barrier: barrier,
	            is_active: !proposal.error && proposal.ask_price && !is_unwelcome,
	            message: proposal.error && proposal.error.code !== 'RateLimit' ? proposal.error.message : '',
	            ask_price: getAskPrice(proposal),
	            sell_price: payout - getAskPrice(proposal_opp),
	            ask_price_movement: !proposal.error ? getMovementDirection(proposal.prev_price, proposal.ask_price) : '',
	            sell_price_movement: proposal_opp && !proposal_opp.error ? getMovementDirection(proposal_opp.ask_price, proposal_opp.prev_price) : ''
	        };
	    };

	    var getAskPrice = function getAskPrice(proposal) {
	        return proposal.error || +proposal.ask_price === 0 ? getPropertyValue(proposal, ['error', 'details', 'display_value']) || proposal.echo_req.amount : // In case of RateLimit error, there is no display_value, so we display the request amount
	        proposal.ask_price;
	    };

	    var getMovementDirection = function getMovementDirection(prev, current) {
	        return current > prev ? 'up' : current < prev ? 'down' : '';
	    };

	    var makePriceRow = function makePriceRow(values, is_update) {
	        var payout = MBDefaults.get('payout');
	        var is_japan = jpClient();
	        return (is_update ? '' : '<div data-barrier="' + values.barrier + '" class="gr-row price-row">') + '\n                <div class="gr-4 barrier">' + values.barrier.split('_').join(' ... ') + '</div>\n                <div class="gr-4 buy-price">\n                    <button class="price-button' + (values.is_active ? '' : ' inactive') + '"\n                        ' + (values.is_active ? ' onclick="return HandleClick(\'MBPrice\', \'' + values.barrier + '\', \'' + values.contract_type + '\')"' : '') + '\n                        ' + (values.message ? ' data-balloon="' + values.message + '"' : '') + '>\n                            <span class="value-wrapper">\n                                <span class="dynamics ' + (values.ask_price_movement || '') + '"></span>\n                                ' + formatPrice(values.ask_price) + '\n                            </span>\n                            ' + (is_japan ? '<span class="base-value">(' + formatPrice(values.ask_price / payout) + ')</span>' : '') + '\n                    </button>\n                </div>\n                <div class="gr-4 sell-price">\n                    <span class="price-wrapper' + (!values.sell_price ? ' inactive' : '') + '">\n                        <span class="dynamics ' + (values.sell_price_movement || '') + '"></span>\n                        ' + formatPrice(values.sell_price) + '\n                        ' + (is_japan ? '<span class="base-value">(' + formatPrice(values.sell_price / payout) + ')</span>' : '') + '\n                    </span>\n                </div>\n            ' + (is_update ? '' : '</div>');
	    };

	    var processBuy = function processBuy(barrier, contract_type) {
	        if (!barrier || !contract_type) return;
	        if (!Client.isLoggedIn()) {
	            MBNotifications.show({ text: localize('Please log in.'), uid: 'LOGIN_ERROR', dismissible: true });
	            return;
	        }
	        MBPrice.showPriceOverlay();
	        MBPrice.sendBuyRequest(barrier, contract_type);
	    };

	    var formatPrice = function formatPrice(price) {
	        return formatMoney(MBContract.getCurrency(), price, 1);
	    };

	    var cleanup = function cleanup() {
	        prices = {};
	        contract_types = {};
	        barriers = [];
	        res_count = 0;
	        is_displayed = false;
	        // display loading
	        if ($(price_selector).html()) {
	            $('#loading-overlay').height($(price_selector).height()).setVisibility(1);
	        }
	        $(price_selector).html('');
	    };

	    var sendBuyRequest = function sendBuyRequest(barrier, contract_type) {
	        var proposal = prices[barrier][contract_type];
	        if (!proposal || proposal.error) return;

	        var req = {
	            buy: 1,
	            price: proposal.ask_price,
	            parameters: {
	                amount: proposal.echo_req.amount,
	                barrier: proposal.barrier,
	                basis: 'payout',
	                contract_type: contract_type,
	                currency: MBContract.getCurrency(),
	                symbol: proposal.echo_req.symbol,
	                date_expiry: proposal.echo_req.date_expiry,
	                trading_period_start: proposal.echo_req.trading_period_start,
	                app_markup_percentage: '0'
	            }
	        };

	        if (proposal.barrier2) {
	            req.parameters.barrier2 = proposal.barrier2;
	        }

	        BinarySocket.send(req).then(function (response) {
	            if (response.error) {
	                hidePriceOverlay();
	                MBNotifications.show({ text: response.error.message, uid: 'BUY_ERROR', dismissible: true });
	            } else {
	                MBNotifications.hide('BUY_ERROR');
	                ViewPopup.init($('<div />', { contract_id: response.buy.contract_id }).get(0));
	                GTM.pushPurchaseData(response);
	            }
	        });
	    };

	    var showPriceOverlay = function showPriceOverlay() {
	        $('#disable-overlay').setVisibility(1);
	    };

	    var hidePriceOverlay = function hidePriceOverlay() {
	        $('#disable-overlay, #loading-overlay').setVisibility(0);
	    };

	    return {
	        display: display,
	        addPriceObj: addPriceObj,
	        processBuy: processBuy,
	        cleanup: cleanup,
	        sendBuyRequest: sendBuyRequest,
	        showPriceOverlay: showPriceOverlay,
	        hidePriceOverlay: hidePriceOverlay,
	        getReqId: function getReqId() {
	            return req_id;
	        },
	        increaseReqId: function increaseReqId() {
	            req_id++;cleanup();
	        },
	        getPrices: function getPrices() {
	            return prices;
	        },
	        onUnload: function onUnload() {
	            cleanup();req_id = 0;$tables = undefined;
	        }
	    };
	}();

	module.exports = MBPrice;

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var moment = __webpack_require__(305);
	var MBDefaults = __webpack_require__(416);
	var MBSymbols = __webpack_require__(418);
	var Client = __webpack_require__(420);
	var getLanguage = __webpack_require__(424).get;
	var localize = __webpack_require__(428).localize;
	var isEmptyObject = __webpack_require__(417).isEmptyObject;
	var elementInnerHtml = __webpack_require__(430).elementInnerHtml;
	var jpClient = __webpack_require__(425).jpClient;
	var formatCurrency = __webpack_require__(433).formatCurrency;

	/*
	 * Contract object mocks the trading form we have on our website
	 * It parses the contracts json we get from socket.send({contracts_for: 'R_50'})
	 */
	var MBContract = function () {
	    'use strict';

	    var contracts_for_response = void 0;

	    var durationText = function durationText(dur) {
	        var duration_map = {
	            m: 'min',
	            h: 'h',
	            d: 'day',
	            W: 'week',
	            M: 'month',
	            Y: 'year'
	        };
	        Object.keys(duration_map).forEach(function (key) {
	            dur = dur.replace(key, localize(duration_map[key] + (+dur[0] === 1 || /h/.test(key) ? '' : 's')));
	        });
	        if (!jpClient()) {
	            dur = dur.replace(/(\d+)([a-z]+)/ig, '$1 $2 ').trim();
	        }
	        return dur;
	    };

	    var PeriodText = function PeriodText(trading_period) {
	        var date_expiry = void 0,
	            duration = void 0;
	        if ((typeof trading_period === 'undefined' ? 'undefined' : _typeof(trading_period)) === 'object') {
	            date_expiry = trading_period.date_expiry.epoch;
	            duration = trading_period.duration;
	        } else {
	            date_expiry = trading_period.split('_')[1];
	            duration = trading_period.split('_')[2];
	        }
	        var text_value = moment.utc(date_expiry * 1000).utcOffset(jpClient() ? '+09:00' : '+00:00').locale(getLanguage().toLowerCase()).format('MMM Do, HH:mm');
	        if (jpClient()) {
	            text_value = text_value.replace(/08:59/, '09:00«') + ' (' + durationText(duration.replace('0d', '1d')) + ')';
	        }
	        return text_value.toString();
	    };

	    // use function to generate elements and append them
	    // e.g. element is select and element to append is option
	    var appendTextValueChild = function appendTextValueChild(element, string, value, is_selected) {
	        if (element && !element.nodeName) {
	            if (typeof element === 'string') {
	                element = document.getElementById(element);
	            } else {
	                element = undefined;
	            }
	        }
	        if (!element) return;
	        var option = document.createElement('option');
	        option.text = string;
	        option.value = value;
	        if (is_selected) {
	            option.setAttribute('selected', 'selected');
	        }
	        element.appendChild(option);
	    };

	    var populatePeriods = function populatePeriods(rebuild) {
	        if (!contracts_for_response || isEmptyObject(contracts_for_response)) return;
	        var trading_period = void 0,
	            start_end = void 0;
	        var trading_period_array = [];
	        var available_contracts = contracts_for_response.contracts_for.available;
	        var selected_option = MBDefaults.get('category');
	        var $period_element = $('#period');
	        if (!selected_option || !available_contracts) return;
	        for (var i = 0; i < available_contracts.length; i++) {
	            if (available_contracts[i].contract_category === selected_option) {
	                trading_period = available_contracts[i].trading_period;
	                if (!trading_period) return;
	                start_end = [trading_period.date_start.epoch, trading_period.date_expiry.epoch, trading_period.duration].join('_');
	                if (trading_period_array.indexOf(start_end) < 0) {
	                    trading_period_array.push(start_end);
	                }
	            }
	        }
	        trading_period_array.sort(sortByExpiryTime);
	        if (rebuild) {
	            $period_element.empty();
	        }
	        if ($period_element.children().length === 0) {
	            // populate for the first time
	            var default_value = MBDefaults.get('period');
	            for (var j = 0; j < trading_period_array.length; j++) {
	                appendTextValueChild('period', PeriodText(trading_period_array[j]), trading_period_array[j], trading_period_array[j] === default_value);
	            }
	            MBDefaults.set('period', $period_element.val());
	            MBContract.displayDescriptions();
	            MBContract.displayRemainingTime(true);
	        } else {
	            // update options
	            var existing_array = [];
	            var missing_array = [];
	            $period_element.find('option').each(function () {
	                existing_array.push($(this).val());
	            });

	            // add new periods to dropdown
	            for (var l = 0; l < trading_period_array.length; l++) {
	                if (existing_array.indexOf(trading_period_array[l]) < 0) {
	                    missing_array.push(trading_period_array[l]);
	                }
	            }
	            if (missing_array.length > 0) {
	                var $new_option = void 0;
	                existing_array = existing_array.concat(missing_array).sort(sortByExpiryTime);
	                for (var m = 0; m < existing_array.length; m++) {
	                    if ($period_element.find('option[value="' + existing_array[m] + '"]').length < 1) {
	                        $new_option = $('<option/>', { value: existing_array[m], text: PeriodText(existing_array[m]) });
	                        if (m < 1) {
	                            $new_option.insertBefore($period_element.children().eq(m));
	                        } else {
	                            $new_option.insertAfter($period_element.children().eq(m - 1));
	                        }
	                    }
	                }
	            }

	            // remove periods that no longer exist
	            existing_array.forEach(function (period) {
	                if (trading_period_array.indexOf(period) < 0) {
	                    $period_element.find('option[value="' + period + '"]').remove();
	                }
	            });
	        }
	    };

	    var period_value = void 0,
	        $count_down_timer = void 0,
	        remaining_time_element = void 0,
	        remaining_timeout = void 0;
	    var displayRemainingTime = function displayRemainingTime(recalculate) {
	        if (typeof period_value === 'undefined' || recalculate) {
	            period_value = document.getElementById('period').value;
	            $count_down_timer = $('.countdown-timer');
	            remaining_time_element = document.getElementById('remaining-time');
	        }
	        if (!period_value) return;
	        var time_left = parseInt(period_value.split('_')[1]) - window.time.unix();
	        if (time_left <= 0) {
	            location.reload();
	        } else if (time_left < 120) {
	            $count_down_timer.addClass('alert');
	        }
	        var remaining_time_string = [];
	        var duration = moment.duration(time_left * 1000);
	        var all_durations = {
	            month: duration.months(),
	            day: duration.days(),
	            hour: duration.hours(),
	            minute: duration.minutes(),
	            second: duration.seconds()
	        };
	        Object.keys(all_durations).forEach(function (key) {
	            if (all_durations[key]) {
	                remaining_time_string.push(all_durations[key] + (jpClient() ? '' : ' ') + localize(key + (+all_durations[key] === 1 ? '' : 's')));
	            }
	        });
	        elementInnerHtml(remaining_time_element, remaining_time_string.join(' '));
	        if (remaining_timeout) clearRemainingTimeout();
	        remaining_timeout = setTimeout(displayRemainingTime, 1000);
	    };

	    var clearRemainingTimeout = function clearRemainingTimeout() {
	        clearTimeout(remaining_timeout);
	    };

	    var sortByExpiryTime = function sortByExpiryTime(first, second) {
	        var a = first.split('_');
	        var b = second.split('_');
	        var duration1 = a[1] - a[0];
	        var duration2 = b[1] - b[0];
	        return a[1] === b[1] ? duration1 - duration2 : a[1] - b[1];
	    };

	    var populateOptions = function populateOptions(rebuild) {
	        if (!contracts_for_response || isEmptyObject(contracts_for_response)) return;
	        var category = void 0;
	        var contracts_array = [];
	        var available_contracts = contracts_for_response.contracts_for.available;
	        var $category_element = $('#category');
	        var category_names = {
	            callput: localize('Higher/Lower'),
	            touchnotouch: localize('Touch/No Touch'),
	            endsinout: localize('Ends In/Out'),
	            staysinout: localize('Stays In/Goes Out')
	        };
	        var category_order = {
	            callput: 1,
	            touchnotouch: 2,
	            endsinout: 3,
	            staysinout: 4
	        };
	        for (var i = 0; i < available_contracts.length; i++) {
	            category = contracts_for_response.contracts_for.available[i].contract_category;
	            if (contracts_array.indexOf(category) < 0) {
	                contracts_array.push(category);
	            }
	        }
	        contracts_array.sort(function (a, b) {
	            return category_order[a] - category_order[b];
	        });
	        if (rebuild) {
	            $category_element.empty();
	        }
	        if ($category_element.children().length === 0) {
	            var default_value = MBDefaults.get('category');
	            for (var j = 0; j < contracts_array.length; j++) {
	                appendTextValueChild('category', category_names[contracts_array[j]], contracts_array[j], contracts_array[j] === default_value);
	            }
	            MBDefaults.set('category', $category_element.val());
	        }
	        populatePeriods(rebuild);
	    };

	    var getCurrentContracts = function getCurrentContracts() {
	        if (!contracts_for_response || isEmptyObject(contracts_for_response)) return [];
	        var contracts = [];
	        var category = MBDefaults.get('category');
	        var periods = MBDefaults.get('period').split('_');
	        contracts_for_response.contracts_for.available.forEach(function (c) {
	            if (c.contract_category === category && c.trading_period && +c.trading_period.date_start.epoch === +periods[0] && +c.trading_period.date_expiry.epoch === +periods[1]) {
	                contracts.push(c);
	            }
	        });
	        return contracts;
	    };

	    var getTemplate = function getTemplate(contract_type) {
	        var templates = {
	            PUT: {
	                opposite: 'CALLE',
	                order: 0,
	                name: 'Lower',
	                description: '[_1] [_2] payout if [_3] is strictly lower than Barrier at close on [_4].'
	            },
	            CALLE: {
	                opposite: 'PUT',
	                order: 1,
	                name: 'Higher',
	                description: '[_1] [_2] payout if [_3] is strictly higher than or equal to Barrier at close on [_4].'
	            },
	            ONETOUCH: {
	                opposite: 'NOTOUCH',
	                order: 0,
	                name: 'Touches',
	                description: '[_1] [_2] payout if [_3] touches Barrier through close on [_4].'
	            },
	            NOTOUCH: {
	                opposite: 'ONETOUCH',
	                order: 1,
	                name: 'Does Not Touch',
	                description: '[_1] [_2] payout if [_3] does not touch Barrier through close on [_4].'
	            },
	            EXPIRYRANGEE: {
	                opposite: 'EXPIRYMISS',
	                order: 0,
	                name: 'Ends Between',
	                description: '[_1] [_2] payout if [_3] ends on or between low and high values of Barrier at close on [_4].'
	            },
	            EXPIRYMISS: {
	                opposite: 'EXPIRYRANGEE',
	                order: 1,
	                name: 'Ends Outside',
	                description: '[_1] [_2] payout if [_3] ends outside low and high values of Barrier at close on [_4].'
	            },
	            RANGE: {
	                opposite: 'UPORDOWN',
	                order: 0,
	                name: 'Stays Between',
	                description: '[_1] [_2] payout if [_3] stays between low and high values of Barrier through close on [_4].'
	            },
	            UPORDOWN: {
	                opposite: 'RANGE',
	                order: 1,
	                name: 'Goes Outside',
	                description: '[_1] [_2] payout if [_3] goes outside of low and high values of Barrier through close on [_4].'
	            }
	        };
	        return contract_type ? templates[contract_type] : templates;
	    };

	    var displayDescriptions = function displayDescriptions() {
	        var contracts = getCurrentContracts();
	        var $desc_wrappers = $('.prices-wrapper');
	        var currency = formatCurrency(Client.get('currency')) || formatCurrency(document.getElementById('currency').value) || '¥';
	        var payout = Number(MBDefaults.get('payout') * (jpClient() ? 1000 : 1)).toLocaleString();
	        var display_name = MBSymbols.getName(MBDefaults.get('underlying'));
	        var date_expiry = PeriodText(contracts[0].trading_period).replace(/\s\(.*\)/, '');
	        contracts.forEach(function (c) {
	            var contract_type = c.contract_type;
	            var template = getTemplate(contract_type);
	            var $wrapper = $($desc_wrappers[template.order]);
	            $wrapper.find('.contract-type').attr('class', 'contract-type ' + contract_type + (template.order ? ' negative-color' : '')).text(localize(template.name));
	            $wrapper.find('.descr').html(localize(template.description, [currency, payout, display_name, date_expiry]));
	        });
	    };

	    var getCurrency = function getCurrency() {
	        return Client.get('currency') || document.getElementById('currency').value || 'JPY';
	    };

	    return {
	        populatePeriods: populatePeriods,
	        populateOptions: populateOptions,
	        displayRemainingTime: displayRemainingTime,
	        getCurrentContracts: getCurrentContracts,
	        getTemplate: getTemplate,
	        displayDescriptions: displayDescriptions,
	        getCurrency: getCurrency,
	        getContractsResponse: function getContractsResponse() {
	            return contracts_for_response;
	        },
	        setContractsResponse: function setContractsResponse(contracts_for) {
	            contracts_for_response = contracts_for;
	        },
	        onUnload: function onUnload() {
	            clearRemainingTimeout();contracts_for_response = {};period_value = undefined;
	        }
	    };
	}();

	module.exports = MBContract;

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
	//! version : 2.17.1
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com

	;(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, (function () { 'use strict';

	var hookCallback;

	function hooks () {
	    return hookCallback.apply(null, arguments);
	}

	// This is done to register the method called with moment()
	// without creating circular dependencies.
	function setHookCallback (callback) {
	    hookCallback = callback;
	}

	function isArray(input) {
	    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	}

	function isObject(input) {
	    // IE8 will treat undefined and null as object if it wasn't for
	    // input != null
	    return input != null && Object.prototype.toString.call(input) === '[object Object]';
	}

	function isObjectEmpty(obj) {
	    var k;
	    for (k in obj) {
	        // even if its not own property I'd still call it non-empty
	        return false;
	    }
	    return true;
	}

	function isNumber(input) {
	    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
	}

	function isDate(input) {
	    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	}

	function map(arr, fn) {
	    var res = [], i;
	    for (i = 0; i < arr.length; ++i) {
	        res.push(fn(arr[i], i));
	    }
	    return res;
	}

	function hasOwnProp(a, b) {
	    return Object.prototype.hasOwnProperty.call(a, b);
	}

	function extend(a, b) {
	    for (var i in b) {
	        if (hasOwnProp(b, i)) {
	            a[i] = b[i];
	        }
	    }

	    if (hasOwnProp(b, 'toString')) {
	        a.toString = b.toString;
	    }

	    if (hasOwnProp(b, 'valueOf')) {
	        a.valueOf = b.valueOf;
	    }

	    return a;
	}

	function createUTC (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, true).utc();
	}

	function defaultParsingFlags() {
	    // We need to deep clone this object.
	    return {
	        empty           : false,
	        unusedTokens    : [],
	        unusedInput     : [],
	        overflow        : -2,
	        charsLeftOver   : 0,
	        nullInput       : false,
	        invalidMonth    : null,
	        invalidFormat   : false,
	        userInvalidated : false,
	        iso             : false,
	        parsedDateParts : [],
	        meridiem        : null
	    };
	}

	function getParsingFlags(m) {
	    if (m._pf == null) {
	        m._pf = defaultParsingFlags();
	    }
	    return m._pf;
	}

	var some;
	if (Array.prototype.some) {
	    some = Array.prototype.some;
	} else {
	    some = function (fun) {
	        var t = Object(this);
	        var len = t.length >>> 0;

	        for (var i = 0; i < len; i++) {
	            if (i in t && fun.call(this, t[i], i, t)) {
	                return true;
	            }
	        }

	        return false;
	    };
	}

	var some$1 = some;

	function isValid(m) {
	    if (m._isValid == null) {
	        var flags = getParsingFlags(m);
	        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
	            return i != null;
	        });
	        var isNowValid = !isNaN(m._d.getTime()) &&
	            flags.overflow < 0 &&
	            !flags.empty &&
	            !flags.invalidMonth &&
	            !flags.invalidWeekday &&
	            !flags.nullInput &&
	            !flags.invalidFormat &&
	            !flags.userInvalidated &&
	            (!flags.meridiem || (flags.meridiem && parsedParts));

	        if (m._strict) {
	            isNowValid = isNowValid &&
	                flags.charsLeftOver === 0 &&
	                flags.unusedTokens.length === 0 &&
	                flags.bigHour === undefined;
	        }

	        if (Object.isFrozen == null || !Object.isFrozen(m)) {
	            m._isValid = isNowValid;
	        }
	        else {
	            return isNowValid;
	        }
	    }
	    return m._isValid;
	}

	function createInvalid (flags) {
	    var m = createUTC(NaN);
	    if (flags != null) {
	        extend(getParsingFlags(m), flags);
	    }
	    else {
	        getParsingFlags(m).userInvalidated = true;
	    }

	    return m;
	}

	function isUndefined(input) {
	    return input === void 0;
	}

	// Plugins that add properties should also add the key here (null value),
	// so we can properly clone ourselves.
	var momentProperties = hooks.momentProperties = [];

	function copyConfig(to, from) {
	    var i, prop, val;

	    if (!isUndefined(from._isAMomentObject)) {
	        to._isAMomentObject = from._isAMomentObject;
	    }
	    if (!isUndefined(from._i)) {
	        to._i = from._i;
	    }
	    if (!isUndefined(from._f)) {
	        to._f = from._f;
	    }
	    if (!isUndefined(from._l)) {
	        to._l = from._l;
	    }
	    if (!isUndefined(from._strict)) {
	        to._strict = from._strict;
	    }
	    if (!isUndefined(from._tzm)) {
	        to._tzm = from._tzm;
	    }
	    if (!isUndefined(from._isUTC)) {
	        to._isUTC = from._isUTC;
	    }
	    if (!isUndefined(from._offset)) {
	        to._offset = from._offset;
	    }
	    if (!isUndefined(from._pf)) {
	        to._pf = getParsingFlags(from);
	    }
	    if (!isUndefined(from._locale)) {
	        to._locale = from._locale;
	    }

	    if (momentProperties.length > 0) {
	        for (i in momentProperties) {
	            prop = momentProperties[i];
	            val = from[prop];
	            if (!isUndefined(val)) {
	                to[prop] = val;
	            }
	        }
	    }

	    return to;
	}

	var updateInProgress = false;

	// Moment prototype object
	function Moment(config) {
	    copyConfig(this, config);
	    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	    if (!this.isValid()) {
	        this._d = new Date(NaN);
	    }
	    // Prevent infinite loop in case updateOffset creates new moment
	    // objects.
	    if (updateInProgress === false) {
	        updateInProgress = true;
	        hooks.updateOffset(this);
	        updateInProgress = false;
	    }
	}

	function isMoment (obj) {
	    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	}

	function absFloor (number) {
	    if (number < 0) {
	        // -0 -> 0
	        return Math.ceil(number) || 0;
	    } else {
	        return Math.floor(number);
	    }
	}

	function toInt(argumentForCoercion) {
	    var coercedNumber = +argumentForCoercion,
	        value = 0;

	    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	        value = absFloor(coercedNumber);
	    }

	    return value;
	}

	// compare two arrays, return the number of differences
	function compareArrays(array1, array2, dontConvert) {
	    var len = Math.min(array1.length, array2.length),
	        lengthDiff = Math.abs(array1.length - array2.length),
	        diffs = 0,
	        i;
	    for (i = 0; i < len; i++) {
	        if ((dontConvert && array1[i] !== array2[i]) ||
	            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	            diffs++;
	        }
	    }
	    return diffs + lengthDiff;
	}

	function warn(msg) {
	    if (hooks.suppressDeprecationWarnings === false &&
	            (typeof console !==  'undefined') && console.warn) {
	        console.warn('Deprecation warning: ' + msg);
	    }
	}

	function deprecate(msg, fn) {
	    var firstTime = true;

	    return extend(function () {
	        if (hooks.deprecationHandler != null) {
	            hooks.deprecationHandler(null, msg);
	        }
	        if (firstTime) {
	            var args = [];
	            var arg;
	            for (var i = 0; i < arguments.length; i++) {
	                arg = '';
	                if (typeof arguments[i] === 'object') {
	                    arg += '\n[' + i + '] ';
	                    for (var key in arguments[0]) {
	                        arg += key + ': ' + arguments[0][key] + ', ';
	                    }
	                    arg = arg.slice(0, -2); // Remove trailing comma and space
	                } else {
	                    arg = arguments[i];
	                }
	                args.push(arg);
	            }
	            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
	            firstTime = false;
	        }
	        return fn.apply(this, arguments);
	    }, fn);
	}

	var deprecations = {};

	function deprecateSimple(name, msg) {
	    if (hooks.deprecationHandler != null) {
	        hooks.deprecationHandler(name, msg);
	    }
	    if (!deprecations[name]) {
	        warn(msg);
	        deprecations[name] = true;
	    }
	}

	hooks.suppressDeprecationWarnings = false;
	hooks.deprecationHandler = null;

	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	}

	function set (config) {
	    var prop, i;
	    for (i in config) {
	        prop = config[i];
	        if (isFunction(prop)) {
	            this[i] = prop;
	        } else {
	            this['_' + i] = prop;
	        }
	    }
	    this._config = config;
	    // Lenient ordinal parsing accepts just a number in addition to
	    // number + (possibly) stuff coming from _ordinalParseLenient.
	    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
	}

	function mergeConfigs(parentConfig, childConfig) {
	    var res = extend({}, parentConfig), prop;
	    for (prop in childConfig) {
	        if (hasOwnProp(childConfig, prop)) {
	            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                res[prop] = {};
	                extend(res[prop], parentConfig[prop]);
	                extend(res[prop], childConfig[prop]);
	            } else if (childConfig[prop] != null) {
	                res[prop] = childConfig[prop];
	            } else {
	                delete res[prop];
	            }
	        }
	    }
	    for (prop in parentConfig) {
	        if (hasOwnProp(parentConfig, prop) &&
	                !hasOwnProp(childConfig, prop) &&
	                isObject(parentConfig[prop])) {
	            // make sure changes to properties don't modify parent config
	            res[prop] = extend({}, res[prop]);
	        }
	    }
	    return res;
	}

	function Locale(config) {
	    if (config != null) {
	        this.set(config);
	    }
	}

	var keys;

	if (Object.keys) {
	    keys = Object.keys;
	} else {
	    keys = function (obj) {
	        var i, res = [];
	        for (i in obj) {
	            if (hasOwnProp(obj, i)) {
	                res.push(i);
	            }
	        }
	        return res;
	    };
	}

	var keys$1 = keys;

	var defaultCalendar = {
	    sameDay : '[Today at] LT',
	    nextDay : '[Tomorrow at] LT',
	    nextWeek : 'dddd [at] LT',
	    lastDay : '[Yesterday at] LT',
	    lastWeek : '[Last] dddd [at] LT',
	    sameElse : 'L'
	};

	function calendar (key, mom, now) {
	    var output = this._calendar[key] || this._calendar['sameElse'];
	    return isFunction(output) ? output.call(mom, now) : output;
	}

	var defaultLongDateFormat = {
	    LTS  : 'h:mm:ss A',
	    LT   : 'h:mm A',
	    L    : 'MM/DD/YYYY',
	    LL   : 'MMMM D, YYYY',
	    LLL  : 'MMMM D, YYYY h:mm A',
	    LLLL : 'dddd, MMMM D, YYYY h:mm A'
	};

	function longDateFormat (key) {
	    var format = this._longDateFormat[key],
	        formatUpper = this._longDateFormat[key.toUpperCase()];

	    if (format || !formatUpper) {
	        return format;
	    }

	    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	        return val.slice(1);
	    });

	    return this._longDateFormat[key];
	}

	var defaultInvalidDate = 'Invalid date';

	function invalidDate () {
	    return this._invalidDate;
	}

	var defaultOrdinal = '%d';
	var defaultOrdinalParse = /\d{1,2}/;

	function ordinal (number) {
	    return this._ordinal.replace('%d', number);
	}

	var defaultRelativeTime = {
	    future : 'in %s',
	    past   : '%s ago',
	    s  : 'a few seconds',
	    m  : 'a minute',
	    mm : '%d minutes',
	    h  : 'an hour',
	    hh : '%d hours',
	    d  : 'a day',
	    dd : '%d days',
	    M  : 'a month',
	    MM : '%d months',
	    y  : 'a year',
	    yy : '%d years'
	};

	function relativeTime (number, withoutSuffix, string, isFuture) {
	    var output = this._relativeTime[string];
	    return (isFunction(output)) ?
	        output(number, withoutSuffix, string, isFuture) :
	        output.replace(/%d/i, number);
	}

	function pastFuture (diff, output) {
	    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	}

	var aliases = {};

	function addUnitAlias (unit, shorthand) {
	    var lowerCase = unit.toLowerCase();
	    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	}

	function normalizeUnits(units) {
	    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	}

	function normalizeObjectUnits(inputObject) {
	    var normalizedInput = {},
	        normalizedProp,
	        prop;

	    for (prop in inputObject) {
	        if (hasOwnProp(inputObject, prop)) {
	            normalizedProp = normalizeUnits(prop);
	            if (normalizedProp) {
	                normalizedInput[normalizedProp] = inputObject[prop];
	            }
	        }
	    }

	    return normalizedInput;
	}

	var priorities = {};

	function addUnitPriority(unit, priority) {
	    priorities[unit] = priority;
	}

	function getPrioritizedUnits(unitsObj) {
	    var units = [];
	    for (var u in unitsObj) {
	        units.push({unit: u, priority: priorities[u]});
	    }
	    units.sort(function (a, b) {
	        return a.priority - b.priority;
	    });
	    return units;
	}

	function makeGetSet (unit, keepTime) {
	    return function (value) {
	        if (value != null) {
	            set$1(this, unit, value);
	            hooks.updateOffset(this, keepTime);
	            return this;
	        } else {
	            return get(this, unit);
	        }
	    };
	}

	function get (mom, unit) {
	    return mom.isValid() ?
	        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	}

	function set$1 (mom, unit, value) {
	    if (mom.isValid()) {
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	    }
	}

	// MOMENTS

	function stringGet (units) {
	    units = normalizeUnits(units);
	    if (isFunction(this[units])) {
	        return this[units]();
	    }
	    return this;
	}


	function stringSet (units, value) {
	    if (typeof units === 'object') {
	        units = normalizeObjectUnits(units);
	        var prioritized = getPrioritizedUnits(units);
	        for (var i = 0; i < prioritized.length; i++) {
	            this[prioritized[i].unit](units[prioritized[i].unit]);
	        }
	    } else {
	        units = normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units](value);
	        }
	    }
	    return this;
	}

	function zeroFill(number, targetLength, forceSign) {
	    var absNumber = '' + Math.abs(number),
	        zerosToFill = targetLength - absNumber.length,
	        sign = number >= 0;
	    return (sign ? (forceSign ? '+' : '') : '-') +
	        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	}

	var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	var formatFunctions = {};

	var formatTokenFunctions = {};

	// token:    'M'
	// padded:   ['MM', 2]
	// ordinal:  'Mo'
	// callback: function () { this.month() + 1 }
	function addFormatToken (token, padded, ordinal, callback) {
	    var func = callback;
	    if (typeof callback === 'string') {
	        func = function () {
	            return this[callback]();
	        };
	    }
	    if (token) {
	        formatTokenFunctions[token] = func;
	    }
	    if (padded) {
	        formatTokenFunctions[padded[0]] = function () {
	            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	        };
	    }
	    if (ordinal) {
	        formatTokenFunctions[ordinal] = function () {
	            return this.localeData().ordinal(func.apply(this, arguments), token);
	        };
	    }
	}

	function removeFormattingTokens(input) {
	    if (input.match(/\[[\s\S]/)) {
	        return input.replace(/^\[|\]$/g, '');
	    }
	    return input.replace(/\\/g, '');
	}

	function makeFormatFunction(format) {
	    var array = format.match(formattingTokens), i, length;

	    for (i = 0, length = array.length; i < length; i++) {
	        if (formatTokenFunctions[array[i]]) {
	            array[i] = formatTokenFunctions[array[i]];
	        } else {
	            array[i] = removeFormattingTokens(array[i]);
	        }
	    }

	    return function (mom) {
	        var output = '', i;
	        for (i = 0; i < length; i++) {
	            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	        }
	        return output;
	    };
	}

	// format date using native date object
	function formatMoment(m, format) {
	    if (!m.isValid()) {
	        return m.localeData().invalidDate();
	    }

	    format = expandFormat(format, m.localeData());
	    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

	    return formatFunctions[format](m);
	}

	function expandFormat(format, locale) {
	    var i = 5;

	    function replaceLongDateFormatTokens(input) {
	        return locale.longDateFormat(input) || input;
	    }

	    localFormattingTokens.lastIndex = 0;
	    while (i >= 0 && localFormattingTokens.test(format)) {
	        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	        localFormattingTokens.lastIndex = 0;
	        i -= 1;
	    }

	    return format;
	}

	var match1         = /\d/;            //       0 - 9
	var match2         = /\d\d/;          //      00 - 99
	var match3         = /\d{3}/;         //     000 - 999
	var match4         = /\d{4}/;         //    0000 - 9999
	var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	var match1to2      = /\d\d?/;         //       0 - 99
	var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	var match1to3      = /\d{1,3}/;       //       0 - 999
	var match1to4      = /\d{1,4}/;       //       0 - 9999
	var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

	var matchUnsigned  = /\d+/;           //       0 - inf
	var matchSigned    = /[+-]?\d+/;      //    -inf - inf

	var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

	// any word (or two) characters or numbers including two/three word month in arabic.
	// includes scottish gaelic two word and hyphenated months
	var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


	var regexes = {};

	function addRegexToken (token, regex, strictRegex) {
	    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	        return (isStrict && strictRegex) ? strictRegex : regex;
	    };
	}

	function getParseRegexForToken (token, config) {
	    if (!hasOwnProp(regexes, token)) {
	        return new RegExp(unescapeFormat(token));
	    }

	    return regexes[token](config._strict, config._locale);
	}

	// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	function unescapeFormat(s) {
	    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	        return p1 || p2 || p3 || p4;
	    }));
	}

	function regexEscape(s) {
	    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	}

	var tokens = {};

	function addParseToken (token, callback) {
	    var i, func = callback;
	    if (typeof token === 'string') {
	        token = [token];
	    }
	    if (isNumber(callback)) {
	        func = function (input, array) {
	            array[callback] = toInt(input);
	        };
	    }
	    for (i = 0; i < token.length; i++) {
	        tokens[token[i]] = func;
	    }
	}

	function addWeekParseToken (token, callback) {
	    addParseToken(token, function (input, array, config, token) {
	        config._w = config._w || {};
	        callback(input, config._w, config, token);
	    });
	}

	function addTimeToArrayFromToken(token, input, config) {
	    if (input != null && hasOwnProp(tokens, token)) {
	        tokens[token](input, config._a, config, token);
	    }
	}

	var YEAR = 0;
	var MONTH = 1;
	var DATE = 2;
	var HOUR = 3;
	var MINUTE = 4;
	var SECOND = 5;
	var MILLISECOND = 6;
	var WEEK = 7;
	var WEEKDAY = 8;

	var indexOf;

	if (Array.prototype.indexOf) {
	    indexOf = Array.prototype.indexOf;
	} else {
	    indexOf = function (o) {
	        // I know
	        var i;
	        for (i = 0; i < this.length; ++i) {
	            if (this[i] === o) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}

	var indexOf$1 = indexOf;

	function daysInMonth(year, month) {
	    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	}

	// FORMATTING

	addFormatToken('M', ['MM', 2], 'Mo', function () {
	    return this.month() + 1;
	});

	addFormatToken('MMM', 0, 0, function (format) {
	    return this.localeData().monthsShort(this, format);
	});

	addFormatToken('MMMM', 0, 0, function (format) {
	    return this.localeData().months(this, format);
	});

	// ALIASES

	addUnitAlias('month', 'M');

	// PRIORITY

	addUnitPriority('month', 8);

	// PARSING

	addRegexToken('M',    match1to2);
	addRegexToken('MM',   match1to2, match2);
	addRegexToken('MMM',  function (isStrict, locale) {
	    return locale.monthsShortRegex(isStrict);
	});
	addRegexToken('MMMM', function (isStrict, locale) {
	    return locale.monthsRegex(isStrict);
	});

	addParseToken(['M', 'MM'], function (input, array) {
	    array[MONTH] = toInt(input) - 1;
	});

	addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	    var month = config._locale.monthsParse(input, token, config._strict);
	    // if we didn't find a month name, mark the date as invalid.
	    if (month != null) {
	        array[MONTH] = month;
	    } else {
	        getParsingFlags(config).invalidMonth = input;
	    }
	});

	// LOCALES

	var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	function localeMonths (m, format) {
	    if (!m) {
	        return this._months;
	    }
	    return isArray(this._months) ? this._months[m.month()] :
	        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
	}

	var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	function localeMonthsShort (m, format) {
	    if (!m) {
	        return this._monthsShort;
	    }
	    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	}

	function handleStrictParse(monthName, format, strict) {
	    var i, ii, mom, llc = monthName.toLocaleLowerCase();
	    if (!this._monthsParse) {
	        // this is not used
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	        for (i = 0; i < 12; ++i) {
	            mom = createUTC([2000, i]);
	            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
	            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	        }
	    }

	    if (strict) {
	        if (format === 'MMM') {
	            ii = indexOf$1.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === 'MMM') {
	            ii = indexOf$1.call(this._shortMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._longMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}

	function localeMonthsParse (monthName, format, strict) {
	    var i, mom, regex;

	    if (this._monthsParseExact) {
	        return handleStrictParse.call(this, monthName, format, strict);
	    }

	    if (!this._monthsParse) {
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	    }

	    // TODO: add sorting
	    // Sorting makes sure if one month (or abbr) is a prefix of another
	    // see sorting in computeMonthsParse
	    for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);
	        if (strict && !this._longMonthsParse[i]) {
	            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	        }
	        if (!strict && !this._monthsParse[i]) {
	            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        }
	        // test the regex
	        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (!strict && this._monthsParse[i].test(monthName)) {
	            return i;
	        }
	    }
	}

	// MOMENTS

	function setMonth (mom, value) {
	    var dayOfMonth;

	    if (!mom.isValid()) {
	        // No op
	        return mom;
	    }

	    if (typeof value === 'string') {
	        if (/^\d+$/.test(value)) {
	            value = toInt(value);
	        } else {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (!isNumber(value)) {
	                return mom;
	            }
	        }
	    }

	    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	    return mom;
	}

	function getSetMonth (value) {
	    if (value != null) {
	        setMonth(this, value);
	        hooks.updateOffset(this, true);
	        return this;
	    } else {
	        return get(this, 'Month');
	    }
	}

	function getDaysInMonth () {
	    return daysInMonth(this.year(), this.month());
	}

	var defaultMonthsShortRegex = matchWord;
	function monthsShortRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsShortStrictRegex;
	        } else {
	            return this._monthsShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_monthsShortRegex')) {
	            this._monthsShortRegex = defaultMonthsShortRegex;
	        }
	        return this._monthsShortStrictRegex && isStrict ?
	            this._monthsShortStrictRegex : this._monthsShortRegex;
	    }
	}

	var defaultMonthsRegex = matchWord;
	function monthsRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsStrictRegex;
	        } else {
	            return this._monthsRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            this._monthsRegex = defaultMonthsRegex;
	        }
	        return this._monthsStrictRegex && isStrict ?
	            this._monthsStrictRegex : this._monthsRegex;
	    }
	}

	function computeMonthsParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }

	    var shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom;
	    for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);
	        shortPieces.push(this.monthsShort(mom, ''));
	        longPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.monthsShort(mom, ''));
	    }
	    // Sorting makes sure if one month (or abbr) is a prefix of another it
	    // will match the longer piece.
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i < 12; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	    }
	    for (i = 0; i < 24; i++) {
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }

	    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._monthsShortRegex = this._monthsRegex;
	    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	}

	// FORMATTING

	addFormatToken('Y', 0, 0, function () {
	    var y = this.year();
	    return y <= 9999 ? '' + y : '+' + y;
	});

	addFormatToken(0, ['YY', 2], 0, function () {
	    return this.year() % 100;
	});

	addFormatToken(0, ['YYYY',   4],       0, 'year');
	addFormatToken(0, ['YYYYY',  5],       0, 'year');
	addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

	// ALIASES

	addUnitAlias('year', 'y');

	// PRIORITIES

	addUnitPriority('year', 1);

	// PARSING

	addRegexToken('Y',      matchSigned);
	addRegexToken('YY',     match1to2, match2);
	addRegexToken('YYYY',   match1to4, match4);
	addRegexToken('YYYYY',  match1to6, match6);
	addRegexToken('YYYYYY', match1to6, match6);

	addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	addParseToken('YYYY', function (input, array) {
	    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	});
	addParseToken('YY', function (input, array) {
	    array[YEAR] = hooks.parseTwoDigitYear(input);
	});
	addParseToken('Y', function (input, array) {
	    array[YEAR] = parseInt(input, 10);
	});

	// HELPERS

	function daysInYear(year) {
	    return isLeapYear(year) ? 366 : 365;
	}

	function isLeapYear(year) {
	    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	}

	// HOOKS

	hooks.parseTwoDigitYear = function (input) {
	    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	};

	// MOMENTS

	var getSetYear = makeGetSet('FullYear', true);

	function getIsLeapYear () {
	    return isLeapYear(this.year());
	}

	function createDate (y, m, d, h, M, s, ms) {
	    //can't just apply() to create a date:
	    //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	    var date = new Date(y, m, d, h, M, s, ms);

	    //the date constructor remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
	        date.setFullYear(y);
	    }
	    return date;
	}

	function createUTCDate (y) {
	    var date = new Date(Date.UTC.apply(null, arguments));

	    //the Date.UTC function remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
	        date.setUTCFullYear(y);
	    }
	    return date;
	}

	// start-of-first-week - start-of-year
	function firstWeekOffset(year, dow, doy) {
	    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	        fwd = 7 + dow - doy,
	        // first-week day local weekday -- which local weekday is fwd
	        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

	    return -fwdlw + fwd - 1;
	}

	//http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	    var localWeekday = (7 + weekday - dow) % 7,
	        weekOffset = firstWeekOffset(year, dow, doy),
	        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	        resYear, resDayOfYear;

	    if (dayOfYear <= 0) {
	        resYear = year - 1;
	        resDayOfYear = daysInYear(resYear) + dayOfYear;
	    } else if (dayOfYear > daysInYear(year)) {
	        resYear = year + 1;
	        resDayOfYear = dayOfYear - daysInYear(year);
	    } else {
	        resYear = year;
	        resDayOfYear = dayOfYear;
	    }

	    return {
	        year: resYear,
	        dayOfYear: resDayOfYear
	    };
	}

	function weekOfYear(mom, dow, doy) {
	    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	        resWeek, resYear;

	    if (week < 1) {
	        resYear = mom.year() - 1;
	        resWeek = week + weeksInYear(resYear, dow, doy);
	    } else if (week > weeksInYear(mom.year(), dow, doy)) {
	        resWeek = week - weeksInYear(mom.year(), dow, doy);
	        resYear = mom.year() + 1;
	    } else {
	        resYear = mom.year();
	        resWeek = week;
	    }

	    return {
	        week: resWeek,
	        year: resYear
	    };
	}

	function weeksInYear(year, dow, doy) {
	    var weekOffset = firstWeekOffset(year, dow, doy),
	        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	}

	// FORMATTING

	addFormatToken('w', ['ww', 2], 'wo', 'week');
	addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

	// ALIASES

	addUnitAlias('week', 'w');
	addUnitAlias('isoWeek', 'W');

	// PRIORITIES

	addUnitPriority('week', 5);
	addUnitPriority('isoWeek', 5);

	// PARSING

	addRegexToken('w',  match1to2);
	addRegexToken('ww', match1to2, match2);
	addRegexToken('W',  match1to2);
	addRegexToken('WW', match1to2, match2);

	addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	    week[token.substr(0, 1)] = toInt(input);
	});

	// HELPERS

	// LOCALES

	function localeWeek (mom) {
	    return weekOfYear(mom, this._week.dow, this._week.doy).week;
	}

	var defaultLocaleWeek = {
	    dow : 0, // Sunday is the first day of the week.
	    doy : 6  // The week that contains Jan 1st is the first week of the year.
	};

	function localeFirstDayOfWeek () {
	    return this._week.dow;
	}

	function localeFirstDayOfYear () {
	    return this._week.doy;
	}

	// MOMENTS

	function getSetWeek (input) {
	    var week = this.localeData().week(this);
	    return input == null ? week : this.add((input - week) * 7, 'd');
	}

	function getSetISOWeek (input) {
	    var week = weekOfYear(this, 1, 4).week;
	    return input == null ? week : this.add((input - week) * 7, 'd');
	}

	// FORMATTING

	addFormatToken('d', 0, 'do', 'day');

	addFormatToken('dd', 0, 0, function (format) {
	    return this.localeData().weekdaysMin(this, format);
	});

	addFormatToken('ddd', 0, 0, function (format) {
	    return this.localeData().weekdaysShort(this, format);
	});

	addFormatToken('dddd', 0, 0, function (format) {
	    return this.localeData().weekdays(this, format);
	});

	addFormatToken('e', 0, 0, 'weekday');
	addFormatToken('E', 0, 0, 'isoWeekday');

	// ALIASES

	addUnitAlias('day', 'd');
	addUnitAlias('weekday', 'e');
	addUnitAlias('isoWeekday', 'E');

	// PRIORITY
	addUnitPriority('day', 11);
	addUnitPriority('weekday', 11);
	addUnitPriority('isoWeekday', 11);

	// PARSING

	addRegexToken('d',    match1to2);
	addRegexToken('e',    match1to2);
	addRegexToken('E',    match1to2);
	addRegexToken('dd',   function (isStrict, locale) {
	    return locale.weekdaysMinRegex(isStrict);
	});
	addRegexToken('ddd',   function (isStrict, locale) {
	    return locale.weekdaysShortRegex(isStrict);
	});
	addRegexToken('dddd',   function (isStrict, locale) {
	    return locale.weekdaysRegex(isStrict);
	});

	addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	    var weekday = config._locale.weekdaysParse(input, token, config._strict);
	    // if we didn't get a weekday name, mark the date as invalid
	    if (weekday != null) {
	        week.d = weekday;
	    } else {
	        getParsingFlags(config).invalidWeekday = input;
	    }
	});

	addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	    week[token] = toInt(input);
	});

	// HELPERS

	function parseWeekday(input, locale) {
	    if (typeof input !== 'string') {
	        return input;
	    }

	    if (!isNaN(input)) {
	        return parseInt(input, 10);
	    }

	    input = locale.weekdaysParse(input);
	    if (typeof input === 'number') {
	        return input;
	    }

	    return null;
	}

	function parseIsoWeekday(input, locale) {
	    if (typeof input === 'string') {
	        return locale.weekdaysParse(input) % 7 || 7;
	    }
	    return isNaN(input) ? null : input;
	}

	// LOCALES

	var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	function localeWeekdays (m, format) {
	    if (!m) {
	        return this._weekdays;
	    }
	    return isArray(this._weekdays) ? this._weekdays[m.day()] :
	        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
	}

	var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	function localeWeekdaysShort (m) {
	    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	}

	var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	function localeWeekdaysMin (m) {
	    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	}

	function handleStrictParse$1(weekdayName, format, strict) {
	    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._minWeekdaysParse = [];

	        for (i = 0; i < 7; ++i) {
	            mom = createUTC([2000, 1]).day(i);
	            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
	            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
	            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	        }
	    }

	    if (strict) {
	        if (format === 'dddd') {
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === 'dddd') {
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}

	function localeWeekdaysParse (weekdayName, format, strict) {
	    var i, mom, regex;

	    if (this._weekdaysParseExact) {
	        return handleStrictParse$1.call(this, weekdayName, format, strict);
	    }

	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._minWeekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._fullWeekdaysParse = [];
	    }

	    for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already

	        mom = createUTC([2000, 1]).day(i);
	        if (strict && !this._fullWeekdaysParse[i]) {
	            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
	            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
	            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
	        }
	        if (!this._weekdaysParse[i]) {
	            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        }
	        // test the regex
	        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	            return i;
	        }
	    }
	}

	// MOMENTS

	function getSetDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	    if (input != null) {
	        input = parseWeekday(input, this.localeData());
	        return this.add(input - day, 'd');
	    } else {
	        return day;
	    }
	}

	function getSetLocaleDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	    return input == null ? weekday : this.add(input - weekday, 'd');
	}

	function getSetISODayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }

	    // behaves the same as moment#day except
	    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	    // as a setter, sunday should belong to the previous week.

	    if (input != null) {
	        var weekday = parseIsoWeekday(input, this.localeData());
	        return this.day(this.day() % 7 ? weekday : weekday - 7);
	    } else {
	        return this.day() || 7;
	    }
	}

	var defaultWeekdaysRegex = matchWord;
	function weekdaysRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysStrictRegex;
	        } else {
	            return this._weekdaysRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            this._weekdaysRegex = defaultWeekdaysRegex;
	        }
	        return this._weekdaysStrictRegex && isStrict ?
	            this._weekdaysStrictRegex : this._weekdaysRegex;
	    }
	}

	var defaultWeekdaysShortRegex = matchWord;
	function weekdaysShortRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysShortStrictRegex;
	        } else {
	            return this._weekdaysShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	        }
	        return this._weekdaysShortStrictRegex && isStrict ?
	            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	    }
	}

	var defaultWeekdaysMinRegex = matchWord;
	function weekdaysMinRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysMinStrictRegex;
	        } else {
	            return this._weekdaysMinRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	        }
	        return this._weekdaysMinStrictRegex && isStrict ?
	            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	    }
	}


	function computeWeekdaysParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }

	    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom, minp, shortp, longp;
	    for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, 1]).day(i);
	        minp = this.weekdaysMin(mom, '');
	        shortp = this.weekdaysShort(mom, '');
	        longp = this.weekdays(mom, '');
	        minPieces.push(minp);
	        shortPieces.push(shortp);
	        longPieces.push(longp);
	        mixedPieces.push(minp);
	        mixedPieces.push(shortp);
	        mixedPieces.push(longp);
	    }
	    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	    // will match the longer piece.
	    minPieces.sort(cmpLenRev);
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i < 7; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }

	    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._weekdaysShortRegex = this._weekdaysRegex;
	    this._weekdaysMinRegex = this._weekdaysRegex;

	    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
	}

	// FORMATTING

	function hFormat() {
	    return this.hours() % 12 || 12;
	}

	function kFormat() {
	    return this.hours() || 24;
	}

	addFormatToken('H', ['HH', 2], 0, 'hour');
	addFormatToken('h', ['hh', 2], 0, hFormat);
	addFormatToken('k', ['kk', 2], 0, kFormat);

	addFormatToken('hmm', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	});

	addFormatToken('hmmss', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});

	addFormatToken('Hmm', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2);
	});

	addFormatToken('Hmmss', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});

	function meridiem (token, lowercase) {
	    addFormatToken(token, 0, 0, function () {
	        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	    });
	}

	meridiem('a', true);
	meridiem('A', false);

	// ALIASES

	addUnitAlias('hour', 'h');

	// PRIORITY
	addUnitPriority('hour', 13);

	// PARSING

	function matchMeridiem (isStrict, locale) {
	    return locale._meridiemParse;
	}

	addRegexToken('a',  matchMeridiem);
	addRegexToken('A',  matchMeridiem);
	addRegexToken('H',  match1to2);
	addRegexToken('h',  match1to2);
	addRegexToken('HH', match1to2, match2);
	addRegexToken('hh', match1to2, match2);

	addRegexToken('hmm', match3to4);
	addRegexToken('hmmss', match5to6);
	addRegexToken('Hmm', match3to4);
	addRegexToken('Hmmss', match5to6);

	addParseToken(['H', 'HH'], HOUR);
	addParseToken(['a', 'A'], function (input, array, config) {
	    config._isPm = config._locale.isPM(input);
	    config._meridiem = input;
	});
	addParseToken(['h', 'hh'], function (input, array, config) {
	    array[HOUR] = toInt(input);
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('Hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	});
	addParseToken('Hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	});

	// LOCALES

	function localeIsPM (input) {
	    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	    // Using charAt should be more compatible.
	    return ((input + '').toLowerCase().charAt(0) === 'p');
	}

	var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	function localeMeridiem (hours, minutes, isLower) {
	    if (hours > 11) {
	        return isLower ? 'pm' : 'PM';
	    } else {
	        return isLower ? 'am' : 'AM';
	    }
	}


	// MOMENTS

	// Setting the hour should keep the time, because the user explicitly
	// specified which hour he wants. So trying to maintain the same hour (in
	// a new timezone) makes sense. Adding/subtracting hours does not follow
	// this rule.
	var getSetHour = makeGetSet('Hours', true);

	// months
	// week
	// weekdays
	// meridiem
	var baseConfig = {
	    calendar: defaultCalendar,
	    longDateFormat: defaultLongDateFormat,
	    invalidDate: defaultInvalidDate,
	    ordinal: defaultOrdinal,
	    ordinalParse: defaultOrdinalParse,
	    relativeTime: defaultRelativeTime,

	    months: defaultLocaleMonths,
	    monthsShort: defaultLocaleMonthsShort,

	    week: defaultLocaleWeek,

	    weekdays: defaultLocaleWeekdays,
	    weekdaysMin: defaultLocaleWeekdaysMin,
	    weekdaysShort: defaultLocaleWeekdaysShort,

	    meridiemParse: defaultLocaleMeridiemParse
	};

	// internal storage for locale config files
	var locales = {};
	var localeFamilies = {};
	var globalLocale;

	function normalizeLocale(key) {
	    return key ? key.toLowerCase().replace('_', '-') : key;
	}

	// pick the locale from the array
	// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	function chooseLocale(names) {
	    var i = 0, j, next, locale, split;

	    while (i < names.length) {
	        split = normalizeLocale(names[i]).split('-');
	        j = split.length;
	        next = normalizeLocale(names[i + 1]);
	        next = next ? next.split('-') : null;
	        while (j > 0) {
	            locale = loadLocale(split.slice(0, j).join('-'));
	            if (locale) {
	                return locale;
	            }
	            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                //the next array item is better than a shallower substring of this one
	                break;
	            }
	            j--;
	        }
	        i++;
	    }
	    return null;
	}

	function loadLocale(name) {
	    var oldLocale = null;
	    // TODO: Find a better way to register and load all the locales in Node
	    if (!locales[name] && (typeof module !== 'undefined') &&
	            module && module.exports) {
	        try {
	            oldLocale = globalLocale._abbr;
	            __webpack_require__(307)("./" + name);
	            // because defineLocale currently also sets the global locale, we
	            // want to undo that for lazy loaded locales
	            getSetGlobalLocale(oldLocale);
	        } catch (e) { }
	    }
	    return locales[name];
	}

	// This function will load locale and then set the global locale.  If
	// no arguments are passed in, it will simply return the current global
	// locale key.
	function getSetGlobalLocale (key, values) {
	    var data;
	    if (key) {
	        if (isUndefined(values)) {
	            data = getLocale(key);
	        }
	        else {
	            data = defineLocale(key, values);
	        }

	        if (data) {
	            // moment.duration._locale = moment._locale = data;
	            globalLocale = data;
	        }
	    }

	    return globalLocale._abbr;
	}

	function defineLocale (name, config) {
	    if (config !== null) {
	        var parentConfig = baseConfig;
	        config.abbr = name;
	        if (locales[name] != null) {
	            deprecateSimple('defineLocaleOverride',
	                    'use moment.updateLocale(localeName, config) to change ' +
	                    'an existing locale. moment.defineLocale(localeName, ' +
	                    'config) should only be used for creating a new locale ' +
	                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
	            parentConfig = locales[name]._config;
	        } else if (config.parentLocale != null) {
	            if (locales[config.parentLocale] != null) {
	                parentConfig = locales[config.parentLocale]._config;
	            } else {
	                if (!localeFamilies[config.parentLocale]) {
	                    localeFamilies[config.parentLocale] = [];
	                }
	                localeFamilies[config.parentLocale].push({
	                    name: name,
	                    config: config
	                });
	                return null;
	            }
	        }
	        locales[name] = new Locale(mergeConfigs(parentConfig, config));

	        if (localeFamilies[name]) {
	            localeFamilies[name].forEach(function (x) {
	                defineLocale(x.name, x.config);
	            });
	        }

	        // backwards compat for now: also set the locale
	        // make sure we set the locale AFTER all child locales have been
	        // created, so we won't end up with the child locale set.
	        getSetGlobalLocale(name);


	        return locales[name];
	    } else {
	        // useful for testing
	        delete locales[name];
	        return null;
	    }
	}

	function updateLocale(name, config) {
	    if (config != null) {
	        var locale, parentConfig = baseConfig;
	        // MERGE
	        if (locales[name] != null) {
	            parentConfig = locales[name]._config;
	        }
	        config = mergeConfigs(parentConfig, config);
	        locale = new Locale(config);
	        locale.parentLocale = locales[name];
	        locales[name] = locale;

	        // backwards compat for now: also set the locale
	        getSetGlobalLocale(name);
	    } else {
	        // pass null for config to unupdate, useful for tests
	        if (locales[name] != null) {
	            if (locales[name].parentLocale != null) {
	                locales[name] = locales[name].parentLocale;
	            } else if (locales[name] != null) {
	                delete locales[name];
	            }
	        }
	    }
	    return locales[name];
	}

	// returns locale data
	function getLocale (key) {
	    var locale;

	    if (key && key._locale && key._locale._abbr) {
	        key = key._locale._abbr;
	    }

	    if (!key) {
	        return globalLocale;
	    }

	    if (!isArray(key)) {
	        //short-circuit everything else
	        locale = loadLocale(key);
	        if (locale) {
	            return locale;
	        }
	        key = [key];
	    }

	    return chooseLocale(key);
	}

	function listLocales() {
	    return keys$1(locales);
	}

	function checkOverflow (m) {
	    var overflow;
	    var a = m._a;

	    if (a && getParsingFlags(m).overflow === -2) {
	        overflow =
	            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	            -1;

	        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	            overflow = DATE;
	        }
	        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	            overflow = WEEK;
	        }
	        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	            overflow = WEEKDAY;
	        }

	        getParsingFlags(m).overflow = overflow;
	    }

	    return m;
	}

	// iso 8601 regex
	// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

	var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

	var isoDates = [
	    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	    ['YYYY-DDD', /\d{4}-\d{3}/],
	    ['YYYY-MM', /\d{4}-\d\d/, false],
	    ['YYYYYYMMDD', /[+-]\d{10}/],
	    ['YYYYMMDD', /\d{8}/],
	    // YYYYMM is NOT allowed by the standard
	    ['GGGG[W]WWE', /\d{4}W\d{3}/],
	    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	    ['YYYYDDD', /\d{7}/]
	];

	// iso time formats and regexes
	var isoTimes = [
	    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	    ['HH:mm', /\d\d:\d\d/],
	    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	    ['HHmmss', /\d\d\d\d\d\d/],
	    ['HHmm', /\d\d\d\d/],
	    ['HH', /\d\d/]
	];

	var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

	// date from iso format
	function configFromISO(config) {
	    var i, l,
	        string = config._i,
	        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	        allowTime, dateFormat, timeFormat, tzFormat;

	    if (match) {
	        getParsingFlags(config).iso = true;

	        for (i = 0, l = isoDates.length; i < l; i++) {
	            if (isoDates[i][1].exec(match[1])) {
	                dateFormat = isoDates[i][0];
	                allowTime = isoDates[i][2] !== false;
	                break;
	            }
	        }
	        if (dateFormat == null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[3]) {
	            for (i = 0, l = isoTimes.length; i < l; i++) {
	                if (isoTimes[i][1].exec(match[3])) {
	                    // match[2] should be 'T' or space
	                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                    break;
	                }
	            }
	            if (timeFormat == null) {
	                config._isValid = false;
	                return;
	            }
	        }
	        if (!allowTime && timeFormat != null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[4]) {
	            if (tzRegex.exec(match[4])) {
	                tzFormat = 'Z';
	            } else {
	                config._isValid = false;
	                return;
	            }
	        }
	        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	        configFromStringAndFormat(config);
	    } else {
	        config._isValid = false;
	    }
	}

	// date from iso format or fallback
	function configFromString(config) {
	    var matched = aspNetJsonRegex.exec(config._i);

	    if (matched !== null) {
	        config._d = new Date(+matched[1]);
	        return;
	    }

	    configFromISO(config);
	    if (config._isValid === false) {
	        delete config._isValid;
	        hooks.createFromInputFallback(config);
	    }
	}

	hooks.createFromInputFallback = deprecate(
	    'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
	    'which is not reliable across all browsers and versions. Non ISO date formats are ' +
	    'discouraged and will be removed in an upcoming major release. Please refer to ' +
	    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
	    function (config) {
	        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	    }
	);

	// Pick the first defined of two or three arguments.
	function defaults(a, b, c) {
	    if (a != null) {
	        return a;
	    }
	    if (b != null) {
	        return b;
	    }
	    return c;
	}

	function currentDateArray(config) {
	    // hooks is actually the exported moment object
	    var nowValue = new Date(hooks.now());
	    if (config._useUTC) {
	        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	    }
	    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	}

	// convert an array to a date.
	// the array should mirror the parameters below
	// note: all values past the year are optional and will default to the lowest possible value.
	// [year, month, day , hour, minute, second, millisecond]
	function configFromArray (config) {
	    var i, date, input = [], currentDate, yearToUse;

	    if (config._d) {
	        return;
	    }

	    currentDate = currentDateArray(config);

	    //compute day of the year from weeks and weekdays
	    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	        dayOfYearFromWeekInfo(config);
	    }

	    //if the day of the year is set, figure out what it is
	    if (config._dayOfYear) {
	        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	        if (config._dayOfYear > daysInYear(yearToUse)) {
	            getParsingFlags(config)._overflowDayOfYear = true;
	        }

	        date = createUTCDate(yearToUse, 0, config._dayOfYear);
	        config._a[MONTH] = date.getUTCMonth();
	        config._a[DATE] = date.getUTCDate();
	    }

	    // Default to current date.
	    // * if no year, month, day of month are given, default to today
	    // * if day of month is given, default month and year
	    // * if month is given, default only year
	    // * if year is given, don't default anything
	    for (i = 0; i < 3 && config._a[i] == null; ++i) {
	        config._a[i] = input[i] = currentDate[i];
	    }

	    // Zero out whatever was not defaulted, including time
	    for (; i < 7; i++) {
	        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	    }

	    // Check for 24:00:00.000
	    if (config._a[HOUR] === 24 &&
	            config._a[MINUTE] === 0 &&
	            config._a[SECOND] === 0 &&
	            config._a[MILLISECOND] === 0) {
	        config._nextDay = true;
	        config._a[HOUR] = 0;
	    }

	    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	    // Apply timezone offset from input. The actual utcOffset can be changed
	    // with parseZone.
	    if (config._tzm != null) {
	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	    }

	    if (config._nextDay) {
	        config._a[HOUR] = 24;
	    }
	}

	function dayOfYearFromWeekInfo(config) {
	    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

	    w = config._w;
	    if (w.GG != null || w.W != null || w.E != null) {
	        dow = 1;
	        doy = 4;

	        // TODO: We need to take the current isoWeekYear, but that depends on
	        // how we interpret now (local, utc, fixed offset). So create
	        // a now version of current config (take local/utc/offset flags, and
	        // create now).
	        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
	        week = defaults(w.W, 1);
	        weekday = defaults(w.E, 1);
	        if (weekday < 1 || weekday > 7) {
	            weekdayOverflow = true;
	        }
	    } else {
	        dow = config._locale._week.dow;
	        doy = config._locale._week.doy;

	        var curWeek = weekOfYear(createLocal(), dow, doy);

	        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

	        // Default to current week.
	        week = defaults(w.w, curWeek.week);

	        if (w.d != null) {
	            // weekday -- low day numbers are considered next week
	            weekday = w.d;
	            if (weekday < 0 || weekday > 6) {
	                weekdayOverflow = true;
	            }
	        } else if (w.e != null) {
	            // local weekday -- counting starts from begining of week
	            weekday = w.e + dow;
	            if (w.e < 0 || w.e > 6) {
	                weekdayOverflow = true;
	            }
	        } else {
	            // default to begining of week
	            weekday = dow;
	        }
	    }
	    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	        getParsingFlags(config)._overflowWeeks = true;
	    } else if (weekdayOverflow != null) {
	        getParsingFlags(config)._overflowWeekday = true;
	    } else {
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	    }
	}

	// constant that refers to the ISO standard
	hooks.ISO_8601 = function () {};

	// date from string and format string
	function configFromStringAndFormat(config) {
	    // TODO: Move this to another part of the creation flow to prevent circular deps
	    if (config._f === hooks.ISO_8601) {
	        configFromISO(config);
	        return;
	    }

	    config._a = [];
	    getParsingFlags(config).empty = true;

	    // This array is used to make a Date, either with `new Date` or `Date.UTC`
	    var string = '' + config._i,
	        i, parsedInput, tokens, token, skipped,
	        stringLength = string.length,
	        totalParsedInputLength = 0;

	    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	    for (i = 0; i < tokens.length; i++) {
	        token = tokens[i];
	        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	        // console.log('token', token, 'parsedInput', parsedInput,
	        //         'regex', getParseRegexForToken(token, config));
	        if (parsedInput) {
	            skipped = string.substr(0, string.indexOf(parsedInput));
	            if (skipped.length > 0) {
	                getParsingFlags(config).unusedInput.push(skipped);
	            }
	            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	            totalParsedInputLength += parsedInput.length;
	        }
	        // don't parse if it's not a known token
	        if (formatTokenFunctions[token]) {
	            if (parsedInput) {
	                getParsingFlags(config).empty = false;
	            }
	            else {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	            addTimeToArrayFromToken(token, parsedInput, config);
	        }
	        else if (config._strict && !parsedInput) {
	            getParsingFlags(config).unusedTokens.push(token);
	        }
	    }

	    // add remaining unparsed input length to the string
	    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	    if (string.length > 0) {
	        getParsingFlags(config).unusedInput.push(string);
	    }

	    // clear _12h flag if hour is <= 12
	    if (config._a[HOUR] <= 12 &&
	        getParsingFlags(config).bigHour === true &&
	        config._a[HOUR] > 0) {
	        getParsingFlags(config).bigHour = undefined;
	    }

	    getParsingFlags(config).parsedDateParts = config._a.slice(0);
	    getParsingFlags(config).meridiem = config._meridiem;
	    // handle meridiem
	    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

	    configFromArray(config);
	    checkOverflow(config);
	}


	function meridiemFixWrap (locale, hour, meridiem) {
	    var isPm;

	    if (meridiem == null) {
	        // nothing to do
	        return hour;
	    }
	    if (locale.meridiemHour != null) {
	        return locale.meridiemHour(hour, meridiem);
	    } else if (locale.isPM != null) {
	        // Fallback
	        isPm = locale.isPM(meridiem);
	        if (isPm && hour < 12) {
	            hour += 12;
	        }
	        if (!isPm && hour === 12) {
	            hour = 0;
	        }
	        return hour;
	    } else {
	        // this is not supposed to happen
	        return hour;
	    }
	}

	// date from string and array of format strings
	function configFromStringAndArray(config) {
	    var tempConfig,
	        bestMoment,

	        scoreToBeat,
	        i,
	        currentScore;

	    if (config._f.length === 0) {
	        getParsingFlags(config).invalidFormat = true;
	        config._d = new Date(NaN);
	        return;
	    }

	    for (i = 0; i < config._f.length; i++) {
	        currentScore = 0;
	        tempConfig = copyConfig({}, config);
	        if (config._useUTC != null) {
	            tempConfig._useUTC = config._useUTC;
	        }
	        tempConfig._f = config._f[i];
	        configFromStringAndFormat(tempConfig);

	        if (!isValid(tempConfig)) {
	            continue;
	        }

	        // if there is any input that was not parsed add a penalty for that format
	        currentScore += getParsingFlags(tempConfig).charsLeftOver;

	        //or tokens
	        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

	        getParsingFlags(tempConfig).score = currentScore;

	        if (scoreToBeat == null || currentScore < scoreToBeat) {
	            scoreToBeat = currentScore;
	            bestMoment = tempConfig;
	        }
	    }

	    extend(config, bestMoment || tempConfig);
	}

	function configFromObject(config) {
	    if (config._d) {
	        return;
	    }

	    var i = normalizeObjectUnits(config._i);
	    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	        return obj && parseInt(obj, 10);
	    });

	    configFromArray(config);
	}

	function createFromConfig (config) {
	    var res = new Moment(checkOverflow(prepareConfig(config)));
	    if (res._nextDay) {
	        // Adding is smart enough around DST
	        res.add(1, 'd');
	        res._nextDay = undefined;
	    }

	    return res;
	}

	function prepareConfig (config) {
	    var input = config._i,
	        format = config._f;

	    config._locale = config._locale || getLocale(config._l);

	    if (input === null || (format === undefined && input === '')) {
	        return createInvalid({nullInput: true});
	    }

	    if (typeof input === 'string') {
	        config._i = input = config._locale.preparse(input);
	    }

	    if (isMoment(input)) {
	        return new Moment(checkOverflow(input));
	    } else if (isDate(input)) {
	        config._d = input;
	    } else if (isArray(format)) {
	        configFromStringAndArray(config);
	    } else if (format) {
	        configFromStringAndFormat(config);
	    }  else {
	        configFromInput(config);
	    }

	    if (!isValid(config)) {
	        config._d = null;
	    }

	    return config;
	}

	function configFromInput(config) {
	    var input = config._i;
	    if (input === undefined) {
	        config._d = new Date(hooks.now());
	    } else if (isDate(input)) {
	        config._d = new Date(input.valueOf());
	    } else if (typeof input === 'string') {
	        configFromString(config);
	    } else if (isArray(input)) {
	        config._a = map(input.slice(0), function (obj) {
	            return parseInt(obj, 10);
	        });
	        configFromArray(config);
	    } else if (typeof(input) === 'object') {
	        configFromObject(config);
	    } else if (isNumber(input)) {
	        // from milliseconds
	        config._d = new Date(input);
	    } else {
	        hooks.createFromInputFallback(config);
	    }
	}

	function createLocalOrUTC (input, format, locale, strict, isUTC) {
	    var c = {};

	    if (locale === true || locale === false) {
	        strict = locale;
	        locale = undefined;
	    }

	    if ((isObject(input) && isObjectEmpty(input)) ||
	            (isArray(input) && input.length === 0)) {
	        input = undefined;
	    }
	    // object construction must be done this way.
	    // https://github.com/moment/moment/issues/1423
	    c._isAMomentObject = true;
	    c._useUTC = c._isUTC = isUTC;
	    c._l = locale;
	    c._i = input;
	    c._f = format;
	    c._strict = strict;

	    return createFromConfig(c);
	}

	function createLocal (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, false);
	}

	var prototypeMin = deprecate(
	    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() && other.isValid()) {
	            return other < this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);

	var prototypeMax = deprecate(
	    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() && other.isValid()) {
	            return other > this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);

	// Pick a moment m from moments so that m[fn](other) is true for all
	// other. This relies on the function fn to be transitive.
	//
	// moments should either be an array of moment objects or an array, whose
	// first element is an array of moment objects.
	function pickBy(fn, moments) {
	    var res, i;
	    if (moments.length === 1 && isArray(moments[0])) {
	        moments = moments[0];
	    }
	    if (!moments.length) {
	        return createLocal();
	    }
	    res = moments[0];
	    for (i = 1; i < moments.length; ++i) {
	        if (!moments[i].isValid() || moments[i][fn](res)) {
	            res = moments[i];
	        }
	    }
	    return res;
	}

	// TODO: Use [].sort instead?
	function min () {
	    var args = [].slice.call(arguments, 0);

	    return pickBy('isBefore', args);
	}

	function max () {
	    var args = [].slice.call(arguments, 0);

	    return pickBy('isAfter', args);
	}

	var now = function () {
	    return Date.now ? Date.now() : +(new Date());
	};

	function Duration (duration) {
	    var normalizedInput = normalizeObjectUnits(duration),
	        years = normalizedInput.year || 0,
	        quarters = normalizedInput.quarter || 0,
	        months = normalizedInput.month || 0,
	        weeks = normalizedInput.week || 0,
	        days = normalizedInput.day || 0,
	        hours = normalizedInput.hour || 0,
	        minutes = normalizedInput.minute || 0,
	        seconds = normalizedInput.second || 0,
	        milliseconds = normalizedInput.millisecond || 0;

	    // representation for dateAddRemove
	    this._milliseconds = +milliseconds +
	        seconds * 1e3 + // 1000
	        minutes * 6e4 + // 1000 * 60
	        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	    // Because of dateAddRemove treats 24 hours as different from a
	    // day when working around DST, we need to store them separately
	    this._days = +days +
	        weeks * 7;
	    // It is impossible translate months into days without knowing
	    // which months you are are talking about, so we have to store
	    // it separately.
	    this._months = +months +
	        quarters * 3 +
	        years * 12;

	    this._data = {};

	    this._locale = getLocale();

	    this._bubble();
	}

	function isDuration (obj) {
	    return obj instanceof Duration;
	}

	function absRound (number) {
	    if (number < 0) {
	        return Math.round(-1 * number) * -1;
	    } else {
	        return Math.round(number);
	    }
	}

	// FORMATTING

	function offset (token, separator) {
	    addFormatToken(token, 0, 0, function () {
	        var offset = this.utcOffset();
	        var sign = '+';
	        if (offset < 0) {
	            offset = -offset;
	            sign = '-';
	        }
	        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	    });
	}

	offset('Z', ':');
	offset('ZZ', '');

	// PARSING

	addRegexToken('Z',  matchShortOffset);
	addRegexToken('ZZ', matchShortOffset);
	addParseToken(['Z', 'ZZ'], function (input, array, config) {
	    config._useUTC = true;
	    config._tzm = offsetFromString(matchShortOffset, input);
	});

	// HELPERS

	// timezone chunker
	// '+10:00' > ['10',  '00']
	// '-1530'  > ['-15', '30']
	var chunkOffset = /([\+\-]|\d\d)/gi;

	function offsetFromString(matcher, string) {
	    var matches = (string || '').match(matcher);

	    if (matches === null) {
	        return null;
	    }

	    var chunk   = matches[matches.length - 1] || [];
	    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	    var minutes = +(parts[1] * 60) + toInt(parts[2]);

	    return minutes === 0 ?
	      0 :
	      parts[0] === '+' ? minutes : -minutes;
	}

	// Return a moment from input, that is local/utc/zone equivalent to model.
	function cloneWithOffset(input, model) {
	    var res, diff;
	    if (model._isUTC) {
	        res = model.clone();
	        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
	        // Use low-level api, because this fn is low-level api.
	        res._d.setTime(res._d.valueOf() + diff);
	        hooks.updateOffset(res, false);
	        return res;
	    } else {
	        return createLocal(input).local();
	    }
	}

	function getDateOffset (m) {
	    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	    // https://github.com/moment/moment/pull/1871
	    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	}

	// HOOKS

	// This function will be called whenever a moment is mutated.
	// It is intended to keep the offset in sync with the timezone.
	hooks.updateOffset = function () {};

	// MOMENTS

	// keepLocalTime = true means only change the timezone, without
	// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	// +0200, so we adjust the time as needed, to be valid.
	//
	// Keeping the time actually adds/subtracts (one hour)
	// from the actual represented time. That is why we call updateOffset
	// a second time. In case it wants us to change the offset again
	// _changeInProgress == true case, then we have to adjust, because
	// there is no such time in the given timezone.
	function getSetOffset (input, keepLocalTime) {
	    var offset = this._offset || 0,
	        localAdjust;
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    if (input != null) {
	        if (typeof input === 'string') {
	            input = offsetFromString(matchShortOffset, input);
	            if (input === null) {
	                return this;
	            }
	        } else if (Math.abs(input) < 16) {
	            input = input * 60;
	        }
	        if (!this._isUTC && keepLocalTime) {
	            localAdjust = getDateOffset(this);
	        }
	        this._offset = input;
	        this._isUTC = true;
	        if (localAdjust != null) {
	            this.add(localAdjust, 'm');
	        }
	        if (offset !== input) {
	            if (!keepLocalTime || this._changeInProgress) {
	                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
	            } else if (!this._changeInProgress) {
	                this._changeInProgress = true;
	                hooks.updateOffset(this, true);
	                this._changeInProgress = null;
	            }
	        }
	        return this;
	    } else {
	        return this._isUTC ? offset : getDateOffset(this);
	    }
	}

	function getSetZone (input, keepLocalTime) {
	    if (input != null) {
	        if (typeof input !== 'string') {
	            input = -input;
	        }

	        this.utcOffset(input, keepLocalTime);

	        return this;
	    } else {
	        return -this.utcOffset();
	    }
	}

	function setOffsetToUTC (keepLocalTime) {
	    return this.utcOffset(0, keepLocalTime);
	}

	function setOffsetToLocal (keepLocalTime) {
	    if (this._isUTC) {
	        this.utcOffset(0, keepLocalTime);
	        this._isUTC = false;

	        if (keepLocalTime) {
	            this.subtract(getDateOffset(this), 'm');
	        }
	    }
	    return this;
	}

	function setOffsetToParsedOffset () {
	    if (this._tzm != null) {
	        this.utcOffset(this._tzm);
	    } else if (typeof this._i === 'string') {
	        var tZone = offsetFromString(matchOffset, this._i);
	        if (tZone != null) {
	            this.utcOffset(tZone);
	        }
	        else {
	            this.utcOffset(0, true);
	        }
	    }
	    return this;
	}

	function hasAlignedHourOffset (input) {
	    if (!this.isValid()) {
	        return false;
	    }
	    input = input ? createLocal(input).utcOffset() : 0;

	    return (this.utcOffset() - input) % 60 === 0;
	}

	function isDaylightSavingTime () {
	    return (
	        this.utcOffset() > this.clone().month(0).utcOffset() ||
	        this.utcOffset() > this.clone().month(5).utcOffset()
	    );
	}

	function isDaylightSavingTimeShifted () {
	    if (!isUndefined(this._isDSTShifted)) {
	        return this._isDSTShifted;
	    }

	    var c = {};

	    copyConfig(c, this);
	    c = prepareConfig(c);

	    if (c._a) {
	        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
	        this._isDSTShifted = this.isValid() &&
	            compareArrays(c._a, other.toArray()) > 0;
	    } else {
	        this._isDSTShifted = false;
	    }

	    return this._isDSTShifted;
	}

	function isLocal () {
	    return this.isValid() ? !this._isUTC : false;
	}

	function isUtcOffset () {
	    return this.isValid() ? this._isUTC : false;
	}

	function isUtc () {
	    return this.isValid() ? this._isUTC && this._offset === 0 : false;
	}

	// ASP.NET json date format regex
	var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

	// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	// and further modified to allow for strings containing both week and day
	var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

	function createDuration (input, key) {
	    var duration = input,
	        // matching against regexp is expensive, do it on demand
	        match = null,
	        sign,
	        ret,
	        diffRes;

	    if (isDuration(input)) {
	        duration = {
	            ms : input._milliseconds,
	            d  : input._days,
	            M  : input._months
	        };
	    } else if (isNumber(input)) {
	        duration = {};
	        if (key) {
	            duration[key] = input;
	        } else {
	            duration.milliseconds = input;
	        }
	    } else if (!!(match = aspNetRegex.exec(input))) {
	        sign = (match[1] === '-') ? -1 : 1;
	        duration = {
	            y  : 0,
	            d  : toInt(match[DATE])                         * sign,
	            h  : toInt(match[HOUR])                         * sign,
	            m  : toInt(match[MINUTE])                       * sign,
	            s  : toInt(match[SECOND])                       * sign,
	            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
	        };
	    } else if (!!(match = isoRegex.exec(input))) {
	        sign = (match[1] === '-') ? -1 : 1;
	        duration = {
	            y : parseIso(match[2], sign),
	            M : parseIso(match[3], sign),
	            w : parseIso(match[4], sign),
	            d : parseIso(match[5], sign),
	            h : parseIso(match[6], sign),
	            m : parseIso(match[7], sign),
	            s : parseIso(match[8], sign)
	        };
	    } else if (duration == null) {// checks for null or undefined
	        duration = {};
	    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

	        duration = {};
	        duration.ms = diffRes.milliseconds;
	        duration.M = diffRes.months;
	    }

	    ret = new Duration(duration);

	    if (isDuration(input) && hasOwnProp(input, '_locale')) {
	        ret._locale = input._locale;
	    }

	    return ret;
	}

	createDuration.fn = Duration.prototype;

	function parseIso (inp, sign) {
	    // We'd normally use ~~inp for this, but unfortunately it also
	    // converts floats to ints.
	    // inp may be undefined, so careful calling replace on it.
	    var res = inp && parseFloat(inp.replace(',', '.'));
	    // apply sign while we're at it
	    return (isNaN(res) ? 0 : res) * sign;
	}

	function positiveMomentsDifference(base, other) {
	    var res = {milliseconds: 0, months: 0};

	    res.months = other.month() - base.month() +
	        (other.year() - base.year()) * 12;
	    if (base.clone().add(res.months, 'M').isAfter(other)) {
	        --res.months;
	    }

	    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

	    return res;
	}

	function momentsDifference(base, other) {
	    var res;
	    if (!(base.isValid() && other.isValid())) {
	        return {milliseconds: 0, months: 0};
	    }

	    other = cloneWithOffset(other, base);
	    if (base.isBefore(other)) {
	        res = positiveMomentsDifference(base, other);
	    } else {
	        res = positiveMomentsDifference(other, base);
	        res.milliseconds = -res.milliseconds;
	        res.months = -res.months;
	    }

	    return res;
	}

	// TODO: remove 'name' arg after deprecation is removed
	function createAdder(direction, name) {
	    return function (val, period) {
	        var dur, tmp;
	        //invert the arguments, but complain about it
	        if (period !== null && !isNaN(+period)) {
	            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
	            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
	            tmp = val; val = period; period = tmp;
	        }

	        val = typeof val === 'string' ? +val : val;
	        dur = createDuration(val, period);
	        addSubtract(this, dur, direction);
	        return this;
	    };
	}

	function addSubtract (mom, duration, isAdding, updateOffset) {
	    var milliseconds = duration._milliseconds,
	        days = absRound(duration._days),
	        months = absRound(duration._months);

	    if (!mom.isValid()) {
	        // No op
	        return;
	    }

	    updateOffset = updateOffset == null ? true : updateOffset;

	    if (milliseconds) {
	        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	    }
	    if (days) {
	        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
	    }
	    if (months) {
	        setMonth(mom, get(mom, 'Month') + months * isAdding);
	    }
	    if (updateOffset) {
	        hooks.updateOffset(mom, days || months);
	    }
	}

	var add      = createAdder(1, 'add');
	var subtract = createAdder(-1, 'subtract');

	function getCalendarFormat(myMoment, now) {
	    var diff = myMoment.diff(now, 'days', true);
	    return diff < -6 ? 'sameElse' :
	            diff < -1 ? 'lastWeek' :
	            diff < 0 ? 'lastDay' :
	            diff < 1 ? 'sameDay' :
	            diff < 2 ? 'nextDay' :
	            diff < 7 ? 'nextWeek' : 'sameElse';
	}

	function calendar$1 (time, formats) {
	    // We want to compare the start of today, vs this.
	    // Getting start-of-today depends on whether we're local/utc/offset or not.
	    var now = time || createLocal(),
	        sod = cloneWithOffset(now, this).startOf('day'),
	        format = hooks.calendarFormat(this, sod) || 'sameElse';

	    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

	    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
	}

	function clone () {
	    return new Moment(this);
	}

	function isAfter (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() > localInput.valueOf();
	    } else {
	        return localInput.valueOf() < this.clone().startOf(units).valueOf();
	    }
	}

	function isBefore (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() < localInput.valueOf();
	    } else {
	        return this.clone().endOf(units).valueOf() < localInput.valueOf();
	    }
	}

	function isBetween (from, to, units, inclusivity) {
	    inclusivity = inclusivity || '()';
	    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
	        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
	}

	function isSame (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input),
	        inputMs;
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(units || 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() === localInput.valueOf();
	    } else {
	        inputMs = localInput.valueOf();
	        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
	    }
	}

	function isSameOrAfter (input, units) {
	    return this.isSame(input, units) || this.isAfter(input,units);
	}

	function isSameOrBefore (input, units) {
	    return this.isSame(input, units) || this.isBefore(input,units);
	}

	function diff (input, units, asFloat) {
	    var that,
	        zoneDelta,
	        delta, output;

	    if (!this.isValid()) {
	        return NaN;
	    }

	    that = cloneWithOffset(input, this);

	    if (!that.isValid()) {
	        return NaN;
	    }

	    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

	    units = normalizeUnits(units);

	    if (units === 'year' || units === 'month' || units === 'quarter') {
	        output = monthDiff(this, that);
	        if (units === 'quarter') {
	            output = output / 3;
	        } else if (units === 'year') {
	            output = output / 12;
	        }
	    } else {
	        delta = this - that;
	        output = units === 'second' ? delta / 1e3 : // 1000
	            units === 'minute' ? delta / 6e4 : // 1000 * 60
	            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
	            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	            delta;
	    }
	    return asFloat ? output : absFloor(output);
	}

	function monthDiff (a, b) {
	    // difference in months
	    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	        // b is in (anchor - 1 month, anchor + 1 month)
	        anchor = a.clone().add(wholeMonthDiff, 'months'),
	        anchor2, adjust;

	    if (b - anchor < 0) {
	        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	        // linear across the month
	        adjust = (b - anchor) / (anchor - anchor2);
	    } else {
	        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	        // linear across the month
	        adjust = (b - anchor) / (anchor2 - anchor);
	    }

	    //check for negative zero, return zero if negative zero
	    return -(wholeMonthDiff + adjust) || 0;
	}

	hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

	function toString () {
	    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	}

	function toISOString () {
	    var m = this.clone().utc();
	    if (0 < m.year() && m.year() <= 9999) {
	        if (isFunction(Date.prototype.toISOString)) {
	            // native implementation is ~50x faster, use it when we can
	            return this.toDate().toISOString();
	        } else {
	            return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	        }
	    } else {
	        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	    }
	}

	/**
	 * Return a human readable representation of a moment that can
	 * also be evaluated to get a new moment which is the same
	 *
	 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	 */
	function inspect () {
	    if (!this.isValid()) {
	        return 'moment.invalid(/* ' + this._i + ' */)';
	    }
	    var func = 'moment';
	    var zone = '';
	    if (!this.isLocal()) {
	        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
	        zone = 'Z';
	    }
	    var prefix = '[' + func + '("]';
	    var year = (0 < this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
	    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
	    var suffix = zone + '[")]';

	    return this.format(prefix + year + datetime + suffix);
	}

	function format (inputString) {
	    if (!inputString) {
	        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
	    }
	    var output = formatMoment(this, inputString);
	    return this.localeData().postformat(output);
	}

	function from (time, withoutSuffix) {
	    if (this.isValid() &&
	            ((isMoment(time) && time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}

	function fromNow (withoutSuffix) {
	    return this.from(createLocal(), withoutSuffix);
	}

	function to (time, withoutSuffix) {
	    if (this.isValid() &&
	            ((isMoment(time) && time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}

	function toNow (withoutSuffix) {
	    return this.to(createLocal(), withoutSuffix);
	}

	// If passed a locale key, it will set the locale for this
	// instance.  Otherwise, it will return the locale configuration
	// variables for this instance.
	function locale (key) {
	    var newLocaleData;

	    if (key === undefined) {
	        return this._locale._abbr;
	    } else {
	        newLocaleData = getLocale(key);
	        if (newLocaleData != null) {
	            this._locale = newLocaleData;
	        }
	        return this;
	    }
	}

	var lang = deprecate(
	    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	    function (key) {
	        if (key === undefined) {
	            return this.localeData();
	        } else {
	            return this.locale(key);
	        }
	    }
	);

	function localeData () {
	    return this._locale;
	}

	function startOf (units) {
	    units = normalizeUnits(units);
	    // the following switch intentionally omits break keywords
	    // to utilize falling through the cases.
	    switch (units) {
	        case 'year':
	            this.month(0);
	            /* falls through */
	        case 'quarter':
	        case 'month':
	            this.date(1);
	            /* falls through */
	        case 'week':
	        case 'isoWeek':
	        case 'day':
	        case 'date':
	            this.hours(0);
	            /* falls through */
	        case 'hour':
	            this.minutes(0);
	            /* falls through */
	        case 'minute':
	            this.seconds(0);
	            /* falls through */
	        case 'second':
	            this.milliseconds(0);
	    }

	    // weeks are a special case
	    if (units === 'week') {
	        this.weekday(0);
	    }
	    if (units === 'isoWeek') {
	        this.isoWeekday(1);
	    }

	    // quarters are also special
	    if (units === 'quarter') {
	        this.month(Math.floor(this.month() / 3) * 3);
	    }

	    return this;
	}

	function endOf (units) {
	    units = normalizeUnits(units);
	    if (units === undefined || units === 'millisecond') {
	        return this;
	    }

	    // 'date' is an alias for 'day', so it should be considered as such.
	    if (units === 'date') {
	        units = 'day';
	    }

	    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	}

	function valueOf () {
	    return this._d.valueOf() - ((this._offset || 0) * 60000);
	}

	function unix () {
	    return Math.floor(this.valueOf() / 1000);
	}

	function toDate () {
	    return new Date(this.valueOf());
	}

	function toArray () {
	    var m = this;
	    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	}

	function toObject () {
	    var m = this;
	    return {
	        years: m.year(),
	        months: m.month(),
	        date: m.date(),
	        hours: m.hours(),
	        minutes: m.minutes(),
	        seconds: m.seconds(),
	        milliseconds: m.milliseconds()
	    };
	}

	function toJSON () {
	    // new Date(NaN).toJSON() === null
	    return this.isValid() ? this.toISOString() : null;
	}

	function isValid$1 () {
	    return isValid(this);
	}

	function parsingFlags () {
	    return extend({}, getParsingFlags(this));
	}

	function invalidAt () {
	    return getParsingFlags(this).overflow;
	}

	function creationData() {
	    return {
	        input: this._i,
	        format: this._f,
	        locale: this._locale,
	        isUTC: this._isUTC,
	        strict: this._strict
	    };
	}

	// FORMATTING

	addFormatToken(0, ['gg', 2], 0, function () {
	    return this.weekYear() % 100;
	});

	addFormatToken(0, ['GG', 2], 0, function () {
	    return this.isoWeekYear() % 100;
	});

	function addWeekYearFormatToken (token, getter) {
	    addFormatToken(0, [token, token.length], 0, getter);
	}

	addWeekYearFormatToken('gggg',     'weekYear');
	addWeekYearFormatToken('ggggg',    'weekYear');
	addWeekYearFormatToken('GGGG',  'isoWeekYear');
	addWeekYearFormatToken('GGGGG', 'isoWeekYear');

	// ALIASES

	addUnitAlias('weekYear', 'gg');
	addUnitAlias('isoWeekYear', 'GG');

	// PRIORITY

	addUnitPriority('weekYear', 1);
	addUnitPriority('isoWeekYear', 1);


	// PARSING

	addRegexToken('G',      matchSigned);
	addRegexToken('g',      matchSigned);
	addRegexToken('GG',     match1to2, match2);
	addRegexToken('gg',     match1to2, match2);
	addRegexToken('GGGG',   match1to4, match4);
	addRegexToken('gggg',   match1to4, match4);
	addRegexToken('GGGGG',  match1to6, match6);
	addRegexToken('ggggg',  match1to6, match6);

	addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	    week[token.substr(0, 2)] = toInt(input);
	});

	addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	    week[token] = hooks.parseTwoDigitYear(input);
	});

	// MOMENTS

	function getSetWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input,
	            this.week(),
	            this.weekday(),
	            this.localeData()._week.dow,
	            this.localeData()._week.doy);
	}

	function getSetISOWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input, this.isoWeek(), this.isoWeekday(), 1, 4);
	}

	function getISOWeeksInYear () {
	    return weeksInYear(this.year(), 1, 4);
	}

	function getWeeksInYear () {
	    var weekInfo = this.localeData()._week;
	    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	}

	function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	    var weeksTarget;
	    if (input == null) {
	        return weekOfYear(this, dow, doy).year;
	    } else {
	        weeksTarget = weeksInYear(input, dow, doy);
	        if (week > weeksTarget) {
	            week = weeksTarget;
	        }
	        return setWeekAll.call(this, input, week, weekday, dow, doy);
	    }
	}

	function setWeekAll(weekYear, week, weekday, dow, doy) {
	    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

	    this.year(date.getUTCFullYear());
	    this.month(date.getUTCMonth());
	    this.date(date.getUTCDate());
	    return this;
	}

	// FORMATTING

	addFormatToken('Q', 0, 'Qo', 'quarter');

	// ALIASES

	addUnitAlias('quarter', 'Q');

	// PRIORITY

	addUnitPriority('quarter', 7);

	// PARSING

	addRegexToken('Q', match1);
	addParseToken('Q', function (input, array) {
	    array[MONTH] = (toInt(input) - 1) * 3;
	});

	// MOMENTS

	function getSetQuarter (input) {
	    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	}

	// FORMATTING

	addFormatToken('D', ['DD', 2], 'Do', 'date');

	// ALIASES

	addUnitAlias('date', 'D');

	// PRIOROITY
	addUnitPriority('date', 9);

	// PARSING

	addRegexToken('D',  match1to2);
	addRegexToken('DD', match1to2, match2);
	addRegexToken('Do', function (isStrict, locale) {
	    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
	});

	addParseToken(['D', 'DD'], DATE);
	addParseToken('Do', function (input, array) {
	    array[DATE] = toInt(input.match(match1to2)[0], 10);
	});

	// MOMENTS

	var getSetDayOfMonth = makeGetSet('Date', true);

	// FORMATTING

	addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

	// ALIASES

	addUnitAlias('dayOfYear', 'DDD');

	// PRIORITY
	addUnitPriority('dayOfYear', 4);

	// PARSING

	addRegexToken('DDD',  match1to3);
	addRegexToken('DDDD', match3);
	addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	    config._dayOfYear = toInt(input);
	});

	// HELPERS

	// MOMENTS

	function getSetDayOfYear (input) {
	    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	}

	// FORMATTING

	addFormatToken('m', ['mm', 2], 0, 'minute');

	// ALIASES

	addUnitAlias('minute', 'm');

	// PRIORITY

	addUnitPriority('minute', 14);

	// PARSING

	addRegexToken('m',  match1to2);
	addRegexToken('mm', match1to2, match2);
	addParseToken(['m', 'mm'], MINUTE);

	// MOMENTS

	var getSetMinute = makeGetSet('Minutes', false);

	// FORMATTING

	addFormatToken('s', ['ss', 2], 0, 'second');

	// ALIASES

	addUnitAlias('second', 's');

	// PRIORITY

	addUnitPriority('second', 15);

	// PARSING

	addRegexToken('s',  match1to2);
	addRegexToken('ss', match1to2, match2);
	addParseToken(['s', 'ss'], SECOND);

	// MOMENTS

	var getSetSecond = makeGetSet('Seconds', false);

	// FORMATTING

	addFormatToken('S', 0, 0, function () {
	    return ~~(this.millisecond() / 100);
	});

	addFormatToken(0, ['SS', 2], 0, function () {
	    return ~~(this.millisecond() / 10);
	});

	addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	addFormatToken(0, ['SSSS', 4], 0, function () {
	    return this.millisecond() * 10;
	});
	addFormatToken(0, ['SSSSS', 5], 0, function () {
	    return this.millisecond() * 100;
	});
	addFormatToken(0, ['SSSSSS', 6], 0, function () {
	    return this.millisecond() * 1000;
	});
	addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	    return this.millisecond() * 10000;
	});
	addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	    return this.millisecond() * 100000;
	});
	addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	    return this.millisecond() * 1000000;
	});


	// ALIASES

	addUnitAlias('millisecond', 'ms');

	// PRIORITY

	addUnitPriority('millisecond', 16);

	// PARSING

	addRegexToken('S',    match1to3, match1);
	addRegexToken('SS',   match1to3, match2);
	addRegexToken('SSS',  match1to3, match3);

	var token;
	for (token = 'SSSS'; token.length <= 9; token += 'S') {
	    addRegexToken(token, matchUnsigned);
	}

	function parseMs(input, array) {
	    array[MILLISECOND] = toInt(('0.' + input) * 1000);
	}

	for (token = 'S'; token.length <= 9; token += 'S') {
	    addParseToken(token, parseMs);
	}
	// MOMENTS

	var getSetMillisecond = makeGetSet('Milliseconds', false);

	// FORMATTING

	addFormatToken('z',  0, 0, 'zoneAbbr');
	addFormatToken('zz', 0, 0, 'zoneName');

	// MOMENTS

	function getZoneAbbr () {
	    return this._isUTC ? 'UTC' : '';
	}

	function getZoneName () {
	    return this._isUTC ? 'Coordinated Universal Time' : '';
	}

	var proto = Moment.prototype;

	proto.add               = add;
	proto.calendar          = calendar$1;
	proto.clone             = clone;
	proto.diff              = diff;
	proto.endOf             = endOf;
	proto.format            = format;
	proto.from              = from;
	proto.fromNow           = fromNow;
	proto.to                = to;
	proto.toNow             = toNow;
	proto.get               = stringGet;
	proto.invalidAt         = invalidAt;
	proto.isAfter           = isAfter;
	proto.isBefore          = isBefore;
	proto.isBetween         = isBetween;
	proto.isSame            = isSame;
	proto.isSameOrAfter     = isSameOrAfter;
	proto.isSameOrBefore    = isSameOrBefore;
	proto.isValid           = isValid$1;
	proto.lang              = lang;
	proto.locale            = locale;
	proto.localeData        = localeData;
	proto.max               = prototypeMax;
	proto.min               = prototypeMin;
	proto.parsingFlags      = parsingFlags;
	proto.set               = stringSet;
	proto.startOf           = startOf;
	proto.subtract          = subtract;
	proto.toArray           = toArray;
	proto.toObject          = toObject;
	proto.toDate            = toDate;
	proto.toISOString       = toISOString;
	proto.inspect           = inspect;
	proto.toJSON            = toJSON;
	proto.toString          = toString;
	proto.unix              = unix;
	proto.valueOf           = valueOf;
	proto.creationData      = creationData;

	// Year
	proto.year       = getSetYear;
	proto.isLeapYear = getIsLeapYear;

	// Week Year
	proto.weekYear    = getSetWeekYear;
	proto.isoWeekYear = getSetISOWeekYear;

	// Quarter
	proto.quarter = proto.quarters = getSetQuarter;

	// Month
	proto.month       = getSetMonth;
	proto.daysInMonth = getDaysInMonth;

	// Week
	proto.week           = proto.weeks        = getSetWeek;
	proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
	proto.weeksInYear    = getWeeksInYear;
	proto.isoWeeksInYear = getISOWeeksInYear;

	// Day
	proto.date       = getSetDayOfMonth;
	proto.day        = proto.days             = getSetDayOfWeek;
	proto.weekday    = getSetLocaleDayOfWeek;
	proto.isoWeekday = getSetISODayOfWeek;
	proto.dayOfYear  = getSetDayOfYear;

	// Hour
	proto.hour = proto.hours = getSetHour;

	// Minute
	proto.minute = proto.minutes = getSetMinute;

	// Second
	proto.second = proto.seconds = getSetSecond;

	// Millisecond
	proto.millisecond = proto.milliseconds = getSetMillisecond;

	// Offset
	proto.utcOffset            = getSetOffset;
	proto.utc                  = setOffsetToUTC;
	proto.local                = setOffsetToLocal;
	proto.parseZone            = setOffsetToParsedOffset;
	proto.hasAlignedHourOffset = hasAlignedHourOffset;
	proto.isDST                = isDaylightSavingTime;
	proto.isLocal              = isLocal;
	proto.isUtcOffset          = isUtcOffset;
	proto.isUtc                = isUtc;
	proto.isUTC                = isUtc;

	// Timezone
	proto.zoneAbbr = getZoneAbbr;
	proto.zoneName = getZoneName;

	// Deprecations
	proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
	proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

	function createUnix (input) {
	    return createLocal(input * 1000);
	}

	function createInZone () {
	    return createLocal.apply(null, arguments).parseZone();
	}

	function preParsePostFormat (string) {
	    return string;
	}

	var proto$1 = Locale.prototype;

	proto$1.calendar        = calendar;
	proto$1.longDateFormat  = longDateFormat;
	proto$1.invalidDate     = invalidDate;
	proto$1.ordinal         = ordinal;
	proto$1.preparse        = preParsePostFormat;
	proto$1.postformat      = preParsePostFormat;
	proto$1.relativeTime    = relativeTime;
	proto$1.pastFuture      = pastFuture;
	proto$1.set             = set;

	// Month
	proto$1.months            =        localeMonths;
	proto$1.monthsShort       =        localeMonthsShort;
	proto$1.monthsParse       =        localeMonthsParse;
	proto$1.monthsRegex       = monthsRegex;
	proto$1.monthsShortRegex  = monthsShortRegex;

	// Week
	proto$1.week = localeWeek;
	proto$1.firstDayOfYear = localeFirstDayOfYear;
	proto$1.firstDayOfWeek = localeFirstDayOfWeek;

	// Day of Week
	proto$1.weekdays       =        localeWeekdays;
	proto$1.weekdaysMin    =        localeWeekdaysMin;
	proto$1.weekdaysShort  =        localeWeekdaysShort;
	proto$1.weekdaysParse  =        localeWeekdaysParse;

	proto$1.weekdaysRegex       =        weekdaysRegex;
	proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
	proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

	// Hours
	proto$1.isPM = localeIsPM;
	proto$1.meridiem = localeMeridiem;

	function get$1 (format, index, field, setter) {
	    var locale = getLocale();
	    var utc = createUTC().set(setter, index);
	    return locale[field](utc, format);
	}

	function listMonthsImpl (format, index, field) {
	    if (isNumber(format)) {
	        index = format;
	        format = undefined;
	    }

	    format = format || '';

	    if (index != null) {
	        return get$1(format, index, field, 'month');
	    }

	    var i;
	    var out = [];
	    for (i = 0; i < 12; i++) {
	        out[i] = get$1(format, i, field, 'month');
	    }
	    return out;
	}

	// ()
	// (5)
	// (fmt, 5)
	// (fmt)
	// (true)
	// (true, 5)
	// (true, fmt, 5)
	// (true, fmt)
	function listWeekdaysImpl (localeSorted, format, index, field) {
	    if (typeof localeSorted === 'boolean') {
	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';
	    } else {
	        format = localeSorted;
	        index = format;
	        localeSorted = false;

	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';
	    }

	    var locale = getLocale(),
	        shift = localeSorted ? locale._week.dow : 0;

	    if (index != null) {
	        return get$1(format, (index + shift) % 7, field, 'day');
	    }

	    var i;
	    var out = [];
	    for (i = 0; i < 7; i++) {
	        out[i] = get$1(format, (i + shift) % 7, field, 'day');
	    }
	    return out;
	}

	function listMonths (format, index) {
	    return listMonthsImpl(format, index, 'months');
	}

	function listMonthsShort (format, index) {
	    return listMonthsImpl(format, index, 'monthsShort');
	}

	function listWeekdays (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	}

	function listWeekdaysShort (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	}

	function listWeekdaysMin (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	}

	getSetGlobalLocale('en', {
	    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (toInt(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    }
	});

	// Side effect imports
	hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
	hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

	var mathAbs = Math.abs;

	function abs () {
	    var data           = this._data;

	    this._milliseconds = mathAbs(this._milliseconds);
	    this._days         = mathAbs(this._days);
	    this._months       = mathAbs(this._months);

	    data.milliseconds  = mathAbs(data.milliseconds);
	    data.seconds       = mathAbs(data.seconds);
	    data.minutes       = mathAbs(data.minutes);
	    data.hours         = mathAbs(data.hours);
	    data.months        = mathAbs(data.months);
	    data.years         = mathAbs(data.years);

	    return this;
	}

	function addSubtract$1 (duration, input, value, direction) {
	    var other = createDuration(input, value);

	    duration._milliseconds += direction * other._milliseconds;
	    duration._days         += direction * other._days;
	    duration._months       += direction * other._months;

	    return duration._bubble();
	}

	// supports only 2.0-style add(1, 's') or add(duration)
	function add$1 (input, value) {
	    return addSubtract$1(this, input, value, 1);
	}

	// supports only 2.0-style subtract(1, 's') or subtract(duration)
	function subtract$1 (input, value) {
	    return addSubtract$1(this, input, value, -1);
	}

	function absCeil (number) {
	    if (number < 0) {
	        return Math.floor(number);
	    } else {
	        return Math.ceil(number);
	    }
	}

	function bubble () {
	    var milliseconds = this._milliseconds;
	    var days         = this._days;
	    var months       = this._months;
	    var data         = this._data;
	    var seconds, minutes, hours, years, monthsFromDays;

	    // if we have a mix of positive and negative values, bubble down first
	    // check: https://github.com/moment/moment/issues/2166
	    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	            (milliseconds <= 0 && days <= 0 && months <= 0))) {
	        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	        days = 0;
	        months = 0;
	    }

	    // The following code bubbles up values, see the tests for
	    // examples of what that means.
	    data.milliseconds = milliseconds % 1000;

	    seconds           = absFloor(milliseconds / 1000);
	    data.seconds      = seconds % 60;

	    minutes           = absFloor(seconds / 60);
	    data.minutes      = minutes % 60;

	    hours             = absFloor(minutes / 60);
	    data.hours        = hours % 24;

	    days += absFloor(hours / 24);

	    // convert days to months
	    monthsFromDays = absFloor(daysToMonths(days));
	    months += monthsFromDays;
	    days -= absCeil(monthsToDays(monthsFromDays));

	    // 12 months -> 1 year
	    years = absFloor(months / 12);
	    months %= 12;

	    data.days   = days;
	    data.months = months;
	    data.years  = years;

	    return this;
	}

	function daysToMonths (days) {
	    // 400 years have 146097 days (taking into account leap year rules)
	    // 400 years have 12 months === 4800
	    return days * 4800 / 146097;
	}

	function monthsToDays (months) {
	    // the reverse of daysToMonths
	    return months * 146097 / 4800;
	}

	function as (units) {
	    var days;
	    var months;
	    var milliseconds = this._milliseconds;

	    units = normalizeUnits(units);

	    if (units === 'month' || units === 'year') {
	        days   = this._days   + milliseconds / 864e5;
	        months = this._months + daysToMonths(days);
	        return units === 'month' ? months : months / 12;
	    } else {
	        // handle milliseconds separately because of floating point math errors (issue #1867)
	        days = this._days + Math.round(monthsToDays(this._months));
	        switch (units) {
	            case 'week'   : return days / 7     + milliseconds / 6048e5;
	            case 'day'    : return days         + milliseconds / 864e5;
	            case 'hour'   : return days * 24    + milliseconds / 36e5;
	            case 'minute' : return days * 1440  + milliseconds / 6e4;
	            case 'second' : return days * 86400 + milliseconds / 1000;
	            // Math.floor prevents floating point math errors here
	            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	            default: throw new Error('Unknown unit ' + units);
	        }
	    }
	}

	// TODO: Use this.as('ms')?
	function valueOf$1 () {
	    return (
	        this._milliseconds +
	        this._days * 864e5 +
	        (this._months % 12) * 2592e6 +
	        toInt(this._months / 12) * 31536e6
	    );
	}

	function makeAs (alias) {
	    return function () {
	        return this.as(alias);
	    };
	}

	var asMilliseconds = makeAs('ms');
	var asSeconds      = makeAs('s');
	var asMinutes      = makeAs('m');
	var asHours        = makeAs('h');
	var asDays         = makeAs('d');
	var asWeeks        = makeAs('w');
	var asMonths       = makeAs('M');
	var asYears        = makeAs('y');

	function get$2 (units) {
	    units = normalizeUnits(units);
	    return this[units + 's']();
	}

	function makeGetter(name) {
	    return function () {
	        return this._data[name];
	    };
	}

	var milliseconds = makeGetter('milliseconds');
	var seconds      = makeGetter('seconds');
	var minutes      = makeGetter('minutes');
	var hours        = makeGetter('hours');
	var days         = makeGetter('days');
	var months       = makeGetter('months');
	var years        = makeGetter('years');

	function weeks () {
	    return absFloor(this.days() / 7);
	}

	var round = Math.round;
	var thresholds = {
	    s: 45,  // seconds to minute
	    m: 45,  // minutes to hour
	    h: 22,  // hours to day
	    d: 26,  // days to month
	    M: 11   // months to year
	};

	// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	}

	function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
	    var duration = createDuration(posNegDuration).abs();
	    var seconds  = round(duration.as('s'));
	    var minutes  = round(duration.as('m'));
	    var hours    = round(duration.as('h'));
	    var days     = round(duration.as('d'));
	    var months   = round(duration.as('M'));
	    var years    = round(duration.as('y'));

	    var a = seconds < thresholds.s && ['s', seconds]  ||
	            minutes <= 1           && ['m']           ||
	            minutes < thresholds.m && ['mm', minutes] ||
	            hours   <= 1           && ['h']           ||
	            hours   < thresholds.h && ['hh', hours]   ||
	            days    <= 1           && ['d']           ||
	            days    < thresholds.d && ['dd', days]    ||
	            months  <= 1           && ['M']           ||
	            months  < thresholds.M && ['MM', months]  ||
	            years   <= 1           && ['y']           || ['yy', years];

	    a[2] = withoutSuffix;
	    a[3] = +posNegDuration > 0;
	    a[4] = locale;
	    return substituteTimeAgo.apply(null, a);
	}

	// This function allows you to set the rounding function for relative time strings
	function getSetRelativeTimeRounding (roundingFunction) {
	    if (roundingFunction === undefined) {
	        return round;
	    }
	    if (typeof(roundingFunction) === 'function') {
	        round = roundingFunction;
	        return true;
	    }
	    return false;
	}

	// This function allows you to set a threshold for relative time strings
	function getSetRelativeTimeThreshold (threshold, limit) {
	    if (thresholds[threshold] === undefined) {
	        return false;
	    }
	    if (limit === undefined) {
	        return thresholds[threshold];
	    }
	    thresholds[threshold] = limit;
	    return true;
	}

	function humanize (withSuffix) {
	    var locale = this.localeData();
	    var output = relativeTime$1(this, !withSuffix, locale);

	    if (withSuffix) {
	        output = locale.pastFuture(+this, output);
	    }

	    return locale.postformat(output);
	}

	var abs$1 = Math.abs;

	function toISOString$1() {
	    // for ISO strings we do not use the normal bubbling rules:
	    //  * milliseconds bubble up until they become hours
	    //  * days do not bubble at all
	    //  * months bubble up until they become years
	    // This is because there is no context-free conversion between hours and days
	    // (think of clock changes)
	    // and also not between days and months (28-31 days per month)
	    var seconds = abs$1(this._milliseconds) / 1000;
	    var days         = abs$1(this._days);
	    var months       = abs$1(this._months);
	    var minutes, hours, years;

	    // 3600 seconds -> 60 minutes -> 1 hour
	    minutes           = absFloor(seconds / 60);
	    hours             = absFloor(minutes / 60);
	    seconds %= 60;
	    minutes %= 60;

	    // 12 months -> 1 year
	    years  = absFloor(months / 12);
	    months %= 12;


	    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	    var Y = years;
	    var M = months;
	    var D = days;
	    var h = hours;
	    var m = minutes;
	    var s = seconds;
	    var total = this.asSeconds();

	    if (!total) {
	        // this is the same as C#'s (Noda) and python (isodate)...
	        // but not other JS (goog.date)
	        return 'P0D';
	    }

	    return (total < 0 ? '-' : '') +
	        'P' +
	        (Y ? Y + 'Y' : '') +
	        (M ? M + 'M' : '') +
	        (D ? D + 'D' : '') +
	        ((h || m || s) ? 'T' : '') +
	        (h ? h + 'H' : '') +
	        (m ? m + 'M' : '') +
	        (s ? s + 'S' : '');
	}

	var proto$2 = Duration.prototype;

	proto$2.abs            = abs;
	proto$2.add            = add$1;
	proto$2.subtract       = subtract$1;
	proto$2.as             = as;
	proto$2.asMilliseconds = asMilliseconds;
	proto$2.asSeconds      = asSeconds;
	proto$2.asMinutes      = asMinutes;
	proto$2.asHours        = asHours;
	proto$2.asDays         = asDays;
	proto$2.asWeeks        = asWeeks;
	proto$2.asMonths       = asMonths;
	proto$2.asYears        = asYears;
	proto$2.valueOf        = valueOf$1;
	proto$2._bubble        = bubble;
	proto$2.get            = get$2;
	proto$2.milliseconds   = milliseconds;
	proto$2.seconds        = seconds;
	proto$2.minutes        = minutes;
	proto$2.hours          = hours;
	proto$2.days           = days;
	proto$2.weeks          = weeks;
	proto$2.months         = months;
	proto$2.years          = years;
	proto$2.humanize       = humanize;
	proto$2.toISOString    = toISOString$1;
	proto$2.toString       = toISOString$1;
	proto$2.toJSON         = toISOString$1;
	proto$2.locale         = locale;
	proto$2.localeData     = localeData;

	// Deprecations
	proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
	proto$2.lang = lang;

	// Side effect imports

	// FORMATTING

	addFormatToken('X', 0, 0, 'unix');
	addFormatToken('x', 0, 0, 'valueOf');

	// PARSING

	addRegexToken('x', matchSigned);
	addRegexToken('X', matchTimestamp);
	addParseToken('X', function (input, array, config) {
	    config._d = new Date(parseFloat(input, 10) * 1000);
	});
	addParseToken('x', function (input, array, config) {
	    config._d = new Date(toInt(input));
	});

	// Side effect imports


	hooks.version = '2.17.1';

	setHookCallback(createLocal);

	hooks.fn                    = proto;
	hooks.min                   = min;
	hooks.max                   = max;
	hooks.now                   = now;
	hooks.utc                   = createUTC;
	hooks.unix                  = createUnix;
	hooks.months                = listMonths;
	hooks.isDate                = isDate;
	hooks.locale                = getSetGlobalLocale;
	hooks.invalid               = createInvalid;
	hooks.duration              = createDuration;
	hooks.isMoment              = isMoment;
	hooks.weekdays              = listWeekdays;
	hooks.parseZone             = createInZone;
	hooks.localeData            = getLocale;
	hooks.isDuration            = isDuration;
	hooks.monthsShort           = listMonthsShort;
	hooks.weekdaysMin           = listWeekdaysMin;
	hooks.defineLocale          = defineLocale;
	hooks.updateLocale          = updateLocale;
	hooks.locales               = listLocales;
	hooks.weekdaysShort         = listWeekdaysShort;
	hooks.normalizeUnits        = normalizeUnits;
	hooks.relativeTimeRounding = getSetRelativeTimeRounding;
	hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
	hooks.calendarFormat        = getCalendarFormat;
	hooks.prototype             = proto;

	return hooks;

	})));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(306)(module)))

/***/ },
/* 306 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./af": 308,
		"./af.js": 308,
		"./ar": 309,
		"./ar-dz": 310,
		"./ar-dz.js": 310,
		"./ar-ly": 311,
		"./ar-ly.js": 311,
		"./ar-ma": 312,
		"./ar-ma.js": 312,
		"./ar-sa": 313,
		"./ar-sa.js": 313,
		"./ar-tn": 314,
		"./ar-tn.js": 314,
		"./ar.js": 309,
		"./az": 315,
		"./az.js": 315,
		"./be": 316,
		"./be.js": 316,
		"./bg": 317,
		"./bg.js": 317,
		"./bn": 318,
		"./bn.js": 318,
		"./bo": 319,
		"./bo.js": 319,
		"./br": 320,
		"./br.js": 320,
		"./bs": 321,
		"./bs.js": 321,
		"./ca": 322,
		"./ca.js": 322,
		"./cs": 323,
		"./cs.js": 323,
		"./cv": 324,
		"./cv.js": 324,
		"./cy": 325,
		"./cy.js": 325,
		"./da": 326,
		"./da.js": 326,
		"./de": 327,
		"./de-at": 328,
		"./de-at.js": 328,
		"./de.js": 327,
		"./dv": 329,
		"./dv.js": 329,
		"./el": 330,
		"./el.js": 330,
		"./en-au": 331,
		"./en-au.js": 331,
		"./en-ca": 332,
		"./en-ca.js": 332,
		"./en-gb": 333,
		"./en-gb.js": 333,
		"./en-ie": 334,
		"./en-ie.js": 334,
		"./en-nz": 335,
		"./en-nz.js": 335,
		"./eo": 336,
		"./eo.js": 336,
		"./es": 337,
		"./es-do": 338,
		"./es-do.js": 338,
		"./es.js": 337,
		"./et": 339,
		"./et.js": 339,
		"./eu": 340,
		"./eu.js": 340,
		"./fa": 341,
		"./fa.js": 341,
		"./fi": 342,
		"./fi.js": 342,
		"./fo": 343,
		"./fo.js": 343,
		"./fr": 344,
		"./fr-ca": 345,
		"./fr-ca.js": 345,
		"./fr-ch": 346,
		"./fr-ch.js": 346,
		"./fr.js": 344,
		"./fy": 347,
		"./fy.js": 347,
		"./gd": 348,
		"./gd.js": 348,
		"./gl": 349,
		"./gl.js": 349,
		"./he": 350,
		"./he.js": 350,
		"./hi": 351,
		"./hi.js": 351,
		"./hr": 352,
		"./hr.js": 352,
		"./hu": 353,
		"./hu.js": 353,
		"./hy-am": 354,
		"./hy-am.js": 354,
		"./id": 355,
		"./id.js": 355,
		"./is": 356,
		"./is.js": 356,
		"./it": 357,
		"./it.js": 357,
		"./ja": 358,
		"./ja.js": 358,
		"./jv": 359,
		"./jv.js": 359,
		"./ka": 360,
		"./ka.js": 360,
		"./kk": 361,
		"./kk.js": 361,
		"./km": 362,
		"./km.js": 362,
		"./ko": 363,
		"./ko.js": 363,
		"./ky": 364,
		"./ky.js": 364,
		"./lb": 365,
		"./lb.js": 365,
		"./lo": 366,
		"./lo.js": 366,
		"./lt": 367,
		"./lt.js": 367,
		"./lv": 368,
		"./lv.js": 368,
		"./me": 369,
		"./me.js": 369,
		"./mi": 370,
		"./mi.js": 370,
		"./mk": 371,
		"./mk.js": 371,
		"./ml": 372,
		"./ml.js": 372,
		"./mr": 373,
		"./mr.js": 373,
		"./ms": 374,
		"./ms-my": 375,
		"./ms-my.js": 375,
		"./ms.js": 374,
		"./my": 376,
		"./my.js": 376,
		"./nb": 377,
		"./nb.js": 377,
		"./ne": 378,
		"./ne.js": 378,
		"./nl": 379,
		"./nl-be": 380,
		"./nl-be.js": 380,
		"./nl.js": 379,
		"./nn": 381,
		"./nn.js": 381,
		"./pa-in": 382,
		"./pa-in.js": 382,
		"./pl": 383,
		"./pl.js": 383,
		"./pt": 384,
		"./pt-br": 385,
		"./pt-br.js": 385,
		"./pt.js": 384,
		"./ro": 386,
		"./ro.js": 386,
		"./ru": 387,
		"./ru.js": 387,
		"./se": 388,
		"./se.js": 388,
		"./si": 389,
		"./si.js": 389,
		"./sk": 390,
		"./sk.js": 390,
		"./sl": 391,
		"./sl.js": 391,
		"./sq": 392,
		"./sq.js": 392,
		"./sr": 393,
		"./sr-cyrl": 394,
		"./sr-cyrl.js": 394,
		"./sr.js": 393,
		"./ss": 395,
		"./ss.js": 395,
		"./sv": 396,
		"./sv.js": 396,
		"./sw": 397,
		"./sw.js": 397,
		"./ta": 398,
		"./ta.js": 398,
		"./te": 399,
		"./te.js": 399,
		"./tet": 400,
		"./tet.js": 400,
		"./th": 401,
		"./th.js": 401,
		"./tl-ph": 402,
		"./tl-ph.js": 402,
		"./tlh": 403,
		"./tlh.js": 403,
		"./tr": 404,
		"./tr.js": 404,
		"./tzl": 405,
		"./tzl.js": 405,
		"./tzm": 406,
		"./tzm-latn": 407,
		"./tzm-latn.js": 407,
		"./tzm.js": 406,
		"./uk": 408,
		"./uk.js": 408,
		"./uz": 409,
		"./uz.js": 409,
		"./vi": 410,
		"./vi.js": 410,
		"./x-pseudo": 411,
		"./x-pseudo.js": 411,
		"./yo": 412,
		"./yo.js": 412,
		"./zh-cn": 413,
		"./zh-cn.js": 413,
		"./zh-hk": 414,
		"./zh-hk.js": 414,
		"./zh-tw": 415,
		"./zh-tw.js": 415
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 307;


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Afrikaans [af]
	//! author : Werner Mollentze : https://github.com/wernerm

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var af = moment.defineLocale('af', {
	    months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
	    weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
	    weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
	    meridiemParse: /vm|nm/i,
	    isPM : function (input) {
	        return /^nm$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower ? 'vm' : 'VM';
	        } else {
	            return isLower ? 'nm' : 'NM';
	        }
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Vandag om] LT',
	        nextDay : '[Môre om] LT',
	        nextWeek : 'dddd [om] LT',
	        lastDay : '[Gister om] LT',
	        lastWeek : '[Laas] dddd [om] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'oor %s',
	        past : '%s gelede',
	        s : '\'n paar sekondes',
	        m : '\'n minuut',
	        mm : '%d minute',
	        h : '\'n uur',
	        hh : '%d ure',
	        d : '\'n dag',
	        dd : '%d dae',
	        M : '\'n maand',
	        MM : '%d maande',
	        y : '\'n jaar',
	        yy : '%d jaar'
	    },
	    ordinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Röling : https://github.com/jjupiter
	    },
	    week : {
	        dow : 1, // Maandag is die eerste dag van die week.
	        doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	    }
	});

	return af;

	})));


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic [ar]
	//! author : Abdel Said: https://github.com/abdelsaid
	//! author : Ahmed Elkhatib
	//! author : forabi https://github.com/forabi

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '١',
	    '2': '٢',
	    '3': '٣',
	    '4': '٤',
	    '5': '٥',
	    '6': '٦',
	    '7': '٧',
	    '8': '٨',
	    '9': '٩',
	    '0': '٠'
	};
	var numberMap = {
	    '١': '1',
	    '٢': '2',
	    '٣': '3',
	    '٤': '4',
	    '٥': '5',
	    '٦': '6',
	    '٧': '7',
	    '٨': '8',
	    '٩': '9',
	    '٠': '0'
	};
	var pluralForm = function (n) {
	    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	};
	var plurals = {
	    s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
	    m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
	    h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
	    d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
	    M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
	    y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
	};
	var pluralize = function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f = pluralForm(number),
	            str = plurals[u][pluralForm(number)];
	        if (f === 2) {
	            str = str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	};
	var months = [
	    'كانون الثاني يناير',
	    'شباط فبراير',
	    'آذار مارس',
	    'نيسان أبريل',
	    'أيار مايو',
	    'حزيران يونيو',
	    'تموز يوليو',
	    'آب أغسطس',
	    'أيلول سبتمبر',
	    'تشرين الأول أكتوبر',
	    'تشرين الثاني نوفمبر',
	    'كانون الأول ديسمبر'
	];

	var ar = moment.defineLocale('ar', {
	    months : months,
	    monthsShort : months,
	    weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	    weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/\u200FM/\u200FYYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /ص|م/,
	    isPM : function (input) {
	        return 'م' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'ص';
	        } else {
	            return 'م';
	        }
	    },
	    calendar : {
	        sameDay: '[اليوم عند الساعة] LT',
	        nextDay: '[غدًا عند الساعة] LT',
	        nextWeek: 'dddd [عند الساعة] LT',
	        lastDay: '[أمس عند الساعة] LT',
	        lastWeek: 'dddd [عند الساعة] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'بعد %s',
	        past : 'منذ %s',
	        s : pluralize('s'),
	        m : pluralize('m'),
	        mm : pluralize('m'),
	        h : pluralize('h'),
	        hh : pluralize('h'),
	        d : pluralize('d'),
	        dd : pluralize('d'),
	        M : pluralize('M'),
	        MM : pluralize('M'),
	        y : pluralize('y'),
	        yy : pluralize('y')
	    },
	    preparse: function (string) {
	        return string.replace(/\u200f/g, '').replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	            return numberMap[match];
	        }).replace(/،/g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '،');
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ar;

	})));


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Algeria) [ar-dz]
	//! author : Noureddine LOUAHEDJ : https://github.com/noureddineme

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var arDz = moment.defineLocale('ar-dz', {
	    months : 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	    monthsShort : 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	    weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	    weekdaysShort : 'احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
	    weekdaysMin : 'أح_إث_ثلا_أر_خم_جم_سب'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[اليوم على الساعة] LT',
	        nextDay: '[غدا على الساعة] LT',
	        nextWeek: 'dddd [على الساعة] LT',
	        lastDay: '[أمس على الساعة] LT',
	        lastWeek: 'dddd [على الساعة] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'في %s',
	        past : 'منذ %s',
	        s : 'ثوان',
	        m : 'دقيقة',
	        mm : '%d دقائق',
	        h : 'ساعة',
	        hh : '%d ساعات',
	        d : 'يوم',
	        dd : '%d أيام',
	        M : 'شهر',
	        MM : '%d أشهر',
	        y : 'سنة',
	        yy : '%d سنوات'
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 4  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arDz;

	})));


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Lybia) [ar-ly]
	//! author : Ali Hmer: https://github.com/kikoanis

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '1',
	    '2': '2',
	    '3': '3',
	    '4': '4',
	    '5': '5',
	    '6': '6',
	    '7': '7',
	    '8': '8',
	    '9': '9',
	    '0': '0'
	};
	var pluralForm = function (n) {
	    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	};
	var plurals = {
	    s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
	    m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
	    h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
	    d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
	    M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
	    y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
	};
	var pluralize = function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f = pluralForm(number),
	            str = plurals[u][pluralForm(number)];
	        if (f === 2) {
	            str = str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	};
	var months = [
	    'يناير',
	    'فبراير',
	    'مارس',
	    'أبريل',
	    'مايو',
	    'يونيو',
	    'يوليو',
	    'أغسطس',
	    'سبتمبر',
	    'أكتوبر',
	    'نوفمبر',
	    'ديسمبر'
	];

	var arLy = moment.defineLocale('ar-ly', {
	    months : months,
	    monthsShort : months,
	    weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	    weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/\u200FM/\u200FYYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /ص|م/,
	    isPM : function (input) {
	        return 'م' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'ص';
	        } else {
	            return 'م';
	        }
	    },
	    calendar : {
	        sameDay: '[اليوم عند الساعة] LT',
	        nextDay: '[غدًا عند الساعة] LT',
	        nextWeek: 'dddd [عند الساعة] LT',
	        lastDay: '[أمس عند الساعة] LT',
	        lastWeek: 'dddd [عند الساعة] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'بعد %s',
	        past : 'منذ %s',
	        s : pluralize('s'),
	        m : pluralize('m'),
	        mm : pluralize('m'),
	        h : pluralize('h'),
	        hh : pluralize('h'),
	        d : pluralize('d'),
	        dd : pluralize('d'),
	        M : pluralize('M'),
	        MM : pluralize('M'),
	        y : pluralize('y'),
	        yy : pluralize('y')
	    },
	    preparse: function (string) {
	        return string.replace(/\u200f/g, '').replace(/،/g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '،');
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arLy;

	})));


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Morocco) [ar-ma]
	//! author : ElFadili Yassine : https://github.com/ElFadiliY
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var arMa = moment.defineLocale('ar-ma', {
	    months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	    monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	    weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	    weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
	    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[اليوم على الساعة] LT',
	        nextDay: '[غدا على الساعة] LT',
	        nextWeek: 'dddd [على الساعة] LT',
	        lastDay: '[أمس على الساعة] LT',
	        lastWeek: 'dddd [على الساعة] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'في %s',
	        past : 'منذ %s',
	        s : 'ثوان',
	        m : 'دقيقة',
	        mm : '%d دقائق',
	        h : 'ساعة',
	        hh : '%d ساعات',
	        d : 'يوم',
	        dd : '%d أيام',
	        M : 'شهر',
	        MM : '%d أشهر',
	        y : 'سنة',
	        yy : '%d سنوات'
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arMa;

	})));


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Saudi Arabia) [ar-sa]
	//! author : Suhail Alkowaileet : https://github.com/xsoh

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '١',
	    '2': '٢',
	    '3': '٣',
	    '4': '٤',
	    '5': '٥',
	    '6': '٦',
	    '7': '٧',
	    '8': '٨',
	    '9': '٩',
	    '0': '٠'
	};
	var numberMap = {
	    '١': '1',
	    '٢': '2',
	    '٣': '3',
	    '٤': '4',
	    '٥': '5',
	    '٦': '6',
	    '٧': '7',
	    '٨': '8',
	    '٩': '9',
	    '٠': '0'
	};

	var arSa = moment.defineLocale('ar-sa', {
	    months : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	    monthsShort : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	    weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	    weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /ص|م/,
	    isPM : function (input) {
	        return 'م' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'ص';
	        } else {
	            return 'م';
	        }
	    },
	    calendar : {
	        sameDay: '[اليوم على الساعة] LT',
	        nextDay: '[غدا على الساعة] LT',
	        nextWeek: 'dddd [على الساعة] LT',
	        lastDay: '[أمس على الساعة] LT',
	        lastWeek: 'dddd [على الساعة] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'في %s',
	        past : 'منذ %s',
	        s : 'ثوان',
	        m : 'دقيقة',
	        mm : '%d دقائق',
	        h : 'ساعة',
	        hh : '%d ساعات',
	        d : 'يوم',
	        dd : '%d أيام',
	        M : 'شهر',
	        MM : '%d أشهر',
	        y : 'سنة',
	        yy : '%d سنوات'
	    },
	    preparse: function (string) {
	        return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	            return numberMap[match];
	        }).replace(/،/g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '،');
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arSa;

	})));


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale  :  Arabic (Tunisia) [ar-tn]
	//! author : Nader Toukabri : https://github.com/naderio

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var arTn = moment.defineLocale('ar-tn', {
	    months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	    monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	    weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	    weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	    weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[اليوم على الساعة] LT',
	        nextDay: '[غدا على الساعة] LT',
	        nextWeek: 'dddd [على الساعة] LT',
	        lastDay: '[أمس على الساعة] LT',
	        lastWeek: 'dddd [على الساعة] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'في %s',
	        past: 'منذ %s',
	        s: 'ثوان',
	        m: 'دقيقة',
	        mm: '%d دقائق',
	        h: 'ساعة',
	        hh: '%d ساعات',
	        d: 'يوم',
	        dd: '%d أيام',
	        M: 'شهر',
	        MM: '%d أشهر',
	        y: 'سنة',
	        yy: '%d سنوات'
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return arTn;

	})));


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Azerbaijani [az]
	//! author : topchiyev : https://github.com/topchiyev

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var suffixes = {
	    1: '-inci',
	    5: '-inci',
	    8: '-inci',
	    70: '-inci',
	    80: '-inci',
	    2: '-nci',
	    7: '-nci',
	    20: '-nci',
	    50: '-nci',
	    3: '-üncü',
	    4: '-üncü',
	    100: '-üncü',
	    6: '-ncı',
	    9: '-uncu',
	    10: '-uncu',
	    30: '-uncu',
	    60: '-ıncı',
	    90: '-ıncı'
	};

	var az = moment.defineLocale('az', {
	    months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
	    monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
	    weekdays : 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
	    weekdaysShort : 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
	    weekdaysMin : 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[bugün saat] LT',
	        nextDay : '[sabah saat] LT',
	        nextWeek : '[gələn həftə] dddd [saat] LT',
	        lastDay : '[dünən] LT',
	        lastWeek : '[keçən həftə] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s sonra',
	        past : '%s əvvəl',
	        s : 'birneçə saniyyə',
	        m : 'bir dəqiqə',
	        mm : '%d dəqiqə',
	        h : 'bir saat',
	        hh : '%d saat',
	        d : 'bir gün',
	        dd : '%d gün',
	        M : 'bir ay',
	        MM : '%d ay',
	        y : 'bir il',
	        yy : '%d il'
	    },
	    meridiemParse: /gecə|səhər|gündüz|axşam/,
	    isPM : function (input) {
	        return /^(gündüz|axşam)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'gecə';
	        } else if (hour < 12) {
	            return 'səhər';
	        } else if (hour < 17) {
	            return 'gündüz';
	        } else {
	            return 'axşam';
	        }
	    },
	    ordinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
	    ordinal : function (number) {
	        if (number === 0) {  // special case for zero
	            return number + '-ıncı';
	        }
	        var a = number % 10,
	            b = number % 100 - a,
	            c = number >= 100 ? 100 : null;
	        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return az;

	})));


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Belarusian [be]
	//! author : Dmitry Demidov : https://github.com/demidov91
	//! author: Praleska: http://praleska.pro/
	//! Author : Menelion Elensúle : https://github.com/Oire

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
	        'hh': withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
	        'dd': 'дзень_дні_дзён',
	        'MM': 'месяц_месяцы_месяцаў',
	        'yy': 'год_гады_гадоў'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? 'хвіліна' : 'хвіліну';
	    }
	    else if (key === 'h') {
	        return withoutSuffix ? 'гадзіна' : 'гадзіну';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}

	var be = moment.defineLocale('be', {
	    months : {
	        format: 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split('_'),
	        standalone: 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split('_')
	    },
	    monthsShort : 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
	    weekdays : {
	        format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_'),
	        standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
	        isFormat: /\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/
	    },
	    weekdaysShort : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	    weekdaysMin : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY г.',
	        LLL : 'D MMMM YYYY г., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY г., HH:mm'
	    },
	    calendar : {
	        sameDay: '[Сёння ў] LT',
	        nextDay: '[Заўтра ў] LT',
	        lastDay: '[Учора ў] LT',
	        nextWeek: function () {
	            return '[У] dddd [ў] LT';
	        },
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return '[У мінулую] dddd [ў] LT';
	                case 1:
	                case 2:
	                case 4:
	                    return '[У мінулы] dddd [ў] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'праз %s',
	        past : '%s таму',
	        s : 'некалькі секунд',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithPlural,
	        hh : relativeTimeWithPlural,
	        d : 'дзень',
	        dd : relativeTimeWithPlural,
	        M : 'месяц',
	        MM : relativeTimeWithPlural,
	        y : 'год',
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /ночы|раніцы|дня|вечара/,
	    isPM : function (input) {
	        return /^(дня|вечара)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'ночы';
	        } else if (hour < 12) {
	            return 'раніцы';
	        } else if (hour < 17) {
	            return 'дня';
	        } else {
	            return 'вечара';
	        }
	    },
	    ordinalParse: /\d{1,2}-(і|ы|га)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-і' : number + '-ы';
	            case 'D':
	                return number + '-га';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return be;

	})));


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bulgarian [bg]
	//! author : Krasen Borisov : https://github.com/kraz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var bg = moment.defineLocale('bg', {
	    months : 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
	    monthsShort : 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
	    weekdays : 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
	    weekdaysShort : 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
	    weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'D.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay : '[Днес в] LT',
	        nextDay : '[Утре в] LT',
	        nextWeek : 'dddd [в] LT',
	        lastDay : '[Вчера в] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[В изминалата] dddd [в] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[В изминалия] dddd [в] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'след %s',
	        past : 'преди %s',
	        s : 'няколко секунди',
	        m : 'минута',
	        mm : '%d минути',
	        h : 'час',
	        hh : '%d часа',
	        d : 'ден',
	        dd : '%d дни',
	        M : 'месец',
	        MM : '%d месеца',
	        y : 'година',
	        yy : '%d години'
	    },
	    ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	    ordinal : function (number) {
	        var lastDigit = number % 10,
	            last2Digits = number % 100;
	        if (number === 0) {
	            return number + '-ев';
	        } else if (last2Digits === 0) {
	            return number + '-ен';
	        } else if (last2Digits > 10 && last2Digits < 20) {
	            return number + '-ти';
	        } else if (lastDigit === 1) {
	            return number + '-ви';
	        } else if (lastDigit === 2) {
	            return number + '-ри';
	        } else if (lastDigit === 7 || lastDigit === 8) {
	            return number + '-ми';
	        } else {
	            return number + '-ти';
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bg;

	})));


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bengali [bn]
	//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '১',
	    '2': '২',
	    '3': '৩',
	    '4': '৪',
	    '5': '৫',
	    '6': '৬',
	    '7': '৭',
	    '8': '৮',
	    '9': '৯',
	    '0': '০'
	};
	var numberMap = {
	    '১': '1',
	    '২': '2',
	    '৩': '3',
	    '৪': '4',
	    '৫': '5',
	    '৬': '6',
	    '৭': '7',
	    '৮': '8',
	    '৯': '9',
	    '০': '0'
	};

	var bn = moment.defineLocale('bn', {
	    months : 'জানুয়ারী_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
	    monthsShort : 'জানু_ফেব_মার্চ_এপ্র_মে_জুন_জুল_আগ_সেপ্ট_অক্টো_নভে_ডিসে'.split('_'),
	    weekdays : 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার'.split('_'),
	    weekdaysShort : 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি'.split('_'),
	    weekdaysMin : 'রবি_সোম_মঙ্গ_বুধ_বৃহঃ_শুক্র_শনি'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm সময়',
	        LTS : 'A h:mm:ss সময়',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm সময়',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm সময়'
	    },
	    calendar : {
	        sameDay : '[আজ] LT',
	        nextDay : '[আগামীকাল] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[গতকাল] LT',
	        lastWeek : '[গত] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s পরে',
	        past : '%s আগে',
	        s : 'কয়েক সেকেন্ড',
	        m : 'এক মিনিট',
	        mm : '%d মিনিট',
	        h : 'এক ঘন্টা',
	        hh : '%d ঘন্টা',
	        d : 'এক দিন',
	        dd : '%d দিন',
	        M : 'এক মাস',
	        MM : '%d মাস',
	        y : 'এক বছর',
	        yy : '%d বছর'
	    },
	    preparse: function (string) {
	        return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === 'রাত' && hour >= 4) ||
	                (meridiem === 'দুপুর' && hour < 5) ||
	                meridiem === 'বিকাল') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'রাত';
	        } else if (hour < 10) {
	            return 'সকাল';
	        } else if (hour < 17) {
	            return 'দুপুর';
	        } else if (hour < 20) {
	            return 'বিকাল';
	        } else {
	            return 'রাত';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bn;

	})));


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tibetan [bo]
	//! author : Thupten N. Chakrishar : https://github.com/vajradog

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '༡',
	    '2': '༢',
	    '3': '༣',
	    '4': '༤',
	    '5': '༥',
	    '6': '༦',
	    '7': '༧',
	    '8': '༨',
	    '9': '༩',
	    '0': '༠'
	};
	var numberMap = {
	    '༡': '1',
	    '༢': '2',
	    '༣': '3',
	    '༤': '4',
	    '༥': '5',
	    '༦': '6',
	    '༧': '7',
	    '༨': '8',
	    '༩': '9',
	    '༠': '0'
	};

	var bo = moment.defineLocale('bo', {
	    months : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	    monthsShort : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	    weekdays : 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
	    weekdaysShort : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	    weekdaysMin : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm'
	    },
	    calendar : {
	        sameDay : '[དི་རིང] LT',
	        nextDay : '[སང་ཉིན] LT',
	        nextWeek : '[བདུན་ཕྲག་རྗེས་མ], LT',
	        lastDay : '[ཁ་སང] LT',
	        lastWeek : '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ལ་',
	        past : '%s སྔན་ལ',
	        s : 'ལམ་སང',
	        m : 'སྐར་མ་གཅིག',
	        mm : '%d སྐར་མ',
	        h : 'ཆུ་ཚོད་གཅིག',
	        hh : '%d ཆུ་ཚོད',
	        d : 'ཉིན་གཅིག',
	        dd : '%d ཉིན་',
	        M : 'ཟླ་བ་གཅིག',
	        MM : '%d ཟླ་བ',
	        y : 'ལོ་གཅིག',
	        yy : '%d ལོ'
	    },
	    preparse: function (string) {
	        return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === 'མཚན་མོ' && hour >= 4) ||
	                (meridiem === 'ཉིན་གུང' && hour < 5) ||
	                meridiem === 'དགོང་དག') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'མཚན་མོ';
	        } else if (hour < 10) {
	            return 'ཞོགས་ཀས';
	        } else if (hour < 17) {
	            return 'ཉིན་གུང';
	        } else if (hour < 20) {
	            return 'དགོང་དག';
	        } else {
	            return 'མཚན་མོ';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bo;

	})));


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Breton [br]
	//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function relativeTimeWithMutation(number, withoutSuffix, key) {
	    var format = {
	        'mm': 'munutenn',
	        'MM': 'miz',
	        'dd': 'devezh'
	    };
	    return number + ' ' + mutation(format[key], number);
	}
	function specialMutationForYears(number) {
	    switch (lastNumber(number)) {
	        case 1:
	        case 3:
	        case 4:
	        case 5:
	        case 9:
	            return number + ' bloaz';
	        default:
	            return number + ' vloaz';
	    }
	}
	function lastNumber(number) {
	    if (number > 9) {
	        return lastNumber(number % 10);
	    }
	    return number;
	}
	function mutation(text, number) {
	    if (number === 2) {
	        return softMutation(text);
	    }
	    return text;
	}
	function softMutation(text) {
	    var mutationTable = {
	        'm': 'v',
	        'b': 'v',
	        'd': 'z'
	    };
	    if (mutationTable[text.charAt(0)] === undefined) {
	        return text;
	    }
	    return mutationTable[text.charAt(0)] + text.substring(1);
	}

	var br = moment.defineLocale('br', {
	    months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
	    monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
	    weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
	    weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
	    weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h[e]mm A',
	        LTS : 'h[e]mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D [a viz] MMMM YYYY',
	        LLL : 'D [a viz] MMMM YYYY h[e]mm A',
	        LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
	    },
	    calendar : {
	        sameDay : '[Hiziv da] LT',
	        nextDay : '[Warc\'hoazh da] LT',
	        nextWeek : 'dddd [da] LT',
	        lastDay : '[Dec\'h da] LT',
	        lastWeek : 'dddd [paset da] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'a-benn %s',
	        past : '%s \'zo',
	        s : 'un nebeud segondennoù',
	        m : 'ur vunutenn',
	        mm : relativeTimeWithMutation,
	        h : 'un eur',
	        hh : '%d eur',
	        d : 'un devezh',
	        dd : relativeTimeWithMutation,
	        M : 'ur miz',
	        MM : relativeTimeWithMutation,
	        y : 'ur bloaz',
	        yy : specialMutationForYears
	    },
	    ordinalParse: /\d{1,2}(añ|vet)/,
	    ordinal : function (number) {
	        var output = (number === 1) ? 'añ' : 'vet';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return br;

	})));


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bosnian [bs]
	//! author : Nedim Cholich : https://github.com/frontyard
	//! based on (hr) translation by Bojan Marković

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	    }
	}

	var bs = moment.defineLocale('bs', {
	    months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	    weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	    weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danas u] LT',
	        nextDay  : '[sutra u] LT',
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[jučer u] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prošlu] dddd [u] LT';
	                case 6:
	                    return '[prošle] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prošli] dddd [u] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'par sekundi',
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : 'dan',
	        dd     : translate,
	        M      : 'mjesec',
	        MM     : translate,
	        y      : 'godinu',
	        yy     : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bs;

	})));


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Catalan [ca]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ca = moment.defineLocale('ca', {
	    months : 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
	    monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
	    weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
	    weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        nextDay : function () {
	            return '[demà a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        lastDay : function () {
	            return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'd\'aquí %s',
	        past : 'fa %s',
	        s : 'uns segons',
	        m : 'un minut',
	        mm : '%d minuts',
	        h : 'una hora',
	        hh : '%d hores',
	        d : 'un dia',
	        dd : '%d dies',
	        M : 'un mes',
	        MM : '%d mesos',
	        y : 'un any',
	        yy : '%d anys'
	    },
	    ordinalParse: /\d{1,2}(r|n|t|è|a)/,
	    ordinal : function (number, period) {
	        var output = (number === 1) ? 'r' :
	            (number === 2) ? 'n' :
	            (number === 3) ? 'r' :
	            (number === 4) ? 't' : 'è';
	        if (period === 'w' || period === 'W') {
	            output = 'a';
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ca;

	})));


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Czech [cs]
	//! author : petrbela : https://github.com/petrbela

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_');
	var monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');
	function plural(n) {
	    return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pár sekund' : 'pár sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minuty' : 'minut');
	            } else {
	                return result + 'minutami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodin');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dny' : 'dní');
	            } else {
	                return result + 'dny';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'měsíc' : 'měsícem';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'měsíce' : 'měsíců');
	            } else {
	                return result + 'měsíci';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'let');
	            } else {
	                return result + 'lety';
	            }
	            break;
	    }
	}

	var cs = moment.defineLocale('cs', {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParse : (function (months, monthsShort) {
	        var i, _monthsParse = [];
	        for (i = 0; i < 12; i++) {
	            // use custom parser to solve problem with July (červenec)
	            _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	        }
	        return _monthsParse;
	    }(months, monthsShort)),
	    shortMonthsParse : (function (monthsShort) {
	        var i, _shortMonthsParse = [];
	        for (i = 0; i < 12; i++) {
	            _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
	        }
	        return _shortMonthsParse;
	    }(monthsShort)),
	    longMonthsParse : (function (months) {
	        var i, _longMonthsParse = [];
	        for (i = 0; i < 12; i++) {
	            _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
	        }
	        return _longMonthsParse;
	    }(months)),
	    weekdays : 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
	    weekdaysShort : 'ne_po_út_st_čt_pá_so'.split('_'),
	    weekdaysMin : 'ne_po_út_st_čt_pá_so'.split('_'),
	    longDateFormat : {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd D. MMMM YYYY H:mm',
	        l : 'D. M. YYYY'
	    },
	    calendar : {
	        sameDay: '[dnes v] LT',
	        nextDay: '[zítra v] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v neděli v] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [v] LT';
	                case 3:
	                    return '[ve středu v] LT';
	                case 4:
	                    return '[ve čtvrtek v] LT';
	                case 5:
	                    return '[v pátek v] LT';
	                case 6:
	                    return '[v sobotu v] LT';
	            }
	        },
	        lastDay: '[včera v] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[minulou neděli v] LT';
	                case 1:
	                case 2:
	                    return '[minulé] dddd [v] LT';
	                case 3:
	                    return '[minulou středu v] LT';
	                case 4:
	                case 5:
	                    return '[minulý] dddd [v] LT';
	                case 6:
	                    return '[minulou sobotu v] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : 'před %s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse : /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return cs;

	})));


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chuvash [cv]
	//! author : Anatoly Mironov : https://github.com/mirontoli

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var cv = moment.defineLocale('cv', {
	    months : 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split('_'),
	    monthsShort : 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
	    weekdays : 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split('_'),
	    weekdaysShort : 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
	    weekdaysMin : 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
	        LLL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
	        LLLL : 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm'
	    },
	    calendar : {
	        sameDay: '[Паян] LT [сехетре]',
	        nextDay: '[Ыран] LT [сехетре]',
	        lastDay: '[Ӗнер] LT [сехетре]',
	        nextWeek: '[Ҫитес] dddd LT [сехетре]',
	        lastWeek: '[Иртнӗ] dddd LT [сехетре]',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : function (output) {
	            var affix = /сехет$/i.exec(output) ? 'рен' : /ҫул$/i.exec(output) ? 'тан' : 'ран';
	            return output + affix;
	        },
	        past : '%s каялла',
	        s : 'пӗр-ик ҫеккунт',
	        m : 'пӗр минут',
	        mm : '%d минут',
	        h : 'пӗр сехет',
	        hh : '%d сехет',
	        d : 'пӗр кун',
	        dd : '%d кун',
	        M : 'пӗр уйӑх',
	        MM : '%d уйӑх',
	        y : 'пӗр ҫул',
	        yy : '%d ҫул'
	    },
	    ordinalParse: /\d{1,2}-мӗш/,
	    ordinal : '%d-мӗш',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return cv;

	})));


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Welsh [cy]
	//! author : Robert Allen : https://github.com/robgallen
	//! author : https://github.com/ryangreaves

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var cy = moment.defineLocale('cy', {
	    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
	    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
	    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
	    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
	    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
	    weekdaysParseExact : true,
	    // time formats are the same as en-gb
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[Heddiw am] LT',
	        nextDay: '[Yfory am] LT',
	        nextWeek: 'dddd [am] LT',
	        lastDay: '[Ddoe am] LT',
	        lastWeek: 'dddd [diwethaf am] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'mewn %s',
	        past: '%s yn ôl',
	        s: 'ychydig eiliadau',
	        m: 'munud',
	        mm: '%d munud',
	        h: 'awr',
	        hh: '%d awr',
	        d: 'diwrnod',
	        dd: '%d diwrnod',
	        M: 'mis',
	        MM: '%d mis',
	        y: 'blwyddyn',
	        yy: '%d flynedd'
	    },
	    ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	    ordinal: function (number) {
	        var b = number,
	            output = '',
	            lookup = [
	                '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
	                'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
	            ];
	        if (b > 20) {
	            if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                output = 'fed'; // not 30ain, 70ain or 90ain
	            } else {
	                output = 'ain';
	            }
	        } else if (b > 0) {
	            output = lookup[b];
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return cy;

	})));


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Danish [da]
	//! author : Ulrik Nielsen : https://github.com/mrbase

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var da = moment.defineLocale('da', {
	    months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	    weekdaysShort : 'søn_man_tir_ons_tor_fre_lør'.split('_'),
	    weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[I dag kl.] LT',
	        nextDay : '[I morgen kl.] LT',
	        nextWeek : 'dddd [kl.] LT',
	        lastDay : '[I går kl.] LT',
	        lastWeek : '[sidste] dddd [kl] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s siden',
	        s : 'få sekunder',
	        m : 'et minut',
	        mm : '%d minutter',
	        h : 'en time',
	        hh : '%d timer',
	        d : 'en dag',
	        dd : '%d dage',
	        M : 'en måned',
	        MM : '%d måneder',
	        y : 'et år',
	        yy : '%d år'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return da;

	})));


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German [de]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensúle: https://github.com/Oire
	//! author : Mikolaj Dadela : https://github.com/mik01aj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eine Minute', 'einer Minute'],
	        'h': ['eine Stunde', 'einer Stunde'],
	        'd': ['ein Tag', 'einem Tag'],
	        'dd': [number + ' Tage', number + ' Tagen'],
	        'M': ['ein Monat', 'einem Monat'],
	        'MM': [number + ' Monate', number + ' Monaten'],
	        'y': ['ein Jahr', 'einem Jahr'],
	        'yy': [number + ' Jahre', number + ' Jahren']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var de = moment.defineLocale('de', {
	    months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd, D. MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[heute um] LT [Uhr]',
	        sameElse: 'L',
	        nextDay: '[morgen um] LT [Uhr]',
	        nextWeek: 'dddd [um] LT [Uhr]',
	        lastDay: '[gestern um] LT [Uhr]',
	        lastWeek: '[letzten] dddd [um] LT [Uhr]'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : 'vor %s',
	        s : 'ein paar Sekunden',
	        m : processRelativeTime,
	        mm : '%d Minuten',
	        h : processRelativeTime,
	        hh : '%d Stunden',
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return de;

	})));


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German (Austria) [de-at]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensúle: https://github.com/Oire
	//! author : Martin Groller : https://github.com/MadMG
	//! author : Mikolaj Dadela : https://github.com/mik01aj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eine Minute', 'einer Minute'],
	        'h': ['eine Stunde', 'einer Stunde'],
	        'd': ['ein Tag', 'einem Tag'],
	        'dd': [number + ' Tage', number + ' Tagen'],
	        'M': ['ein Monat', 'einem Monat'],
	        'MM': [number + ' Monate', number + ' Monaten'],
	        'y': ['ein Jahr', 'einem Jahr'],
	        'yy': [number + ' Jahre', number + ' Jahren']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var deAt = moment.defineLocale('de-at', {
	    months : 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort : 'Jän._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd, D. MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[heute um] LT [Uhr]',
	        sameElse: 'L',
	        nextDay: '[morgen um] LT [Uhr]',
	        nextWeek: 'dddd [um] LT [Uhr]',
	        lastDay: '[gestern um] LT [Uhr]',
	        lastWeek: '[letzten] dddd [um] LT [Uhr]'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : 'vor %s',
	        s : 'ein paar Sekunden',
	        m : processRelativeTime,
	        mm : '%d Minuten',
	        h : processRelativeTime,
	        hh : '%d Stunden',
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return deAt;

	})));


/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maldivian [dv]
	//! author : Jawish Hameed : https://github.com/jawish

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = [
	    'ޖެނުއަރީ',
	    'ފެބްރުއަރީ',
	    'މާރިޗު',
	    'އޭޕްރީލު',
	    'މޭ',
	    'ޖޫން',
	    'ޖުލައި',
	    'އޯގަސްޓު',
	    'ސެޕްޓެމްބަރު',
	    'އޮކްޓޯބަރު',
	    'ނޮވެމްބަރު',
	    'ޑިސެމްބަރު'
	];
	var weekdays = [
	    'އާދިއްތަ',
	    'ހޯމަ',
	    'އަންގާރަ',
	    'ބުދަ',
	    'ބުރާސްފަތި',
	    'ހުކުރު',
	    'ހޮނިހިރު'
	];

	var dv = moment.defineLocale('dv', {
	    months : months,
	    monthsShort : months,
	    weekdays : weekdays,
	    weekdaysShort : weekdays,
	    weekdaysMin : 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
	    longDateFormat : {

	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/M/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /މކ|މފ/,
	    isPM : function (input) {
	        return 'މފ' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'މކ';
	        } else {
	            return 'މފ';
	        }
	    },
	    calendar : {
	        sameDay : '[މިއަދު] LT',
	        nextDay : '[މާދަމާ] LT',
	        nextWeek : 'dddd LT',
	        lastDay : '[އިއްޔެ] LT',
	        lastWeek : '[ފާއިތުވި] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ތެރޭގައި %s',
	        past : 'ކުރިން %s',
	        s : 'ސިކުންތުކޮޅެއް',
	        m : 'މިނިޓެއް',
	        mm : 'މިނިޓު %d',
	        h : 'ގަޑިއިރެއް',
	        hh : 'ގަޑިއިރު %d',
	        d : 'ދުވަހެއް',
	        dd : 'ދުވަސް %d',
	        M : 'މަހެއް',
	        MM : 'މަސް %d',
	        y : 'އަހަރެއް',
	        yy : 'އަހަރު %d'
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, '،');
	    },
	    week : {
	        dow : 7,  // Sunday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return dv;

	})));


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Greek [el]
	//! author : Aggelos Karalias : https://github.com/mehiel

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';

	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	}


	var el = moment.defineLocale('el', {
	    monthsNominativeEl : 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
	    monthsGenitiveEl : 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
	    months : function (momentToFormat, format) {
	        if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
	            return this._monthsGenitiveEl[momentToFormat.month()];
	        } else {
	            return this._monthsNominativeEl[momentToFormat.month()];
	        }
	    },
	    monthsShort : 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
	    weekdays : 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
	    weekdaysShort : 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
	    weekdaysMin : 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'μμ' : 'ΜΜ';
	        } else {
	            return isLower ? 'πμ' : 'ΠΜ';
	        }
	    },
	    isPM : function (input) {
	        return ((input + '').toLowerCase()[0] === 'μ');
	    },
	    meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendarEl : {
	        sameDay : '[Σήμερα {}] LT',
	        nextDay : '[Αύριο {}] LT',
	        nextWeek : 'dddd [{}] LT',
	        lastDay : '[Χθες {}] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 6:
	                    return '[το προηγούμενο] dddd [{}] LT';
	                default:
	                    return '[την προηγούμενη] dddd [{}] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    calendar : function (key, mom) {
	        var output = this._calendarEl[key],
	            hours = mom && mom.hours();
	        if (isFunction(output)) {
	            output = output.apply(mom);
	        }
	        return output.replace('{}', (hours % 12 === 1 ? 'στη' : 'στις'));
	    },
	    relativeTime : {
	        future : 'σε %s',
	        past : '%s πριν',
	        s : 'λίγα δευτερόλεπτα',
	        m : 'ένα λεπτό',
	        mm : '%d λεπτά',
	        h : 'μία ώρα',
	        hh : '%d ώρες',
	        d : 'μία μέρα',
	        dd : '%d μέρες',
	        M : 'ένας μήνας',
	        MM : '%d μήνες',
	        y : 'ένας χρόνος',
	        yy : '%d χρόνια'
	    },
	    ordinalParse: /\d{1,2}η/,
	    ordinal: '%dη',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4st is the first week of the year.
	    }
	});

	return el;

	})));


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Australia) [en-au]
	//! author : Jared Morse : https://github.com/jarcoal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enAu = moment.defineLocale('en-au', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enAu;

	})));


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Canada) [en-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enCa = moment.defineLocale('en-ca', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'YYYY-MM-DD',
	        LL : 'MMMM D, YYYY',
	        LLL : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    }
	});

	return enCa;

	})));


/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (United Kingdom) [en-gb]
	//! author : Chris Gedrim : https://github.com/chrisgedrim

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enGb = moment.defineLocale('en-gb', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enGb;

	})));


/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Ireland) [en-ie]
	//! author : Chris Cartlidge : https://github.com/chriscartlidge

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enIe = moment.defineLocale('en-ie', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enIe;

	})));


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (New Zealand) [en-nz]
	//! author : Luke McGregor : https://github.com/lukemcgregor

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enNz = moment.defineLocale('en-nz', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enNz;

	})));


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Esperanto [eo]
	//! author : Colin Dean : https://github.com/colindean
	//! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
	//!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var eo = moment.defineLocale('eo', {
	    months : 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
	    weekdays : 'Dimanĉo_Lundo_Mardo_Merkredo_Ĵaŭdo_Vendredo_Sabato'.split('_'),
	    weekdaysShort : 'Dim_Lun_Mard_Merk_Ĵaŭ_Ven_Sab'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Ĵa_Ve_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D[-an de] MMMM, YYYY',
	        LLL : 'D[-an de] MMMM, YYYY HH:mm',
	        LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
	    },
	    meridiemParse: /[ap]\.t\.m/i,
	    isPM: function (input) {
	        return input.charAt(0).toLowerCase() === 'p';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'p.t.m.' : 'P.T.M.';
	        } else {
	            return isLower ? 'a.t.m.' : 'A.T.M.';
	        }
	    },
	    calendar : {
	        sameDay : '[Hodiaŭ je] LT',
	        nextDay : '[Morgaŭ je] LT',
	        nextWeek : 'dddd [je] LT',
	        lastDay : '[Hieraŭ je] LT',
	        lastWeek : '[pasinta] dddd [je] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'je %s',
	        past : 'antaŭ %s',
	        s : 'sekundoj',
	        m : 'minuto',
	        mm : '%d minutoj',
	        h : 'horo',
	        hh : '%d horoj',
	        d : 'tago',//ne 'diurno', ĉar estas uzita por proksimumo
	        dd : '%d tagoj',
	        M : 'monato',
	        MM : '%d monatoj',
	        y : 'jaro',
	        yy : '%d jaroj'
	    },
	    ordinalParse: /\d{1,2}a/,
	    ordinal : '%da',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return eo;

	})));


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish [es]
	//! author : Julio Napurí : https://github.com/julionc

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
	var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	var es = moment.defineLocale('es', {
	    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY H:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastDay : function () {
	            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'en %s',
	        past : 'hace %s',
	        s : 'unos segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'una hora',
	        hh : '%d horas',
	        d : 'un día',
	        dd : '%d días',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un año',
	        yy : '%d años'
	    },
	    ordinalParse : /\d{1,2}º/,
	    ordinal : '%dº',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return es;

	})));


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish (Dominican Republic) [es-do]

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
	var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	var esDo = moment.defineLocale('es-do', {
	    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY h:mm A',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastDay : function () {
	            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'en %s',
	        past : 'hace %s',
	        s : 'unos segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'una hora',
	        hh : '%d horas',
	        d : 'un día',
	        dd : '%d días',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un año',
	        yy : '%d años'
	    },
	    ordinalParse : /\d{1,2}º/,
	    ordinal : '%dº',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return esDo;

	})));


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Estonian [et]
	//! author : Henry Kehlmann : https://github.com/madhenry
	//! improvements : Illimar Tambek : https://github.com/ragulka

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        's' : ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
	        'm' : ['ühe minuti', 'üks minut'],
	        'mm': [number + ' minuti', number + ' minutit'],
	        'h' : ['ühe tunni', 'tund aega', 'üks tund'],
	        'hh': [number + ' tunni', number + ' tundi'],
	        'd' : ['ühe päeva', 'üks päev'],
	        'M' : ['kuu aja', 'kuu aega', 'üks kuu'],
	        'MM': [number + ' kuu', number + ' kuud'],
	        'y' : ['ühe aasta', 'aasta', 'üks aasta'],
	        'yy': [number + ' aasta', number + ' aastat']
	    };
	    if (withoutSuffix) {
	        return format[key][2] ? format[key][2] : format[key][1];
	    }
	    return isFuture ? format[key][0] : format[key][1];
	}

	var et = moment.defineLocale('et', {
	    months        : 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
	    monthsShort   : 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
	    weekdays      : 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
	    weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
	    weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
	    longDateFormat : {
	        LT   : 'H:mm',
	        LTS : 'H:mm:ss',
	        L    : 'DD.MM.YYYY',
	        LL   : 'D. MMMM YYYY',
	        LLL  : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[Täna,] LT',
	        nextDay  : '[Homme,] LT',
	        nextWeek : '[Järgmine] dddd LT',
	        lastDay  : '[Eile,] LT',
	        lastWeek : '[Eelmine] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s pärast',
	        past   : '%s tagasi',
	        s      : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : '%d päeva',
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return et;

	})));


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Basque [eu]
	//! author : Eneko Illarramendi : https://github.com/eillarra

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var eu = moment.defineLocale('eu', {
	    months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
	    monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
	    weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
	    weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'YYYY[ko] MMMM[ren] D[a]',
	        LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
	        LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
	        l : 'YYYY-M-D',
	        ll : 'YYYY[ko] MMM D[a]',
	        lll : 'YYYY[ko] MMM D[a] HH:mm',
	        llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
	    },
	    calendar : {
	        sameDay : '[gaur] LT[etan]',
	        nextDay : '[bihar] LT[etan]',
	        nextWeek : 'dddd LT[etan]',
	        lastDay : '[atzo] LT[etan]',
	        lastWeek : '[aurreko] dddd LT[etan]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s barru',
	        past : 'duela %s',
	        s : 'segundo batzuk',
	        m : 'minutu bat',
	        mm : '%d minutu',
	        h : 'ordu bat',
	        hh : '%d ordu',
	        d : 'egun bat',
	        dd : '%d egun',
	        M : 'hilabete bat',
	        MM : '%d hilabete',
	        y : 'urte bat',
	        yy : '%d urte'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return eu;

	})));


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Persian [fa]
	//! author : Ebrahim Byagowi : https://github.com/ebraminio

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '۱',
	    '2': '۲',
	    '3': '۳',
	    '4': '۴',
	    '5': '۵',
	    '6': '۶',
	    '7': '۷',
	    '8': '۸',
	    '9': '۹',
	    '0': '۰'
	};
	var numberMap = {
	    '۱': '1',
	    '۲': '2',
	    '۳': '3',
	    '۴': '4',
	    '۵': '5',
	    '۶': '6',
	    '۷': '7',
	    '۸': '8',
	    '۹': '9',
	    '۰': '0'
	};

	var fa = moment.defineLocale('fa', {
	    months : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	    monthsShort : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	    weekdays : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	    weekdaysShort : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	    weekdaysMin : 'ی_د_س_چ_پ_ج_ش'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /قبل از ظهر|بعد از ظهر/,
	    isPM: function (input) {
	        return /بعد از ظهر/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'قبل از ظهر';
	        } else {
	            return 'بعد از ظهر';
	        }
	    },
	    calendar : {
	        sameDay : '[امروز ساعت] LT',
	        nextDay : '[فردا ساعت] LT',
	        nextWeek : 'dddd [ساعت] LT',
	        lastDay : '[دیروز ساعت] LT',
	        lastWeek : 'dddd [پیش] [ساعت] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'در %s',
	        past : '%s پیش',
	        s : 'چندین ثانیه',
	        m : 'یک دقیقه',
	        mm : '%d دقیقه',
	        h : 'یک ساعت',
	        hh : '%d ساعت',
	        d : 'یک روز',
	        dd : '%d روز',
	        M : 'یک ماه',
	        MM : '%d ماه',
	        y : 'یک سال',
	        yy : '%d سال'
	    },
	    preparse: function (string) {
	        return string.replace(/[۰-۹]/g, function (match) {
	            return numberMap[match];
	        }).replace(/،/g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '،');
	    },
	    ordinalParse: /\d{1,2}م/,
	    ordinal : '%dم',
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return fa;

	})));


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Finnish [fi]
	//! author : Tarmo Aidantausta : https://github.com/bleadof

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' ');
	var numbersFuture = [
	        'nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden',
	        numbersPast[7], numbersPast[8], numbersPast[9]
	    ];
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = '';
	    switch (key) {
	        case 's':
	            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
	        case 'm':
	            return isFuture ? 'minuutin' : 'minuutti';
	        case 'mm':
	            result = isFuture ? 'minuutin' : 'minuuttia';
	            break;
	        case 'h':
	            return isFuture ? 'tunnin' : 'tunti';
	        case 'hh':
	            result = isFuture ? 'tunnin' : 'tuntia';
	            break;
	        case 'd':
	            return isFuture ? 'päivän' : 'päivä';
	        case 'dd':
	            result = isFuture ? 'päivän' : 'päivää';
	            break;
	        case 'M':
	            return isFuture ? 'kuukauden' : 'kuukausi';
	        case 'MM':
	            result = isFuture ? 'kuukauden' : 'kuukautta';
	            break;
	        case 'y':
	            return isFuture ? 'vuoden' : 'vuosi';
	        case 'yy':
	            result = isFuture ? 'vuoden' : 'vuotta';
	            break;
	    }
	    result = verbalNumber(number, isFuture) + ' ' + result;
	    return result;
	}
	function verbalNumber(number, isFuture) {
	    return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	}

	var fi = moment.defineLocale('fi', {
	    months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
	    monthsShort : 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
	    weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
	    weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
	    weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD.MM.YYYY',
	        LL : 'Do MMMM[ta] YYYY',
	        LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
	        LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
	        l : 'D.M.YYYY',
	        ll : 'Do MMM YYYY',
	        lll : 'Do MMM YYYY, [klo] HH.mm',
	        llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
	    },
	    calendar : {
	        sameDay : '[tänään] [klo] LT',
	        nextDay : '[huomenna] [klo] LT',
	        nextWeek : 'dddd [klo] LT',
	        lastDay : '[eilen] [klo] LT',
	        lastWeek : '[viime] dddd[na] [klo] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s päästä',
	        past : '%s sitten',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fi;

	})));


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Faroese [fo]
	//! author : Ragnar Johannesen : https://github.com/ragnar123

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var fo = moment.defineLocale('fo', {
	    months : 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	    weekdays : 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
	    weekdaysShort : 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
	    weekdaysMin : 'su_má_tý_mi_hó_fr_le'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D. MMMM, YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Í dag kl.] LT',
	        nextDay : '[Í morgin kl.] LT',
	        nextWeek : 'dddd [kl.] LT',
	        lastDay : '[Í gjár kl.] LT',
	        lastWeek : '[síðstu] dddd [kl] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'um %s',
	        past : '%s síðani',
	        s : 'fá sekund',
	        m : 'ein minutt',
	        mm : '%d minuttir',
	        h : 'ein tími',
	        hh : '%d tímar',
	        d : 'ein dagur',
	        dd : '%d dagar',
	        M : 'ein mánaði',
	        MM : '%d mánaðir',
	        y : 'eitt ár',
	        yy : '%d ár'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fo;

	})));


/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French [fr]
	//! author : John Fischer : https://github.com/jfroffice

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var fr = moment.defineLocale('fr', {
	    months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	    monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Aujourd\'hui à] LT',
	        nextDay: '[Demain à] LT',
	        nextWeek: 'dddd [à] LT',
	        lastDay: '[Hier à] LT',
	        lastWeek: 'dddd [dernier à] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    ordinalParse: /\d{1,2}(er|)/,
	    ordinal : function (number) {
	        return number + (number === 1 ? 'er' : '');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fr;

	})));


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Canada) [fr-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var frCa = moment.defineLocale('fr-ca', {
	    months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	    monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Aujourd\'hui à] LT',
	        nextDay: '[Demain à] LT',
	        nextWeek: 'dddd [à] LT',
	        lastDay: '[Hier à] LT',
	        lastWeek: 'dddd [dernier à] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    ordinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number) {
	        return number + (number === 1 ? 'er' : 'e');
	    }
	});

	return frCa;

	})));


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Switzerland) [fr-ch]
	//! author : Gaspard Bucher : https://github.com/gaspard

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var frCh = moment.defineLocale('fr-ch', {
	    months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	    monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Aujourd\'hui à] LT',
	        nextDay: '[Demain à] LT',
	        nextWeek: 'dddd [à] LT',
	        lastDay: '[Hier à] LT',
	        lastWeek: 'dddd [dernier à] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    ordinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number) {
	        return number + (number === 1 ? 'er' : 'e');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return frCh;

	})));


/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Frisian [fy]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

	var fy = moment.defineLocale('fy', {
	    months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
	    weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
	    weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[hjoed om] LT',
	        nextDay: '[moarn om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[juster om] LT',
	        lastWeek: '[ôfrûne] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'oer %s',
	        past : '%s lyn',
	        s : 'in pear sekonden',
	        m : 'ien minút',
	        mm : '%d minuten',
	        h : 'ien oere',
	        hh : '%d oeren',
	        d : 'ien dei',
	        dd : '%d dagen',
	        M : 'ien moanne',
	        MM : '%d moannen',
	        y : 'ien jier',
	        yy : '%d jierren'
	    },
	    ordinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fy;

	})));


/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Scottish Gaelic [gd]
	//! author : Jon Ashdown : https://github.com/jonashdown

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = [
	    'Am Faoilleach', 'An Gearran', 'Am Màrt', 'An Giblean', 'An Cèitean', 'An t-Ògmhios', 'An t-Iuchar', 'An Lùnastal', 'An t-Sultain', 'An Dàmhair', 'An t-Samhain', 'An Dùbhlachd'
	];

	var monthsShort = ['Faoi', 'Gear', 'Màrt', 'Gibl', 'Cèit', 'Ògmh', 'Iuch', 'Lùn', 'Sult', 'Dàmh', 'Samh', 'Dùbh'];

	var weekdays = ['Didòmhnaich', 'Diluain', 'Dimàirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

	var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

	var weekdaysMin = ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'];

	var gd = moment.defineLocale('gd', {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParseExact : true,
	    weekdays : weekdays,
	    weekdaysShort : weekdaysShort,
	    weekdaysMin : weekdaysMin,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[An-diugh aig] LT',
	        nextDay : '[A-màireach aig] LT',
	        nextWeek : 'dddd [aig] LT',
	        lastDay : '[An-dè aig] LT',
	        lastWeek : 'dddd [seo chaidh] [aig] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ann an %s',
	        past : 'bho chionn %s',
	        s : 'beagan diogan',
	        m : 'mionaid',
	        mm : '%d mionaidean',
	        h : 'uair',
	        hh : '%d uairean',
	        d : 'latha',
	        dd : '%d latha',
	        M : 'mìos',
	        MM : '%d mìosan',
	        y : 'bliadhna',
	        yy : '%d bliadhna'
	    },
	    ordinalParse : /\d{1,2}(d|na|mh)/,
	    ordinal : function (number) {
	        var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return gd;

	})));


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Galician [gl]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var gl = moment.defineLocale('gl', {
	    months : 'xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
	    monthsShort : 'xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'domingo_luns_martes_mércores_xoves_venres_sábado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mér._xov._ven._sáb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_mé_xo_ve_sá'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY H:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoxe ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	        },
	        nextDay : function () {
	            return '[mañá ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	        },
	        lastDay : function () {
	            return '[onte ' + ((this.hours() !== 1) ? 'á' : 'a') + '] LT';
	        },
	        lastWeek : function () {
	            return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : function (str) {
	            if (str.indexOf('un') === 0) {
	                return 'n' + str;
	            }
	            return 'en ' + str;
	        },
	        past : 'hai %s',
	        s : 'uns segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'unha hora',
	        hh : '%d horas',
	        d : 'un día',
	        dd : '%d días',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un ano',
	        yy : '%d anos'
	    },
	    ordinalParse : /\d{1,2}º/,
	    ordinal : '%dº',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return gl;

	})));


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hebrew [he]
	//! author : Tomer Cohen : https://github.com/tomer
	//! author : Moshe Simantov : https://github.com/DevelopmentIL
	//! author : Tal Ater : https://github.com/TalAter

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var he = moment.defineLocale('he', {
	    months : 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
	    monthsShort : 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
	    weekdays : 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
	    weekdaysShort : 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
	    weekdaysMin : 'א_ב_ג_ד_ה_ו_ש'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [ב]MMMM YYYY',
	        LLL : 'D [ב]MMMM YYYY HH:mm',
	        LLLL : 'dddd, D [ב]MMMM YYYY HH:mm',
	        l : 'D/M/YYYY',
	        ll : 'D MMM YYYY',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd, D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[היום ב־]LT',
	        nextDay : '[מחר ב־]LT',
	        nextWeek : 'dddd [בשעה] LT',
	        lastDay : '[אתמול ב־]LT',
	        lastWeek : '[ביום] dddd [האחרון בשעה] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'בעוד %s',
	        past : 'לפני %s',
	        s : 'מספר שניות',
	        m : 'דקה',
	        mm : '%d דקות',
	        h : 'שעה',
	        hh : function (number) {
	            if (number === 2) {
	                return 'שעתיים';
	            }
	            return number + ' שעות';
	        },
	        d : 'יום',
	        dd : function (number) {
	            if (number === 2) {
	                return 'יומיים';
	            }
	            return number + ' ימים';
	        },
	        M : 'חודש',
	        MM : function (number) {
	            if (number === 2) {
	                return 'חודשיים';
	            }
	            return number + ' חודשים';
	        },
	        y : 'שנה',
	        yy : function (number) {
	            if (number === 2) {
	                return 'שנתיים';
	            } else if (number % 10 === 0 && number !== 10) {
	                return number + ' שנה';
	            }
	            return number + ' שנים';
	        }
	    },
	    meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
	    isPM : function (input) {
	        return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 5) {
	            return 'לפנות בוקר';
	        } else if (hour < 10) {
	            return 'בבוקר';
	        } else if (hour < 12) {
	            return isLower ? 'לפנה"צ' : 'לפני הצהריים';
	        } else if (hour < 18) {
	            return isLower ? 'אחה"צ' : 'אחרי הצהריים';
	        } else {
	            return 'בערב';
	        }
	    }
	});

	return he;

	})));


/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hindi [hi]
	//! author : Mayank Singhal : https://github.com/mayanksinghal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '१',
	    '2': '२',
	    '3': '३',
	    '4': '४',
	    '5': '५',
	    '6': '६',
	    '7': '७',
	    '8': '८',
	    '9': '९',
	    '0': '०'
	};
	var numberMap = {
	    '१': '1',
	    '२': '2',
	    '३': '3',
	    '४': '4',
	    '५': '5',
	    '६': '6',
	    '७': '7',
	    '८': '8',
	    '९': '9',
	    '०': '0'
	};

	var hi = moment.defineLocale('hi', {
	    months : 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
	    monthsShort : 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	    weekdaysShort : 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
	    weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm बजे',
	        LTS : 'A h:mm:ss बजे',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm बजे',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm बजे'
	    },
	    calendar : {
	        sameDay : '[आज] LT',
	        nextDay : '[कल] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[कल] LT',
	        lastWeek : '[पिछले] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s में',
	        past : '%s पहले',
	        s : 'कुछ ही क्षण',
	        m : 'एक मिनट',
	        mm : '%d मिनट',
	        h : 'एक घंटा',
	        hh : '%d घंटे',
	        d : 'एक दिन',
	        dd : '%d दिन',
	        M : 'एक महीने',
	        MM : '%d महीने',
	        y : 'एक वर्ष',
	        yy : '%d वर्ष'
	    },
	    preparse: function (string) {
	        return string.replace(/[१२३४५६७८९०]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
	    meridiemParse: /रात|सुबह|दोपहर|शाम/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'रात') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === 'सुबह') {
	            return hour;
	        } else if (meridiem === 'दोपहर') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === 'शाम') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'रात';
	        } else if (hour < 10) {
	            return 'सुबह';
	        } else if (hour < 17) {
	            return 'दोपहर';
	        } else if (hour < 20) {
	            return 'शाम';
	        } else {
	            return 'रात';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hi;

	})));


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Croatian [hr]
	//! author : Bojan Marković : https://github.com/bmarkovic

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	    }
	}

	var hr = moment.defineLocale('hr', {
	    months : {
	        format: 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
	        standalone: 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
	    },
	    monthsShort : 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	    weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	    weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danas u] LT',
	        nextDay  : '[sutra u] LT',
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[jučer u] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prošlu] dddd [u] LT';
	                case 6:
	                    return '[prošle] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prošli] dddd [u] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'par sekundi',
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : 'dan',
	        dd     : translate,
	        M      : 'mjesec',
	        MM     : translate,
	        y      : 'godinu',
	        yy     : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hr;

	})));


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hungarian [hu]
	//! author : Adam Brunner : https://github.com/adambrunner

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');
	function translate(number, withoutSuffix, key, isFuture) {
	    var num = number,
	        suffix;
	    switch (key) {
	        case 's':
	            return (isFuture || withoutSuffix) ? 'néhány másodperc' : 'néhány másodperce';
	        case 'm':
	            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'mm':
	            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'h':
	            return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
	        case 'hh':
	            return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
	        case 'd':
	            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'dd':
	            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'M':
	            return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	        case 'MM':
	            return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	        case 'y':
	            return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
	        case 'yy':
	            return num + (isFuture || withoutSuffix ? ' év' : ' éve');
	    }
	    return '';
	}
	function week(isFuture) {
	    return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	}

	var hu = moment.defineLocale('hu', {
	    months : 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
	    monthsShort : 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
	    weekdays : 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
	    weekdaysShort : 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
	    weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'YYYY.MM.DD.',
	        LL : 'YYYY. MMMM D.',
	        LLL : 'YYYY. MMMM D. H:mm',
	        LLLL : 'YYYY. MMMM D., dddd H:mm'
	    },
	    meridiemParse: /de|du/i,
	    isPM: function (input) {
	        return input.charAt(1).toLowerCase() === 'u';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower === true ? 'de' : 'DE';
	        } else {
	            return isLower === true ? 'du' : 'DU';
	        }
	    },
	    calendar : {
	        sameDay : '[ma] LT[-kor]',
	        nextDay : '[holnap] LT[-kor]',
	        nextWeek : function () {
	            return week.call(this, true);
	        },
	        lastDay : '[tegnap] LT[-kor]',
	        lastWeek : function () {
	            return week.call(this, false);
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s múlva',
	        past : '%s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return hu;

	})));


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Armenian [hy-am]
	//! author : Armendarabyan : https://github.com/armendarabyan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var hyAm = moment.defineLocale('hy-am', {
	    months : {
	        format: 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split('_'),
	        standalone: 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_')
	    },
	    monthsShort : 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
	    weekdays : 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_'),
	    weekdaysShort : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	    weekdaysMin : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY թ.',
	        LLL : 'D MMMM YYYY թ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY թ., HH:mm'
	    },
	    calendar : {
	        sameDay: '[այսօր] LT',
	        nextDay: '[վաղը] LT',
	        lastDay: '[երեկ] LT',
	        nextWeek: function () {
	            return 'dddd [օրը ժամը] LT';
	        },
	        lastWeek: function () {
	            return '[անցած] dddd [օրը ժամը] LT';
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s հետո',
	        past : '%s առաջ',
	        s : 'մի քանի վայրկյան',
	        m : 'րոպե',
	        mm : '%d րոպե',
	        h : 'ժամ',
	        hh : '%d ժամ',
	        d : 'օր',
	        dd : '%d օր',
	        M : 'ամիս',
	        MM : '%d ամիս',
	        y : 'տարի',
	        yy : '%d տարի'
	    },
	    meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
	    isPM: function (input) {
	        return /^(ցերեկվա|երեկոյան)$/.test(input);
	    },
	    meridiem : function (hour) {
	        if (hour < 4) {
	            return 'գիշերվա';
	        } else if (hour < 12) {
	            return 'առավոտվա';
	        } else if (hour < 17) {
	            return 'ցերեկվա';
	        } else {
	            return 'երեկոյան';
	        }
	    },
	    ordinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'DDD':
	            case 'w':
	            case 'W':
	            case 'DDDo':
	                if (number === 1) {
	                    return number + '-ին';
	                }
	                return number + '-րդ';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hyAm;

	})));


/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Indonesian [id]
	//! author : Mohammad Satrio Utomo : https://github.com/tyok
	//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var id = moment.defineLocale('id', {
	    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
	    weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
	    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|siang|sore|malam/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'siang') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'sore' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'siang';
	        } else if (hours < 19) {
	            return 'sore';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Besok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kemarin pukul] LT',
	        lastWeek : 'dddd [lalu pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lalu',
	        s : 'beberapa detik',
	        m : 'semenit',
	        mm : '%d menit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return id;

	})));


/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Icelandic [is]
	//! author : Hinrik Örn Sigurðsson : https://github.com/hinrik

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function plural(n) {
	    if (n % 100 === 11) {
	        return true;
	    } else if (n % 10 === 1) {
	        return false;
	    }
	    return true;
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum';
	        case 'm':
	            return withoutSuffix ? 'mínúta' : 'mínútu';
	        case 'mm':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum');
	            } else if (withoutSuffix) {
	                return result + 'mínúta';
	            }
	            return result + 'mínútu';
	        case 'hh':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
	            }
	            return result + 'klukkustund';
	        case 'd':
	            if (withoutSuffix) {
	                return 'dagur';
	            }
	            return isFuture ? 'dag' : 'degi';
	        case 'dd':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'dagar';
	                }
	                return result + (isFuture ? 'daga' : 'dögum');
	            } else if (withoutSuffix) {
	                return result + 'dagur';
	            }
	            return result + (isFuture ? 'dag' : 'degi');
	        case 'M':
	            if (withoutSuffix) {
	                return 'mánuður';
	            }
	            return isFuture ? 'mánuð' : 'mánuði';
	        case 'MM':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'mánuðir';
	                }
	                return result + (isFuture ? 'mánuði' : 'mánuðum');
	            } else if (withoutSuffix) {
	                return result + 'mánuður';
	            }
	            return result + (isFuture ? 'mánuð' : 'mánuði');
	        case 'y':
	            return withoutSuffix || isFuture ? 'ár' : 'ári';
	        case 'yy':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
	            }
	            return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
	    }
	}

	var is = moment.defineLocale('is', {
	    months : 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
	    weekdays : 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
	    weekdaysShort : 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
	    weekdaysMin : 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] H:mm',
	        LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
	    },
	    calendar : {
	        sameDay : '[í dag kl.] LT',
	        nextDay : '[á morgun kl.] LT',
	        nextWeek : 'dddd [kl.] LT',
	        lastDay : '[í gær kl.] LT',
	        lastWeek : '[síðasta] dddd [kl.] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'eftir %s',
	        past : 'fyrir %s síðan',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : 'klukkustund',
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return is;

	})));


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Italian [it]
	//! author : Lorenzo : https://github.com/aliem
	//! author: Mattia Larentis: https://github.com/nostalgiaz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var it = moment.defineLocale('it', {
	    months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
	    monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
	    weekdays : 'Domenica_Lunedì_Martedì_Mercoledì_Giovedì_Venerdì_Sabato'.split('_'),
	    weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
	    weekdaysMin : 'Do_Lu_Ma_Me_Gi_Ve_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Oggi alle] LT',
	        nextDay: '[Domani alle] LT',
	        nextWeek: 'dddd [alle] LT',
	        lastDay: '[Ieri alle] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[la scorsa] dddd [alle] LT';
	                default:
	                    return '[lo scorso] dddd [alle] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : function (s) {
	            return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
	        },
	        past : '%s fa',
	        s : 'alcuni secondi',
	        m : 'un minuto',
	        mm : '%d minuti',
	        h : 'un\'ora',
	        hh : '%d ore',
	        d : 'un giorno',
	        dd : '%d giorni',
	        M : 'un mese',
	        MM : '%d mesi',
	        y : 'un anno',
	        yy : '%d anni'
	    },
	    ordinalParse : /\d{1,2}º/,
	    ordinal: '%dº',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return it;

	})));


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Japanese [ja]
	//! author : LI Long : https://github.com/baryon

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ja = moment.defineLocale('ja', {
	    months : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	    weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
	    weekdaysShort : '日_月_火_水_木_金_土'.split('_'),
	    weekdaysMin : '日_月_火_水_木_金_土'.split('_'),
	    longDateFormat : {
	        LT : 'Ah時m分',
	        LTS : 'Ah時m分s秒',
	        L : 'YYYY/MM/DD',
	        LL : 'YYYY年M月D日',
	        LLL : 'YYYY年M月D日Ah時m分',
	        LLLL : 'YYYY年M月D日Ah時m分 dddd'
	    },
	    meridiemParse: /午前|午後/i,
	    isPM : function (input) {
	        return input === '午後';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '午前';
	        } else {
	            return '午後';
	        }
	    },
	    calendar : {
	        sameDay : '[今日] LT',
	        nextDay : '[明日] LT',
	        nextWeek : '[来週]dddd LT',
	        lastDay : '[昨日] LT',
	        lastWeek : '[前週]dddd LT',
	        sameElse : 'L'
	    },
	    ordinalParse : /\d{1,2}日/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '日';
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s後',
	        past : '%s前',
	        s : '数秒',
	        m : '1分',
	        mm : '%d分',
	        h : '1時間',
	        hh : '%d時間',
	        d : '1日',
	        dd : '%d日',
	        M : '1ヶ月',
	        MM : '%dヶ月',
	        y : '1年',
	        yy : '%d年'
	    }
	});

	return ja;

	})));


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Javanese [jv]
	//! author : Rony Lantip : https://github.com/lantip
	//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var jv = moment.defineLocale('jv', {
	    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
	    weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
	    weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
	    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /enjing|siyang|sonten|ndalu/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'enjing') {
	            return hour;
	        } else if (meridiem === 'siyang') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'enjing';
	        } else if (hours < 15) {
	            return 'siyang';
	        } else if (hours < 19) {
	            return 'sonten';
	        } else {
	            return 'ndalu';
	        }
	    },
	    calendar : {
	        sameDay : '[Dinten puniko pukul] LT',
	        nextDay : '[Mbenjang pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kala wingi pukul] LT',
	        lastWeek : 'dddd [kepengker pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'wonten ing %s',
	        past : '%s ingkang kepengker',
	        s : 'sawetawis detik',
	        m : 'setunggal menit',
	        mm : '%d menit',
	        h : 'setunggal jam',
	        hh : '%d jam',
	        d : 'sedinten',
	        dd : '%d dinten',
	        M : 'sewulan',
	        MM : '%d wulan',
	        y : 'setaun',
	        yy : '%d taun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return jv;

	})));


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Georgian [ka]
	//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ka = moment.defineLocale('ka', {
	    months : {
	        standalone: 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split('_'),
	        format: 'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split('_')
	    },
	    monthsShort : 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
	    weekdays : {
	        standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
	        format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_'),
	        isFormat: /(წინა|შემდეგ)/
	    },
	    weekdaysShort : 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
	    weekdaysMin : 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[დღეს] LT[-ზე]',
	        nextDay : '[ხვალ] LT[-ზე]',
	        lastDay : '[გუშინ] LT[-ზე]',
	        nextWeek : '[შემდეგ] dddd LT[-ზე]',
	        lastWeek : '[წინა] dddd LT-ზე',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : function (s) {
	            return (/(წამი|წუთი|საათი|წელი)/).test(s) ?
	                s.replace(/ი$/, 'ში') :
	                s + 'ში';
	        },
	        past : function (s) {
	            if ((/(წამი|წუთი|საათი|დღე|თვე)/).test(s)) {
	                return s.replace(/(ი|ე)$/, 'ის წინ');
	            }
	            if ((/წელი/).test(s)) {
	                return s.replace(/წელი$/, 'წლის წინ');
	            }
	        },
	        s : 'რამდენიმე წამი',
	        m : 'წუთი',
	        mm : '%d წუთი',
	        h : 'საათი',
	        hh : '%d საათი',
	        d : 'დღე',
	        dd : '%d დღე',
	        M : 'თვე',
	        MM : '%d თვე',
	        y : 'წელი',
	        yy : '%d წელი'
	    },
	    ordinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
	    ordinal : function (number) {
	        if (number === 0) {
	            return number;
	        }
	        if (number === 1) {
	            return number + '-ლი';
	        }
	        if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
	            return 'მე-' + number;
	        }
	        return number + '-ე';
	    },
	    week : {
	        dow : 1,
	        doy : 7
	    }
	});

	return ka;

	})));


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kazakh [kk]
	//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var suffixes = {
	    0: '-ші',
	    1: '-ші',
	    2: '-ші',
	    3: '-ші',
	    4: '-ші',
	    5: '-ші',
	    6: '-шы',
	    7: '-ші',
	    8: '-ші',
	    9: '-шы',
	    10: '-шы',
	    20: '-шы',
	    30: '-шы',
	    40: '-шы',
	    50: '-ші',
	    60: '-шы',
	    70: '-ші',
	    80: '-ші',
	    90: '-шы',
	    100: '-ші'
	};

	var kk = moment.defineLocale('kk', {
	    months : 'қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан'.split('_'),
	    monthsShort : 'қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел'.split('_'),
	    weekdays : 'жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі'.split('_'),
	    weekdaysShort : 'жек_дүй_сей_сәр_бей_жұм_сен'.split('_'),
	    weekdaysMin : 'жк_дй_сй_ср_бй_жм_сн'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Бүгін сағат] LT',
	        nextDay : '[Ертең сағат] LT',
	        nextWeek : 'dddd [сағат] LT',
	        lastDay : '[Кеше сағат] LT',
	        lastWeek : '[Өткен аптаның] dddd [сағат] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ішінде',
	        past : '%s бұрын',
	        s : 'бірнеше секунд',
	        m : 'бір минут',
	        mm : '%d минут',
	        h : 'бір сағат',
	        hh : '%d сағат',
	        d : 'бір күн',
	        dd : '%d күн',
	        M : 'бір ай',
	        MM : '%d ай',
	        y : 'бір жыл',
	        yy : '%d жыл'
	    },
	    ordinalParse: /\d{1,2}-(ші|шы)/,
	    ordinal : function (number) {
	        var a = number % 10,
	            b = number >= 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return kk;

	})));


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Cambodian [km]
	//! author : Kruy Vanna : https://github.com/kruyvanna

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var km = moment.defineLocale('km', {
	    months: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	    monthsShort: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	    weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	    weekdaysShort: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	    weekdaysMin: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
	        nextDay: '[ស្អែក ម៉ោង] LT',
	        nextWeek: 'dddd [ម៉ោង] LT',
	        lastDay: '[ម្សិលមិញ ម៉ោង] LT',
	        lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: '%sទៀត',
	        past: '%sមុន',
	        s: 'ប៉ុន្មានវិនាទី',
	        m: 'មួយនាទី',
	        mm: '%d នាទី',
	        h: 'មួយម៉ោង',
	        hh: '%d ម៉ោង',
	        d: 'មួយថ្ងៃ',
	        dd: '%d ថ្ងៃ',
	        M: 'មួយខែ',
	        MM: '%d ខែ',
	        y: 'មួយឆ្នាំ',
	        yy: '%d ឆ្នាំ'
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return km;

	})));


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Korean [ko]
	//! author : Kyungwook, Park : https://github.com/kyungw00k
	//! author : Jeeeyul Lee <jeeeyul@gmail.com>

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ko = moment.defineLocale('ko', {
	    months : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	    monthsShort : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	    weekdays : '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
	    weekdaysShort : '일_월_화_수_목_금_토'.split('_'),
	    weekdaysMin : '일_월_화_수_목_금_토'.split('_'),
	    longDateFormat : {
	        LT : 'A h시 m분',
	        LTS : 'A h시 m분 s초',
	        L : 'YYYY.MM.DD',
	        LL : 'YYYY년 MMMM D일',
	        LLL : 'YYYY년 MMMM D일 A h시 m분',
	        LLLL : 'YYYY년 MMMM D일 dddd A h시 m분'
	    },
	    calendar : {
	        sameDay : '오늘 LT',
	        nextDay : '내일 LT',
	        nextWeek : 'dddd LT',
	        lastDay : '어제 LT',
	        lastWeek : '지난주 dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s 후',
	        past : '%s 전',
	        s : '몇 초',
	        ss : '%d초',
	        m : '일분',
	        mm : '%d분',
	        h : '한 시간',
	        hh : '%d시간',
	        d : '하루',
	        dd : '%d일',
	        M : '한 달',
	        MM : '%d달',
	        y : '일 년',
	        yy : '%d년'
	    },
	    ordinalParse : /\d{1,2}일/,
	    ordinal : '%d일',
	    meridiemParse : /오전|오후/,
	    isPM : function (token) {
	        return token === '오후';
	    },
	    meridiem : function (hour, minute, isUpper) {
	        return hour < 12 ? '오전' : '오후';
	    }
	});

	return ko;

	})));


/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kyrgyz [ky]
	//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';



	var suffixes = {
	    0: '-чү',
	    1: '-чи',
	    2: '-чи',
	    3: '-чү',
	    4: '-чү',
	    5: '-чи',
	    6: '-чы',
	    7: '-чи',
	    8: '-чи',
	    9: '-чу',
	    10: '-чу',
	    20: '-чы',
	    30: '-чу',
	    40: '-чы',
	    50: '-чү',
	    60: '-чы',
	    70: '-чи',
	    80: '-чи',
	    90: '-чу',
	    100: '-чү'
	};

	var ky = moment.defineLocale('ky', {
	    months : 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
	    monthsShort : 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
	    weekdays : 'Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби'.split('_'),
	    weekdaysShort : 'Жек_Дүй_Шей_Шар_Бей_Жум_Ише'.split('_'),
	    weekdaysMin : 'Жк_Дй_Шй_Шр_Бй_Жм_Иш'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Бүгүн саат] LT',
	        nextDay : '[Эртең саат] LT',
	        nextWeek : 'dddd [саат] LT',
	        lastDay : '[Кече саат] LT',
	        lastWeek : '[Өткен аптанын] dddd [күнү] [саат] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ичинде',
	        past : '%s мурун',
	        s : 'бирнече секунд',
	        m : 'бир мүнөт',
	        mm : '%d мүнөт',
	        h : 'бир саат',
	        hh : '%d саат',
	        d : 'бир күн',
	        dd : '%d күн',
	        M : 'бир ай',
	        MM : '%d ай',
	        y : 'бир жыл',
	        yy : '%d жыл'
	    },
	    ordinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
	    ordinal : function (number) {
	        var a = number % 10,
	            b = number >= 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ky;

	})));


/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Luxembourgish [lb]
	//! author : mweimerskirch : https://github.com/mweimerskirch
	//! author : David Raison : https://github.com/kwisatz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eng Minutt', 'enger Minutt'],
	        'h': ['eng Stonn', 'enger Stonn'],
	        'd': ['een Dag', 'engem Dag'],
	        'M': ['ee Mount', 'engem Mount'],
	        'y': ['ee Joer', 'engem Joer']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}
	function processFutureTime(string) {
	    var number = string.substr(0, string.indexOf(' '));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return 'a ' + string;
	    }
	    return 'an ' + string;
	}
	function processPastTime(string) {
	    var number = string.substr(0, string.indexOf(' '));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return 'viru ' + string;
	    }
	    return 'virun ' + string;
	}
	/**
	 * Returns true if the word before the given number loses the '-n' ending.
	 * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	 *
	 * @param number {integer}
	 * @returns {boolean}
	 */
	function eifelerRegelAppliesToNumber(number) {
	    number = parseInt(number, 10);
	    if (isNaN(number)) {
	        return false;
	    }
	    if (number < 0) {
	        // Negative Number --> always true
	        return true;
	    } else if (number < 10) {
	        // Only 1 digit
	        if (4 <= number && number <= 7) {
	            return true;
	        }
	        return false;
	    } else if (number < 100) {
	        // 2 digits
	        var lastDigit = number % 10, firstDigit = number / 10;
	        if (lastDigit === 0) {
	            return eifelerRegelAppliesToNumber(firstDigit);
	        }
	        return eifelerRegelAppliesToNumber(lastDigit);
	    } else if (number < 10000) {
	        // 3 or 4 digits --> recursively check first digit
	        while (number >= 10) {
	            number = number / 10;
	        }
	        return eifelerRegelAppliesToNumber(number);
	    } else {
	        // Anything larger than 4 digits: recursively check first n-3 digits
	        number = number / 1000;
	        return eifelerRegelAppliesToNumber(number);
	    }
	}

	var lb = moment.defineLocale('lb', {
	    months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
	    weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
	    weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm [Auer]',
	        LTS: 'H:mm:ss [Auer]',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm [Auer]',
	        LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
	    },
	    calendar: {
	        sameDay: '[Haut um] LT',
	        sameElse: 'L',
	        nextDay: '[Muer um] LT',
	        nextWeek: 'dddd [um] LT',
	        lastDay: '[Gëschter um] LT',
	        lastWeek: function () {
	            // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
	            switch (this.day()) {
	                case 2:
	                case 4:
	                    return '[Leschten] dddd [um] LT';
	                default:
	                    return '[Leschte] dddd [um] LT';
	            }
	        }
	    },
	    relativeTime : {
	        future : processFutureTime,
	        past : processPastTime,
	        s : 'e puer Sekonnen',
	        m : processRelativeTime,
	        mm : '%d Minutten',
	        h : processRelativeTime,
	        hh : '%d Stonnen',
	        d : processRelativeTime,
	        dd : '%d Deeg',
	        M : processRelativeTime,
	        MM : '%d Méint',
	        y : processRelativeTime,
	        yy : '%d Joer'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal: '%d.',
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lb;

	})));


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lao [lo]
	//! author : Ryan Hart : https://github.com/ryanhart2

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var lo = moment.defineLocale('lo', {
	    months : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
	    monthsShort : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
	    weekdays : 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
	    weekdaysShort : 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
	    weekdaysMin : 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'ວັນdddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
	    isPM: function (input) {
	        return input === 'ຕອນແລງ';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'ຕອນເຊົ້າ';
	        } else {
	            return 'ຕອນແລງ';
	        }
	    },
	    calendar : {
	        sameDay : '[ມື້ນີ້ເວລາ] LT',
	        nextDay : '[ມື້ອື່ນເວລາ] LT',
	        nextWeek : '[ວັນ]dddd[ໜ້າເວລາ] LT',
	        lastDay : '[ມື້ວານນີ້ເວລາ] LT',
	        lastWeek : '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ອີກ %s',
	        past : '%sຜ່ານມາ',
	        s : 'ບໍ່ເທົ່າໃດວິນາທີ',
	        m : '1 ນາທີ',
	        mm : '%d ນາທີ',
	        h : '1 ຊົ່ວໂມງ',
	        hh : '%d ຊົ່ວໂມງ',
	        d : '1 ມື້',
	        dd : '%d ມື້',
	        M : '1 ເດືອນ',
	        MM : '%d ເດືອນ',
	        y : '1 ປີ',
	        yy : '%d ປີ'
	    },
	    ordinalParse: /(ທີ່)\d{1,2}/,
	    ordinal : function (number) {
	        return 'ທີ່' + number;
	    }
	});

	return lo;

	})));


/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lithuanian [lt]
	//! author : Mindaugas Mozūras : https://github.com/mmozuras

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var units = {
	    'm' : 'minutė_minutės_minutę',
	    'mm': 'minutės_minučių_minutes',
	    'h' : 'valanda_valandos_valandą',
	    'hh': 'valandos_valandų_valandas',
	    'd' : 'diena_dienos_dieną',
	    'dd': 'dienos_dienų_dienas',
	    'M' : 'mėnuo_mėnesio_mėnesį',
	    'MM': 'mėnesiai_mėnesių_mėnesius',
	    'y' : 'metai_metų_metus',
	    'yy': 'metai_metų_metus'
	};
	function translateSeconds(number, withoutSuffix, key, isFuture) {
	    if (withoutSuffix) {
	        return 'kelios sekundės';
	    } else {
	        return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
	    }
	}
	function translateSingular(number, withoutSuffix, key, isFuture) {
	    return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	}
	function special(number) {
	    return number % 10 === 0 || (number > 10 && number < 20);
	}
	function forms(key) {
	    return units[key].split('_');
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    if (number === 1) {
	        return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	    } else if (withoutSuffix) {
	        return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	    } else {
	        if (isFuture) {
	            return result + forms(key)[1];
	        } else {
	            return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	        }
	    }
	}
	var lt = moment.defineLocale('lt', {
	    months : {
	        format: 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_'),
	        standalone: 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split('_'),
	        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
	    },
	    monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
	    weekdays : {
	        format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split('_'),
	        standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_'),
	        isFormat: /dddd HH:mm/
	    },
	    weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
	    weekdaysMin : 'S_P_A_T_K_Pn_Š'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'YYYY [m.] MMMM D [d.]',
	        LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	        LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
	        l : 'YYYY-MM-DD',
	        ll : 'YYYY [m.] MMMM D [d.]',
	        lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	        llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
	    },
	    calendar : {
	        sameDay : '[Šiandien] LT',
	        nextDay : '[Rytoj] LT',
	        nextWeek : 'dddd LT',
	        lastDay : '[Vakar] LT',
	        lastWeek : '[Praėjusį] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'po %s',
	        past : 'prieš %s',
	        s : translateSeconds,
	        m : translateSingular,
	        mm : translate,
	        h : translateSingular,
	        hh : translate,
	        d : translateSingular,
	        dd : translate,
	        M : translateSingular,
	        MM : translate,
	        y : translateSingular,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}-oji/,
	    ordinal : function (number) {
	        return number + '-oji';
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lt;

	})));


/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Latvian [lv]
	//! author : Kristaps Karlsons : https://github.com/skakri
	//! author : Jānis Elmeris : https://github.com/JanisE

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var units = {
	    'm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
	    'mm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
	    'h': 'stundas_stundām_stunda_stundas'.split('_'),
	    'hh': 'stundas_stundām_stunda_stundas'.split('_'),
	    'd': 'dienas_dienām_diena_dienas'.split('_'),
	    'dd': 'dienas_dienām_diena_dienas'.split('_'),
	    'M': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
	    'MM': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
	    'y': 'gada_gadiem_gads_gadi'.split('_'),
	    'yy': 'gada_gadiem_gads_gadi'.split('_')
	};
	/**
	 * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
	 */
	function format(forms, number, withoutSuffix) {
	    if (withoutSuffix) {
	        // E.g. "21 minūte", "3 minūtes".
	        return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
	    } else {
	        // E.g. "21 minūtes" as in "pēc 21 minūtes".
	        // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
	        return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
	    }
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    return number + ' ' + format(units[key], number, withoutSuffix);
	}
	function relativeTimeWithSingular(number, withoutSuffix, key) {
	    return format(units[key], number, withoutSuffix);
	}
	function relativeSeconds(number, withoutSuffix) {
	    return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
	}

	var lv = moment.defineLocale('lv', {
	    months : 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
	    weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
	    weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY.',
	        LL : 'YYYY. [gada] D. MMMM',
	        LLL : 'YYYY. [gada] D. MMMM, HH:mm',
	        LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
	    },
	    calendar : {
	        sameDay : '[Šodien pulksten] LT',
	        nextDay : '[Rīt pulksten] LT',
	        nextWeek : 'dddd [pulksten] LT',
	        lastDay : '[Vakar pulksten] LT',
	        lastWeek : '[Pagājušā] dddd [pulksten] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'pēc %s',
	        past : 'pirms %s',
	        s : relativeSeconds,
	        m : relativeTimeWithSingular,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithSingular,
	        hh : relativeTimeWithPlural,
	        d : relativeTimeWithSingular,
	        dd : relativeTimeWithPlural,
	        M : relativeTimeWithSingular,
	        MM : relativeTimeWithPlural,
	        y : relativeTimeWithSingular,
	        yy : relativeTimeWithPlural
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lv;

	})));


/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Montenegrin [me]
	//! author : Miodrag Nikač <miodrag@restartit.me> : https://github.com/miodragnikac

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var translator = {
	    words: { //Different grammatical cases
	        m: ['jedan minut', 'jednog minuta'],
	        mm: ['minut', 'minuta', 'minuta'],
	        h: ['jedan sat', 'jednog sata'],
	        hh: ['sat', 'sata', 'sati'],
	        dd: ['dan', 'dana', 'dana'],
	        MM: ['mjesec', 'mjeseca', 'mjeseci'],
	        yy: ['godina', 'godine', 'godina']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var me = moment.defineLocale('me', {
	    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact : true,
	    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	    weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	    weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[danas u] LT',
	        nextDay: '[sjutra u] LT',

	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[juče u] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[prošle] [nedjelje] [u] LT',
	                '[prošlog] [ponedjeljka] [u] LT',
	                '[prošlog] [utorka] [u] LT',
	                '[prošle] [srijede] [u] LT',
	                '[prošlog] [četvrtka] [u] LT',
	                '[prošlog] [petka] [u] LT',
	                '[prošle] [subote] [u] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'nekoliko sekundi',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : 'dan',
	        dd     : translator.translate,
	        M      : 'mjesec',
	        MM     : translator.translate,
	        y      : 'godinu',
	        yy     : translator.translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return me;

	})));


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maori [mi]
	//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var mi = moment.defineLocale('mi', {
	    months: 'Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea'.split('_'),
	    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
	    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
	    weekdays: 'Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei'.split('_'),
	    weekdaysShort: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
	    weekdaysMin: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY [i] HH:mm',
	        LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
	    },
	    calendar: {
	        sameDay: '[i teie mahana, i] LT',
	        nextDay: '[apopo i] LT',
	        nextWeek: 'dddd [i] LT',
	        lastDay: '[inanahi i] LT',
	        lastWeek: 'dddd [whakamutunga i] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'i roto i %s',
	        past: '%s i mua',
	        s: 'te hēkona ruarua',
	        m: 'he meneti',
	        mm: '%d meneti',
	        h: 'te haora',
	        hh: '%d haora',
	        d: 'he ra',
	        dd: '%d ra',
	        M: 'he marama',
	        MM: '%d marama',
	        y: 'he tau',
	        yy: '%d tau'
	    },
	    ordinalParse: /\d{1,2}º/,
	    ordinal: '%dº',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return mi;

	})));


/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Macedonian [mk]
	//! author : Borislav Mickov : https://github.com/B0k0

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var mk = moment.defineLocale('mk', {
	    months : 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
	    monthsShort : 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
	    weekdays : 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
	    weekdaysShort : 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
	    weekdaysMin : 'нe_пo_вт_ср_че_пе_сa'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'D.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay : '[Денес во] LT',
	        nextDay : '[Утре во] LT',
	        nextWeek : '[Во] dddd [во] LT',
	        lastDay : '[Вчера во] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[Изминатата] dddd [во] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[Изминатиот] dddd [во] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'после %s',
	        past : 'пред %s',
	        s : 'неколку секунди',
	        m : 'минута',
	        mm : '%d минути',
	        h : 'час',
	        hh : '%d часа',
	        d : 'ден',
	        dd : '%d дена',
	        M : 'месец',
	        MM : '%d месеци',
	        y : 'година',
	        yy : '%d години'
	    },
	    ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	    ordinal : function (number) {
	        var lastDigit = number % 10,
	            last2Digits = number % 100;
	        if (number === 0) {
	            return number + '-ев';
	        } else if (last2Digits === 0) {
	            return number + '-ен';
	        } else if (last2Digits > 10 && last2Digits < 20) {
	            return number + '-ти';
	        } else if (lastDigit === 1) {
	            return number + '-ви';
	        } else if (lastDigit === 2) {
	            return number + '-ри';
	        } else if (lastDigit === 7 || lastDigit === 8) {
	            return number + '-ми';
	        } else {
	            return number + '-ти';
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return mk;

	})));


/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malayalam [ml]
	//! author : Floyd Pink : https://github.com/floydpink

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ml = moment.defineLocale('ml', {
	    months : 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
	    monthsShort : 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
	    weekdaysShort : 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
	    weekdaysMin : 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm -നു',
	        LTS : 'A h:mm:ss -നു',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm -നു',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm -നു'
	    },
	    calendar : {
	        sameDay : '[ഇന്ന്] LT',
	        nextDay : '[നാളെ] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[ഇന്നലെ] LT',
	        lastWeek : '[കഴിഞ്ഞ] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s കഴിഞ്ഞ്',
	        past : '%s മുൻപ്',
	        s : 'അൽപ നിമിഷങ്ങൾ',
	        m : 'ഒരു മിനിറ്റ്',
	        mm : '%d മിനിറ്റ്',
	        h : 'ഒരു മണിക്കൂർ',
	        hh : '%d മണിക്കൂർ',
	        d : 'ഒരു ദിവസം',
	        dd : '%d ദിവസം',
	        M : 'ഒരു മാസം',
	        MM : '%d മാസം',
	        y : 'ഒരു വർഷം',
	        yy : '%d വർഷം'
	    },
	    meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === 'രാത്രി' && hour >= 4) ||
	                meridiem === 'ഉച്ച കഴിഞ്ഞ്' ||
	                meridiem === 'വൈകുന്നേരം') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'രാത്രി';
	        } else if (hour < 12) {
	            return 'രാവിലെ';
	        } else if (hour < 17) {
	            return 'ഉച്ച കഴിഞ്ഞ്';
	        } else if (hour < 20) {
	            return 'വൈകുന്നേരം';
	        } else {
	            return 'രാത്രി';
	        }
	    }
	});

	return ml;

	})));


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Marathi [mr]
	//! author : Harshad Kale : https://github.com/kalehv
	//! author : Vivek Athalye : https://github.com/vnathalye

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '१',
	    '2': '२',
	    '3': '३',
	    '4': '४',
	    '5': '५',
	    '6': '६',
	    '7': '७',
	    '8': '८',
	    '9': '९',
	    '0': '०'
	};
	var numberMap = {
	    '१': '1',
	    '२': '2',
	    '३': '3',
	    '४': '4',
	    '५': '5',
	    '६': '6',
	    '७': '7',
	    '८': '8',
	    '९': '9',
	    '०': '0'
	};

	function relativeTimeMr(number, withoutSuffix, string, isFuture)
	{
	    var output = '';
	    if (withoutSuffix) {
	        switch (string) {
	            case 's': output = 'काही सेकंद'; break;
	            case 'm': output = 'एक मिनिट'; break;
	            case 'mm': output = '%d मिनिटे'; break;
	            case 'h': output = 'एक तास'; break;
	            case 'hh': output = '%d तास'; break;
	            case 'd': output = 'एक दिवस'; break;
	            case 'dd': output = '%d दिवस'; break;
	            case 'M': output = 'एक महिना'; break;
	            case 'MM': output = '%d महिने'; break;
	            case 'y': output = 'एक वर्ष'; break;
	            case 'yy': output = '%d वर्षे'; break;
	        }
	    }
	    else {
	        switch (string) {
	            case 's': output = 'काही सेकंदां'; break;
	            case 'm': output = 'एका मिनिटा'; break;
	            case 'mm': output = '%d मिनिटां'; break;
	            case 'h': output = 'एका तासा'; break;
	            case 'hh': output = '%d तासां'; break;
	            case 'd': output = 'एका दिवसा'; break;
	            case 'dd': output = '%d दिवसां'; break;
	            case 'M': output = 'एका महिन्या'; break;
	            case 'MM': output = '%d महिन्यां'; break;
	            case 'y': output = 'एका वर्षा'; break;
	            case 'yy': output = '%d वर्षां'; break;
	        }
	    }
	    return output.replace(/%d/i, number);
	}

	var mr = moment.defineLocale('mr', {
	    months : 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
	    monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	    weekdaysShort : 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
	    weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm वाजता',
	        LTS : 'A h:mm:ss वाजता',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm वाजता',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm वाजता'
	    },
	    calendar : {
	        sameDay : '[आज] LT',
	        nextDay : '[उद्या] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[काल] LT',
	        lastWeek: '[मागील] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future: '%sमध्ये',
	        past: '%sपूर्वी',
	        s: relativeTimeMr,
	        m: relativeTimeMr,
	        mm: relativeTimeMr,
	        h: relativeTimeMr,
	        hh: relativeTimeMr,
	        d: relativeTimeMr,
	        dd: relativeTimeMr,
	        M: relativeTimeMr,
	        MM: relativeTimeMr,
	        y: relativeTimeMr,
	        yy: relativeTimeMr
	    },
	    preparse: function (string) {
	        return string.replace(/[१२३४५६७८९०]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'रात्री') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === 'सकाळी') {
	            return hour;
	        } else if (meridiem === 'दुपारी') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === 'सायंकाळी') {
	            return hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'रात्री';
	        } else if (hour < 10) {
	            return 'सकाळी';
	        } else if (hour < 17) {
	            return 'दुपारी';
	        } else if (hour < 20) {
	            return 'सायंकाळी';
	        } else {
	            return 'रात्री';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return mr;

	})));


/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms]
	//! author : Weldan Jamili : https://github.com/weldan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ms = moment.defineLocale('ms', {
	    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'tengahari') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'petang' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'tengahari';
	        } else if (hours < 19) {
	            return 'petang';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Esok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kelmarin pukul] LT',
	        lastWeek : 'dddd [lepas pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lepas',
	        s : 'beberapa saat',
	        m : 'seminit',
	        mm : '%d minit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ms;

	})));


/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms-my]
	//! note : DEPRECATED, the correct one is [ms]
	//! author : Weldan Jamili : https://github.com/weldan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var msMy = moment.defineLocale('ms-my', {
	    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'tengahari') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'petang' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'tengahari';
	        } else if (hours < 19) {
	            return 'petang';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Esok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kelmarin pukul] LT',
	        lastWeek : 'dddd [lepas pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lepas',
	        s : 'beberapa saat',
	        m : 'seminit',
	        mm : '%d minit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return msMy;

	})));


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Burmese [my]
	//! author : Squar team, mysquar.com
	//! author : David Rossellat : https://github.com/gholadr
	//! author : Tin Aung Lin : https://github.com/thanyawzinmin

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '၁',
	    '2': '၂',
	    '3': '၃',
	    '4': '၄',
	    '5': '၅',
	    '6': '၆',
	    '7': '၇',
	    '8': '၈',
	    '9': '၉',
	    '0': '၀'
	};
	var numberMap = {
	    '၁': '1',
	    '၂': '2',
	    '၃': '3',
	    '၄': '4',
	    '၅': '5',
	    '၆': '6',
	    '၇': '7',
	    '၈': '8',
	    '၉': '9',
	    '၀': '0'
	};

	var my = moment.defineLocale('my', {
	    months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
	    monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
	    weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
	    weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
	    weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),

	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[ယနေ.] LT [မှာ]',
	        nextDay: '[မနက်ဖြန်] LT [မှာ]',
	        nextWeek: 'dddd LT [မှာ]',
	        lastDay: '[မနေ.က] LT [မှာ]',
	        lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'လာမည့် %s မှာ',
	        past: 'လွန်ခဲ့သော %s က',
	        s: 'စက္ကန်.အနည်းငယ်',
	        m: 'တစ်မိနစ်',
	        mm: '%d မိနစ်',
	        h: 'တစ်နာရီ',
	        hh: '%d နာရီ',
	        d: 'တစ်ရက်',
	        dd: '%d ရက်',
	        M: 'တစ်လ',
	        MM: '%d လ',
	        y: 'တစ်နှစ်',
	        yy: '%d နှစ်'
	    },
	    preparse: function (string) {
	        return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return my;

	})));


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Norwegian Bokmål [nb]
	//! authors : Espen Hovlandsdal : https://github.com/rexxars
	//!           Sigurd Gartmann : https://github.com/sigurdga

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var nb = moment.defineLocale('nb', {
	    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	    weekdaysShort : 'sø._ma._ti._on._to._fr._lø.'.split('_'),
	    weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] HH:mm',
	        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[i dag kl.] LT',
	        nextDay: '[i morgen kl.] LT',
	        nextWeek: 'dddd [kl.] LT',
	        lastDay: '[i går kl.] LT',
	        lastWeek: '[forrige] dddd [kl.] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s siden',
	        s : 'noen sekunder',
	        m : 'ett minutt',
	        mm : '%d minutter',
	        h : 'en time',
	        hh : '%d timer',
	        d : 'en dag',
	        dd : '%d dager',
	        M : 'en måned',
	        MM : '%d måneder',
	        y : 'ett år',
	        yy : '%d år'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nb;

	})));


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nepalese [ne]
	//! author : suvash : https://github.com/suvash

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '१',
	    '2': '२',
	    '3': '३',
	    '4': '४',
	    '5': '५',
	    '6': '६',
	    '7': '७',
	    '8': '८',
	    '9': '९',
	    '0': '०'
	};
	var numberMap = {
	    '१': '1',
	    '२': '2',
	    '३': '3',
	    '४': '4',
	    '५': '5',
	    '६': '6',
	    '७': '7',
	    '८': '8',
	    '९': '9',
	    '०': '0'
	};

	var ne = moment.defineLocale('ne', {
	    months : 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
	    monthsShort : 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
	    weekdaysShort : 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
	    weekdaysMin : 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'Aको h:mm बजे',
	        LTS : 'Aको h:mm:ss बजे',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, Aको h:mm बजे',
	        LLLL : 'dddd, D MMMM YYYY, Aको h:mm बजे'
	    },
	    preparse: function (string) {
	        return string.replace(/[१२३४५६७८९०]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'राति') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === 'बिहान') {
	            return hour;
	        } else if (meridiem === 'दिउँसो') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === 'साँझ') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 3) {
	            return 'राति';
	        } else if (hour < 12) {
	            return 'बिहान';
	        } else if (hour < 16) {
	            return 'दिउँसो';
	        } else if (hour < 20) {
	            return 'साँझ';
	        } else {
	            return 'राति';
	        }
	    },
	    calendar : {
	        sameDay : '[आज] LT',
	        nextDay : '[भोलि] LT',
	        nextWeek : '[आउँदो] dddd[,] LT',
	        lastDay : '[हिजो] LT',
	        lastWeek : '[गएको] dddd[,] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%sमा',
	        past : '%s अगाडि',
	        s : 'केही क्षण',
	        m : 'एक मिनेट',
	        mm : '%d मिनेट',
	        h : 'एक घण्टा',
	        hh : '%d घण्टा',
	        d : 'एक दिन',
	        dd : '%d दिन',
	        M : 'एक महिना',
	        MM : '%d महिना',
	        y : 'एक बर्ष',
	        yy : '%d बर्ष'
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ne;

	})));


/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Dutch [nl]
	//! author : Joris Röling : https://github.com/jorisroling
	//! author : Jacob Middag : https://github.com/middagj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

	var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	var nl = moment.defineLocale('nl', {
	    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },

	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	    weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[vandaag om] LT',
	        nextDay: '[morgen om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[gisteren om] LT',
	        lastWeek: '[afgelopen] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'over %s',
	        past : '%s geleden',
	        s : 'een paar seconden',
	        m : 'één minuut',
	        mm : '%d minuten',
	        h : 'één uur',
	        hh : '%d uur',
	        d : 'één dag',
	        dd : '%d dagen',
	        M : 'één maand',
	        MM : '%d maanden',
	        y : 'één jaar',
	        yy : '%d jaar'
	    },
	    ordinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nl;

	})));


/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Dutch (Belgium) [nl-be]
	//! author : Joris Röling : https://github.com/jorisroling
	//! author : Jacob Middag : https://github.com/middagj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

	var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	var nlBe = moment.defineLocale('nl-be', {
	    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },

	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	    weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[vandaag om] LT',
	        nextDay: '[morgen om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[gisteren om] LT',
	        lastWeek: '[afgelopen] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'over %s',
	        past : '%s geleden',
	        s : 'een paar seconden',
	        m : 'één minuut',
	        mm : '%d minuten',
	        h : 'één uur',
	        hh : '%d uur',
	        d : 'één dag',
	        dd : '%d dagen',
	        M : 'één maand',
	        MM : '%d maanden',
	        y : 'één jaar',
	        yy : '%d jaar'
	    },
	    ordinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nlBe;

	})));


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nynorsk [nn]
	//! author : https://github.com/mechuwind

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var nn = moment.defineLocale('nn', {
	    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	    weekdays : 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
	    weekdaysShort : 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
	    weekdaysMin : 'su_må_ty_on_to_fr_lø'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] H:mm',
	        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[I dag klokka] LT',
	        nextDay: '[I morgon klokka] LT',
	        nextWeek: 'dddd [klokka] LT',
	        lastDay: '[I går klokka] LT',
	        lastWeek: '[Føregåande] dddd [klokka] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s sidan',
	        s : 'nokre sekund',
	        m : 'eit minutt',
	        mm : '%d minutt',
	        h : 'ein time',
	        hh : '%d timar',
	        d : 'ein dag',
	        dd : '%d dagar',
	        M : 'ein månad',
	        MM : '%d månader',
	        y : 'eit år',
	        yy : '%d år'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nn;

	})));


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Punjabi (India) [pa-in]
	//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '੧',
	    '2': '੨',
	    '3': '੩',
	    '4': '੪',
	    '5': '੫',
	    '6': '੬',
	    '7': '੭',
	    '8': '੮',
	    '9': '੯',
	    '0': '੦'
	};
	var numberMap = {
	    '੧': '1',
	    '੨': '2',
	    '੩': '3',
	    '੪': '4',
	    '੫': '5',
	    '੬': '6',
	    '੭': '7',
	    '੮': '8',
	    '੯': '9',
	    '੦': '0'
	};

	var paIn = moment.defineLocale('pa-in', {
	    // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
	    months : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
	    monthsShort : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
	    weekdays : 'ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ'.split('_'),
	    weekdaysShort : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
	    weekdaysMin : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ਵਜੇ',
	        LTS : 'A h:mm:ss ਵਜੇ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ਵਜੇ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm ਵਜੇ'
	    },
	    calendar : {
	        sameDay : '[ਅਜ] LT',
	        nextDay : '[ਕਲ] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[ਕਲ] LT',
	        lastWeek : '[ਪਿਛਲੇ] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ਵਿੱਚ',
	        past : '%s ਪਿਛਲੇ',
	        s : 'ਕੁਝ ਸਕਿੰਟ',
	        m : 'ਇਕ ਮਿੰਟ',
	        mm : '%d ਮਿੰਟ',
	        h : 'ਇੱਕ ਘੰਟਾ',
	        hh : '%d ਘੰਟੇ',
	        d : 'ਇੱਕ ਦਿਨ',
	        dd : '%d ਦਿਨ',
	        M : 'ਇੱਕ ਮਹੀਨਾ',
	        MM : '%d ਮਹੀਨੇ',
	        y : 'ਇੱਕ ਸਾਲ',
	        yy : '%d ਸਾਲ'
	    },
	    preparse: function (string) {
	        return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
	    meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'ਰਾਤ') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === 'ਸਵੇਰ') {
	            return hour;
	        } else if (meridiem === 'ਦੁਪਹਿਰ') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === 'ਸ਼ਾਮ') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'ਰਾਤ';
	        } else if (hour < 10) {
	            return 'ਸਵੇਰ';
	        } else if (hour < 17) {
	            return 'ਦੁਪਹਿਰ';
	        } else if (hour < 20) {
	            return 'ਸ਼ਾਮ';
	        } else {
	            return 'ਰਾਤ';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return paIn;

	})));


/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Polish [pl]
	//! author : Rafal Hirsz : https://github.com/evoL

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_');
	var monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');
	function plural(n) {
	    return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	}
	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'minuta' : 'minutę';
	        case 'mm':
	            return result + (plural(number) ? 'minuty' : 'minut');
	        case 'h':
	            return withoutSuffix  ? 'godzina'  : 'godzinę';
	        case 'hh':
	            return result + (plural(number) ? 'godziny' : 'godzin');
	        case 'MM':
	            return result + (plural(number) ? 'miesiące' : 'miesięcy');
	        case 'yy':
	            return result + (plural(number) ? 'lata' : 'lat');
	    }
	}

	var pl = moment.defineLocale('pl', {
	    months : function (momentToFormat, format) {
	        if (format === '') {
	            // Hack: if format empty we know this is used to generate
	            // RegExp by moment. Give then back both valid forms of months
	            // in RegExp ready format.
	            return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
	        } else if (/D MMMM/.test(format)) {
	            return monthsSubjective[momentToFormat.month()];
	        } else {
	            return monthsNominative[momentToFormat.month()];
	        }
	    },
	    monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
	    weekdays : 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
	    weekdaysShort : 'ndz_pon_wt_śr_czw_pt_sob'.split('_'),
	    weekdaysMin : 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Dziś o] LT',
	        nextDay: '[Jutro o] LT',
	        nextWeek: '[W] dddd [o] LT',
	        lastDay: '[Wczoraj o] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[W zeszłą niedzielę o] LT';
	                case 3:
	                    return '[W zeszłą środę o] LT';
	                case 6:
	                    return '[W zeszłą sobotę o] LT';
	                default:
	                    return '[W zeszły] dddd [o] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : '%s temu',
	        s : 'kilka sekund',
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : '1 dzień',
	        dd : '%d dni',
	        M : 'miesiąc',
	        MM : translate,
	        y : 'rok',
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return pl;

	})));


/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese [pt]
	//! author : Jefferson : https://github.com/jalex79

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var pt = moment.defineLocale('pt', {
	    months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	    weekdays : 'Domingo_Segunda-Feira_Terça-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sábado'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
	    weekdaysMin : 'Dom_2ª_3ª_4ª_5ª_6ª_Sáb'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY HH:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hoje às] LT',
	        nextDay: '[Amanhã às] LT',
	        nextWeek: 'dddd [às] LT',
	        lastDay: '[Ontem às] LT',
	        lastWeek: function () {
	            return (this.day() === 0 || this.day() === 6) ?
	                '[Último] dddd [às] LT' : // Saturday + Sunday
	                '[Última] dddd [às] LT'; // Monday - Friday
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'em %s',
	        past : 'há %s',
	        s : 'segundos',
	        m : 'um minuto',
	        mm : '%d minutos',
	        h : 'uma hora',
	        hh : '%d horas',
	        d : 'um dia',
	        dd : '%d dias',
	        M : 'um mês',
	        MM : '%d meses',
	        y : 'um ano',
	        yy : '%d anos'
	    },
	    ordinalParse: /\d{1,2}º/,
	    ordinal : '%dº',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return pt;

	})));


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese (Brazil) [pt-br]
	//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ptBr = moment.defineLocale('pt-br', {
	    months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	    weekdays : 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
	    weekdaysMin : 'Dom_2ª_3ª_4ª_5ª_6ª_Sáb'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY [às] HH:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hoje às] LT',
	        nextDay: '[Amanhã às] LT',
	        nextWeek: 'dddd [às] LT',
	        lastDay: '[Ontem às] LT',
	        lastWeek: function () {
	            return (this.day() === 0 || this.day() === 6) ?
	                '[Último] dddd [às] LT' : // Saturday + Sunday
	                '[Última] dddd [às] LT'; // Monday - Friday
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'em %s',
	        past : '%s atrás',
	        s : 'poucos segundos',
	        m : 'um minuto',
	        mm : '%d minutos',
	        h : 'uma hora',
	        hh : '%d horas',
	        d : 'um dia',
	        dd : '%d dias',
	        M : 'um mês',
	        MM : '%d meses',
	        y : 'um ano',
	        yy : '%d anos'
	    },
	    ordinalParse: /\d{1,2}º/,
	    ordinal : '%dº'
	});

	return ptBr;

	})));


/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Romanian [ro]
	//! author : Vlad Gurdiga : https://github.com/gurdiga
	//! author : Valentin Agachi : https://github.com/avaly

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	            'mm': 'minute',
	            'hh': 'ore',
	            'dd': 'zile',
	            'MM': 'luni',
	            'yy': 'ani'
	        },
	        separator = ' ';
	    if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
	        separator = ' de ';
	    }
	    return number + separator + format[key];
	}

	var ro = moment.defineLocale('ro', {
	    months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
	    monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
	    weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
	    weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay: '[azi la] LT',
	        nextDay: '[mâine la] LT',
	        nextWeek: 'dddd [la] LT',
	        lastDay: '[ieri la] LT',
	        lastWeek: '[fosta] dddd [la] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'peste %s',
	        past : '%s în urmă',
	        s : 'câteva secunde',
	        m : 'un minut',
	        mm : relativeTimeWithPlural,
	        h : 'o oră',
	        hh : relativeTimeWithPlural,
	        d : 'o zi',
	        dd : relativeTimeWithPlural,
	        M : 'o lună',
	        MM : relativeTimeWithPlural,
	        y : 'un an',
	        yy : relativeTimeWithPlural
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ro;

	})));


/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Russian [ru]
	//! author : Viktorminator : https://github.com/Viktorminator
	//! Author : Menelion Elensúle : https://github.com/Oire
	//! author : Коренберг Марк : https://github.com/socketpair

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
	        'hh': 'час_часа_часов',
	        'dd': 'день_дня_дней',
	        'MM': 'месяц_месяца_месяцев',
	        'yy': 'год_года_лет'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? 'минута' : 'минуту';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}
	var monthsParse = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];

	// http://new.gramota.ru/spravka/rules/139-prop : § 103
	// Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s=242637
	// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
	var ru = moment.defineLocale('ru', {
	    months : {
	        format: 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_'),
	        standalone: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_')
	    },
	    monthsShort : {
	        // по CLDR именно "июл." и "июн.", но какой смысл менять букву на точку ?
	        format: 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split('_'),
	        standalone: 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split('_')
	    },
	    weekdays : {
	        standalone: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
	        format: 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_'),
	        isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/
	    },
	    weekdaysShort : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
	    weekdaysMin : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
	    monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

	    // копия предыдущего
	    monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

	    // полные названия с падежами
	    monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,

	    // Выражение, которое соотвествует только сокращённым формам
	    monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY г.',
	        LLL : 'D MMMM YYYY г., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY г., HH:mm'
	    },
	    calendar : {
	        sameDay: '[Сегодня в] LT',
	        nextDay: '[Завтра в] LT',
	        lastDay: '[Вчера в] LT',
	        nextWeek: function (now) {
	            if (now.week() !== this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return '[В следующее] dddd [в] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[В следующий] dddd [в] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[В следующую] dddd [в] LT';
	                }
	            } else {
	                if (this.day() === 2) {
	                    return '[Во] dddd [в] LT';
	                } else {
	                    return '[В] dddd [в] LT';
	                }
	            }
	        },
	        lastWeek: function (now) {
	            if (now.week() !== this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return '[В прошлое] dddd [в] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[В прошлый] dddd [в] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[В прошлую] dddd [в] LT';
	                }
	            } else {
	                if (this.day() === 2) {
	                    return '[Во] dddd [в] LT';
	                } else {
	                    return '[В] dddd [в] LT';
	                }
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'через %s',
	        past : '%s назад',
	        s : 'несколько секунд',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : 'час',
	        hh : relativeTimeWithPlural,
	        d : 'день',
	        dd : relativeTimeWithPlural,
	        M : 'месяц',
	        MM : relativeTimeWithPlural,
	        y : 'год',
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /ночи|утра|дня|вечера/i,
	    isPM : function (input) {
	        return /^(дня|вечера)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'ночи';
	        } else if (hour < 12) {
	            return 'утра';
	        } else if (hour < 17) {
	            return 'дня';
	        } else {
	            return 'вечера';
	        }
	    },
	    ordinalParse: /\d{1,2}-(й|го|я)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	                return number + '-й';
	            case 'D':
	                return number + '-го';
	            case 'w':
	            case 'W':
	                return number + '-я';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ru;

	})));


/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Northern Sami [se]
	//! authors : Bård Rolstad Henriksen : https://github.com/karamell

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';



	var se = moment.defineLocale('se', {
	    months : 'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split('_'),
	    monthsShort : 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split('_'),
	    weekdays : 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split('_'),
	    weekdaysShort : 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
	    weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'MMMM D. [b.] YYYY',
	        LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
	        LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[otne ti] LT',
	        nextDay: '[ihttin ti] LT',
	        nextWeek: 'dddd [ti] LT',
	        lastDay: '[ikte ti] LT',
	        lastWeek: '[ovddit] dddd [ti] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s geažes',
	        past : 'maŋit %s',
	        s : 'moadde sekunddat',
	        m : 'okta minuhta',
	        mm : '%d minuhtat',
	        h : 'okta diimmu',
	        hh : '%d diimmut',
	        d : 'okta beaivi',
	        dd : '%d beaivvit',
	        M : 'okta mánnu',
	        MM : '%d mánut',
	        y : 'okta jahki',
	        yy : '%d jagit'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return se;

	})));


/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Sinhalese [si]
	//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	/*jshint -W100*/
	var si = moment.defineLocale('si', {
	    months : 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split('_'),
	    monthsShort : 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split('_'),
	    weekdays : 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split('_'),
	    weekdaysShort : 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
	    weekdaysMin : 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'a h:mm',
	        LTS : 'a h:mm:ss',
	        L : 'YYYY/MM/DD',
	        LL : 'YYYY MMMM D',
	        LLL : 'YYYY MMMM D, a h:mm',
	        LLLL : 'YYYY MMMM D [වැනි] dddd, a h:mm:ss'
	    },
	    calendar : {
	        sameDay : '[අද] LT[ට]',
	        nextDay : '[හෙට] LT[ට]',
	        nextWeek : 'dddd LT[ට]',
	        lastDay : '[ඊයේ] LT[ට]',
	        lastWeek : '[පසුගිය] dddd LT[ට]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%sකින්',
	        past : '%sකට පෙර',
	        s : 'තත්පර කිහිපය',
	        m : 'මිනිත්තුව',
	        mm : 'මිනිත්තු %d',
	        h : 'පැය',
	        hh : 'පැය %d',
	        d : 'දිනය',
	        dd : 'දින %d',
	        M : 'මාසය',
	        MM : 'මාස %d',
	        y : 'වසර',
	        yy : 'වසර %d'
	    },
	    ordinalParse: /\d{1,2} වැනි/,
	    ordinal : function (number) {
	        return number + ' වැනි';
	    },
	    meridiemParse : /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
	    isPM : function (input) {
	        return input === 'ප.ව.' || input === 'පස් වරු';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'ප.ව.' : 'පස් වරු';
	        } else {
	            return isLower ? 'පෙ.ව.' : 'පෙර වරු';
	        }
	    }
	});

	return si;

	})));


/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovak [sk]
	//! author : Martin Minka : https://github.com/k2s
	//! based on work of petrbela : https://github.com/petrbela

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_');
	var monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');
	function plural(n) {
	    return (n > 1) && (n < 5);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pár sekúnd' : 'pár sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minúta' : (isFuture ? 'minútu' : 'minútou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minúty' : 'minút');
	            } else {
	                return result + 'minútami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodín');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'deň' : 'dňom';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dni' : 'dní');
	            } else {
	                return result + 'dňami';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'mesiace' : 'mesiacov');
	            } else {
	                return result + 'mesiacmi';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'rokov');
	            } else {
	                return result + 'rokmi';
	            }
	            break;
	    }
	}

	var sk = moment.defineLocale('sk', {
	    months : months,
	    monthsShort : monthsShort,
	    weekdays : 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
	    weekdaysShort : 'ne_po_ut_st_št_pi_so'.split('_'),
	    weekdaysMin : 'ne_po_ut_st_št_pi_so'.split('_'),
	    longDateFormat : {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay: '[dnes o] LT',
	        nextDay: '[zajtra o] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v nedeľu o] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [o] LT';
	                case 3:
	                    return '[v stredu o] LT';
	                case 4:
	                    return '[vo štvrtok o] LT';
	                case 5:
	                    return '[v piatok o] LT';
	                case 6:
	                    return '[v sobotu o] LT';
	            }
	        },
	        lastDay: '[včera o] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[minulú nedeľu o] LT';
	                case 1:
	                case 2:
	                    return '[minulý] dddd [o] LT';
	                case 3:
	                    return '[minulú stredu o] LT';
	                case 4:
	                case 5:
	                    return '[minulý] dddd [o] LT';
	                case 6:
	                    return '[minulú sobotu o] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : 'pred %s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sk;

	})));


/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovenian [sl]
	//! author : Robert Sedovšek : https://github.com/sedovsek

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
	        case 'm':
	            return withoutSuffix ? 'ena minuta' : 'eno minuto';
	        case 'mm':
	            if (number === 1) {
	                result += withoutSuffix ? 'minuta' : 'minuto';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
	            } else {
	                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'ena ura' : 'eno uro';
	        case 'hh':
	            if (number === 1) {
	                result += withoutSuffix ? 'ura' : 'uro';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'uri' : 'urama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'ure' : 'urami';
	            } else {
	                result += withoutSuffix || isFuture ? 'ur' : 'urami';
	            }
	            return result;
	        case 'd':
	            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
	        case 'dd':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
	            } else {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
	            }
	            return result;
	        case 'M':
	            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
	        case 'MM':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
	            } else {
	                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
	            }
	            return result;
	        case 'y':
	            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
	        case 'yy':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'leto' : 'letom';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'leta' : 'leti';
	            } else {
	                result += withoutSuffix || isFuture ? 'let' : 'leti';
	            }
	            return result;
	    }
	}

	var sl = moment.defineLocale('sl', {
	    months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
	    weekdaysShort : 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
	    weekdaysMin : 'ne_po_to_sr_če_pe_so'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danes ob] LT',
	        nextDay  : '[jutri ob] LT',

	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v] [nedeljo] [ob] LT';
	                case 3:
	                    return '[v] [sredo] [ob] LT';
	                case 6:
	                    return '[v] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[v] dddd [ob] LT';
	            }
	        },
	        lastDay  : '[včeraj ob] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[prejšnjo] [nedeljo] [ob] LT';
	                case 3:
	                    return '[prejšnjo] [sredo] [ob] LT';
	                case 6:
	                    return '[prejšnjo] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prejšnji] dddd [ob] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'čez %s',
	        past   : 'pred %s',
	        s      : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : processRelativeTime,
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sl;

	})));


/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Albanian [sq]
	//! author : Flakërim Ismani : https://github.com/flakerimi
	//! author : Menelion Elensúle : https://github.com/Oire
	//! author : Oerd Cukalla : https://github.com/oerd

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var sq = moment.defineLocale('sq', {
	    months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
	    monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
	    weekdays : 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
	    weekdaysShort : 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
	    weekdaysMin : 'D_H_Ma_Më_E_P_Sh'.split('_'),
	    weekdaysParseExact : true,
	    meridiemParse: /PD|MD/,
	    isPM: function (input) {
	        return input.charAt(0) === 'M';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        return hours < 12 ? 'PD' : 'MD';
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Sot në] LT',
	        nextDay : '[Nesër në] LT',
	        nextWeek : 'dddd [në] LT',
	        lastDay : '[Dje në] LT',
	        lastWeek : 'dddd [e kaluar në] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'në %s',
	        past : '%s më parë',
	        s : 'disa sekonda',
	        m : 'një minutë',
	        mm : '%d minuta',
	        h : 'një orë',
	        hh : '%d orë',
	        d : 'një ditë',
	        dd : '%d ditë',
	        M : 'një muaj',
	        MM : '%d muaj',
	        y : 'një vit',
	        yy : '%d vite'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sq;

	})));


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian [sr]
	//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var translator = {
	    words: { //Different grammatical cases
	        m: ['jedan minut', 'jedne minute'],
	        mm: ['minut', 'minute', 'minuta'],
	        h: ['jedan sat', 'jednog sata'],
	        hh: ['sat', 'sata', 'sati'],
	        dd: ['dan', 'dana', 'dana'],
	        MM: ['mesec', 'meseca', 'meseci'],
	        yy: ['godina', 'godine', 'godina']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var sr = moment.defineLocale('sr', {
	    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays: 'nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota'.split('_'),
	    weekdaysShort: 'ned._pon._uto._sre._čet._pet._sub.'.split('_'),
	    weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[danas u] LT',
	        nextDay: '[sutra u] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedelju] [u] LT';
	                case 3:
	                    return '[u] [sredu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[juče u] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[prošle] [nedelje] [u] LT',
	                '[prošlog] [ponedeljka] [u] LT',
	                '[prošlog] [utorka] [u] LT',
	                '[prošle] [srede] [u] LT',
	                '[prošlog] [četvrtka] [u] LT',
	                '[prošlog] [petka] [u] LT',
	                '[prošle] [subote] [u] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'pre %s',
	        s      : 'nekoliko sekundi',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : 'dan',
	        dd     : translator.translate,
	        M      : 'mesec',
	        MM     : translator.translate,
	        y      : 'godinu',
	        yy     : translator.translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sr;

	})));


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian Cyrillic [sr-cyrl]
	//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var translator = {
	    words: { //Different grammatical cases
	        m: ['један минут', 'једне минуте'],
	        mm: ['минут', 'минуте', 'минута'],
	        h: ['један сат', 'једног сата'],
	        hh: ['сат', 'сата', 'сати'],
	        dd: ['дан', 'дана', 'дана'],
	        MM: ['месец', 'месеца', 'месеци'],
	        yy: ['година', 'године', 'година']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var srCyrl = moment.defineLocale('sr-cyrl', {
	    months: 'јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар'.split('_'),
	    monthsShort: 'јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.'.split('_'),
	    monthsParseExact: true,
	    weekdays: 'недеља_понедељак_уторак_среда_четвртак_петак_субота'.split('_'),
	    weekdaysShort: 'нед._пон._уто._сре._чет._пет._суб.'.split('_'),
	    weekdaysMin: 'не_по_ут_ср_че_пе_су'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[данас у] LT',
	        nextDay: '[сутра у] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[у] [недељу] [у] LT';
	                case 3:
	                    return '[у] [среду] [у] LT';
	                case 6:
	                    return '[у] [суботу] [у] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[у] dddd [у] LT';
	            }
	        },
	        lastDay  : '[јуче у] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[прошле] [недеље] [у] LT',
	                '[прошлог] [понедељка] [у] LT',
	                '[прошлог] [уторка] [у] LT',
	                '[прошле] [среде] [у] LT',
	                '[прошлог] [четвртка] [у] LT',
	                '[прошлог] [петка] [у] LT',
	                '[прошле] [суботе] [у] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'за %s',
	        past   : 'пре %s',
	        s      : 'неколико секунди',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : 'дан',
	        dd     : translator.translate,
	        M      : 'месец',
	        MM     : translator.translate,
	        y      : 'годину',
	        yy     : translator.translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return srCyrl;

	})));


/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : siSwati [ss]
	//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';



	var ss = moment.defineLocale('ss', {
	    months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
	    monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
	    weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
	    weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
	    weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Namuhla nga] LT',
	        nextDay : '[Kusasa nga] LT',
	        nextWeek : 'dddd [nga] LT',
	        lastDay : '[Itolo nga] LT',
	        lastWeek : 'dddd [leliphelile] [nga] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'nga %s',
	        past : 'wenteka nga %s',
	        s : 'emizuzwana lomcane',
	        m : 'umzuzu',
	        mm : '%d emizuzu',
	        h : 'lihora',
	        hh : '%d emahora',
	        d : 'lilanga',
	        dd : '%d emalanga',
	        M : 'inyanga',
	        MM : '%d tinyanga',
	        y : 'umnyaka',
	        yy : '%d iminyaka'
	    },
	    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'ekuseni';
	        } else if (hours < 15) {
	            return 'emini';
	        } else if (hours < 19) {
	            return 'entsambama';
	        } else {
	            return 'ebusuku';
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'ekuseni') {
	            return hour;
	        } else if (meridiem === 'emini') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
	            if (hour === 0) {
	                return 0;
	            }
	            return hour + 12;
	        }
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ss;

	})));


/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swedish [sv]
	//! author : Jens Alm : https://github.com/ulmus

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var sv = moment.defineLocale('sv', {
	    months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
	    weekdaysShort : 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
	    weekdaysMin : 'sö_må_ti_on_to_fr_lö'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [kl.] HH:mm',
	        LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Idag] LT',
	        nextDay: '[Imorgon] LT',
	        lastDay: '[Igår] LT',
	        nextWeek: '[På] dddd LT',
	        lastWeek: '[I] dddd[s] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : 'för %s sedan',
	        s : 'några sekunder',
	        m : 'en minut',
	        mm : '%d minuter',
	        h : 'en timme',
	        hh : '%d timmar',
	        d : 'en dag',
	        dd : '%d dagar',
	        M : 'en månad',
	        MM : '%d månader',
	        y : 'ett år',
	        yy : '%d år'
	    },
	    ordinalParse: /\d{1,2}(e|a)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'e' :
	            (b === 1) ? 'a' :
	            (b === 2) ? 'a' :
	            (b === 3) ? 'e' : 'e';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sv;

	})));


/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swahili [sw]
	//! author : Fahad Kassim : https://github.com/fadsel

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var sw = moment.defineLocale('sw', {
	    months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
	    weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
	    weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[leo saa] LT',
	        nextDay : '[kesho saa] LT',
	        nextWeek : '[wiki ijayo] dddd [saat] LT',
	        lastDay : '[jana] LT',
	        lastWeek : '[wiki iliyopita] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s baadaye',
	        past : 'tokea %s',
	        s : 'hivi punde',
	        m : 'dakika moja',
	        mm : 'dakika %d',
	        h : 'saa limoja',
	        hh : 'masaa %d',
	        d : 'siku moja',
	        dd : 'masiku %d',
	        M : 'mwezi mmoja',
	        MM : 'miezi %d',
	        y : 'mwaka mmoja',
	        yy : 'miaka %d'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sw;

	})));


/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tamil [ta]
	//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '௧',
	    '2': '௨',
	    '3': '௩',
	    '4': '௪',
	    '5': '௫',
	    '6': '௬',
	    '7': '௭',
	    '8': '௮',
	    '9': '௯',
	    '0': '௦'
	};
	var numberMap = {
	    '௧': '1',
	    '௨': '2',
	    '௩': '3',
	    '௪': '4',
	    '௫': '5',
	    '௬': '6',
	    '௭': '7',
	    '௮': '8',
	    '௯': '9',
	    '௦': '0'
	};

	var ta = moment.defineLocale('ta', {
	    months : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	    monthsShort : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	    weekdays : 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split('_'),
	    weekdaysShort : 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
	    weekdaysMin : 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, HH:mm',
	        LLLL : 'dddd, D MMMM YYYY, HH:mm'
	    },
	    calendar : {
	        sameDay : '[இன்று] LT',
	        nextDay : '[நாளை] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[நேற்று] LT',
	        lastWeek : '[கடந்த வாரம்] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s இல்',
	        past : '%s முன்',
	        s : 'ஒரு சில விநாடிகள்',
	        m : 'ஒரு நிமிடம்',
	        mm : '%d நிமிடங்கள்',
	        h : 'ஒரு மணி நேரம்',
	        hh : '%d மணி நேரம்',
	        d : 'ஒரு நாள்',
	        dd : '%d நாட்கள்',
	        M : 'ஒரு மாதம்',
	        MM : '%d மாதங்கள்',
	        y : 'ஒரு வருடம்',
	        yy : '%d ஆண்டுகள்'
	    },
	    ordinalParse: /\d{1,2}வது/,
	    ordinal : function (number) {
	        return number + 'வது';
	    },
	    preparse: function (string) {
	        return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // refer http://ta.wikipedia.org/s/1er1
	    meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 2) {
	            return ' யாமம்';
	        } else if (hour < 6) {
	            return ' வைகறை';  // வைகறை
	        } else if (hour < 10) {
	            return ' காலை'; // காலை
	        } else if (hour < 14) {
	            return ' நண்பகல்'; // நண்பகல்
	        } else if (hour < 18) {
	            return ' எற்பாடு'; // எற்பாடு
	        } else if (hour < 22) {
	            return ' மாலை'; // மாலை
	        } else {
	            return ' யாமம்';
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'யாமம்') {
	            return hour < 2 ? hour : hour + 12;
	        } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
	            return hour;
	        } else if (meridiem === 'நண்பகல்') {
	            return hour >= 10 ? hour : hour + 12;
	        } else {
	            return hour + 12;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ta;

	})));


/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Telugu [te]
	//! author : Krishna Chaitanya Thota : https://github.com/kcthota

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var te = moment.defineLocale('te', {
	    months : 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జూలై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split('_'),
	    monthsShort : 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జూలై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split('_'),
	    weekdaysShort : 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
	    weekdaysMin : 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm'
	    },
	    calendar : {
	        sameDay : '[నేడు] LT',
	        nextDay : '[రేపు] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[నిన్న] LT',
	        lastWeek : '[గత] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s లో',
	        past : '%s క్రితం',
	        s : 'కొన్ని క్షణాలు',
	        m : 'ఒక నిమిషం',
	        mm : '%d నిమిషాలు',
	        h : 'ఒక గంట',
	        hh : '%d గంటలు',
	        d : 'ఒక రోజు',
	        dd : '%d రోజులు',
	        M : 'ఒక నెల',
	        MM : '%d నెలలు',
	        y : 'ఒక సంవత్సరం',
	        yy : '%d సంవత్సరాలు'
	    },
	    ordinalParse : /\d{1,2}వ/,
	    ordinal : '%dవ',
	    meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'రాత్రి') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === 'ఉదయం') {
	            return hour;
	        } else if (meridiem === 'మధ్యాహ్నం') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === 'సాయంత్రం') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'రాత్రి';
	        } else if (hour < 10) {
	            return 'ఉదయం';
	        } else if (hour < 17) {
	            return 'మధ్యాహ్నం';
	        } else if (hour < 20) {
	            return 'సాయంత్రం';
	        } else {
	            return 'రాత్రి';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return te;

	})));


/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tetun Dili (East Timor) [tet]
	//! author : Joshua Brooks : https://github.com/joshbrooks
	//! author : Onorio De J. Afonso : https://github.com/marobo

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var tet = moment.defineLocale('tet', {
	    months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez'.split('_'),
	    weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sext_Sab'.split('_'),
	    weekdaysMin : 'Do_Seg_Te_Ku_Ki_Sex_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Ohin iha] LT',
	        nextDay: '[Aban iha] LT',
	        nextWeek: 'dddd [iha] LT',
	        lastDay: '[Horiseik iha] LT',
	        lastWeek: 'dddd [semana kotuk] [iha] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'iha %s',
	        past : '%s liuba',
	        s : 'minutu balun',
	        m : 'minutu ida',
	        mm : 'minutus %d',
	        h : 'horas ida',
	        hh : 'horas %d',
	        d : 'loron ida',
	        dd : 'loron %d',
	        M : 'fulan ida',
	        MM : 'fulan %d',
	        y : 'tinan ida',
	        yy : 'tinan %d'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tet;

	})));


/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Thai [th]
	//! author : Kridsada Thanabulpong : https://github.com/sirn

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var th = moment.defineLocale('th', {
	    months : 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
	    monthsShort : 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
	    weekdaysShort : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
	    weekdaysMin : 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'YYYY/MM/DD',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY เวลา H:mm',
	        LLLL : 'วันddddที่ D MMMM YYYY เวลา H:mm'
	    },
	    meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
	    isPM: function (input) {
	        return input === 'หลังเที่ยง';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'ก่อนเที่ยง';
	        } else {
	            return 'หลังเที่ยง';
	        }
	    },
	    calendar : {
	        sameDay : '[วันนี้ เวลา] LT',
	        nextDay : '[พรุ่งนี้ เวลา] LT',
	        nextWeek : 'dddd[หน้า เวลา] LT',
	        lastDay : '[เมื่อวานนี้ เวลา] LT',
	        lastWeek : '[วัน]dddd[ที่แล้ว เวลา] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'อีก %s',
	        past : '%sที่แล้ว',
	        s : 'ไม่กี่วินาที',
	        m : '1 นาที',
	        mm : '%d นาที',
	        h : '1 ชั่วโมง',
	        hh : '%d ชั่วโมง',
	        d : '1 วัน',
	        dd : '%d วัน',
	        M : '1 เดือน',
	        MM : '%d เดือน',
	        y : '1 ปี',
	        yy : '%d ปี'
	    }
	});

	return th;

	})));


/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tagalog (Philippines) [tl-ph]
	//! author : Dan Hagman : https://github.com/hagmandan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var tlPh = moment.defineLocale('tl-ph', {
	    months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
	    monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
	    weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
	    weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
	    weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'MM/D/YYYY',
	        LL : 'MMMM D, YYYY',
	        LLL : 'MMMM D, YYYY HH:mm',
	        LLLL : 'dddd, MMMM DD, YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: 'LT [ngayong araw]',
	        nextDay: '[Bukas ng] LT',
	        nextWeek: 'LT [sa susunod na] dddd',
	        lastDay: 'LT [kahapon]',
	        lastWeek: 'LT [noong nakaraang] dddd',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'sa loob ng %s',
	        past : '%s ang nakalipas',
	        s : 'ilang segundo',
	        m : 'isang minuto',
	        mm : '%d minuto',
	        h : 'isang oras',
	        hh : '%d oras',
	        d : 'isang araw',
	        dd : '%d araw',
	        M : 'isang buwan',
	        MM : '%d buwan',
	        y : 'isang taon',
	        yy : '%d taon'
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tlPh;

	})));


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Klingon [tlh]
	//! author : Dominika Kruk : https://github.com/amaranthrose

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

	function translateFuture(output) {
	    var time = output;
	    time = (output.indexOf('jaj') !== -1) ?
	    time.slice(0, -3) + 'leS' :
	    (output.indexOf('jar') !== -1) ?
	    time.slice(0, -3) + 'waQ' :
	    (output.indexOf('DIS') !== -1) ?
	    time.slice(0, -3) + 'nem' :
	    time + ' pIq';
	    return time;
	}

	function translatePast(output) {
	    var time = output;
	    time = (output.indexOf('jaj') !== -1) ?
	    time.slice(0, -3) + 'Hu’' :
	    (output.indexOf('jar') !== -1) ?
	    time.slice(0, -3) + 'wen' :
	    (output.indexOf('DIS') !== -1) ?
	    time.slice(0, -3) + 'ben' :
	    time + ' ret';
	    return time;
	}

	function translate(number, withoutSuffix, string, isFuture) {
	    var numberNoun = numberAsNoun(number);
	    switch (string) {
	        case 'mm':
	            return numberNoun + ' tup';
	        case 'hh':
	            return numberNoun + ' rep';
	        case 'dd':
	            return numberNoun + ' jaj';
	        case 'MM':
	            return numberNoun + ' jar';
	        case 'yy':
	            return numberNoun + ' DIS';
	    }
	}

	function numberAsNoun(number) {
	    var hundred = Math.floor((number % 1000) / 100),
	    ten = Math.floor((number % 100) / 10),
	    one = number % 10,
	    word = '';
	    if (hundred > 0) {
	        word += numbersNouns[hundred] + 'vatlh';
	    }
	    if (ten > 0) {
	        word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
	    }
	    if (one > 0) {
	        word += ((word !== '') ? ' ' : '') + numbersNouns[one];
	    }
	    return (word === '') ? 'pagh' : word;
	}

	var tlh = moment.defineLocale('tlh', {
	    months : 'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split('_'),
	    monthsShort : 'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[DaHjaj] LT',
	        nextDay: '[wa’leS] LT',
	        nextWeek: 'LLL',
	        lastDay: '[wa’Hu’] LT',
	        lastWeek: 'LLL',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : translateFuture,
	        past : translatePast,
	        s : 'puS lup',
	        m : 'wa’ tup',
	        mm : translate,
	        h : 'wa’ rep',
	        hh : translate,
	        d : 'wa’ jaj',
	        dd : translate,
	        M : 'wa’ jar',
	        MM : translate,
	        y : 'wa’ DIS',
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tlh;

	})));


/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Turkish [tr]
	//! authors : Erhan Gundogan : https://github.com/erhangundogan,
	//!           Burak Yiğit Kaya: https://github.com/BYK

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var suffixes = {
	    1: '\'inci',
	    5: '\'inci',
	    8: '\'inci',
	    70: '\'inci',
	    80: '\'inci',
	    2: '\'nci',
	    7: '\'nci',
	    20: '\'nci',
	    50: '\'nci',
	    3: '\'üncü',
	    4: '\'üncü',
	    100: '\'üncü',
	    6: '\'ncı',
	    9: '\'uncu',
	    10: '\'uncu',
	    30: '\'uncu',
	    60: '\'ıncı',
	    90: '\'ıncı'
	};

	var tr = moment.defineLocale('tr', {
	    months : 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
	    monthsShort : 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
	    weekdays : 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
	    weekdaysShort : 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
	    weekdaysMin : 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[bugün saat] LT',
	        nextDay : '[yarın saat] LT',
	        nextWeek : '[haftaya] dddd [saat] LT',
	        lastDay : '[dün] LT',
	        lastWeek : '[geçen hafta] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s sonra',
	        past : '%s önce',
	        s : 'birkaç saniye',
	        m : 'bir dakika',
	        mm : '%d dakika',
	        h : 'bir saat',
	        hh : '%d saat',
	        d : 'bir gün',
	        dd : '%d gün',
	        M : 'bir ay',
	        MM : '%d ay',
	        y : 'bir yıl',
	        yy : '%d yıl'
	    },
	    ordinalParse: /\d{1,2}'(inci|nci|üncü|ncı|uncu|ıncı)/,
	    ordinal : function (number) {
	        if (number === 0) {  // special case for zero
	            return number + '\'ıncı';
	        }
	        var a = number % 10,
	            b = number % 100 - a,
	            c = number >= 100 ? 100 : null;
	        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tr;

	})));


/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Talossan [tzl]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v
	//! author : Iustì Canun

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
	// This is currently too difficult (maybe even impossible) to add.
	var tzl = moment.defineLocale('tzl', {
	    months : 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
	    weekdays : 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
	    weekdaysShort : 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
	    weekdaysMin : 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM [dallas] YYYY',
	        LLL : 'D. MMMM [dallas] YYYY HH.mm',
	        LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
	    },
	    meridiemParse: /d\'o|d\'a/i,
	    isPM : function (input) {
	        return 'd\'o' === input.toLowerCase();
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'd\'o' : 'D\'O';
	        } else {
	            return isLower ? 'd\'a' : 'D\'A';
	        }
	    },
	    calendar : {
	        sameDay : '[oxhi à] LT',
	        nextDay : '[demà à] LT',
	        nextWeek : 'dddd [à] LT',
	        lastDay : '[ieiri à] LT',
	        lastWeek : '[sür el] dddd [lasteu à] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'osprei %s',
	        past : 'ja%s',
	        s : processRelativeTime,
	        m : processRelativeTime,
	        mm : processRelativeTime,
	        h : processRelativeTime,
	        hh : processRelativeTime,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        's': ['viensas secunds', '\'iensas secunds'],
	        'm': ['\'n míut', '\'iens míut'],
	        'mm': [number + ' míuts', '' + number + ' míuts'],
	        'h': ['\'n þora', '\'iensa þora'],
	        'hh': [number + ' þoras', '' + number + ' þoras'],
	        'd': ['\'n ziua', '\'iensa ziua'],
	        'dd': [number + ' ziuas', '' + number + ' ziuas'],
	        'M': ['\'n mes', '\'iens mes'],
	        'MM': [number + ' mesen', '' + number + ' mesen'],
	        'y': ['\'n ar', '\'iens ar'],
	        'yy': [number + ' ars', '' + number + ' ars']
	    };
	    return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
	}

	return tzl;

	})));


/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight [tzm]
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var tzm = moment.defineLocale('tzm', {
	    months : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	    monthsShort : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	    weekdays : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	    weekdaysShort : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	    weekdaysMin : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
	        nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
	        nextWeek: 'dddd [ⴴ] LT',
	        lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
	        lastWeek: 'dddd [ⴴ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
	        past : 'ⵢⴰⵏ %s',
	        s : 'ⵉⵎⵉⴽ',
	        m : 'ⵎⵉⵏⵓⴺ',
	        mm : '%d ⵎⵉⵏⵓⴺ',
	        h : 'ⵙⴰⵄⴰ',
	        hh : '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
	        d : 'ⴰⵙⵙ',
	        dd : '%d oⵙⵙⴰⵏ',
	        M : 'ⴰⵢoⵓⵔ',
	        MM : '%d ⵉⵢⵢⵉⵔⵏ',
	        y : 'ⴰⵙⴳⴰⵙ',
	        yy : '%d ⵉⵙⴳⴰⵙⵏ'
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tzm;

	})));


/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight Latin [tzm-latn]
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var tzmLatn = moment.defineLocale('tzm-latn', {
	    months : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	    monthsShort : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	    weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	    weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	    weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[asdkh g] LT',
	        nextDay: '[aska g] LT',
	        nextWeek: 'dddd [g] LT',
	        lastDay: '[assant g] LT',
	        lastWeek: 'dddd [g] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dadkh s yan %s',
	        past : 'yan %s',
	        s : 'imik',
	        m : 'minuḍ',
	        mm : '%d minuḍ',
	        h : 'saɛa',
	        hh : '%d tassaɛin',
	        d : 'ass',
	        dd : '%d ossan',
	        M : 'ayowr',
	        MM : '%d iyyirn',
	        y : 'asgas',
	        yy : '%d isgasn'
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tzmLatn;

	})));


/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Ukrainian [uk]
	//! author : zemlanin : https://github.com/zemlanin
	//! Author : Menelion Elensúle : https://github.com/Oire

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
	        'hh': withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
	        'dd': 'день_дні_днів',
	        'MM': 'місяць_місяці_місяців',
	        'yy': 'рік_роки_років'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? 'хвилина' : 'хвилину';
	    }
	    else if (key === 'h') {
	        return withoutSuffix ? 'година' : 'годину';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}
	function weekdaysCaseReplace(m, format) {
	    var weekdays = {
	        'nominative': 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
	        'accusative': 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
	        'genitive': 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_')
	    },
	    nounCase = (/(\[[ВвУу]\]) ?dddd/).test(format) ?
	        'accusative' :
	        ((/\[?(?:минулої|наступної)? ?\] ?dddd/).test(format) ?
	            'genitive' :
	            'nominative');
	    return weekdays[nounCase][m.day()];
	}
	function processHoursFunction(str) {
	    return function () {
	        return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
	    };
	}

	var uk = moment.defineLocale('uk', {
	    months : {
	        'format': 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_'),
	        'standalone': 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_')
	    },
	    monthsShort : 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
	    weekdays : weekdaysCaseReplace,
	    weekdaysShort : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	    weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY р.',
	        LLL : 'D MMMM YYYY р., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY р., HH:mm'
	    },
	    calendar : {
	        sameDay: processHoursFunction('[Сьогодні '),
	        nextDay: processHoursFunction('[Завтра '),
	        lastDay: processHoursFunction('[Вчора '),
	        nextWeek: processHoursFunction('[У] dddd ['),
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return processHoursFunction('[Минулої] dddd [').call(this);
	                case 1:
	                case 2:
	                case 4:
	                    return processHoursFunction('[Минулого] dddd [').call(this);
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'за %s',
	        past : '%s тому',
	        s : 'декілька секунд',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : 'годину',
	        hh : relativeTimeWithPlural,
	        d : 'день',
	        dd : relativeTimeWithPlural,
	        M : 'місяць',
	        MM : relativeTimeWithPlural,
	        y : 'рік',
	        yy : relativeTimeWithPlural
	    },
	    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	    meridiemParse: /ночі|ранку|дня|вечора/,
	    isPM: function (input) {
	        return /^(дня|вечора)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'ночі';
	        } else if (hour < 12) {
	            return 'ранку';
	        } else if (hour < 17) {
	            return 'дня';
	        } else {
	            return 'вечора';
	        }
	    },
	    ordinalParse: /\d{1,2}-(й|го)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return number + '-й';
	            case 'D':
	                return number + '-го';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return uk;

	})));


/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Uzbek [uz]
	//! author : Sardor Muminov : https://github.com/muminoff

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var uz = moment.defineLocale('uz', {
	    months : 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
	    monthsShort : 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
	    weekdays : 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
	    weekdaysShort : 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
	    weekdaysMin : 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'D MMMM YYYY, dddd HH:mm'
	    },
	    calendar : {
	        sameDay : '[Бугун соат] LT [да]',
	        nextDay : '[Эртага] LT [да]',
	        nextWeek : 'dddd [куни соат] LT [да]',
	        lastDay : '[Кеча соат] LT [да]',
	        lastWeek : '[Утган] dddd [куни соат] LT [да]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'Якин %s ичида',
	        past : 'Бир неча %s олдин',
	        s : 'фурсат',
	        m : 'бир дакика',
	        mm : '%d дакика',
	        h : 'бир соат',
	        hh : '%d соат',
	        d : 'бир кун',
	        dd : '%d кун',
	        M : 'бир ой',
	        MM : '%d ой',
	        y : 'бир йил',
	        yy : '%d йил'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return uz;

	})));


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Vietnamese [vi]
	//! author : Bang Nguyen : https://github.com/bangnk

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var vi = moment.defineLocale('vi', {
	    months : 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
	    monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
	    weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	    weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	    weekdaysParseExact : true,
	    meridiemParse: /sa|ch/i,
	    isPM : function (input) {
	        return /^ch$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower ? 'sa' : 'SA';
	        } else {
	            return isLower ? 'ch' : 'CH';
	        }
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM [năm] YYYY',
	        LLL : 'D MMMM [năm] YYYY HH:mm',
	        LLLL : 'dddd, D MMMM [năm] YYYY HH:mm',
	        l : 'DD/M/YYYY',
	        ll : 'D MMM YYYY',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd, D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hôm nay lúc] LT',
	        nextDay: '[Ngày mai lúc] LT',
	        nextWeek: 'dddd [tuần tới lúc] LT',
	        lastDay: '[Hôm qua lúc] LT',
	        lastWeek: 'dddd [tuần rồi lúc] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s tới',
	        past : '%s trước',
	        s : 'vài giây',
	        m : 'một phút',
	        mm : '%d phút',
	        h : 'một giờ',
	        hh : '%d giờ',
	        d : 'một ngày',
	        dd : '%d ngày',
	        M : 'một tháng',
	        MM : '%d tháng',
	        y : 'một năm',
	        yy : '%d năm'
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return vi;

	})));


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Pseudo [x-pseudo]
	//! author : Andrew Hood : https://github.com/andrewhood125

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var xPseudo = moment.defineLocale('x-pseudo', {
	    months : 'J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér'.split('_'),
	    monthsShort : 'J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý'.split('_'),
	    weekdaysShort : 'S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát'.split('_'),
	    weekdaysMin : 'S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[T~ódá~ý át] LT',
	        nextDay : '[T~ómó~rró~w át] LT',
	        nextWeek : 'dddd [át] LT',
	        lastDay : '[Ý~ést~érdá~ý át] LT',
	        lastWeek : '[L~ást] dddd [át] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'í~ñ %s',
	        past : '%s á~gó',
	        s : 'á ~féw ~sécó~ñds',
	        m : 'á ~míñ~úté',
	        mm : '%d m~íñú~tés',
	        h : 'á~ñ hó~úr',
	        hh : '%d h~óúrs',
	        d : 'á ~dáý',
	        dd : '%d d~áýs',
	        M : 'á ~móñ~th',
	        MM : '%d m~óñt~hs',
	        y : 'á ~ýéár',
	        yy : '%d ý~éárs'
	    },
	    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return xPseudo;

	})));


/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Yoruba Nigeria [yo]
	//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var yo = moment.defineLocale('yo', {
	    months : 'Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀'.split('_'),
	    monthsShort : 'Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀'.split('_'),
	    weekdays : 'Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta'.split('_'),
	    weekdaysShort : 'Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá'.split('_'),
	    weekdaysMin : 'Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Ònì ni] LT',
	        nextDay : '[Ọ̀la ni] LT',
	        nextWeek : 'dddd [Ọsẹ̀ tón\'bọ] [ni] LT',
	        lastDay : '[Àna ni] LT',
	        lastWeek : 'dddd [Ọsẹ̀ tólọ́] [ni] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ní %s',
	        past : '%s kọjá',
	        s : 'ìsẹjú aayá die',
	        m : 'ìsẹjú kan',
	        mm : 'ìsẹjú %d',
	        h : 'wákati kan',
	        hh : 'wákati %d',
	        d : 'ọjọ́ kan',
	        dd : 'ọjọ́ %d',
	        M : 'osù kan',
	        MM : 'osù %d',
	        y : 'ọdún kan',
	        yy : 'ọdún %d'
	    },
	    ordinalParse : /ọjọ́\s\d{1,2}/,
	    ordinal : 'ọjọ́ %d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return yo;

	})));


/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (China) [zh-cn]
	//! author : suupic : https://github.com/suupic
	//! author : Zeno Zeng : https://github.com/zenozeng

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var zhCn = moment.defineLocale('zh-cn', {
	    months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	    weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	    weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),
	    weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	    longDateFormat : {
	        LT : 'Ah点mm分',
	        LTS : 'Ah点m分s秒',
	        L : 'YYYY-MM-DD',
	        LL : 'YYYY年MMMD日',
	        LLL : 'YYYY年MMMD日Ah点mm分',
	        LLLL : 'YYYY年MMMD日ddddAh点mm分',
	        l : 'YYYY-MM-DD',
	        ll : 'YYYY年MMMD日',
	        lll : 'YYYY年MMMD日Ah点mm分',
	        llll : 'YYYY年MMMD日ddddAh点mm分'
	    },
	    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '凌晨' || meridiem === '早上' ||
	                meridiem === '上午') {
	            return hour;
	        } else if (meridiem === '下午' || meridiem === '晚上') {
	            return hour + 12;
	        } else {
	            // '中午'
	            return hour >= 11 ? hour : hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '凌晨';
	        } else if (hm < 900) {
	            return '早上';
	        } else if (hm < 1130) {
	            return '上午';
	        } else if (hm < 1230) {
	            return '中午';
	        } else if (hm < 1800) {
	            return '下午';
	        } else {
	            return '晚上';
	        }
	    },
	    calendar : {
	        sameDay : function () {
	            return this.minutes() === 0 ? '[今天]Ah[点整]' : '[今天]LT';
	        },
	        nextDay : function () {
	            return this.minutes() === 0 ? '[明天]Ah[点整]' : '[明天]LT';
	        },
	        lastDay : function () {
	            return this.minutes() === 0 ? '[昨天]Ah[点整]' : '[昨天]LT';
	        },
	        nextWeek : function () {
	            var startOfWeek, prefix;
	            startOfWeek = moment().startOf('week');
	            prefix = this.diff(startOfWeek, 'days') >= 7 ? '[下]' : '[本]';
	            return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
	        },
	        lastWeek : function () {
	            var startOfWeek, prefix;
	            startOfWeek = moment().startOf('week');
	            prefix = this.unix() < startOfWeek.unix()  ? '[上]' : '[本]';
	            return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
	        },
	        sameElse : 'LL'
	    },
	    ordinalParse: /\d{1,2}(日|月|周)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '日';
	            case 'M':
	                return number + '月';
	            case 'w':
	            case 'W':
	                return number + '周';
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s内',
	        past : '%s前',
	        s : '几秒',
	        m : '1 分钟',
	        mm : '%d 分钟',
	        h : '1 小时',
	        hh : '%d 小时',
	        d : '1 天',
	        dd : '%d 天',
	        M : '1 个月',
	        MM : '%d 个月',
	        y : '1 年',
	        yy : '%d 年'
	    },
	    week : {
	        // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return zhCn;

	})));


/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Hong Kong) [zh-hk]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris
	//! author : Konstantin : https://github.com/skfd

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var zhHk = moment.defineLocale('zh-hk', {
	    months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	    weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	    weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
	    weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	    longDateFormat : {
	        LT : 'Ah點mm分',
	        LTS : 'Ah點m分s秒',
	        L : 'YYYY年MMMD日',
	        LL : 'YYYY年MMMD日',
	        LLL : 'YYYY年MMMD日Ah點mm分',
	        LLLL : 'YYYY年MMMD日ddddAh點mm分',
	        l : 'YYYY年MMMD日',
	        ll : 'YYYY年MMMD日',
	        lll : 'YYYY年MMMD日Ah點mm分',
	        llll : 'YYYY年MMMD日ddddAh點mm分'
	    },
	    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
	            return hour;
	        } else if (meridiem === '中午') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === '下午' || meridiem === '晚上') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '凌晨';
	        } else if (hm < 900) {
	            return '早上';
	        } else if (hm < 1130) {
	            return '上午';
	        } else if (hm < 1230) {
	            return '中午';
	        } else if (hm < 1800) {
	            return '下午';
	        } else {
	            return '晚上';
	        }
	    },
	    calendar : {
	        sameDay : '[今天]LT',
	        nextDay : '[明天]LT',
	        nextWeek : '[下]ddddLT',
	        lastDay : '[昨天]LT',
	        lastWeek : '[上]ddddLT',
	        sameElse : 'L'
	    },
	    ordinalParse: /\d{1,2}(日|月|週)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '日';
	            case 'M' :
	                return number + '月';
	            case 'w' :
	            case 'W' :
	                return number + '週';
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s內',
	        past : '%s前',
	        s : '幾秒',
	        m : '1 分鐘',
	        mm : '%d 分鐘',
	        h : '1 小時',
	        hh : '%d 小時',
	        d : '1 天',
	        dd : '%d 天',
	        M : '1 個月',
	        MM : '%d 個月',
	        y : '1 年',
	        yy : '%d 年'
	    }
	});

	return zhHk;

	})));


/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Taiwan) [zh-tw]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris

	;(function (global, factory) {
	    true ? factory(__webpack_require__(305)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var zhTw = moment.defineLocale('zh-tw', {
	    months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	    weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	    weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
	    weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	    longDateFormat : {
	        LT : 'Ah點mm分',
	        LTS : 'Ah點m分s秒',
	        L : 'YYYY年MMMD日',
	        LL : 'YYYY年MMMD日',
	        LLL : 'YYYY年MMMD日Ah點mm分',
	        LLLL : 'YYYY年MMMD日ddddAh點mm分',
	        l : 'YYYY年MMMD日',
	        ll : 'YYYY年MMMD日',
	        lll : 'YYYY年MMMD日Ah點mm分',
	        llll : 'YYYY年MMMD日ddddAh點mm分'
	    },
	    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
	            return hour;
	        } else if (meridiem === '中午') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === '下午' || meridiem === '晚上') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '凌晨';
	        } else if (hm < 900) {
	            return '早上';
	        } else if (hm < 1130) {
	            return '上午';
	        } else if (hm < 1230) {
	            return '中午';
	        } else if (hm < 1800) {
	            return '下午';
	        } else {
	            return '晚上';
	        }
	    },
	    calendar : {
	        sameDay : '[今天]LT',
	        nextDay : '[明天]LT',
	        nextWeek : '[下]ddddLT',
	        lastDay : '[昨天]LT',
	        lastWeek : '[上]ddddLT',
	        sameElse : 'L'
	    },
	    ordinalParse: /\d{1,2}(日|月|週)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '日';
	            case 'M' :
	                return number + '月';
	            case 'w' :
	            case 'W' :
	                return number + '週';
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s內',
	        past : '%s前',
	        s : '幾秒',
	        m : '1 分鐘',
	        mm : '%d 分鐘',
	        h : '1 小時',
	        hh : '%d 小時',
	        d : '1 天',
	        dd : '%d 天',
	        M : '1 個月',
	        MM : '%d 個月',
	        y : '1 年',
	        yy : '%d 年'
	    }
	});

	return zhTw;

	})));


/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var isEmptyObject = __webpack_require__(417).isEmptyObject;

	/*
	 * Handles trading page default values
	 *
	 * Priorities:
	 * 1. Client's input: on each change to form, it will reflect to both query string & session storage
	 * 2. Local storage values: if none of the above, it will be the source
	 *
	 */

	var MBDefaults = function () {
	    'use strict';

	    var params = {};
	    var getDefault = function getDefault(key) {
	        loadParams();
	        return params[key];
	    };

	    var loadParams = function loadParams() {
	        if (isEmptyObject(params)) params = JSON.parse(localStorage.getItem('mb_trading')) || {};
	    };

	    var saveParams = function saveParams() {
	        localStorage.setItem('mb_trading', JSON.stringify(params));
	    };

	    var setDefault = function setDefault(key, value) {
	        if (!key) return;
	        value = value || '';
	        loadParams();
	        if (params[key] !== value) {
	            params[key] = value;
	            saveParams();
	        }
	    };

	    var removeDefault = function removeDefault() {
	        for (var _len = arguments.length, keys = Array(_len), _key = 0; _key < _len; _key++) {
	            keys[_key] = arguments[_key];
	        }

	        loadParams();
	        var is_updated = false;
	        keys.forEach(function (key) {
	            if (key in params) {
	                delete params[key];
	                is_updated = true;
	            }
	        });
	        if (is_updated) {
	            saveParams();
	        }
	    };

	    return {
	        get: getDefault,
	        set: setDefault,
	        remove: removeDefault,
	        clear: function clear() {
	            params = {};
	        }
	    };
	}();

	module.exports = MBDefaults;

/***/ },
/* 417 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Write loading image to a container for ajax request
	 *
	 * @param container: a jQuery object
	 * @param theme: dark or white
	 */
	var showLoadingImage = function showLoadingImage(container) {
	    var theme = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'dark';

	    container.empty().append('<div class="barspinner ' + theme + '"><div class="rect1"></div><div class="rect2"></div><div class="rect3"></div><div class="rect4"></div><div class="rect5"></div></div>');
	};

	/**
	 * Returns the highest z-index in the page.
	 * Accepts a jquery style selector to only check those elements,
	 * uses all container tags by default
	 * If no element found, returns null.
	 *
	 * @param selector: a jquery style selector for target elements
	 * @return int|null
	 */
	var getHighestZIndex = function getHighestZIndex(selector) {
	    if (!selector) {
	        selector = 'div,p,area,nav,section,header,canvas,aside,span';
	    }
	    var all = [];
	    var _store_zindex = function _store_zindex() {
	        if ($(this).is(':visible')) {
	            var z = $(this).css('z-index');
	            if (!isNaN(z)) {
	                all.push(z);
	            }
	        }
	    };
	    $(selector).each(_store_zindex);

	    return all.length ? Math.max.apply(Math, all) : null;
	};

	var downloadCSV = function downloadCSV(csv_contents, filename) {
	    filename = filename || 'data.csv';
	    if (navigator.msSaveBlob) {
	        // IE 10+
	        navigator.msSaveBlob(new Blob([csv_contents], { type: 'text/csv;charset=utf-8;' }), filename);
	    } else {
	        // Other browsers
	        var csv = 'data:text/csv;charset=utf-8,' + csv_contents;
	        var download_link = document.createElement('a');
	        download_link.href = encodeURI(csv);
	        download_link.download = filename;

	        document.body.appendChild(download_link);
	        download_link.click();
	        document.body.removeChild(download_link);
	    }
	};

	var template = function template(string, content) {
	    return string.replace(/\[_(\d+)]/g, function (s, index) {
	        return content[+index - 1];
	    });
	};

	var isEmptyObject = function isEmptyObject(obj) {
	    var is_empty = true;
	    if (obj && obj instanceof Object) {
	        Object.keys(obj).forEach(function (key) {
	            if (obj.hasOwnProperty(key)) is_empty = false;
	        });
	    }
	    return is_empty;
	};

	var cloneObject = function cloneObject(obj) {
	    return !isEmptyObject(obj) ? $.extend({}, obj) : obj;
	};

	var getPropertyValue = function getPropertyValue(obj, keys) {
	    if (!Array.isArray(keys)) keys = [keys];
	    if (!isEmptyObject(obj) && keys[0] in obj && keys && keys.length > 1) {
	        return getPropertyValue(obj[keys[0]], keys.slice(1));
	    }
	    // else return clone of object to avoid overwriting data
	    return obj ? cloneObject(obj[keys[0]]) : undefined;
	};

	var handleHash = function handleHash() {
	    var hash = window.location.hash;
	    if (hash) {
	        $('a[href="' + hash + '"]').click();
	    }
	};

	var clearable = function clearable(element) {
	    element.addClass('clear');
	    $(document).on('mousemove', '.clear', function (e) {
	        e.stopPropagation();
	        $(e.currentTarget)[toggleAddRemoveClass(this.offsetWidth - 18 < e.clientX - this.getBoundingClientRect().left)]('onClear');
	    }).on('mousedown', '.onClear', function (e) {
	        e.stopPropagation();
	        $(e.currentTarget).attr('data-value', '');
	        $(e.currentTarget).removeClass('clear onClear').val('').change();
	    });
	};

	var toggleAddRemoveClass = function toggleAddRemoveClass(condition) {
	    return condition ? 'addClass' : 'removeClass';
	};

	module.exports = {
	    showLoadingImage: showLoadingImage,
	    getHighestZIndex: getHighestZIndex,
	    downloadCSV: downloadCSV,
	    template: template,
	    isEmptyObject: isEmptyObject,
	    getPropertyValue: getPropertyValue,
	    handleHash: handleHash,
	    clearable: clearable
	};

/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ActiveSymbols = __webpack_require__(419);

	/*
	 * MBSymbols object parses the active_symbols json that we get from socket.send({active_symbols: 'brief'}
	 * and outputs in usable form, it gives markets, underlyings
	 *
	 *
	 * Usage:
	 *
	 * use `MBSymbols.details` to populate this object first
	 *
	 * then use
	 *
	 * `MBSymbols.markets` to get markets like Forex
	 * `MBSymbols.underlyings` to get underlyings
	 *
	 */

	var MBSymbols = function () {
	    'use strict';

	    var trade_markets = {},
	        trade_markets_list = {},
	        trade_underlyings = {},
	        all_symbols = {},
	        names = {};

	    var details = function details(data) {
	        ActiveSymbols.clearData();
	        var active_symbols = data.active_symbols;
	        trade_markets = ActiveSymbols.getMarkets(active_symbols);
	        trade_markets_list = ActiveSymbols.getMarketsList(active_symbols);
	        trade_underlyings = ActiveSymbols.getTradeUnderlyings(active_symbols);
	        all_symbols = ActiveSymbols.getSymbols(all_symbols);
	        names = ActiveSymbols.getSymbolNames(active_symbols);
	    };

	    return {
	        details: details,
	        markets: function markets(list) {
	            return list ? trade_markets_list : trade_markets;
	        },
	        underlyings: function underlyings() {
	            return trade_underlyings;
	        },
	        getName: function getName(symbol) {
	            return names[symbol];
	        },
	        getAllSymbols: function getAllSymbols() {
	            return all_symbols;
	        },
	        clearData: function clearData() {
	            ActiveSymbols.clearData();
	        }
	    };
	}();

	module.exports = MBSymbols;

/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var isEmptyObject = __webpack_require__(417).isEmptyObject;

	var ActiveSymbols = function () {
	    'use strict';

	    var groupBy = function groupBy(xs, key) {
	        return xs.reduce(function (rv, x) {
	            (rv[x[key]] = rv[x[key]] || []).push(x);
	            return rv;
	        }, {});
	    };

	    var extend = function extend(a, b) {
	        if (!a || !b) return null;
	        Object.keys(b).forEach(function (key) {
	            a[key] = b[key];
	        });
	        return a;
	    };

	    var clone = function clone(obj) {
	        return extend({}, obj);
	    };

	    var markets = {},
	        submarkets = {},
	        symbols = {};

	    var getMarkets = function getMarkets(all_symbols) {
	        if (!isEmptyObject(markets)) {
	            return clone(markets);
	        }

	        var all_markets = groupBy(all_symbols, 'market');
	        Object.keys(all_markets).forEach(function (key) {
	            var market_name = key;
	            var market_symbols = all_markets[key];
	            var symbol = market_symbols[0];
	            markets[market_name] = {
	                name: symbol.market_display_name,
	                is_active: !symbol.is_trading_suspended && symbol.exchange_is_open
	            };
	            getSubmarketsForMarket(market_symbols, markets[market_name]);
	        });
	        return clone(markets);
	    };

	    var clearData = function clearData() {
	        markets = {};
	        symbols = {};
	        submarkets = {};
	    };

	    var getSubmarketsForMarket = function getSubmarketsForMarket(all_symbols, market) {
	        if (!isEmptyObject(market.submarkets)) {
	            return clone(market.submarkets);
	        }
	        market.submarkets = {};
	        var all_submarkets = groupBy(all_symbols, 'submarket');
	        Object.keys(all_submarkets).forEach(function (key) {
	            var submarket_name = key;
	            var submarket_symbols = all_submarkets[key];
	            var symbol = submarket_symbols[0];
	            market.submarkets[submarket_name] = {
	                name: symbol.submarket_display_name,
	                is_active: !symbol.is_trading_suspended && symbol.exchange_is_open
	            };
	            getSymbolsForSubmarket(submarket_symbols, market.submarkets[submarket_name]);
	        });
	        return clone(market.submarkets);
	    };

	    var getSymbolsForSubmarket = function getSymbolsForSubmarket(all_symbols, submarket) {
	        if (isEmptyObject(submarket.symbols)) {
	            submarket.symbols = {};
	            all_symbols.forEach(function (symbol) {
	                submarket.symbols[symbol.symbol] = {
	                    display: symbol.display_name,
	                    symbol_type: symbol.symbol_type,
	                    is_active: !symbol.is_trading_suspended && symbol.exchange_is_open,
	                    pip: symbol.pip,
	                    market: symbol.market,
	                    submarket: symbol.submarket
	                };
	            });
	        }
	        return clone(submarket.symbols);
	    };

	    var getSubmarkets = function getSubmarkets(active_symbols) {
	        if (isEmptyObject(submarkets)) {
	            var all_markets = getMarkets(active_symbols);
	            Object.keys(all_markets).forEach(function (key) {
	                var market = all_markets[key];
	                var all_submarkets = getSubmarketsForMarket(active_symbols, market);
	                extend(submarkets, all_submarkets);
	            });
	        }
	        return clone(submarkets);
	    };

	    var getSymbols = function getSymbols(active_symbols) {
	        if (isEmptyObject(symbols)) {
	            var all_submarkets = getSubmarkets(active_symbols);
	            Object.keys(all_submarkets).forEach(function (key) {
	                var submarket = all_submarkets[key];
	                var all_symbols = getSymbolsForSubmarket(active_symbols, submarket);
	                extend(symbols, all_symbols);
	            });
	        }
	        return clone(symbols);
	    };

	    var getMarketsList = function getMarketsList(active_symbols) {
	        var trade_markets_list = {};
	        extend(trade_markets_list, getMarkets(active_symbols));
	        extend(trade_markets_list, getSubmarkets(active_symbols));
	        return trade_markets_list;
	    };

	    var getTradeUnderlyings = function getTradeUnderlyings(active_symbols) {
	        var trade_underlyings = {};
	        var all_symbols = getSymbols(active_symbols);
	        Object.keys(all_symbols).forEach(function (key) {
	            var symbol = all_symbols[key];
	            if (!trade_underlyings[symbol.market]) {
	                trade_underlyings[symbol.market] = {};
	            }
	            if (!trade_underlyings[symbol.submarket]) {
	                trade_underlyings[symbol.submarket] = {};
	            }
	            trade_underlyings[symbol.market][key] = symbol;
	            trade_underlyings[symbol.submarket][key] = symbol;
	        });
	        return trade_underlyings;
	    };

	    var getSymbolNames = function getSymbolNames(active_symbols) {
	        var all_symbols = clone(getSymbols(active_symbols));
	        Object.keys(all_symbols).forEach(function (key) {
	            all_symbols[key] = all_symbols[key].display;
	        });
	        return all_symbols;
	    };

	    return {
	        getMarkets: getMarkets,
	        getSubmarkets: getSubmarkets,
	        getMarketsList: getMarketsList,
	        getTradeUnderlyings: getTradeUnderlyings,
	        getSymbolNames: getSymbolNames,
	        clearData: clearData,
	        getSymbols: getSymbols
	    };
	}();

	module.exports = ActiveSymbols;

/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var CookieStorage = __webpack_require__(421).CookieStorage;
	var LocalStore = __webpack_require__(421).LocalStore;
	var State = __webpack_require__(421).State;
	var defaultRedirectUrl = __webpack_require__(423).defaultRedirectUrl;
	var getLoginToken = __webpack_require__(430).getLoginToken;
	var jpClient = __webpack_require__(425).jpClient;
	var BinarySocket = __webpack_require__(427);
	var RealityCheckData = __webpack_require__(432);
	var Cookies = __webpack_require__(422);

	var Client = function () {
	    'use strict';

	    var client_object = {};

	    var parseLoginIDList = function parseLoginIDList(string) {
	        if (!string) return [];
	        return string.split('+').sort().map(function (str) {
	            var items = str.split(':');
	            var id = items[0];
	            var is_real = items[1] === 'R';
	            var is_financial = /^MF/.test(id);
	            var is_gaming = /^MLT/.test(id);

	            if (is_real) client_object.has_real = is_real;
	            if (is_financial) client_object.has_financial = is_financial;
	            if (is_gaming) client_object.has_gaming = is_gaming;

	            return {
	                id: id,
	                real: is_real,
	                disabled: items[2] === 'D',
	                financial: is_financial,
	                non_financial: is_gaming
	            };
	        });
	    };

	    var init = function init() {
	        client_object.loginid_array = parseLoginIDList(Cookies.get('loginid_list') || '');

	        set('email', Cookies.get('email'));
	        set('loginid', Cookies.get('loginid'));
	        set('residence', Cookies.get('residence'));
	    };

	    var isLoggedIn = function isLoggedIn() {
	        return get('tokens') && getLoginToken() && Cookies.get('loginid') && client_object.loginid_array.length > 0;
	    };

	    var validateLoginid = function validateLoginid() {
	        var loginid_list = Cookies.get('loginid_list');
	        var client_id = Cookies.get('loginid');
	        if (!client_id || !loginid_list) return;

	        var valid_login_ids = new RegExp('^(MX|MF|VRTC|MLT|CR|FOG|VRTJ|JP)[0-9]+$', 'i');

	        if (!valid_login_ids.test(client_id)) {
	            sendLogoutRequest();
	        }

	        loginid_list.split('+').forEach(function (acc_id) {
	            if (!valid_login_ids.test(acc_id.split(':')[0])) {
	                sendLogoutRequest();
	            }
	        });
	    };

	    var set = function set(key, value) {
	        client_object[key] = value;
	        return LocalStore.set('client.' + key, value);
	    };

	    // use this function to get variables that have values
	    var get = function get(key) {
	        var value = client_object[key] || LocalStore.get('client.' + key) || '';
	        if (!Array.isArray(value) && (+value === 1 || +value === 0 || value === 'true' || value === 'false')) {
	            value = JSON.parse(value || false);
	        }
	        return value;
	    };

	    var responseAuthorize = function responseAuthorize(response) {
	        var authorize = response.authorize;
	        if (!Cookies.get('email')) {
	            setCookie('email', authorize.email);
	            set('email', authorize.email);
	        }
	        set('session_start', parseInt(moment().valueOf() / 1000));
	        set('is_virtual', authorize.is_virtual);
	        set('landing_company_name', authorize.landing_company_name);
	        set('landing_company_fullname', authorize.landing_company_fullname);
	        set('currency', authorize.currency);
	    };

	    var shouldAcceptTnc = function shouldAcceptTnc() {
	        if (get('is_virtual')) return false;
	        var website_tnc_version = State.get(['response', 'website_status', 'website_status', 'terms_conditions_version']);
	        var get_settings = State.get(['response', 'get_settings', 'get_settings']);
	        return get_settings.hasOwnProperty('client_tnc_status') && get_settings.client_tnc_status !== website_tnc_version;
	    };

	    var clear = function clear() {
	        // clear all client values from local storage
	        Object.keys(localStorage).forEach(function (c) {
	            if (/^client\.(?!(tokens$))/.test(c)) {
	                LocalStore.set(c, '');
	            }
	        });
	        var hash = window.location.hash;
	        if (/no-reality-check/.test(hash)) {
	            window.location.hash = hash.replace('no-reality-check', '');
	        }
	    };

	    var getToken = function getToken(client_loginid) {
	        var token = void 0;
	        var tokens = get('tokens');
	        if (client_loginid && tokens) {
	            var tokens_obj = JSON.parse(tokens);
	            if (tokens_obj.hasOwnProperty(client_loginid) && tokens_obj[client_loginid]) {
	                token = tokens_obj[client_loginid];
	            }
	        }
	        return token;
	    };

	    var addToken = function addToken(client_loginid, token) {
	        if (!client_loginid || !token || getToken(client_loginid)) {
	            return false;
	        }
	        var tokens = get('tokens');
	        var tokens_obj = tokens && tokens.length > 0 ? JSON.parse(tokens) : {};
	        tokens_obj[client_loginid] = token;
	        set('tokens', JSON.stringify(tokens_obj));
	        return true;
	    };

	    var setCookie = function setCookie(cookie_name, Value, domain) {
	        var cookie_expire = new Date();
	        cookie_expire.setDate(cookie_expire.getDate() + 60);
	        var cookie = new CookieStorage(cookie_name, domain);
	        cookie.write(Value, cookie_expire, true);
	    };

	    var processNewAccount = function processNewAccount(client_email, client_loginid, token, virtual_client) {
	        if (!client_email || !client_loginid || !token) {
	            return;
	        }
	        // save token
	        addToken(client_loginid, token);
	        // set cookies
	        setCookie('email', client_email);
	        setCookie('login', token);
	        setCookie('loginid', client_loginid);
	        setCookie('loginid_list', virtual_client ? client_loginid + ':V:E' : client_loginid + ':R:E+' + Cookies.get('loginid_list'));
	        // set local storage
	        localStorage.setItem('GTM_new_account', '1');
	        localStorage.setItem('active_loginid', client_loginid);
	        RealityCheckData.clear();
	        window.location.href = defaultRedirectUrl(); // need to redirect not using pjax
	    };

	    var hasShortCode = function hasShortCode(data, code) {
	        return (data || {}).shortcode === code;
	    };

	    var canUpgradeGamingToFinancial = function canUpgradeGamingToFinancial(data) {
	        return hasShortCode(data.financial_company, 'maltainvest');
	    };

	    var canUpgradeVirtualToFinancial = function canUpgradeVirtualToFinancial(data) {
	        return !data.gaming_company && hasShortCode(data.financial_company, 'maltainvest');
	    };

	    var canUpgradeVirtualToJapan = function canUpgradeVirtualToJapan(data) {
	        return !data.gaming_company && hasShortCode(data.financial_company, 'japan');
	    };

	    var hasGamingFinancialEnabled = function hasGamingFinancialEnabled() {
	        var has_financial = false,
	            has_gaming = false;

	        client_object.loginid_array.forEach(function (client) {
	            if (!client.disabled) {
	                if (client.financial) {
	                    has_financial = true;
	                } else if (client.non_financial) {
	                    has_gaming = true;
	                }
	            }
	        });

	        return has_gaming && has_financial;
	    };

	    var activateByClientType = function activateByClientType() {
	        var section = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'body';

	        if (isLoggedIn()) {
	            BinarySocket.wait('authorize', 'website_status').then(function () {
	                $('#client-logged-in').addClass('gr-centered');
	                $('.client_logged_in').setVisibility(1);
	                if (get('is_virtual')) {
	                    $(section).find('.client_virtual').setVisibility(1);
	                    $('#topbar').addClass('secondary-bg-color').removeClass('primary-color-dark');
	                } else {
	                    $(section).find('.client_real').not(jpClient() ? '.ja-hide' : '').setVisibility(1);
	                    $('#topbar').addClass('primary-color-dark').removeClass('secondary-bg-color');
	                }
	            });
	        } else {
	            $(section).find('.client_logged_out').setVisibility(1);
	            $('#topbar').addClass('primary-color-dark').removeClass('secondary-bg-color');
	        }
	    };

	    var sendLogoutRequest = function sendLogoutRequest(show_login_page) {
	        if (show_login_page) {
	            sessionStorage.setItem('showLoginPage', 1);
	        }
	        BinarySocket.send({ logout: '1' });
	    };

	    var doLogout = function doLogout(response) {
	        if (response.logout !== 1) return;
	        clear();
	        LocalStore.remove('client.tokens');
	        var cookies = ['login', 'loginid', 'loginid_list', 'email', 'settings', 'reality_check', 'affiliate_token', 'affiliate_tracking', 'residence'];
	        var domains = ['.' + document.domain.split('.').slice(-2).join('.'), '.' + document.domain];

	        var parent_path = window.location.pathname.split('/', 2)[1];
	        if (parent_path !== '') {
	            parent_path = '/' + parent_path;
	        }

	        cookies.forEach(function (c) {
	            var regex = new RegExp(c);
	            Cookies.remove(c, { path: '/', domain: domains[0] });
	            Cookies.remove(c, { path: '/', domain: domains[1] });
	            Cookies.remove(c);
	            if (regex.test(document.cookie) && parent_path) {
	                Cookies.remove(c, { path: parent_path, domain: domains[0] });
	                Cookies.remove(c, { path: parent_path, domain: domains[1] });
	                Cookies.remove(c, { path: parent_path });
	            }
	        });
	        window.location.reload();
	    };

	    var currentLandingCompany = function currentLandingCompany() {
	        var landing_company_response = State.get(['response', 'landing_company', 'landing_company']) || {};
	        var client_landing_company = {};
	        Object.keys(landing_company_response).forEach(function (key) {
	            if (client_object.landing_company_name === landing_company_response[key].shortcode) {
	                client_landing_company = landing_company_response[key];
	            }
	        });
	        return client_landing_company;
	    };

	    var isFinancial = function isFinancial() {
	        return (client_object.loginid_array.find(function (obj) {
	            return obj.id === get('loginid');
	        }) || {}).financial;
	    };

	    var shouldCompleteTax = function shouldCompleteTax() {
	        return isFinancial() && !/crs_tin_information/.test((State.get(['response', 'get_account_status', 'get_account_status']) || {}).status);
	    };

	    return {
	        init: init,
	        validateLoginid: validateLoginid,
	        set: set,
	        get: get,
	        responseAuthorize: responseAuthorize,
	        shouldAcceptTnc: shouldAcceptTnc,
	        clear: clear,
	        getToken: getToken,
	        setCookie: setCookie,
	        processNewAccount: processNewAccount,
	        isLoggedIn: isLoggedIn,
	        sendLogoutRequest: sendLogoutRequest,
	        doLogout: doLogout,
	        isFinancial: isFinancial,
	        shouldCompleteTax: shouldCompleteTax,

	        canUpgradeGamingToFinancial: canUpgradeGamingToFinancial,
	        canUpgradeVirtualToFinancial: canUpgradeVirtualToFinancial,
	        canUpgradeVirtualToJapan: canUpgradeVirtualToJapan,
	        hasGamingFinancialEnabled: hasGamingFinancialEnabled,
	        activateByClientType: activateByClientType,
	        currentLandingCompany: currentLandingCompany
	    };
	}();

	module.exports = Client;

/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var getPropertyValue = __webpack_require__(417).getPropertyValue;
	var isEmptyObject = __webpack_require__(417).isEmptyObject;
	var Cookies = __webpack_require__(422);

	var isStorageSupported = function isStorageSupported(storage) {
	    if (typeof storage === 'undefined') {
	        return false;
	    }

	    var test_key = 'test';
	    try {
	        storage.setItem(test_key, '1');
	        storage.removeItem(test_key);
	        return true;
	    } catch (e) {
	        return false;
	    }
	};

	var Store = function Store(storage) {
	    this.storage = storage;
	};

	Store.prototype = {
	    get: function get(key) {
	        return this.storage.getItem(key) || undefined;
	    },
	    set: function set(key, value) {
	        if (typeof value !== 'undefined') {
	            this.storage.setItem(key, value);
	        }
	    },
	    remove: function remove(key) {
	        this.storage.removeItem(key);
	    },
	    clear: function clear() {
	        this.storage.clear();
	    }
	};

	var InScriptStore = function InScriptStore(object) {
	    this.store = typeof object !== 'undefined' ? object : {};
	};

	InScriptStore.prototype = {
	    get: function get(key) {
	        return getPropertyValue(this.store, key);
	    },
	    set: function set(key, value) {
	        var obj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.store;

	        if (!Array.isArray(key)) key = [key];
	        if (key.length > 1) {
	            if (!(key[0] in obj) || isEmptyObject(obj[key[0]])) obj[key[0]] = {};
	            this.set(key.slice(1), value, obj[key[0]]);
	        } else {
	            obj[key[0]] = value;
	        }
	    },
	    remove: function remove() {
	        var _this = this;

	        for (var _len = arguments.length, keys = Array(_len), _key = 0; _key < _len; _key++) {
	            keys[_key] = arguments[_key];
	        }

	        keys.forEach(function (key) {
	            delete _this.store[key];
	        });
	    },
	    clear: function clear() {
	        this.store = {};
	    },
	    has: function has(key) {
	        return this.get(key) !== undefined;
	    },
	    keys: function keys() {
	        return Object.keys(this.store);
	    },
	    call: function call(key) {
	        if (typeof this.get(key) === 'function') this.get(key)();
	    }
	};

	var State = new InScriptStore();
	State.set('response', {});

	var CookieStorage = function CookieStorage(cookie_name, cookie_domain) {
	    this.initialized = false;
	    this.cookie_name = cookie_name;
	    var hostname = window.location.hostname;
	    this.domain = cookie_domain || (/\.binary\.com/i.test(hostname) ? '.' + hostname.split('.').slice(-2).join('.') : hostname);
	    this.path = '/';
	    this.expires = new Date('Thu, 1 Jan 2037 12:00:00 GMT');
	    this.value = {};
	};

	CookieStorage.prototype = {
	    read: function read() {
	        var cookie_value = Cookies.get(this.cookie_name);
	        try {
	            this.value = cookie_value ? JSON.parse(cookie_value) : {};
	        } catch (e) {
	            this.value = {};
	        }
	        this.initialized = true;
	    },
	    write: function write(val, expireDate, isSecure) {
	        if (!this.initialized) this.read();
	        this.value = val;
	        if (expireDate) this.expires = expireDate;
	        Cookies.set(this.cookie_name, this.value, {
	            expires: this.expires,
	            path: this.path,
	            domain: this.domain,
	            secure: !!isSecure
	        });
	    },
	    get: function get(key) {
	        if (!this.initialized) this.read();
	        return this.value[key];
	    },
	    set: function set(key, val) {
	        if (!this.initialized) this.read();
	        this.value[key] = val;
	        Cookies.set(this.cookie_name, this.value, {
	            expires: new Date(this.expires),
	            path: this.path,
	            domain: this.domain
	        });
	    },
	    remove: function remove() {
	        Cookies.remove(this.cookie_name, {
	            path: this.path,
	            domain: this.domain
	        });
	    }
	};

	var SessionStore = void 0,
	    LocalStore = void 0;

	if (isStorageSupported(window.localStorage)) {
	    LocalStore = new Store(window.localStorage);
	}
	if (isStorageSupported(window.sessionStorage)) {
	    SessionStore = new Store(window.sessionStorage);
	}

	if (!LocalStore) {
	    LocalStore = new InScriptStore();
	}
	if (!SessionStore) {
	    SessionStore = new InScriptStore();
	}

	module.exports = {
	    isStorageSupported: isStorageSupported,
	    Store: Store,
	    InScriptStore: InScriptStore,
	    CookieStorage: CookieStorage,
	    State: State,
	    SessionStore: SessionStore,
	    LocalStore: LocalStore
	};

/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/*!
	 * JavaScript Cookie v2.1.2
	 * https://github.com/js-cookie/js-cookie
	 *
	 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
	 * Released under the MIT license
	 */
	;(function (factory) {
		if (true) {
			!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
			module.exports = factory();
		} else {
			var OldCookies = window.Cookies;
			var api = window.Cookies = factory();
			api.noConflict = function () {
				window.Cookies = OldCookies;
				return api;
			};
		}
	})(function () {
		function extend() {
			var i = 0;
			var result = {};
			for (; i < arguments.length; i++) {
				var attributes = arguments[i];
				for (var key in attributes) {
					result[key] = attributes[key];
				}
			}
			return result;
		}

		function init(converter) {
			function api(key, value, attributes) {
				var result;
				if (typeof document === 'undefined') {
					return;
				}

				// Write

				if (arguments.length > 1) {
					attributes = extend({
						path: '/'
					}, api.defaults, attributes);

					if (typeof attributes.expires === 'number') {
						var expires = new Date();
						expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);
						attributes.expires = expires;
					}

					try {
						result = JSON.stringify(value);
						if (/^[\{\[]/.test(result)) {
							value = result;
						}
					} catch (e) {}

					if (!converter.write) {
						value = encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
					} else {
						value = converter.write(value, key);
					}

					key = encodeURIComponent(String(key));
					key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
					key = key.replace(/[\(\)]/g, escape);

					return document.cookie = [key, '=', value, attributes.expires && '; expires=' + attributes.expires.toUTCString(), // use expires attribute, max-age is not supported by IE
					attributes.path && '; path=' + attributes.path, attributes.domain && '; domain=' + attributes.domain, attributes.secure ? '; secure' : ''].join('');
				}

				// Read

				if (!key) {
					result = {};
				}

				// To prevent the for loop in the first place assign an empty array
				// in case there are no cookies at all. Also prevents odd result when
				// calling "get()"
				var cookies = document.cookie ? document.cookie.split('; ') : [];
				var rdecode = /(%[0-9A-Z]{2})+/g;
				var i = 0;

				for (; i < cookies.length; i++) {
					var parts = cookies[i].split('=');
					var cookie = parts.slice(1).join('=');

					if (cookie.charAt(0) === '"') {
						cookie = cookie.slice(1, -1);
					}

					try {
						var name = parts[0].replace(rdecode, decodeURIComponent);
						cookie = converter.read ? converter.read(cookie, name) : converter(cookie, name) || cookie.replace(rdecode, decodeURIComponent);

						if (this.json) {
							try {
								cookie = JSON.parse(cookie);
							} catch (e) {}
						}

						if (key === name) {
							result = cookie;
							break;
						}

						if (!key) {
							result[name] = cookie;
						}
					} catch (e) {}
				}

				return result;
			}

			api.set = api;
			api.get = function (key) {
				return api(key);
			};
			api.getJSON = function () {
				return api.apply({
					json: true
				}, [].slice.call(arguments));
			};
			api.defaults = {};

			api.remove = function (key, attributes) {
				api(key, '', extend(attributes, {
					expires: -1
				}));
			};

			api.withConverter = init;

			return api;
		}

		return init(function () {});
	});

/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var getLanguage = __webpack_require__(424).get;
	var jpClient = __webpack_require__(425).jpClient;

	var Url = function () {
	    'use strict';

	    var location_url = void 0,
	        static_host = void 0;

	    var init = function init(url) {
	        location_url = url ? getLocation(url) : window ? window.location : '';
	    };

	    var getLocation = function getLocation(url) {
	        return $('<a>', { href: decodeURIComponent(url) })[0];
	    };

	    var reset = function reset() {
	        location_url = window ? window.location : location_url;
	    };

	    var params = function params(href) {
	        var arr_params = [];
	        var parsed = (href ? new URL(href) : location_url).search.substr(1).split('&');
	        var p_l = parsed.length;
	        while (p_l--) {
	            var param = parsed[p_l].split('=');
	            arr_params.push(param);
	        }
	        return arr_params;
	    };

	    var paramsHash = function paramsHash(href) {
	        var param_hash = {};
	        var arr_params = params(href);
	        var param = arr_params.length;
	        while (param--) {
	            if (arr_params[param][0]) {
	                param_hash[arr_params[param][0]] = arr_params[param][1];
	            }
	        }
	        return param_hash;
	    };

	    var paramsHashToString = function paramsHashToString(pars) {
	        return Object.keys(pars).map(function (key) {
	            return key + '=' + pars[key];
	        }).join('&');
	    };

	    var urlFor = function urlFor(path, pars) {
	        if (!path) {
	            path = '';
	        } else if (path.length > 0 && path[0] === '/') {
	            path = path.substr(1);
	        }
	        var lang = getLanguage().toLowerCase();
	        var url = window.location.href;
	        return '' + url.substring(0, url.indexOf('/' + lang + '/') + lang.length + 2) + (path || 'home' + (lang === 'ja' ? '-jp' : '')) + '.html' + (pars ? '?' + pars : '');
	    };

	    var urlForStatic = function urlForStatic(path) {
	        if (!path) {
	            path = '';
	        } else if (path.length > 0 && path[0] === '/') {
	            path = path.substr(1);
	        }

	        if (!static_host || static_host.length === 0) {
	            static_host = $('script[src*="binary.min.js"],script[src*="binary.js"]').attr('src');

	            if (static_host && static_host.length > 0) {
	                static_host = static_host.substr(0, static_host.indexOf('/js/') + 1);
	            } else {
	                static_host = 'https://www.binary.com/';
	            }
	        }

	        return static_host + path;
	    };

	    var defaultRedirectUrl = function defaultRedirectUrl() {
	        return urlFor(jpClient() ? 'multi_barriers_trading' : 'trading');
	    };

	    return {
	        init: init,
	        reset: reset,
	        paramsHash: paramsHash,

	        param: function param(name) {
	            return paramsHash()[name];
	        },
	        getLocation: getLocation,

	        paramsHashToString: paramsHashToString,
	        urlFor: urlFor,
	        urlForStatic: urlForStatic,
	        defaultRedirectUrl: defaultRedirectUrl
	    };
	}();

	module.exports = Url;

/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var CookieStorage = __webpack_require__(421).CookieStorage;
	var Cookies = __webpack_require__(422);

	var Language = function () {
	    'use strict';

	    var all_languages = {
	        EN: 'English',
	        DE: 'Deutsch',
	        ES: 'Español',
	        FR: 'Français',
	        ID: 'Indonesia',
	        IT: 'Italiano',
	        JA: '日本語',
	        PL: 'Polish',
	        PT: 'Português',
	        RU: 'Русский',
	        TH: 'Thai',
	        VI: 'Tiếng Việt',
	        ZH_CN: '简体中文',
	        ZH_TW: '繁體中文'
	    };

	    var setCookieLanguage = function setCookieLanguage(lang, set_anyway) {
	        if (!Cookies.get('language') || set_anyway) {
	            var cookie = new CookieStorage('language');
	            cookie.write(lang || getLanguage());
	        }
	    };

	    var languageFromUrl = function languageFromUrl() {
	        var regex = new RegExp('^(' + Object.keys(all_languages).join('|') + ')$', 'i');
	        var url_params = window.location.href.split('/').slice(3);
	        return url_params.find(function (lang) {
	            return regex.test(lang);
	        }) || '';
	    };

	    var current_lang = null;
	    var getLanguage = function getLanguage() {
	        return current_lang = current_lang || (languageFromUrl() || Cookies.get('language') || 'EN').toUpperCase();
	    };

	    var urlForLanguage = function urlForLanguage(lang) {
	        return window.location.href.replace(new RegExp('/' + getLanguage() + '/', 'i'), '/' + lang.trim().toLowerCase() + '/');
	    };

	    var onChangeLanguage = function onChangeLanguage() {
	        var $this = void 0;
	        $('#select_language').find('li').on('click', function () {
	            $this = $(this);
	            var lang = $this.attr('class');
	            if (getLanguage() === lang) return;
	            $('#display_language').find('.language').text($this.text());
	            setCookieLanguage(lang, true);
	            document.location = urlForLanguage(lang);
	        });
	    };

	    return {
	        getAll: function getAll() {
	            return all_languages;
	        },
	        setCookie: setCookieLanguage,
	        get: getLanguage,
	        onChange: onChangeLanguage,
	        urlFor: urlForLanguage
	    };
	}();

	module.exports = Language;

/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Language = __webpack_require__(424);
	var createLanguageDropDown = __webpack_require__(426);
	var Cookies = __webpack_require__(422);
	var BinarySocket = __webpack_require__(427);

	var checkClientsCountry = function checkClientsCountry() {
	    BinarySocket.wait('website_status').then(function (response) {
	        if (response.error) return;
	        var website_status = response.website_status;
	        var clients_country = website_status.clients_country;
	        if (clients_country === 'jp') {
	            limitLanguage('JA');
	        } else if (clients_country === 'id') {
	            limitLanguage('ID');
	        } else {
	            createLanguageDropDown(website_status);
	        }
	    });
	};

	var limitLanguage = function limitLanguage(lang) {
	    if (Language.get() !== lang) {
	        window.location.href = Language.urlFor(lang); // need to redirect not using pjax
	    }
	    if (document.getElementById('select_language')) {
	        $('.languages').remove();
	        $('#gmt-clock').addClass('gr-6 gr-12-m').removeClass('gr-5 gr-6-m');
	        $('#contact-us').addClass('gr-6').removeClass('gr-2');
	    }
	};

	var jpClient = function jpClient() {
	    return Language.get() === 'JA' || jpResidence();
	};

	var jpResidence = function jpResidence() {
	    return Cookies.get('residence') === 'jp';
	};

	var checkLanguage = function checkLanguage() {
	    if (Language.get() === 'ID') {
	        var $academy_link = $('.academy a');
	        var academy_href = $academy_link.attr('href');
	        var regex = /id/;
	        if (!regex.test(academy_href)) {
	            $academy_link.attr('href', academy_href + regex);
	        }
	    }
	    if (jpClient()) {
	        $('.ja-hide').setVisibility(0);
	        $('.ja-show').setVisibility(1);
	        $('#regulatory-text').addClass('gr-12 gr-12-p').removeClass('gr-9 gr-7-p');
	        if (!jpResidence()) {
	            $('#topMenuCashier').hide();
	        }
	    }
	};

	module.exports = {
	    checkClientsCountry: checkClientsCountry,
	    jpClient: jpClient,
	    jpResidence: jpResidence,
	    checkLanguage: checkLanguage
	};

/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Language = __webpack_require__(424);

	var createLanguageDropDown = function createLanguageDropDown(website_status) {
	    var $languages = $('.languages');
	    var select_language_id = '#select_language';
	    var current_language = Language.get();

	    $languages.find('#display_language li, ' + select_language_id + ' li').addClass(current_language).find('span.language').text(mapCodeToLanguage(current_language));

	    var languages = website_status.supported_languages.sort(function (a, b) {
	        return a === 'EN' || a < b ? -1 : 1;
	    });
	    var $select_language = $languages.find(select_language_id);
	    languages.forEach(function (language) {
	        $select_language.append($('<li/>', { class: language, text: mapCodeToLanguage(language) }));
	    });

	    $select_language.find('.' + current_language + ':eq(1)').setVisibility(0);
	    Language.onChange();
	    $languages.setVisibility(1);
	};

	var mapCodeToLanguage = function mapCodeToLanguage(code) {
	    return Language.getAll()[code];
	};

	module.exports = createLanguageDropDown;

/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var getLanguage = __webpack_require__(424).get;
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var getPropertyValue = __webpack_require__(417).getPropertyValue;
	var getLoginToken = __webpack_require__(430).getLoginToken;
	var getAppId = __webpack_require__(431).getAppId;
	var getSocketURL = __webpack_require__(431).getSocketURL;

	/*
	 * An abstraction layer over native javascript WebSocket,
	 * which provides additional functionality like
	 * reopen the closed connection and process the buffered requests
	 */
	var BinarySocket = function () {
	    'use strict';

	    var binary_socket = void 0,
	        config = {},
	        buffered_sends = [],
	        req_number = 0,
	        req_id = 0,
	        wrong_app_id = 0,
	        is_available = true,
	        is_disconnect_called = false;

	    var socket_url = getSocketURL() + '?app_id=' + getAppId() + '&l=' + getLanguage();
	    var timeouts = {};
	    var promises = {};
	    var no_duplicate_requests = ['authorize', 'get_settings', 'residence_list', 'landing_company', 'payout_currencies', 'asset_index'];
	    var sent_requests = {
	        items: [],
	        clear: function clear() {
	            sent_requests.items = [];
	        },
	        has: function has(msg_type) {
	            return sent_requests.items.indexOf(msg_type) >= 0;
	        },
	        add: function add(msg_type) {
	            if (!sent_requests.has(msg_type)) sent_requests.items.push(msg_type);
	        },
	        remove: function remove(msg_type) {
	            if (sent_requests.has(msg_type)) sent_requests.items.splice(sent_requests.items.indexOf(msg_type, 1));
	        }
	    };
	    var waiting_list = {
	        items: {},
	        add: function add(msg_type, promise_obj) {
	            if (!waiting_list.items[msg_type]) {
	                waiting_list.items[msg_type] = [];
	            }
	            waiting_list.items[msg_type].push(promise_obj);
	        },
	        resolve: function resolve(response) {
	            var msg_type = response.msg_type;
	            var this_promises = waiting_list.items[msg_type];
	            if (this_promises && this_promises.length) {
	                this_promises.forEach(function (pr) {
	                    if (!waiting_list.another_exists(pr, msg_type)) {
	                        pr.resolve(response);
	                    }
	                });
	                waiting_list.items[msg_type] = [];
	            }
	        },
	        another_exists: function another_exists(pr, msg_type) {
	            return Object.keys(waiting_list.items).some(function (type) {
	                return type !== msg_type && $.inArray(pr, waiting_list.items[type]) >= 0;
	            });
	        }
	    };

	    var clearTimeouts = function clearTimeouts() {
	        Object.keys(timeouts).forEach(function (key) {
	            clearTimeout(timeouts[key]);
	            delete timeouts[key];
	        });
	    };

	    var isReady = function isReady() {
	        return binary_socket && binary_socket.readyState === 1;
	    };

	    var isClose = function isClose() {
	        return !binary_socket || binary_socket.readyState === 2 || binary_socket.readyState === 3;
	    };

	    var sendBufferedRequests = function sendBufferedRequests() {
	        while (buffered_sends.length > 0) {
	            var req_obj = buffered_sends.shift();
	            send(req_obj.request, req_obj.options);
	        }
	    };

	    var wait = function wait() {
	        for (var _len = arguments.length, msg_types = Array(_len), _key = 0; _key < _len; _key++) {
	            msg_types[_key] = arguments[_key];
	        }

	        var promise_obj = new PromiseClass();
	        var is_resolved = true;
	        msg_types.forEach(function (msg_type) {
	            var last_response = State.get(['response', msg_type]);
	            if (!last_response) {
	                if (msg_type !== 'authorize' || config.is_logged_in) {
	                    waiting_list.add(msg_type, promise_obj);
	                    is_resolved = false;
	                }
	            } else if (msg_types.length === 1) {
	                promise_obj.resolve(last_response);
	            }
	        });
	        if (is_resolved) {
	            promise_obj.resolve();
	        }
	        return promise_obj.promise;
	    };

	    /**
	     * @param {Object} data: request object
	     * @param {Object} options:
	     *      forced  : {boolean}  sends the request regardless the same msg_type has been sent before
	     *      msg_type: {string}   specify the type of request call
	     *      callback: {function} to call on response of streaming requests
	     */
	    var send = function send(data) {
	        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	        var promise_obj = options.promise || new PromiseClass();

	        var msg_type = options.msg_type || no_duplicate_requests.find(function (c) {
	            return c in data;
	        });
	        if (!options.forced && msg_type) {
	            var last_response = State.get(['response', msg_type]);
	            if (last_response) {
	                promise_obj.resolve(last_response);
	                return promise_obj.promise;
	            } else if (sent_requests.has(msg_type)) {
	                return wait(msg_type).then(function (response) {
	                    promise_obj.resolve(response);
	                    return promise_obj.promise;
	                });
	            }
	        }

	        if (!data.req_id) {
	            data.req_id = ++req_id;
	        }
	        promises[data.req_id] = {
	            callback: function callback(response) {
	                if (typeof options.callback === 'function') {
	                    options.callback(response);
	                } else {
	                    promise_obj.resolve(response);
	                }
	            },
	            subscribe: !!data.subscribe
	        };

	        if (isReady() && is_available) {
	            is_disconnect_called = false;
	            if (!data.hasOwnProperty('passthrough') && !data.hasOwnProperty('verify_email')) {
	                data.passthrough = {};
	            }
	            if (+data.time === 1) {
	                data.passthrough.req_number = ++req_number;
	                timeouts[req_number] = setTimeout(binary_socket.onclose, 10 * 1000);
	            }

	            binary_socket.send(JSON.stringify(data));
	            if (msg_type && !sent_requests.has(msg_type)) {
	                sent_requests.add(msg_type);
	            }
	        } else {
	            buffered_sends.push({ request: data, options: $.extend(options, { promise: promise_obj }) });
	            if (isClose() && !timeouts.reconnect) {
	                timeouts.reconnect = setTimeout(function () {
	                    init(1);
	                }, 5 * 1000);
	            }
	        }

	        return promise_obj.promise;
	    };

	    var init = function init(options) {
	        if (wrong_app_id === getAppId()) {
	            return;
	        }
	        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
	            config = options;
	            buffered_sends = [];
	        }
	        clearTimeouts();

	        if (isClose()) {
	            binary_socket = new WebSocket(socket_url);
	            State.set('response', {});
	        }

	        binary_socket.onopen = function () {
	            var api_token = getLoginToken();
	            if (api_token && localStorage.getItem('client.tokens')) {
	                send({ authorize: api_token }, { forced: true });
	            } else {
	                sendBufferedRequests();
	            }

	            if (typeof config.onOpen === 'function') {
	                config.onOpen(isReady());
	            }
	        };

	        binary_socket.onmessage = function (msg) {
	            var response = JSON.parse(msg.data);
	            if (response) {
	                var passthrough = getPropertyValue(response, ['echo_req', 'passthrough']);
	                if (passthrough) {
	                    var this_req_number = passthrough.req_number;
	                    if (this_req_number) {
	                        clearInterval(timeouts[this_req_number]);
	                        delete timeouts[this_req_number];
	                    }
	                }

	                var type = response.msg_type;

	                // store in State
	                if (!getPropertyValue(response, ['echo_req', 'subscribe']) || /(balance|website_status)/.test(type)) {
	                    State.set(['response', type], $.extend({}, response));
	                }
	                // resolve the send promise
	                var this_req_id = response.req_id;
	                var pr = this_req_id ? promises[this_req_id] : null;
	                if (pr && typeof pr.callback === 'function') {
	                    pr.callback(response);
	                    if (!pr.subscribe) {
	                        delete promises[this_req_id];
	                    }
	                }
	                // resolve the wait promise
	                waiting_list.resolve(response);

	                var error_code = getPropertyValue(response, ['error', 'code']);
	                switch (error_code) {
	                    case 'WrongResponse':
	                    case 'OutputValidationFailed':
	                        {
	                            var text_value = error_code === 'WrongResponse' && response.error.message ? response.error.message : localize('Sorry, an error occurred while processing your request.');
	                            $('#content').empty().html($('<div/>', { class: 'container' }).append($('<p/>', { class: 'notice-msg center-text', text: text_value })));
	                            break;
	                        }
	                    case 'RateLimit':
	                        config.notify(localize('You have reached the rate limit of requests per second. Please try later.'), true);
	                        break;
	                    case 'InvalidAppID':
	                        wrong_app_id = getAppId();
	                        config.notify(response.error.message, true);
	                        break;
	                    // no default
	                }

	                if (typeof config.onMessage === 'function') {
	                    config.onMessage(response);
	                }
	            }
	        };

	        binary_socket.onclose = function () {
	            sent_requests.clear();
	            clearTimeouts();

	            if (wrong_app_id !== getAppId()) {
	                config.notify(localize('Connection error: Please check your internet connection.'), true);
	                if (typeof config.onDisconnect === 'function' && !is_disconnect_called) {
	                    config.onDisconnect();
	                    is_disconnect_called = true;
	                } else if (!timeouts.reconnect) {
	                    timeouts.reconnect = setTimeout(function () {
	                        init(1);
	                    }, 5 * 1000);
	                }
	            }
	        };
	    };

	    var clear = function clear(msg_type) {
	        buffered_sends = [];
	        if (msg_type) {
	            State.set(['response', msg_type], undefined);
	            sent_requests.remove(msg_type);
	        }
	    };

	    var availability = function availability(status) {
	        if (typeof status !== 'undefined') {
	            is_available = !!status;
	        }
	        return is_available;
	    };

	    return {
	        init: init,
	        wait: wait,
	        send: send,
	        clear: clear,
	        clearTimeouts: clearTimeouts,
	        sendBuffered: sendBufferedRequests,
	        availability: availability,
	        setOnDisconnect: function setOnDisconnect(onDisconnect) {
	            config.onDisconnect = onDisconnect;
	        },
	        removeOnDisconnect: function removeOnDisconnect() {
	            delete config.onDisconnect;
	        }
	    };
	}();

	var PromiseClass = function PromiseClass() {
	    var _this = this;

	    _classCallCheck(this, PromiseClass);

	    this.promise = new Promise(function (resolve, reject) {
	        _this.reject = reject;
	        _this.resolve = resolve;
	    });
	};

	module.exports = BinarySocket;

/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var template = __webpack_require__(417).template;
	var texts_json = __webpack_require__(429).texts_json;

	var Localize = function () {
	    'use strict';

	    var localized_texts = void 0;

	    var localizeForLang = function localizeForLang(lang) {
	        localized_texts = texts_json[lang];
	        moment.locale(lang.toLowerCase());
	    };

	    var doLocalize = function doLocalize(text, params) {
	        var index = text.replace(/[\s|.]/g, '_');
	        text = localized_texts && localized_texts[index] || text;
	        // only use template when explicitly required
	        return params ? template(text, params) : text;
	    };

	    var localize = function localize(text, params) {
	        return Array.isArray(text) ? text.map(function (t) {
	            return doLocalize(t, params);
	        }) : doLocalize(text, params);
	    };

	    return {
	        forLang: localizeForLang,
	        localize: localize
	    };
	}();

	module.exports = Localize;

/***/ },
/* 429 */
/***/ function(module, exports) {

	'use strict';

	var texts_json = {};
	texts_json['EN'] = {};
	texts_json['DE'] = { "today,_Fridays": "heute, Freitage", "IP_Address": "IP-Adresse", "Only_[_1]_decimal_points_are_allowed_": "Es sind nur [_1] Dezimalstellen erlaubt.", "Contract_ID": "Kontrakt ID", "Total_Cost": "Gesamtkosten", "Please_submit_a_valid_verification_token_": "Bitte übermitteln Sie einen gültigen Verifikationstoken.", "February": "Februar", "Buy_price": "Kaufpreis", "Payment_Agent": "Zahlungsagent", "Please_[_1]accept_the_updated_Terms_and_Conditions[_2]_to_lift_your_withdrawal_and_trading_limits_": "Bitte [_1]akzeptieren Sie die aktualisierten allgemeinen Geschäftsbedingungen[_2], um Ihre Abhebe- und Handelslimits aufzuheben.", "Your_trading_statistics_since_[_1]_": "Ihre Trading-Statistiken seit [_1].", "Are_you_sure_that_you_want_to_permanently_delete_token": "Sind Sie sicher, dass Sie den Token endgültig löschen möchten?", "[_1]_deposit_from_[_2]_to_account_number_[_3]_is_done__Transaction_ID:_[_4]": "[_1] Einzahlung von [_2] zu Kontonummer [_3] ist erledigt. Überweisungs-ID: [_4]", "letters": "Buchstaben", "Upgrade_to_a_Financial_Account": "In ein Finanzkonto ändern", "[_1]_days_[_2]_hours_[_3]_minutes": "[_1] Tage [_2] Stunden [_3] Minuten", "Resources": "Quellen", "Su": "So", "The_email_address_provided_is_already_in_use__If_you_forgot_your_password,_please_try_our_<a_href=\"[_1]\">password_recovery_tool</a>_or_contact_our_customer_service_": "Die angegebene E-Mail Adresse, ist bereits in Verwendung. Wenn Sie Ihr Passwort vergessen haben, versuchen Sie bitte unser <a href=\"[_1]\">Passwort-Wiederfindung Tool</a>, oder kontaktieren Sie die Kundenbetreuung.", "Please_select_a_payment_agent": "Bitte wählen Sie einen Zahlungsagent aus", "Upcoming_Events": "Bevorstehende Events", "Current": "Derzeit", "months": "Monate", "Sorry,_your_account_is_not_authorised_for_any_further_contract_purchases_": "Es tut uns leid, aber Ihr Konto ist für den Erwerb weiterer Kontrakte nicht berechtigt.", "Please_input_a_valid_date": "Bitte geben Sie ein gültiges Datum ein", "Your_account_is_restricted__Kindly_[_1]contact_customer_support[_2]_for_assistance_": "Ihr Konto ist eingeschränkt. Bitte [_1]kontaktieren Sie die Kundenbetreuung[_2] für Hilfe.", "Note": "Anmerkung", "mins": "Min", "Over/Under": "Über/Unter", "View": "Ansehen", "email_address": "E-Mail Adresse", "Barrier_Change": "Grenzänderung", "Adjust_trade_parameters": "Anpassen von Handelsparametern", "You_have_reached_the_rate_limit_of_requests_per_second__Please_try_later_": "Sie haben das Kurslimit für Anfragen pro Sekunde erreicht. Bitte versuchen Sie es später.", "Payments": "Zahlungen", "Please_<a_href=\"[_1]\">log_in</a>_to_view_this_page_": "Bitte <a href=\"[_1]\">melden Sie sich an</a>, um diese Seite anzuzeigen.", "Payout": "Auszahlung", "You_did_not_change_anything_": "Sie haben nichts geändert.", "Your_settings_have_been_updated_successfully_": "Ihre Einstellungen wurden erfolgreich aktualisiert.", "Revoke_access": "Zugang widerrufen", "Exclude_time_cannot_be_less_than_6_months_": "Die Ausschlusszeit darf nicht kürzer als 6 Monate sein.", "Contract_Information": "Kontraktinformation", "Real_Volatility": "Echte Volatilität", "Real_Account": "Echtes Konto", "Are_you_sure_that_you_want_to_permanently_revoke_access_to_application": "Sind Sie sicher, dass Sie den Zugang endgültig widerrufen möchten", "Goes_Outside": "Geht Außerhalb", "Duration": "Laufzeit", "Cashier": "Kasse", "Sunday": "Sonntag", "Old_password_is_wrong_": "Altes Passwort ist falsch.", "This_contract_lost": "Dieser Kontrakt verlor", "Contract_is_not_started_yet": "Kontrakt ist noch nicht gestartet", "[_1]Authenticate_your_account[_2]_now_to_take_full_advantage_of_all_withdrawal_options_available_": "Bitte [_1]Authentifizieren Sie Ihr Konto[_2] jetzt, um von allen Abhebeoptionen Gebrauch zu machen.", "Stays_In/Goes_Out": "Bleibt in/Geht außerhalb", "Your_transaction_reference_number_is_[_1]": "Ihre Überweisungsnummer ist [_1]", "Equals": "Gleicht", "Sell_time": "Verkaufszeit", "Final_price": "Schlusskurs", "Only_numbers,_space,_and_hyphen_are_allowed_": "Es sind nur Zahlen, Abstände und Bindestriche erlaubt.", "Account_balance:": "Kontostand:", "Hour": "Stunde", "Only_letters,_numbers,_and_hyphen_are_allowed_": "Es sind nur Buchstaben, Zahlen, und Bindestriche erlaubt.", "Update": "Aktualisieren", "Year": "Jahr", "Long": "Lang", "Profit": "Rendite", "day": "Tag", "Th": "Do", "Monday": "Montag", "Virtual_Account": "Virtuelles Konto", "[_1]_[_2]_payout_if_[_3]_touches_Barrier_through_close_on_[_4]_": "[_1] [_2] Auszahlung, wenn [_3] die Schwelle durch den Schluss auf [_4] berührt.", "Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_": "Ihr Auftrag, [_1] [_2] von Ihrem Konto [_3] auf das Konto des Zahlungsagent [_4] zu überweisen, wurde erfolgreich bearbeitet.", "Start_Time": "Startzeit", "There_was_some_invalid_character_in_an_input_field_": "Es ist ein ungültiges Zeichen in einem Eingabefeld vorhanden.", "Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_": "Der Kontrakt wird, sobald der Auftrag von unseren Servern empfangen wurde, zum dann geltenden Marktkurs verkauft. Dieser Kurs kann von den angegebenen Kursen abweichen.", "This_symbol_is_not_active__Please_try_another_symbol_": "Dieses Zeichen ist nicht aktiv. Bitte versuchen Sie ein anderes Zeichen.", "Sorry,_this_feature_is_not_available_": "Leider ist diese Funktion nicht vorhanden.", "We": "Mi", "Spot": "Kassakurs", "Step": "Schritt", "AM": "morgens", "Minimum_of_[_1]_characters_required_": "Mindestens [_1] Zeichen sind erforderlich.", "Credit/Debit": "Gutschrift/Lastschrift", "Sorry,_you_have_entered_an_incorrect_cashier_password": "Es tut uns leid, aber Sie haben ein ungültiges Kassen-Passwort eingegeben", "Change_Password": "Passwort ändern", "Friday": "Freitag", "Successful": "Erfolgreich", "logout": "abmelden", "Your_session_duration_limit_will_end_in_[_1]_seconds_": "Das Limit Ihrer Sitzungsdauer endet in [_1] Sekunden.", "Please_complete_the_[_1]financial_assessment_form[_2]_to_lift_your_withdrawal_and_trading_limits_": "Füllen Sie bitte das [_1]finanzielle Beurteilungsformular[_2] aus, um Ihre Abhebe- und Handelslimits aufzuheben.", "Open_a_Financial_Account": "Eröffnen Sie ein Finanzkonto", "Current_Time": "Aktuelle Zeit", "Even/Odd": "Gerade/ungerade", "Price": "Kurs", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_": "Sie haben bereits den Gegenwert von [_1] [_2]  abgehoben, der sich in den letzten [_3] Tagen angesammelt hat.", "Sell_at_market": "Zum Börsenkurs verkaufen", "Purchase_Price": "Kaufpreis", "year": "Jahr", "Walkthrough_Guide": "Kompletter Leitfaden", "End_time_must_be_after_start_time_": "Die Endzeit muss nach der Startzeit beginnen.", "Contract": "Kontrakt", "Higher": "Höher", "Only_numbers_and_spaces_are_allowed_": "Es sind nur Zahlen und Abstände erlaubt.", "All_barriers_in_this_trading_window_are_expired": "Alle Schwellen in diesem Handelsfenster sind abgelaufen", "Contract_Sold": "Kontrakt verkauft", "Explanation": "Erläuterung", "Investment_Account": "Investmentkonto", "Password_is_not_strong_enough_": "Passwort ist nicht stark genug.", "Should_be_between_[_1]_and_[_2]": "Sollte zwischen [_1] und [_2] betragen", "The_maximum_number_of_tokens_([_1])_has_been_reached_": "Die Höchstzahl an Token ([_1]) wurde erreicht.", "Your_token_has_expired__Please_click_<a_href=\"[_1]\">here</a>_to_restart_the_verification_process_": "Ihr Token ist abgelaufen. Bitte klicken Sie <a href=\"[_1]\">hier</a>, um den Verfikationsprozess zu wiederholen.", "Number_of_ticks": "Anzahl der Ticks", "This_field_is_required_": "Dieses Feld ist erforderlich.", "Touch/No_Touch": "Erreicht", "Not": "Nicht", "Tuesday": "Dienstag", "Trading_Times": "Börsenzeiten", "An_additional_password_can_be_used_to_restrict_access_to_the_cashier_": "Es darf ein zusätzliches Passwort verwendet werden, um den Zugang zum Kassensabschnitt zu beschränken.", "Short": "Kurz", "Please_enter_a_number_between_[_1]_": "Bitte geben Sie eine Zahl zwischen [_1] ein.", "Day": "Tag", "Wednesday": "Mittwoch", "Buy": "Kaufen", "Read": "Lesen", "Time_out_must_be_after_today_": "Die Auszeit muss nach dem heutigen Tag beginnen.", "Sale_Price": "Verkaufskurs", "Loss": "Verlust", "Create_Account": "Konto einrichten", "Permissions": "Berechtigungen", "Your_account_is_currently_suspended__Only_withdrawals_are_now_permitted__For_further_information,_please_contact_[_1]_": "Ihr Konto ist derzeit gesperrt. Jetzt sind nur Auszahlungen erlaubt. Setzen Sie sich bitte mit [_1] in Verbindung, um mehr Informationen zu erhalten.", "second": "Sekunde", "Low_Barrier": "Untere Schwelle", "Month": "Monat", "Your_transaction_reference_is": "Ihre Überweisungsreferenz lautet", "Verification_code_format_incorrect_": "Format des Verifikationscodes falsch.", "Upgrade_to_a_Real_Account": "Erweitern Sie auf ein Echtgeldkonto", "Deposits_and_withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Derzeit sind Einzahlungen und Auszahlungen nicht erlaubt. Bitte setzen Sie sich mit [_1] in Verbindung, um es freizuschalten.", "Sell": "Verkaufen", "Only_[_1]_are_allowed_": "Es sind nur [_1] erlaubt.", "days": "Tage", "Select_your_underlying_asset": "Wählen Sie Ihren Basiswert aus", "Asset_Index": "Vermögensindex", "Finish": "Beenden", "Investor_password": "Investoren Passwort", "Connection_error:_Please_check_your_internet_connection_": "Verbindungsfehler: Bitte überprüfen Sie Ihre Internetverbindung.", "The_Payment_Agent_facility_is_currently_not_available_in_your_country_": "In Ihrem Land ist derzeit kein Zahlungsagent vorhanden.", "End_Time": "Endzeit", "Target": "Ziel", "Description": "Beschreibung", "Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_": "Bitte befolgen Sie dieses Muster: 3 Zahlen, ein Bindestrich, gefolgt von 4 Zahlen.", "Ends_Outside": "Endet Außerhalb", "Spot_Time": "Kassa-Zeit", "Please_select_at_least_one_scope": "Bitte wählen Sie zumindest einen Bereich aus", "Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_": "Ihr Konto ist vollständig authentifiziert und Ihr Abhebelimit wurde angehoben.", "Market_is_closed__Please_try_again_later_": "Börse ist derzeit geschlossen. Bitte versuchen Sie es später erneut.", "Potential_Payout": "Mögliche Auszahlung", "Barrier_([_1])": "Schwelle ([_1])", "There_was_a_problem_accessing_the_server_": "Es gab ein Problem beim Zugriff auf den Server.", "Now": "Jetzt", "today": "heute", "Exit_Spot": "Schlusskurs", "There_was_a_problem_accessing_the_server_during_purchase_": "Während des Kaufs ist ein Problem beim Zugriff auf den Server aufgetreten.", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Daher ist Ihr aktuelles sofortiges Maximum für eine Abhebung (sofern Ihr Konto über ausreichend Guthaben verfügt) EUR [_1] [_2] (oder Gegenwert in einer anderen Währung).", "Stake": "Einsatz", "Action": "Handlung", "Details": "Angaben", "Insufficient_balance_": "Unzureichendes Guthaben.", "Contract_Expiry": "Kontraktauslauf", "details": "Angaben", "Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_": "Ihr Auftrag [_1] [_2] von [_3] an [_4] zu überweisen, wurde erfolgreich bearbeitet.", "Statement": "Abrechnung", "[_1]_Please_click_the_link_below_to_restart_the_password_recovery_process__If_you_require_further_assistance,_please_contact_our_Customer_Support_": "[_1] Bitte klicken Sie auf den nachfolgenden Link, um den Passwort Erneuerungsprozess zu starten. Wenn Sie weitere Unterstützung benötigen, setzen Sie sich bitte mit unserem Kundensupport in Verbindung.", "Waiting_for_exit_tick_": "Warten auf den Endtick.", "Higher/Lower": "Höher/Tiefer", "Questions": "Fragen", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_": "Ihre Kasse ist auf Ihren Antrag hin gesperrt - um Sie zu entsperren, geben Sie bitte das Passwort ein.", "Unlock_Cashier": "Kasse entsperren", "Your_Application_is_Being_Processed_": "Ihr Antrag wird bearbeitet.", "Exclude_time_cannot_be_for_more_than_5_years_": "Die Ausschlusszeit darf nicht länger als 5 Jahre sein.", "Sorry,_this_feature_is_available_to_virtual_accounts_only_": "Leider steht diese Funktion nur für virtuelle Konten zur Verfügung.", "Never_Used": "Nie verwendet", "Weekday": "Wochentag", "Select_your_market": "Wählen Sie Ihren Markt", "Today": "Heute", "Please_select": "Bitte wählen Sie", "Last_Used": "Zuletzt verwendet", "Entry_spot": "Startkurs", "Fridays": "Freitage", "years": "Jahre", "Deposit": "Einzahlung", "The_two_passwords_that_you_entered_do_not_match_": "Die beiden Passwörter, die Sie eingegeben haben, stimmen nicht überein.", "The_main_password_of_account_number_[_1]_has_been_changed_": "Das Hauptpasswort für die Kontonummer [_1] wurde geändert.", "Invalid_amount,_minimum_is": "Ungültiger Betrag, das Minimum ist", "Gaming_Account": "Spielkonto", "There_was_an_error": "Es ist ein Fehler aufgetreten", "The_server_<a_href=\"[_1]\">endpoint</a>_is:_[_2]": "Der Server <a href=\"[_1]\">Endpunkt</a> ist: [_2]", "Net_profit": "Nettogewinn", "Total_Profit/Loss": "Gesamter Gewinn/Verlust", "Transaction_performed_by_[_1]_(App_ID:_[_2])": "Überweisung durchgeführt von [_1] (App ID: [_2])", "Date_and_Time": "Datum und Zeit", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_click_<a_href=\"[_1]\">here</a>_": "Ihre Kasse wurde auf Ihren Antrag hin gesperrt - um Sie wieder zu entsperren, bitte <a href=\"[_1]\">hier</a>anklicken.", "Sorry,_account_signup_is_not_available_in_your_country__Please_contact_<a_href=\"[_1]\">customer_support</a>_for_more_information_": "Es tut uns leid, die Anmeldung ist in Ihrem Land nicht vorhanden. Bitte kontaktieren Sie die <a class=\"pjaxload\" href=\"[_1]\">Kundenbetreuung</a>, um weitere Informationen zu erhalten.", "Your_changes_have_been_updated_": "Ihre Änderungen wurden aktualisiert.", "This_feature_is_not_relevant_to_virtual-money_accounts_": "Diese Funktion ist für virtuelle Geldkonten nicht relevant", "New_password": "Neues Passwort", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_": "Daher beträgt Ihre derzeitige maximale Sofortabhebung (vorausgesetzt Ihr Konto hat ein ausreichendes Guthaben) [_1] [_2].", "Invalid_amount,_maximum_is": "Ungültiger Betrag, das Maximum ist", "[_1]_[_2]_payout_if_[_3]_is_strictly_lower_than_Barrier_at_close_on_[_4]_": "[_1] [_2] Auszahlung, wenn [_3] ausdrücklich niedriger als die Schwelle zum Schluss auf [_4] ist.", "Return": "Rendite", "Rise/Fall": "Steigen/Fallen", "All_markets_are_closed_now__Please_try_again_later_": "Alle Börsen sind derzeit geschlossen. Bitte versuchen Sie es später erneut.", "Does_Not_Touch": "Erreicht Nicht", "Real_STP": "Echtes STP", "Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_": "Ihr Passwort wurde erfolgreich zurückgesetzt. Bitte loggen Sie mit Ihrem neuen Passwort in Ihr Konto ein.", "New_Year's_Day": "Neujahrstag", "Real_Cent": "Echter Cent", "Date": "Datum", "Open": "Offen", "[_1]_[_2]_payout_if_[_3]_ends_outside_low_and_high_values_of_Barrier_at_close_on_[_4]_": "[_1] [_2] Auszahlung, wenn [_3] außerhalb der niedrigen und hohen Werte der Schwelle zum Schluss auf [_4] endet.", "[_1]_[_2]_payout_if_[_3]_stays_between_low_and_high_values_of_Barrier_through_close_on_[_4]_": "[_1] [_2] Auszahlung, wenn [_3] zwischen den niedrigen und hohen Werten der Schwelle durch den Schluss auf [_4] bleibt.", "Never": "Nie", "You_have_sold_this_contract_at_[_1]_[_2]": "Sie haben diesen Kontrakt für [_1] [_2] verkauft", "Major_Pairs": "Wichtigste Paare", "Saturday": "Samstag", "Sorry,_an_error_occurred_while_processing_your_request_": "Es tut uns leid, bei der Bearbeitung Ihrer Anfrage ist ein Fehler aufgetreten.", "Failed": "Fehlgeschlagen", "Select_your_trade_type": "Wählen Sie Ihren Trade-Typ aus", "Time_out_cannot_be_more_than_6_weeks_": "Die Auszeit kann nicht mehr als 6 Wochen betragen.", "Exit_Spot_Time": "Schlusskurszeit", "Please_[_1]complete_your_account_profile[_2]_to_lift_your_withdrawal_and_trading_limits_": "Bitte [_1]vervollständigen Sie Ihr Kontoprofil[_2], um Ihre Abhebe- und Handelslimits aufzuheben.", "You_have_not_granted_access_to_any_applications_": "Sie haben keinen Zugriff auf Anwendungen gewährt.", "Your_changes_have_been_updated_successfully_": "Ihre Änderungen wurden erfolgreich aktualisiert.", "Please_select_a_valid_date_": "Bitte wählen Sie ein gültiges Datum aus.", "Time_out_cannot_be_in_the_past_": "Die Auszeit darf nicht in der Vergangenheit sein.", "[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]": "[_1] [_2] wurden Ihrem virtuellen Geldkonto [_3] gutgeschrieben", "You_should_enter_[_1]_characters_": "Sie müssen [_1] Zeichen eingeben.", "Congratulations!_Your_[_1]_Account_has_been_created_": "Herzlichen Glückwunsch! Ihr [_1] Konto wurde erstellt.", "Potential_Profit": "Möglicher Gewinn", "[_1]_and_[_2]_cannot_be_the_same_": "[_1] und [_2] können nicht gleich sein.", "Please_accept_the_terms_and_conditions_": "Bitte akzeptieren Sie die Geschäftsbedingungen.", "Tu": "Di", "December": "Dezember", "Matches/Differs": "Gleich/Verschieden", "Mar": "Mär", "[_1]_[_2]_payout_if_[_3]_does_not_touch_Barrier_through_close_on_[_4]_": "[_1] [_2] Auszahlung, wenn [_3] die Schwelle nicht durch das Schließen auf [_4] erreicht.", "Closes": "Schließt", "Christmas_Day": "Weihnachtstag", "Please_check_the_above_form_for_pending_errors_": "Bitte überprüfen Sie das oben stehende Formular nach ausstehenden Fehlern.", "Up/Down": "Auf/Ab", "March": "März", "Next": "Weiter", "Invalid_email_address": "Falsche E-Mail Adresse", "Amount": "Betrag", "[_1]_[_2]_payout_if_[_3]_goes_outside_of_low_and_high_values_of_Barrier_through_close_on_[_4]_": "[_1] [_2] Auszahlung, wenn [_3] außerhalb der niedrigen und hohen Werte der Schwelle zum Schluss auf [_4] geht.", "Should_be_more_than_[_1]": "Sollte mehr als [_1] sein", "[_1]_[_2]_payout_if_[_3]_is_strictly_higher_than_or_equal_to_Barrier_at_close_on_[_4]_": "[_1] [_2] Auszahlung, wenn [_3] ausdrücklich höher als oder gleich mit (der), die Schwelle zum Schluss auf [_4] ist.", "Profit_Table": "Gewinntabelle", "PM": "nachmittags", "Barrier": "Schwelle", "Sorry,_an_error_occurred_while_processing_your_account_": "Es tut uns leid, bei der Bearbeitung Ihres Kontos ist ein Fehler aufgetreten.", "Ends_In/Out": "Endet innerhalb/außerhalb", "Password_should_have_lower_and_uppercase_letters_with_numbers_": "Das Passwort muss Klein- und Großbuchstaben sowie Zahlen enthalten.", "Sale_Date": "Verkaufsdatum", "May": "Mai", "Purchase_Time": "Kaufuhrzeit", "January": "Januar", "Closed": "Geschlossen", "Contract_Confirmation": "Vertragsbestätigung", "Only_letters,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Es sind nur Buchstaben, Leerzeichen, Bindestriche, Punkte und Apostrophe erlaubt.", "Forex": "Devisenhandel", "Please_log_in_": "Melden Sie sich bitte an.", "Please_select_the_checkbox_": "Bitte wählen Sie das Kontrollkästchen.", "October": "Oktober", "space": "Bereich", "Real_Standard": "Echter Standard", "Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Ihr Auszahlungslimit beträgt  [_1] [_2] (oder Gegenwert in anderer Währung).", "Processing_your_request___": "Ihre Anfrage wird bearbeitet...", "Closes_early_(at_18:00)": "Schließt früh (um 18:00)", "June": "Juni", "False": "Falsch", "Resale_not_offered": "Wiederverkauf wird nicht angeboten", "minutes": "Minuten", "End_time": "Endzeit", "hours": "Stunden", "seconds": "Sekunden", "Should_be_less_than_[_1]": "Sollte kleiner als [_1] sein", "Low_Barrier_([_1])": "Untere Schwelle ([_1])", "Remaining_time": "Verbleibende Zeit", "High_Barrier_([_1])": "Hohe Schwelle ([_1])", "Withdraw": "Abheben", "Closes_early_(at_21:00)": "Schließt früh (um 21:00)", "Scopes": "Geltungsbereiche", "Dec": "Dez", "month": "Monat", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_": "Sie haben bereits den Gegenwert von [_1] [_2] abgehoben.", "Touches": "Berührt", "hour": "Stunde", "Last_Digit_Stats": "Statistiken der Letzten Stelle", "Exit_spot": "Schlusskurs", "Main_password": "Hauptpasswort", "Session_duration_limit_cannot_be_more_than_6_weeks_": "Die Sitzungsdauer kann nicht mehr als 6 Wochen betragen.", "Profit/Loss": "Gewinn/Verlust", "min": "Min.", "Should_be_a_valid_number": "Sollte eine gültige Zahl sein", "Oct": "Okt", "Settles": "Begleicht", "July": "Juli", "[_1]_withdrawal_from_account_number_[_2]_to_[_3]_is_done__Transaction_ID:_[_4]": "[_1] Auszahlung von Kontonummer [_2] bis [_3] ist erledigt. Überweisungs-ID: [_4]", "High_Barrier": "Hohe Schwelle", "Percentage": "Prozentsatz", "Asset": "Kapital", "Indicative": "Indikativ", "Current_password": "Aktuelles Passwort", "Opens": "Öffnet", "True": "Wahr", "weeks": "Wochen", "minute": "Minute", "Only_letters,_numbers,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Nur Buchstaben, Zahlen, Abstände, Bindestriche, Punkte, und Apostrophe sind erlaubt.", "Delete": "Löschen", "Balance": "Guthaben", "verification_token": "Verifikationstoken", "Lock_Cashier": "Kasse blockieren", "When_you_click_\"OK\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_": "Wenn Sie auf 'OK' klicken, werden Sie bis zum ausgewählten Datum vom Handel auf dieser Site ausgeschlossen.", "Withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Auszahlungen von Ihrem Konto sind derzeit nicht erlaubt. Bitte setzen Sie sich mi [_1] in Verbindung, um es zu entsperren.", "Please_enter_an_integer_value": "Bitte geben Sie einen ganzzahligen Wert ein", "Entry_Spot": "Startkurs", "This_contract_won": "Dieser Vertrag gewann", "Trade": "Handel", "Your_withdrawal_limit_is_[_1]_[_2]_": "Ihr Abhebelimit beträgt  [_1] [_2].", "Reference_ID": "Referenznr.", "In/Out": "Innerhalb/Außerhalb", "Your_account_has_no_trading_activity_": "Ihr Konto hat keine Handelsaktivität.", "New_token_created_": "Neuer Token generiert.", "Predict_the_direction<br_/>and_purchase": "Sagen Sie die Richtung voraus<br />und kaufen Sie", "Your_token_has_expired__Please_click_[_1]here[_2]_to_restart_the_verification_process_": "Ihr Token ist abgelaufen. Bitte klicken Sie [_1]hier[_2], um den Verfikationsprozess zu wiederholen.", "Remaining_Time": "Verbleibende Zeit", "Waiting_for_entry_tick_": "Warten auf den Eingangstick.", "Please_select_a_value": "Bitte wählen Sie einen Wert aus", "numbers": "Zahlen", "Chart": "Diagramm", "Previous": "Vorige", "Please_set_[_1]country_of_residence[_2]_before_upgrading_to_a_real-money_account_": "Bitte legen Sie ein [_1]Wohnsitzland[_2] fest, bevor Sie auf ein Echtgeldkonto aufrüsten.", "Lower": "Niedriger", "week": "Woche", "from_[_1]_to_[_2]": "von [_1] bis [_2]", "Virtual_money_credit_to_account": "Virtuelles Geldguthaben zum Konto", "Please_set_your_30-day_turnover_limit_in_our_[_1]self-exclusion_facilities[_2]_to_remove_deposit_limits_": "Bitte legen Sie Ihre 30-Tage Umsatzgrenze in unseren [_1]Selbstausschluss Einrichtungen[_2] fest, um Einzahlungslimits zu entfernen.", "Select_market": "Wählen Sie den Markt", "Start_time": "Startzeit", "Charting_for_this_underlying_is_delayed": "Die grafische Darstellung für diesen Basiswert ist verzögert", "Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_": "Ihr [_1] Tage Abhebelimit beträgt derzeit [_2] [_3] (oder Gegenwert in einer anderen Währung).", "[_1]_[_2]_payout_if_[_3]_ends_on_or_between_low_and_high_values_of_Barrier_at_close_on_[_4]_": "[_1] [_2] Auszahlung, wenn [_3] auf, oder zwischen niedrigen und hohen Werten der Schwelle, zum Schluss auf [_4] endet.", "Your_account_has_no_Login/Logout_activity_": "Ihr Konto hat keine Anmelde- und/oder Abmeldeaktivität.", "Time_is_in_the_wrong_format_": "Die Zeit ist im falschen Format.", "This_is_a_staging_server_-_For_testing_purposes_only": "Dies ist ein Staging-Server - Nur zu Testzwecken", "Digit": "Ziffer", "You_have_already_withdrawn_[_1]_[_2]_": "Sie haben bereits [_1] [_2] abgehoben.", "Ends_Between": "Schließt Zwischen", "You_need_to_finish_all_20_questions_": "Sie müssen alle 20 Fragen beantworten.", "Stays_Between": "Bleibt Zwischen", "Please_select_a_valid_time_": "Bitte wählen Sie eine gültige Uhrzeit aus.", "Thursday": "Donnerstag" };
	texts_json['ES'] = { "Wednesday": "Miércoles", "Buy": "Comprar", "Day": "Día", "Please_enter_a_number_between_[_1]_": "Por favor, introduzca un número entre [_1].", "Trading_Times": "Horarios comerciales", "An_additional_password_can_be_used_to_restrict_access_to_the_cashier_": "Se puede utilizar una contraseña adicional para restringir el acceso al cajero.", "Short": "Cortos", "Permissions": "Permisos", "Loss": "Pérdida", "Your_account_is_currently_suspended__Only_withdrawals_are_now_permitted__For_further_information,_please_contact_[_1]_": "Su cuenta está actualmente suspendida. Solo tiene permitido retirar. Para más información, por favor póngase en contacto con 1%.", "Read": "Leer", "Sale_Price": "Precio venta", "The_maximum_number_of_tokens_([_1])_has_been_reached_": "El máximo número de tokens ([_1]) ha sido alcanzado.", "Contract_Sold": "Contrato Vendido", "Explanation": "Explicación", "Investment_Account": "Cuenta de inversión", "Password_is_not_strong_enough_": "La contraseña no es lo suficientemente fuerte.", "Shop": "Tienda", "Number_of_ticks": "Número de intervalos", "Tuesday": "Martes", "Touch/No_Touch": "Toque/Sin toque", "This_field_is_required_": "Este campo es obligatorio.", "Open_a_Financial_Account": "Abrir una cuenta financiera", "Current_Time": "Hora actual", "Price": "Precio", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_": "Usted ya retiró un total equivalente a [_1] [_2]  en los últimos [_3] días.", "Even/Odd": "Par/Impar", "Your_session_duration_limit_will_end_in_[_1]_seconds_": "El límite de duración de su sesión terminará en [_1] segundos.", "Contract": "Contrato", "All_barriers_in_this_trading_window_are_expired": "Todos los límites en esta ventana de comercio han caducado", "Purchase_Price": "Precio de compra", "Sell_at_market": "Vender al precio actual", "year": "año", "Walkthrough_Guide": "Guía tutorial", "Sorry,_you_have_entered_an_incorrect_cashier_password": "Lo sentimos, ingresó una contraseña de cajero incorrecta", "Credit/Debit": "Crédito/débito", "Minimum_of_[_1]_characters_required_": "Mínimo de [_1] caracteres requeridos.", "Successful": "Exitoso", "Friday": "Viernes", "Change_Password": "Cambiar contraseña", "Statement": "Extracto", "[_1]_Please_click_the_link_below_to_restart_the_password_recovery_process__If_you_require_further_assistance,_please_contact_our_Customer_Support_": "[_1] Por favor haga clic en el enlace de abajo para reiniciar el proceso de recuperación de contraseña. Si necesita más ayuda, póngase en contacto con nuestro Servicio de Atención al Cliente.", "details": "detalles", "Contract_Expiry": "Vencimiento del Contrato", "Details": "detalles", "Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_": "Su solicitud de transferencia [_1] [_2] de [_3] a [_4] ha sido procesada exitosamente.", "Unlock_Cashier": "Desbloquear cajero", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_": "Su cajero está bloqueado según su petición - para desbloquearlo, por favor introduzca la contraseña.", "Higher/Lower": "Superior/Inferior", "Questions": "Preguntas", "Potential_Payout": "Pago potencial", "Spot_Time": "Tiempo Spot", "Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_": "Su cuenta está totalmente autenticada y su límite de retirada ha sido aumentado.", "Stake": "Inversión", "There_was_a_problem_accessing_the_server_during_purchase_": "Hubo un problema al acceder al servidor durante la compra.", "Exit_Spot": "Punto de salida", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Por lo tanto, la cantidad máxima que puede retirar de forma inmediata (sujeta a la existencia de fondos suficientes en su cuenta) es [_1] [_2] (o su equivalente en otra divisa).", "Action": "Acción", "There_was_a_problem_accessing_the_server_": "Hubo un problema al acceder al servidor.", "Now": "Ahora", "Asset_Index": "Índice de activos", "Finish": "Terminar", "Select_your_underlying_asset": "Seleccione el activo subyacente", "End_Time": "Hora de finalización", "Description": "Descripción", "Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_": "Por favor, siga el patrón de 3 números y un guión seguido de 4 números.", "Target": "Objetivo", "The_Payment_Agent_facility_is_currently_not_available_in_your_country_": "Los agentes de pagos no están disponibles actualmente para su país.", "Low_Barrier": "Barrera Inferior", "Month": "Mes", "Your_transaction_reference_is": "La referencia de su transacción es", "Name": "Nombre", "Verification_code_format_incorrect_": "El formato del código de verificación es incorrecto.", "second": "segundo", "November": "Noviembre", "Sell": "Venta", "days": "días", "Male": "Hombre", "Only_[_1]_are_allowed_": "Se permiten solo [_1].", "Upgrade_to_a_Real_Account": "Actualice a la cuenta de dinero real", "Deposits_and_withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "En este momento no puede depositar ni retirar fondos de su cuenta. Por favor, póngase en contacto con [_1] para desbloquearla.", "Over/Under": "Encima/Debajo", "Please_input_a_valid_date": "Ingrese una fecha válida", "Note": "Nota", "Payments": "Pagos", "Browser": "Navegador", "Payout": "Pago", "You_did_not_change_anything_": "No ha cambiado nada.", "Adjust_trade_parameters": "Ajustar parámetros de comercio", "Barrier_Change": "Cambio de Límite", "View": "Ver", "email_address": "correo electrónico", "Su": "DO", "Resources": "Recursos", "[_1]_days_[_2]_hours_[_3]_minutes": "[_1] días [_2] horas [_3] minutos", "Please_select_a_payment_agent": "Seleccione un agente de pago", "August": "Agosto", "letters": "letras", "Upgrade_to_a_Financial_Account": "Actualice a la cuenta financiera", "months": "meses", "Current": "Actual", "Sorry,_your_account_is_not_authorised_for_any_further_contract_purchases_": "Lo sentimos, su cuenta no está autorizada para continuar con la compra de contratos.", "Upcoming_Events": "Próximos eventos", "Payment_Agent": "Agente de Pagos", "Are_you_sure_that_you_want_to_permanently_delete_token": "Está seguro de querer eliminar el token", "Your_trading_statistics_since_[_1]_": "Las estadísticas de sus transacciones desde [_1].", "Total_Cost": "Coste total", "Contract_ID": "ID del Contrato", "IP_Address": "Dirección IP", "February": "Febrero", "Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_": "Su solicitud de retirada de [_1] [_2] de su cuenta [_3] al agente de pagos [_4] se ha procesado correctamente.", "There_was_some_invalid_character_in_an_input_field_": "Había un carácter no válido en el campo de entrada.", "Start_Time": "Hora de comienzo", "Virtual_Account": "Cuenta virtual", "Th": "JU", "Monday": "Lunes", "Status": "Estado", "We": "MI", "Sorry,_this_feature_is_not_available_": "Esta funcionalidad no está disponible.", "Step": "Paso", "Spot": "Precio actual del mercado", "Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_": "El contrato se venderá al precio vigente en el mercado en el momento de la recepción de la solicitud de venta por nuestros servidores. Este precio puede ser diferente del precio indicado.", "Portfolio": "Cartera", "Your_transaction_reference_number_is_[_1]": "El número de referencia de su transacción es [_1]", "Sa": "SA", "Profit": "Beneficios", "Year": "Año", "Long": "Largos", "day": "día", "Update": "Actualizar", "Sunday": "Domingo", "Old_password_is_wrong_": "Su antigua contraseña es incorrecta.", "This_contract_lost": "Este contrato perdió", "Cashier": "Cajero", "Duration": "Duración", "Stays_In/Goes_Out": "Queda Dentro/Sale Fuera", "Contract_is_not_started_yet": "El contrato no ha comenzado todavía", "Contract_Information": "Información del Contrato", "Revoke_access": "Revocar el acceso", "Exclude_time_cannot_be_less_than_6_months_": "El tiempo de exclusión no puede ser menor a 6 meses.", "Are_you_sure_that_you_want_to_permanently_revoke_access_to_application": "Está seguro de que desea revocar permanentemente el acceso a la aplicación", "Real_Account": "Cuenta real", "Tick": "Intervalo", "Current_password": "Contraseña actual", "Opens": "Abre", "Female": "Mujer", "minute": "minuto", "Lock_Cashier": "Bloquear cajero", "Balance": "Saldo", "verification_token": "token de verificación", "Delete": "Eliminar", "High_Barrier": "Barrera Superior", "September": "Septiembre", "July": "Julio", "Indicative": "Indicativo", "Asset": "Activo", "month": "mes", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_": "Usted ya retiró el equivalente a [_1] [_2].", "Dec": "Dic", "Session_duration_limit_cannot_be_more_than_6_weeks_": "El límite de la duración de la sesión no puede ser superior a 6 semanas.", "Profit/Loss": "Ganado/Perdido", "Exit_spot": "Punto de salida", "Settles": "Establece", "Last_Digit_Stats": "Estadísticas del último dígito", "hour": "hora", "seconds": "segundos", "minutes": "minutos", "hours": "horas", "End_time": "Hora de finalización", "Withdraw": "Retirar", "Thursday": "Jueves", "You_have_already_withdrawn_[_1]_[_2]_": "Usted ya retiró [_1] [_2].", "You_need_to_finish_all_20_questions_": "Tiene que terminar todas las 20 preguntas.", "Previous": "Anterior", "Chart": "Gráfico", "Jan": "Ene", "Charting_for_this_underlying_is_delayed": "Gráficos para este instrumento se muestran con retraso", "Your_account_has_no_Login/Logout_activity_": "Su cuenta no tiene actividad de accesos/cierres de sesión.", "Apr": "Abr", "Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_": "Su [_1] límite diario para retirar dinero es actualmente [_2] [_3] (o el equivalente en otra divisa).", "Select_market": "Seleccione mercado", "Fr": "VI", "Start_time": "Hora de comienzo", "New_token_created_": "Un token nuevo ha sido creado.", "Your_account_has_no_trading_activity_": "Su cuenta no tiene actividad comercial.", "Predict_the_direction<br_/>and_purchase": "Prediga la dirección<br /> y compre", "In/Out": "Dentro/Fuera", "Reference_ID": "ID de Referencia", "numbers": "números", "Waiting_for_entry_tick_": "Esperando el tick de entrada.", "Remaining_Time": "Tiempo Restante", "Please_enter_an_integer_value": "Ingrese un valor entero", "Mo": "LU", "Withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "No se permiten las retiradas de su cuenta en este momento. Por favor, póngase en contacto con [_1] para desbloquearla.", "Your_withdrawal_limit_is_[_1]_[_2]_": "Su límite de retirada es [_1] [_2].", "Trade": "Operar", "This_contract_won": "Este contrato ganó", "Entry_Spot": "Punto de entrada", "Never": "Nunca", "Major_Pairs": "Pares mayores", "You_have_sold_this_contract_at_[_1]_[_2]": "Usted ha vendido este contrato en [_1] [_2]", "Open": "Abierto", "Date": "Fecha", "Select_your_trade_type": "Seleccione el tipo de contrato", "Exit_Spot_Time": "Tiempo de Punto de Salida", "Saturday": "Sábado", "Sorry,_an_error_occurred_while_processing_your_request_": "Lo sentimos, ha ocurrido un error mientras se procesaba su petición.", "Failed": "Fallado", "New_password": "Contraseña nueva", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_": "Por lo tanto, la cantidad máxima que puede retirar de forma inmediata (sujeta a la existencia de fondos suficientes en su cuenta) es [_1] [_2].", "This_feature_is_not_relevant_to_virtual-money_accounts_": "Esta característica no es relevante para cuentas de dinero virtual.", "Your_changes_have_been_updated_": "Sus cambios se han actualizado.", "Date_and_Time": "Fecha y Hora", "Transaction_performed_by_[_1]_(App_ID:_[_2])": "Transacción realizada por [_1] (ID de la aplicación: [_2])", "Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_": "Su contraseña se ha restablecido. Por favor, inicie sesión en su cuenta utilizando su nueva contraseña.", "All_markets_are_closed_now__Please_try_again_later_": "Todos los mercados están cerrados ahora. Inténtelo más tarde.", "Invalid_amount,_maximum_is": "Monto invalido. El máximo es", "Admin": "Administrador", "Rise/Fall": "Alza/Baja", "Return": "Ganancias", "The_two_passwords_that_you_entered_do_not_match_": "Las dos contraseñas introducidas no coinciden.", "Deposit": "Depósito", "years": "años", "Fridays": "Viernes", "Entry_spot": "Punto de entrada", "Net_profit": "Beneficio Neto", "Total_Profit/Loss": "Beneficios/perdidas totales", "There_was_an_error": "Hubo un error", "Invalid_amount,_minimum_is": "Monto inválido, el mínimo es", "Gaming_Account": "Cuenta de juego", "Never_Used": "Nunca usado", "Sorry,_this_feature_is_available_to_virtual_accounts_only_": "Lo sentimos, esta característica está disponible solo para cuentas virtuales.", "Exclude_time_cannot_be_for_more_than_5_years_": "El tiempo de exclusión no puede ser mayor a 5 años.", "Last_Used": "Último usado", "Please_select": "Seleccione", "Weekday": "Día de la semana", "Select_your_market": "Seleccione su mercado", "October": "Octubre", "space": "espacio", "Closed": "Cerrado", "January": "Enero", "Please_log_in_": "Por favor inicie sesión.", "Contract_Confirmation": "Confirmación del contrato", "June": "Junio", "Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Su límite de retirada es [_1] [_2] (o el equivalente en otra divisa).", "Japan": "Japón", "Profit_Table": "Tabla de beneficios", "April": "Abril", "Aug": "Ago", "Sale_Date": "Fecha de venta", "Purchase_Time": "Hora de compra", "Barrier": "Límite", "Password_should_have_lower_and_uppercase_letters_with_numbers_": "La contraseña debe tener letras minúsculas y mayúsculas con números.", "Ends_In/Out": "Finaliza Dentro/Fuera", "Sorry,_an_error_occurred_while_processing_your_account_": "Lo sentimos, ha ocurrido un error mientras se procesaba su cuenta.", "Invalid_email_address": "Correo electrónico no válido", "March": "Marzo", "Up/Down": "Arriba/Abajo", "Next": "Siguiente", "Amount": "Monto", "You_have_not_granted_access_to_any_applications_": "Usted no ha concedido acceso a ninguna aplicación.", "Tu": "MA", "December": "Diciembre", "[_1]_and_[_2]_cannot_be_the_same_": "[_1] y [_2] no pueden ser iguales.", "Closes": "Cierra", "Matches/Differs": "Iguales/Diferentes", "Potential_Profit": "Beneficios potenciales", "[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]": "[_1] [_2] se ha acreditado en su cuenta de dinero virtual [_3]" };
	texts_json['FR'] = { "Month": "Mois", "Low_Barrier": "Barrière inférieure", "Your_transaction_reference_is": "Votre référence de transaction est", "Verification_code_format_incorrect_": "Le format du code de vérification est incorrect.", "Name": "Nom", "November": "novembre", "second": "seconde", "Sell": "Vente", "Male": "Masculin", "Only_[_1]_are_allowed_": "Seulement [_1] autorisées.", "days": "jours", "Upgrade_to_a_Real_Account": "Ouvrir un compte réel", "Deposits_and_withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Les dépôts et retraits ne sont actuellement pas autorisés sur votre compte. Veuillez contacter [_1] pour accéder à ces fonctions.", "Asset_Index": "Indice des actifs", "Finish": "Finnois", "{JAPAN_ONLY}Your_Application_has_Been_Processed__Please_Re-Login_to_Access_Your_Real-Money_Account_": "{seulement pour le JAPON}Votre requête a été traité. Connectez vous s'il vous plaît pour accéder à votre Compte d'Argent Réel.", "Ref_": "Réf.", "Select_your_underlying_asset": "Sélectionnez votre actif sous-jacent", "End_Time": "Heure de fin", "Target": "Cible", "Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_": "Veuillez respecter le format suivant : 3 chiffres, 1 tiret suivi de 4 chiffres.", "Ends_Outside": "Termine hors de la zone", "Investor_password": "Mot de passe investisseur", "Connection_error:_Please_check_your_internet_connection_": "Erreur de connexion : veuillez vérifier votre connexion à Internet.", "The_Payment_Agent_facility_is_currently_not_available_in_your_country_": "L'option des Agents de Paiement n'est pas disponible pour le moment dans votre pays.", "Potential_Payout": "Paiement potentiel", "Spot_Time": "Heure spot", "Please_select_at_least_one_scope": "Veuillez sélectionner au moins un champ d'application", "Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_": "Votre compte est entièrement authentifié et vos limites de retrait ont été levées.", "Market_is_closed__Please_try_again_later_": "Le marché est fermé. Veuillez réessayer ultérieurement.", "There_was_a_problem_accessing_the_server_during_purchase_": "Il y a eu un problème d'accès au serveur durant l'achat.", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Par conséquent, votre montant maximal de retrait immédiat (sous réserve de fonds suffisants disponibles sur votre compte) est de [_2] [_1] (ou équivalent dans une autre devise).", "Exit_Spot": "Point de sortie", "Stake": "Investissement", "There_was_a_problem_accessing_the_server_": "Il y a eu un problème d'accès au serveur.", "Barrier_([_1])": "Barrière ([_1])", "today": "aujourd'hui", "Now": "Maintenant", "Statement": "Relevé", "Waiting_for_exit_tick_": "En attente du tick de sortie.", "[_1]_Please_click_the_link_below_to_restart_the_password_recovery_process__If_you_require_further_assistance,_please_contact_our_Customer_Support_": "[_1] Veuillez cliquer sur le lien ci-dessous pour relancer le processus de récupération de mot de passe. Pour obtenir de l'aide, veuillez contacter notre Service Clientèle.", "Insufficient_balance_": "Solde insuffisant.", "Contract_Expiry": "Échéance du contrat", "Details": "Informations", "details": "informations", "Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_": "Votre demande de transférer [_1] [_2] de [_3] à [_4] a été traitée avec succès.", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_": "Votre caisse est verrouillée conformément à votre demande - si vous souhaitez la déverrouiller, veuillez saisir le mot de passe.", "Unlock_Cashier": "Déverrouiller la caisse", "Your_Application_is_Being_Processed_": "Votre demande est en cours de traitement.", "Higher/Lower": "Supérieur/Inférieur", "Sorry,_you_have_entered_an_incorrect_cashier_password": "Désolé, vous avez entré un mot de passe de caisse incorrect", "AM": " ", "Minimum_of_[_1]_characters_required_": "Un minimum de [_1] caractères est requis.", "Credit/Debit": "Crédit/débit", "Successful": "Réussite", "logout": "déconnexion", "Change_Password": "Modifier le mot de passe", "Friday": "vendredi", "Open_a_Financial_Account": "Ouvrir un compte financier", "Current_Time": "Heure actuelle", "Even/Odd": "Pair/Impair", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_": "Vous avez déjà retiré l'équivalent de [_2] [_1] au total au cours des [_3] derniers jours.", "Price": "Prix", "Your_session_duration_limit_will_end_in_[_1]_seconds_": "Votre limite de durée de session sera atteinte dans [_1] secondes.", "Please_complete_the_[_1]financial_assessment_form[_2]_to_lift_your_withdrawal_and_trading_limits_": "Veuillez remplir le [_1]formulaire d'évaluation financière[_2] pour lever vos limites de retrait et de trading.", "Contract": "Contrat", "Only_numbers_and_spaces_are_allowed_": "Les chiffres et les espaces sont les seuls caractères autorisés.", "Higher": "Supérieur", "All_barriers_in_this_trading_window_are_expired": "Toutes les barrières de cette fenêtre de trading sont expirées", "Sell_at_market": "Vendre au prix du marché", "Purchase_Price": "Prix d'achat", "year": "année", "Walkthrough_Guide": "Guide interactif", "End_time_must_be_after_start_time_": "L'heure de fin doit être ultérieure à l'heure de début.", "The_maximum_number_of_tokens_([_1])_has_been_reached_": "Le nombre maximum de jetons d'authentification ([_1]) est atteint.", "Should_be_between_[_1]_and_[_2]": "La saisie doit se situer entre [_1] et [_2]", "Explanation": "Explication", "Contract_Sold": "Contrat vendu", "Investment_Account": "Compte d'investissement", "Password_is_not_strong_enough_": "Le mot de passe n'est pas assez fiable.", "Shop": "Boutique", "Number_of_ticks": "Nombre de ticks", "Your_token_has_expired__Please_click_<a_href=\"[_1]\">here</a>_to_restart_the_verification_process_": "Votre jeton a expiré. Veuillez cliquer <a href=\"[_1]\">ici</a> pour relancer le processus de vérification.", "This_field_is_required_": "Ce champ est requis.", "Touch/No_Touch": "Touche/Ne touche pas", "Not": "Pas", "Tuesday": "mardi", "Please_enter_a_number_between_[_1]_": "Veuillez saisir un chiffre entre [_1].", "Buy": "Acheter", "Day": "Jour", "Wednesday": "mercredi", "Trading_Times": "Horaires de trading", "Short": "Court", "An_additional_password_can_be_used_to_restrict_access_to_the_cashier_": "Un mot de passe supplémentaire peut être utilisé afin de restreindre l'accès à la caisse.", "Create_Account": "Créer un compte", "Loss": "Pertes", "Your_account_is_currently_suspended__Only_withdrawals_are_now_permitted__For_further_information,_please_contact_[_1]_": "Votre compte est actuellement suspendu. Désormais, seuls les retraits sont autorisés. Pour obtenir des informations supplémentaires, veuillez contacter [_1].", "Read": "Lire", "Time_out_must_be_after_today_": "La période d'expiration doit être ultérieure.", "Sale_Price": "Prix de vente", "Contract_Information": "Informations du contrat", "Real_Volatility": "Volatilité réelle", "Your_settings_have_been_updated_successfully_": "Vos paramètres ont été actualisés avec succès.", "Exclude_time_cannot_be_less_than_6_months_": "Le temps d'exclusion ne peut pas être inférieur à 6 mois.", "Revoke_access": "Révoquer l'accès", "Real_Account": "Compte réel", "Are_you_sure_that_you_want_to_permanently_revoke_access_to_application": "Voulez-vous vraiment révoquer l'accès à cette application de façon permanente ?", "Sunday": "dimanche", "Old_password_is_wrong_": "L'ancien mot de passe est erroné.", "This_contract_lost": "Ce contrat a été perdu", "Goes_Outside": "Sort de la zone", "Duration": "Durée", "Cashier": "Caisse", "Stays_In/Goes_Out": "Reste dans/Sort de la zone", "Contract_is_not_started_yet": "Le contrat n'est pas encore actif", "Only_numbers,_space,_and_hyphen_are_allowed_": "Les chiffres, les espaces et les traits d'union sont les seuls caractères autorisés.", "Account_balance:": "Solde du compte :", "Your_transaction_reference_number_is_[_1]": "Le numéro de référence de votre transaction est [_1]", "Portfolio": "Portefeuille", "Sell_time": "Heure de vente", "Equals": "Égaux", "Final_price": "Prix final", "Year": "Année", "Profit": "Profits", "day": "jour", "Hour": "Heure", "Update": "Mise à jour", "Only_letters,_numbers,_and_hyphen_are_allowed_": "Les lettres, les chiffres et les traits d'union sont les seuls caractères autorisés.", "Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_": "Votre demande de retirer [_1] [_2] de votre compte [_3] pour le compte de l'Agent de Paiement [_4] a été traitée avec succès.", "Start_Time": "Heure de début", "There_was_some_invalid_character_in_an_input_field_": "Un caractère non valide a été saisi dans un champ.", "Th": "Je", "Monday": "lundi", "Virtual_Account": "Compte virtuel", "Status": "Statut", "[_1]_[_2]_payout_if_[_3]_touches_Barrier_through_close_on_[_4]_": "Paiement de [_2] [_1] si [_3] touche la barrière avant la fermeture le [_4].", "Sorry,_this_feature_is_not_available_": "Désolé, cette option n'est pas disponible.", "We": "Me", "Step": "Étape", "Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_": "Le contrat sera vendu au prix de marché en vigueur à réception de la demande par nos serveurs. Ce prix peut différer du prix indiqué.", "This_symbol_is_not_active__Please_try_another_symbol_": "Ce symbole n'est pas actif. Veuillez sélectionner un autre symbole.", "Only_[_1]_decimal_points_are_allowed_": "[_1] décimales seulement sont autorisées.", "Total_Cost": "Coût total", "Contract_ID": "Identifiant du contrat", "today,_Fridays": "aujourd'hui, vendredis", "IP_Address": "Adresse IP", "February": "février", "Buy_price": "Prix d'achat", "Please_submit_a_valid_verification_token_": "Veuillez saisir un jeton de vérification valide.", "Please_[_1]accept_the_updated_Terms_and_Conditions[_2]_to_lift_your_withdrawal_and_trading_limits_": "S'il vous plait [_1]acceptez les termes et conditions mises à jour[_2] pour supprimer vos limites de retrait et de trading.", "Payment_Agent": "Agent de paiement", "Are_you_sure_that_you_want_to_permanently_delete_token": "Voulez-vous vraiment supprimer ce jeton de façon permanente ?", "Your_trading_statistics_since_[_1]_": "Vos statistiques de trading depuis [_1].", "[_1]_days_[_2]_hours_[_3]_minutes": "[_1] jours [_2] heures [_3] minutes", "The_email_address_provided_is_already_in_use__If_you_forgot_your_password,_please_try_our_<a_href=\"[_1]\">password_recovery_tool</a>_or_contact_our_customer_service_": "L'adresse e-mail que vous avez saisie est déjà utilisée. Si vous avez oublié votre mot de passe, veuillez essayer notre <a href=\"[_1]\">outil de récupération de mot de passe</a> ou contacter le service clientèle.", "Resources": "Ressources", "Su": "Di", "Please_select_a_payment_agent": "Veuillez sélectionner une date valide", "[_1]_deposit_from_[_2]_to_account_number_[_3]_is_done__Transaction_ID:_[_4]": "Le dépôt [_1] à partir de [_2] vers le numéro de compte [_3] est effectué. Identifiant de transaction : [_4]", "August": "août", "letters": "lettres", "Upgrade_to_a_Financial_Account": "Ouvrir un compte financier", "Sorry,_your_account_is_not_authorised_for_any_further_contract_purchases_": "Désolé, votre compte n'est autorisé pour aucun achat supplémentaire de contrat.", "Current": "Valeur actuelle", "months": "mois", "Upcoming_Events": "Évènements à venir", "Over/Under": "Au dessus/En dessous", "Please_input_a_valid_date": "Veuillez saisir une date valide", "Your_account_is_restricted__Kindly_[_1]contact_customer_support[_2]_for_assistance_": "Votre compte est restreint. Veuillez [_1]contacter le Service Clientèle[_2] pour obtenir de l'aide.", "Note": "Remarque", "Payments": "Paiements", "Please_<a_href=\"[_1]\">log_in</a>_to_view_this_page_": "Veuillez <a href=\"[_1]\">vous connecter</a> pour afficher cette page.", "Browser": "Navigateur", "You_did_not_change_anything_": "Vous n'avez effectué aucune modification.", "Payout": "Paiement", "email_address": "Adresse e-mail", "View": "Affichage", "Barrier_Change": "Modification de barrière", "Adjust_trade_parameters": "Définir les paramètres de la transaction", "You_have_reached_the_rate_limit_of_requests_per_second__Please_try_later_": "Vous avez atteint la limite de tentatives par seconde. Veuillez réessayer ultérieurement.", "Please_enter_an_integer_value": "Veuillez saisir un nombre entier", "Mo": "Lu", "When_you_click_\"OK\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_": "Lorsque vous cliquerez sur « Ok », vous serez exclu des opérations de trading du site jusqu'à la date sélectionnée.", "Withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Les retraits sur votre compte ne sont pas autorisés actuellement. Veuillez contacter [_1] pour déverrouiller cette fontion.", "Your_withdrawal_limit_is_[_1]_[_2]_": "Votre limite de retrait est de [_2] [_1].", "Entry_Spot": "Point d'entrée", "Trade": "Trading", "This_contract_won": "Ce contrat a été gagné", "New_token_created_": "Nouveau jeton d'authentification créé.", "Your_account_has_no_trading_activity_": "Votre compte n'indique aucune activité de trading.", "Predict_the_direction<br_/>and_purchase": "Prédire la direction<br />et acheter", "Reference_ID": "Identifiant de référence", "In/Out": "Zone In/Out", "Waiting_for_entry_tick_": "En attente du tick d'entrée.", "Please_select_a_value": "Veuillez sélectionner une valeur", "numbers": "chiffres", "Remaining_Time": "Temps restant", "Your_token_has_expired__Please_click_[_1]here[_2]_to_restart_the_verification_process_": "Votre jeton a expiré. Veuillez cliquer [_1]ici[_2] pour relancer le processus de vérification.", "from_[_1]_to_[_2]": "de [_1] à [_2]", "Jul": "juill.", "Virtual_money_credit_to_account": "Crédit de fonds virtuels sur le compte", "Jan": "jan.", "Chart": "Graphique", "Previous": "Précédent", "Lower": "Inférieur", "week": "semaine", "Nov": "nov.", "Charting_for_this_underlying_is_delayed": "Les graphiques sont retardés pour ce sous-jacent", "Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_": "Votre limite de retrait sur [_1] jours est actuellement de [_3] [_2] (ou équivalent dans une autre devise).", "[_1]_[_2]_payout_if_[_3]_ends_on_or_between_low_and_high_values_of_Barrier_at_close_on_[_4]_": "Paiement de [_2] [_1] si [_3] termine sur ou entre les valeurs inférieure et supérieure de la barrière à la fermeture le [_4].", "Apr": "avr.", "Your_account_has_no_Login/Logout_activity_": "Votre compte n'indique aucune activité de connexion/déconnexion.", "Fr": "ven.", "Select_market": "Sélectionnez un marché", "Start_time": "Heure de début", "Digit": "Chiffre", "This_is_a_staging_server_-_For_testing_purposes_only": "Il s'agit d'un serveur intermédiaire, utilisé uniquement à des fins de test", "Time_is_in_the_wrong_format_": "Le format de l'heure est incorrect.", "Stays_Between": "Reste dans la zone", "Please_select_a_valid_time_": "Veuillez sélectionner un horaire valide.", "Thursday": "jeudi", "You_have_already_withdrawn_[_1]_[_2]_": "Vous avez déjà retiré [_2] [_1].", "Ends_Between": "Termine dans la zone", "You_need_to_finish_all_20_questions_": "Vous devez répondre aux 20 questions.", "seconds": "secondes", "Low_Barrier_([_1])": "Barrière inférieure ([_1])", "Should_be_less_than_[_1]": "La saisie doit être inférieure à [_1]", "Resale_not_offered": "La revente n'est pas proposée", "hours": "heures", "End_time": "Moment de fin", "High_Barrier_([_1])": "Barrière supérieure ([_1])", "Withdraw": "Retrait", "Remaining_time": "Temps restant", "month": "mois", "Sep": "sep.", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_": "Vous avez déjà retiré l'équivalent de [_2] [_1].", "Closes_early_(at_21:00)": "Ferme tôt (à 21h)", "Scopes": "Périmètre", "Dec": "déc.", "Exit_spot": "Point de sortie", "Main_password": "Mot de passe principal", "Session_duration_limit_cannot_be_more_than_6_weeks_": "La limite de durée de session ne peut excéder 6 semaines.", "Profit/Loss": "Profits/pertes", "Should_be_a_valid_number": "La saisie doit être un nombre valide", "Oct": "oct.", "Settles": "Règlements", "Demo": "Demonstration", "Touches": "Touche", "hour": "heure", "Last_Digit_Stats": "Statistiques du dernier chiffre", "September": "septembre", "High_Barrier": "Barrière supérieure", "July": "juillet", "[_1]_withdrawal_from_account_number_[_2]_to_[_3]_is_done__Transaction_ID:_[_4]": "Le retrait [_1] à partir du numéo de compte [_2] vers [_3] a été effectué. Identifiant de transaction : [_4]", "Indicative": "Indicatif", "Percentage": "Pourcentage", "Asset": "Actif", "Current_password": "Mot de passe actuel", "True": "Vrai", "Opens": "Ouvre", "Female": "Femme", "Delete": "Supprimer", "Only_letters,_numbers,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Seuls les lettres, chiffres, espace, trait d'union et apostrophe sont permis.", "verification_token": "jeton de vérification", "Balance": "Solde", "Lock_Cashier": "Caisse", "weeks": "semaines", "Please_[_1]complete_your_account_profile[_2]_to_lift_your_withdrawal_and_trading_limits_": "S'il vous plait [_1]complétez le profile de votre compte[_2] pour supprimer vos limites de retrait et de trading.", "You_have_not_granted_access_to_any_applications_": "Vous n'avez acheté aucun contrat.", "Please_accept_the_terms_and_conditions_": "Veuillez accepter les conditions générales.", "[_1]_and_[_2]_cannot_be_the_same_": "[_1] et [_2] ne peuvent être identiques.", "Tu": "mar.", "December": "décembre", "Mar": "mars", "Matches/Differs": "Égal/Différent", "Feb": "fév.", "[_1]_[_2]_payout_if_[_3]_does_not_touch_Barrier_through_close_on_[_4]_": "Paiement de [_2] [_1] si [_3] ne touche pas la barrière jusqu'à la fermeture de l'option le [_4].", "Closes": "Fermetures", "Please_select_a_valid_date_": "Veuillez sélectionner une date valide.", "Your_changes_have_been_updated_successfully_": "Vos modifications ont bien été prises en compte.", "Time_out_cannot_be_in_the_past_": "La période d'expiration ne peut être antérieure.", "[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]": "[_2] [_1] ont été crédités sur votre compte virtuel [_3]", "You_should_enter_[_1]_characters_": "Vous devez saisir [_1] caractères.", "Congratulations!_Your_[_1]_Account_has_been_created_": "Félicitations ! Votre compte [_1] a été créé.", "Potential_Profit": "Profits potentiels", "March": "mars", "Up/Down": "Hausse/Baisse", "Next": "Suivant", "Invalid_email_address": "Adresse email non valide", "Amount": "Montant", "Please_check_the_above_form_for_pending_errors_": "Veuillez vérifier que les informations ci-dessus ne contiennent pas d'erreurs.", "Christmas_Day": "Jour de Noël", "Should_be_more_than_[_1]": "Devrait être plus de [_1]", "[_1]_[_2]_payout_if_[_3]_goes_outside_of_low_and_high_values_of_Barrier_through_close_on_[_4]_": "Paiement de [_2] [_1] si [_3] sort de la zone délimitée par les valeurs inférieure et supérieure de la barrière avant la fermeture le [_4].", "Profit_Table": "Tableau des profits", "April": "avril", "[_1]_[_2]_payout_if_[_3]_is_strictly_higher_than_or_equal_to_Barrier_at_close_on_[_4]_": "Paiement de [_2] [_1] si [_3] est strictement supérieur ou égal à la barrière au moment de la fermeture le [_4].", "Jun": "juin", "Aug": "août", "Sale_Date": "Date de vente", "May": "mai", "Purchase_Time": "Heure d'achat", "Barrier": "Barrière", "Sorry,_an_error_occurred_while_processing_your_account_": "Désolé, une erreur est survenu pendant le traitement de votre compte.", "Ends_In/Out": "Termine dans/hors de la zone", "Password_should_have_lower_and_uppercase_letters_with_numbers_": "Le mot de passe doit se composer de majuscules, de minuscules et de chiffres.", "Please_select_the_checkbox_": "Veuillez cocher la case.", "space": "espace", "October": "octobre", "Real_Standard": "Réel Standard", "January": "janvier", "Closed": "Fermé", "Contract_Confirmation": "Confirmation de contrat", "Only_letters,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Les lettres, les espaces, les traits d'union, la virgule et le point sont les seuls caractères autorisés.", "Please_log_in_": "Veuillez vous connecter.", "Closes_early_(at_18:00)": "Ferme tôt (à 18h)", "June": "juin", "False": "Faux", "Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Votre limite de retrait est de [_2] [_1] (ou équivalent dans une autre devise).", "Processing_your_request___": "Traitement de votre demande en cours...", "Japan": "Japon", "Sorry,_this_feature_is_available_to_virtual_accounts_only_": "Désolé, cette fonctionnalité est disponible uniquement pour les comptes virtuels.", "Never_Used": "Jamais utilisé", "Exclude_time_cannot_be_for_more_than_5_years_": "Le temps d'exclusion ne peut pas être supérieur à 5 ans.", "Please_select": "Sélection", "Last_Used": "Dernière utilisation", "Weekday": "Jour de la semaine", "Select_your_market": "Sélectionnez votre marché", "Today": "Aujourd'hui", "years": "années", "Deposit": "Dépôt", "The_two_passwords_that_you_entered_do_not_match_": "Les deux mots de passe que vous avez entrés ne correspondent pas.", "The_main_password_of_account_number_[_1]_has_been_changed_": "Le mot de passe principal du compte numéro [_1] a été modifié.", "Entry_spot": "Point d'entrée", "Fridays": "Vendredis", "The_server_<a_href=\"[_1]\">endpoint</a>_is:_[_2]": "Le <a href=\"[_1]\"> 1terminal</a> 2 du serveur est : [_2]", "Net_profit": "Bénéfice net", "Total_Profit/Loss": "Total des profits/pertes", "Invalid_amount,_minimum_is": "Montant non valide, le minimum est de", "Gaming_Account": "Compte de jeu", "There_was_an_error": "Une erreur s'est produite", "Token": "Jeton", "Sorry,_account_signup_is_not_available_in_your_country__Please_contact_<a_href=\"[_1]\">customer_support</a>_for_more_information_": "Nous sommes désolés, l'inscription pour un compte n'est pas disponible dans votre pays. Veuillez contacter le <a href=\"[_1]\">service clientèle</a> pour obtenir des informations.", "This_feature_is_not_relevant_to_virtual-money_accounts_": "Cette fonction ne s'applique pas aux comptes virtuels.", "Your_changes_have_been_updated_": "Vos modifications ont été prises en compte.", "New_password": "Nouveau mot de passe", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_": "Par conséquent, votre montant maximal de retrait immédiat (sous réserve de fonds suffisants disponibles sur votre compte) est de [_2] [_1].", "Transaction_performed_by_[_1]_(App_ID:_[_2])": "Transaction effectuée par [_1] (identifiant d'application : [_2])", "Date_and_Time": "Date et heure", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_click_<a_href=\"[_1]\">here</a>_": "Votre caisse est verrouillée conformément à votre demande - si vous souhaitez la déverrouiller, veuillez cliquer <a href=\"[_1]\">ici</a>.", "All_markets_are_closed_now__Please_try_again_later_": "Tous les marchés sont actuellement fermés. Veuillez réessayer ultérieurement.", "Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_": "Votre mot de passe a été réinitialisé avec succès. Veuillez vous connecter à votre compte en utilisant votre nouveau mot de passe.", "Real_STP": "Réel STP", "Does_Not_Touch": "Ne touche pas", "Invalid_amount,_maximum_is": "Montant non valide, le maximum est de", "[_1]_[_2]_payout_if_[_3]_is_strictly_lower_than_Barrier_at_close_on_[_4]_": "Paiement de [_2] [_1] si [_3] est strictement inférieur ou égal à la barrière au moment de la fermeture le [_4].", "Return": "Retours sur investissement", "Rise/Fall": "Hausse/Baisse", "Admin": "Administration", "[_1]_[_2]_payout_if_[_3]_stays_between_low_and_high_values_of_Barrier_through_close_on_[_4]_": "Paiement de [_2] [_1] si [_3] reste dans la zone délimitée par les valeurs supérieure et inférieure de la barrière jusqu'à la fermeture le [_4].", "Never": "Jamais", "You_have_sold_this_contract_at_[_1]_[_2]": "Vous avez vendu ce contrat [_2] [_1]", "Major_Pairs": "Paires majeures", "Real_Cent": "Compte réel Cent", "New_Year's_Day": "Jour de l'An", "Open": "Ouvrir", "[_1]_[_2]_payout_if_[_3]_ends_outside_low_and_high_values_of_Barrier_at_close_on_[_4]_": "Paiement de [_2] [_1] si [_3] termine hors de la zone délimitée par les valeurs inférieure et supérieure de la barrière à la fermeture le [_4].", "Select_your_trade_type": "Sélectionnez votre type de transaction", "Time_out_cannot_be_more_than_6_weeks_": "La période d'expiration ne peut excéder 6 semaines.", "Exit_Spot_Time": "Prix de sortie actuel", "Saturday": "samedi", "Sorry,_an_error_occurred_while_processing_your_request_": "Désolé, une erreur s'est produite pendant le traitement de votre demande.", "Failed": "Échec" };
	texts_json['ID'] = { "Closes_early_(at_18:00)": "Ditutup awal (pada 18:00)", "June": "Juni", "False": "Salah", "Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Batas penarikan Anda adalah [_1] [_2] (atau setara dengan mata uang lain).", "Processing_your_request___": "Memproses permintaan Anda...", "Japan": "Jepang", "Please_select_the_checkbox_": "Silakan pilih kotak centang.", "space": "ruang", "October": "Oktober", "Real_Standard": "Standar Riil", "January": "Januari", "Closed": "Tutup", "Contract_Confirmation": "Konfirmasi Kontrak", "Please_log_in_": "Silahkan log in.", "Only_letters,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Hanya huruf, spasi, tanda hubung, periode, dan apostrof diperbolehkan.", "May": "Mei", "Sale_Date": "Tanggal Jual", "Purchase_Time": "Waktu Beli", "Barrier": "Batasan", "Sorry,_an_error_occurred_while_processing_your_account_": "Maaf, error terjadi ketika memproses rekening Anda.", "Password_should_have_lower_and_uppercase_letters_with_numbers_": "Kata sandi harus memiliki huruf kecil dan besar beserta angka.", "Profit_Table": "Tabel Laba Rugi", "[_1]_[_2]_payout_if_[_3]_is_strictly_higher_than_or_equal_to_Barrier_at_close_on_[_4]_": "Hasil [_1] [_2] jika [_3] pasti lebih tinggi dari atau sama dengan Batasan pada penutupan [_4].", "Jun": "Juni", "Aug": "Agustus", "Should_be_more_than_[_1]": "Harus lebih dari [_1]", "[_1]_[_2]_payout_if_[_3]_goes_outside_of_low_and_high_values_of_Barrier_through_close_on_[_4]_": "Hasil [_1] [_2] jika [_3] berakhir keluar Batasan rendah dan tinggi hingga penutupan [_4].", "March": "Maret", "Next": "Lanjutkan", "Invalid_email_address": "Invalid alamat email", "Amount": "Jumlah", "Please_check_the_above_form_for_pending_errors_": "Silahkan periksa formulir diatas untuk error yang masih tertunda.", "Christmas_Day": "Hari Natal", "[_1]_and_[_2]_cannot_be_the_same_": "[_1] dan [_2] tidak bisa sama.", "Please_accept_the_terms_and_conditions_": "Silahkan terima syarat dan ketentuan.", "December": "Desember", "Tu": "Kam", "Feb": "Peb", "Closes": "Ditutup", "[_1]_[_2]_payout_if_[_3]_does_not_touch_Barrier_through_close_on_[_4]_": "Hasil [_1] [_2] jika [_3] tidak menyentuh Batasan hingga penutupan [_4].", "Please_select_a_valid_date_": "Pilih tanggal yang berlaku.", "Your_changes_have_been_updated_successfully_": "Perubahan Anda telah berhasil diperbarui.", "Time_out_cannot_be_in_the_past_": "Time out tidak bisa di masa lalu.", "[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]": "[_1] [_2] telah dikreditkan kedalam akun uang virtual Anda [_3]", "You_should_enter_[_1]_characters_": "Anda harus memasukkan [_1] karakter.", "Congratulations!_Your_[_1]_Account_has_been_created_": "Selamat! Akun [_1] Anda telah berhasil didaftarkan.", "Potential_Profit": "Potensi Hasil", "Please_[_1]complete_your_account_profile[_2]_to_lift_your_withdrawal_and_trading_limits_": "Silahkan [_1]lengkapi profil akun Anda[_2] untuk meningkatkan batasan penarikan dan trading.", "You_have_not_granted_access_to_any_applications_": "Anda belum diberikan akses ke dalam aplikasi apapun.", "Time_out_cannot_be_more_than_6_weeks_": "Time out tidak bisa lebih dari 6 minggu.", "Select_your_trade_type": "Pilih jenis kontrak Anda", "Exit_Spot_Time": "Waktu Exit Spot", "Saturday": "Sabtu", "Failed": "Gagal", "Sorry,_an_error_occurred_while_processing_your_request_": "Maaf, error terjadi ketika memproses permohonan Anda.", "[_1]_[_2]_payout_if_[_3]_stays_between_low_and_high_values_of_Barrier_through_close_on_[_4]_": "Hasil [_1] [_2] jika [_3] tetap berada pada Batasan rendah dan tinggi hingga penutupan [_4].", "Never": "Tidak pernah", "You_have_sold_this_contract_at_[_1]_[_2]": "Anda telah menjual kontrak pada [_1] [_2]", "Major_Pairs": "Pasangan Utama", "Real_Cent": "Riil Cent", "New_Year's_Day": "Tahun Baru", "Date": "Tanggal", "Open": "Awal", "[_1]_[_2]_payout_if_[_3]_ends_outside_low_and_high_values_of_Barrier_at_close_on_[_4]_": "Hasil [_1] [_2] jika [_3] berakhir diluar Batasan rendah dan tinggi pada penutupan [_4].", "All_markets_are_closed_now__Please_try_again_later_": "Semua pasar ditutup saat ini. Coba kembali nanti.", "Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_": "Kata sandi Anda sudah berhasil dibuat ulang. Silahkan akes akun Anda menggunakan kata sandi baru.", "Real_STP": "STP Riil", "[_1]_[_2]_payout_if_[_3]_is_strictly_lower_than_Barrier_at_close_on_[_4]_": "Hasil [_1] [_2] jika [_3] pasti lebih rendah dari Batasan pada penutupan [_4].", "Invalid_amount,_maximum_is": "Jumlah tidak berlaku, maksimal", "Return": "Laba", "Sorry,_account_signup_is_not_available_in_your_country__Please_contact_<a_href=\"[_1]\">customer_support</a>_for_more_information_": "Maaf, pendaftaran akun tidak tersedia untuk negara domisili Anda. Silahkan hubungi <a href=\"[_1]\">customer support</a> untuk info lebih lanjut.", "Your_changes_have_been_updated_": "Perubahan Anda telah diperbarui.", "This_feature_is_not_relevant_to_virtual-money_accounts_": "Fasilitas ini tidak tersedia untuk akun uang virtual.", "New_password": "Kata sandi baru", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_": "Oleh karena itu jumlah maksimal yang dapat Anda cairkan langsung (jika saldo mencukupi) adalah [_1] [_2].", "Transaction_performed_by_[_1]_(App_ID:_[_2])": "Transaksi dilakukan oleh [_1] (App ID: [_2])", "Date_and_Time": "Tanggal dan Waktu", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_click_<a_href=\"[_1]\">here</a>_": "Bagian kasir akun Anda telah di batalkan - untuk membukanya, silahkan klik <a href=\"[_1]\">disini</a>.", "The_server_<a_href=\"[_1]\">endpoint</a>_is:_[_2]": "Titik akhir <a href=\"[_1]\">server</a> adalah: [_2]", "Net_profit": "Laba bersih", "Total_Profit/Loss": "Total Untung/Rugi", "Invalid_amount,_minimum_is": "Jumlah tidak berlaku, minimal", "Gaming_Account": "Akun Trading", "There_was_an_error": "Terdapat error", "years": "tahun", "The_two_passwords_that_you_entered_do_not_match_": "Kedua-dua kata sandi yang Anda masukkan tidak cocok.", "The_main_password_of_account_number_[_1]_has_been_changed_": "Kata sandi utama untuk akun [_1] telah dirubah.", "Entry_spot": "Spot masuk", "Fridays": "Jum'at", "Please_select": "Tolong pilih", "Last_Used": "Terakhir digunakan", "Weekday": "Hari Kerja", "Select_your_market": "Pilih market anda", "Today": "Hari ini", "Sorry,_this_feature_is_available_to_virtual_accounts_only_": "Maaf, fasilitas ini hanya tersedia untuk rekening virtual saja.", "Never_Used": "Tidak pernah dipakai", "Exclude_time_cannot_be_for_more_than_5_years_": "Waktu pengecualian tidak dapat melebihi 5 tahun.", "Please_select_a_valid_time_": "Silahkan pilih waktu yang berlaku.", "Thursday": "Kamis", "You_have_already_withdrawn_[_1]_[_2]_": "Anda telah menarik dana sebesar [_1] [_2].", "You_need_to_finish_all_20_questions_": "Anda perlu menjawab semua 20 pertanyaan.", "This_is_a_staging_server_-_For_testing_purposes_only": "Ini adalah staging server - Untuk tujuan pengujian saja", "Time_is_in_the_wrong_format_": "Waktu dalam format salah.", "Nov": "Nop", "Charting_for_this_underlying_is_delayed": "Grafik untuk dasar pasar mengalami penundaan", "Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_": "Batas penarikan [_1] hari Anda saat ini adalah [_2] [_3] (atau setara dengan mata uang lainnya).", "[_1]_[_2]_payout_if_[_3]_ends_on_or_between_low_and_high_values_of_Barrier_at_close_on_[_4]_": "Hasil [_1] [_2] jika [_3] berakhir pada atau antara Batasan rendah dan tinggi pada penutupan [_4].", "Your_account_has_no_Login/Logout_activity_": "Akun Anda tidak memiliki aktifitas Login/Logout.", "Fr": "Jum", "Please_set_your_30-day_turnover_limit_in_our_[_1]self-exclusion_facilities[_2]_to_remove_deposit_limits_": "Tentukan batasan total pembelian kontrak 30-hari pada [_1]fasilitas pengecualian diri[_2] untuk menghapus batasan deposit Anda.", "Select_market": "Pilih pasar", "Start_time": "Waktu mulai", "from_[_1]_to_[_2]": "dari [_1] ke [_2]", "Virtual_money_credit_to_account": "Mengkreditkan dana virtual kedalam akun", "Previous": "Sebelumnya", "Chart": "Grafik", "Please_set_[_1]country_of_residence[_2]_before_upgrading_to_a_real-money_account_": "Silahkan pilih %negara domisili[_2] sebelum mengupgrade ke dalam akun riil.", "week": "minggu", "Please_select_a_value": "Silahkan pilih nilai", "Waiting_for_entry_tick_": "Menunggu tik masuk...", "numbers": "nomor", "Your_token_has_expired__Please_click_[_1]here[_2]_to_restart_the_verification_process_": "Token Anda telah berakhir. Silahkan klik [_1]disini[_2] untuk memulai proses verifikasi.", "Remaining_Time": "Waktu Yang Tersisa", "New_token_created_": "Token baru dibuat.", "Your_account_has_no_trading_activity_": "Akun Anda tidak memiliki aktifitas trading.", "Predict_the_direction<br_/>and_purchase": "Analisa arah<br />dan beli", "Reference_ID": "ID referensi", "Minute": "Menitan", "Your_withdrawal_limit_is_[_1]_[_2]_": "Batas penarikan Anda adalah [_1] [_2].", "Entry_Spot": "Spot Masuk", "This_contract_won": "Kontrak ini untung", "Please_enter_an_integer_value": "Silahkan masukan nilai penuh", "Mo": "Sen", "When_you_click_\"OK\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_": "Setelah mengklik \"OK\" Anda akan dikecualikan dari trading hingga tanggal yang dipilih.", "Withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Penarikan untuk akun Anda tidak dapat dilanjutkan untuk saat ini. Silahkan hubungi [_1] untuk pengaktifan.", "minute": "menit", "Delete": "Hapus", "Only_letters,_numbers,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Hanya huruf, angka, ruang, tanda hubung, periode, dan apostrof diperbolehkan.", "verification_token": "token verifikasi", "Balance": "Saldo", "Lock_Cashier": "Kunci Kasir", "weeks": "minggu", "Tick": "Tik", "Current_password": "Kata sandi saat ini", "Female": "Wanita", "True": "Benar", "Opens": "Dibuka", "Indicative": "Indikatif", "Percentage": "Persentase", "Asset": "Aset", "High_Barrier": "Batasan Tinggi", "July": "Juli", "[_1]_withdrawal_from_account_number_[_2]_to_[_3]_is_done__Transaction_ID:_[_4]": "[_1] penarikan dari akun [_2] ke [_3] telah berhasil. ID Transaksi: [_4]", "Exit_spot": "Spot akhir", "Main_password": "Kata sandi utama", "Profit/Loss": "Untung/Rugi", "Session_duration_limit_cannot_be_more_than_6_weeks_": "Batas durasi sesi tidak dapat lebih dari 6 minggu.", "Should_be_a_valid_number": "Harus angka yang berlaku", "Settles": "Diselesaikan", "Oct": "Oktober", "hour": "jam", "Last_Digit_Stats": "Statistik Digit Terakhir", "month": "bulan", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_": "Anda telah melakukan penarikan setara dengan [_1] [_2].", "Closes_early_(at_21:00)": "Ditutup awal (pada 21:00)", "Scopes": "Cakupan", "Dec": "Des", "High_Barrier_([_1])": "Batasan Tinggi ([_1])", "Score": "Skor", "Withdraw": "Pencairan", "Remaining_time": "Waktu yang tersisa", "seconds": "detik", "Low_Barrier_([_1])": "Batasan Rendah ([_1])", "Should_be_less_than_[_1]": "Harus kurang dari [_1]", "Resale_not_offered": "Penjualan ulang tidak ditawarkan", "minutes": "menit", "hours": "jam", "End_time": "Waktu end", "We": "Kami", "Sorry,_this_feature_is_not_available_": "Maaf, fasilitas ini tidak tersedia.", "Spot": "Posisi", "Step": "Langkah", "Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_": "Kontrak akan dijual pada harga pasar terkini ketika permintaan diterima oleh server kami. Harga ini mungkin berbeda dari harga yang diindikasikan.", "This_symbol_is_not_active__Please_try_another_symbol_": "Simbol ini tidak aktif. Silakan coba simbol lain.", "Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_": "Permohonan penarikan Anda [_1] [_2] dari account [_3] ke Agen Pembayaran [_4] telah diproses.", "There_was_some_invalid_character_in_an_input_field_": "Terdapat beberapa karakter yang tidak berlaku pada kolom input.", "Start_Time": "Waktu Mulai", "Monday": "Senin", "Th": "Kam", "Virtual_Account": "Akun Virtual", "[_1]_[_2]_payout_if_[_3]_touches_Barrier_through_close_on_[_4]_": "Hasil [_1] [_2] jika [_3] menyentuh Batasan hingga penutupan [_4].", "Long": "Panjang", "Year": "Tahun", "Profit": "Keuntungan", "day": "hari", "Hour": "Jam", "Only_letters,_numbers,_and_hyphen_are_allowed_": "Hanya huruf, angka, dan tanda hubung diperbolehkan.", "Update": "Memperbarui", "Account_balance:": "Saldo akun:", "Only_numbers,_space,_and_hyphen_are_allowed_": "Hanya angka, ruang dan tanda hubung diperbolehkan.", "Your_transaction_reference_number_is_[_1]": "Nomor referensi transaksi Anda adalah [_1]", "Portfolio": "Portopolio", "Equals": "Sama", "Sell_time": "Waktu jual", "Sa": "Sab", "Final_price": "Harga akhir", "[_1]Authenticate_your_account[_2]_now_to_take_full_advantage_of_all_withdrawal_options_available_": "[_1]Otentikasi akun Anda[_2] untuk manfaat maksimal dari pilihan penarikan yang tersedia.", "Contract_is_not_started_yet": "Kontrak belum dimulai", "Sunday": "Minggu", "Old_password_is_wrong_": "Kata sandi lama salah.", "This_contract_lost": "Kontrak ini rugi", "Cashier": "Kasir", "Duration": "Durasi", "Real_Account": "Akun Riil", "Are_you_sure_that_you_want_to_permanently_revoke_access_to_application": "Apakah Anda yakin bahwa Anda ingin secara permanen mencabut akses ke aplikasi", "Contract_Information": "Informasi Kontrak", "Real_Volatility": "Volatilitas Nyata", "Your_settings_have_been_updated_successfully_": "Bagian pengaturan Anda telah berhasil diperbarui.", "Revoke_access": "Mencabut akses", "Exclude_time_cannot_be_less_than_6_months_": "Waktu pengecualian tidak boleh kurang dari 6 bulan.", "Payments": "Pembayaran", "Please_<a_href=\"[_1]\">log_in</a>_to_view_this_page_": "Silahkan <a href=\"[_1]\">masuk</a> untuk melihat halaman ini.", "Payout": "Hasil", "You_did_not_change_anything_": "Anda tidak melakukan perubahan.", "View": "Lihat", "email_address": "alamat email", "Adjust_trade_parameters": "Menyesuaikan parameter trading", "Barrier_Change": "Perubahan Batasan", "You_have_reached_the_rate_limit_of_requests_per_second__Please_try_later_": "Anda telah mencapai batas tingkat permintaan per detik. Silakan coba lagi nanti.", "Please_input_a_valid_date": "Masukkan tanggal yang benar", "Your_account_is_restricted__Kindly_[_1]contact_customer_support[_2]_for_assistance_": "Akun Anda memiliki akses terbatas. Silahkan [_1]hubungi customer support[_2] untuk bantuan.", "Note": "Catatan", "mins": "menit", "Current": "Saat ini", "months": "bulan", "Sorry,_your_account_is_not_authorised_for_any_further_contract_purchases_": "Maaf, akun Anda tidak dapat membeli kontrak selanjutnya.", "Upcoming_Events": "Acara Mendatang", "[_1]_days_[_2]_hours_[_3]_minutes": "[_1] hari [_2] jam [_3] menit", "The_email_address_provided_is_already_in_use__If_you_forgot_your_password,_please_try_our_<a_href=\"[_1]\">password_recovery_tool</a>_or_contact_our_customer_service_": "Alamat email yang Anda sediakan sudah pernah di daftarkan. Jika Anda lupa kata sandi, silahkan coba <a href=\"[_1]\">alat pemulihan kata sandi</a> atau hubungi customer service kami.", "Resources": "Sumber", "Su": "Mgg", "Please_select_a_payment_agent": "Silahkan pilih agen pembayaran", "[_1]_deposit_from_[_2]_to_account_number_[_3]_is_done__Transaction_ID:_[_4]": "[_1] deposit dari [_2] ke dalam akun [_3] telah berhasil. ID Transaksi: [_4]", "August": "Agustus", "Upgrade_to_a_Financial_Account": "Upgrade ke Akun Finansial", "letters": "huruf", "Your_trading_statistics_since_[_1]_": "Statistik trading Anda sejak [_1].", "Are_you_sure_that_you_want_to_permanently_delete_token": "Apakah Anda yakin untuk menghapus token secara permanen", "Please_[_1]accept_the_updated_Terms_and_Conditions[_2]_to_lift_your_withdrawal_and_trading_limits_": "Silahkan [_1]setujui Syarat dan Ketentuan terbaru[_2] untuk meningkatkan batasan penarikan dan trading Anda.", "Payment_Agent": "Agen Pembayaran", "February": "Pebruari", "Buy_price": "Harga beli", "Please_submit_a_valid_verification_token_": "Kirimkan token verifikasi yang berlaku.", "Only_[_1]_decimal_points_are_allowed_": "Hanya [_1] poin desimal diperbolehkan.", "Contract_ID": "ID Kontrak", "Total_Cost": "Total Biaya", "today,_Fridays": "hari ini, Jumat", "IP_Address": "Alamat IP", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_": "Kasir Anda terkunci sesuai permintaan Anda - untuk membuka kunci, masukkan kata sandi.", "Unlock_Cashier": "Buka Kasir", "Your_Application_is_Being_Processed_": "Permohonan Anda Sudah Terproses.", "Questions": "Pertanyaan", "Statement": "Pernyataan", "Waiting_for_exit_tick_": "Menunggu tik akhir.", "[_1]_Please_click_the_link_below_to_restart_the_password_recovery_process__If_you_require_further_assistance,_please_contact_our_Customer_Support_": "[_1] Silahkan klik link di bawah ini untuk memulai kembali proses pemulihan kata sandi. Jika Anda membutuhkan bantuan lebih lanjut, silakan hubungi Customer Support kami.", "Contract_Expiry": "Kontrak berakhir", "Insufficient_balance_": "Saldo tidak mencukupi.", "Details": "Rincian", "details": "perincian", "Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_": "Permintaan Anda untuk mentransfer [_1] [_2] dari [_3] ke [_4] berhasil diproses.", "There_was_a_problem_accessing_the_server_during_purchase_": "Terjadi masalah mengakses server saat pembelian berlangsung.", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Maka dengan itu jumlah maksimal yang dapat Anda tarik (tergantung pada saldo tunai yang tersedia) adalah [_1] [_2] (atau setara dengan mata uang lainnya).", "Exit_Spot": "Spot akhir", "Stake": "Modal", "Action": "Aksi", "Now": "Sekarang", "There_was_a_problem_accessing_the_server_": "Terjadi masalah pada saat mengakses server.", "Barrier_([_1])": "Batasan ([_1])", "today": "hari ini", "Potential_Payout": "Potensi Hasil", "Spot_Time": "Waktu Spot", "Please_select_at_least_one_scope": "Silakan pilih minimal satu scope", "Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_": "Akun Anda telah terbukti dan batasan penarikan Anda telah dihapuskan.", "Market_is_closed__Please_try_again_later_": "Pasar ditutup. Silakan coba kembali nanti.", "End_Time": "Waktu berakhir", "Target": "Sasaran", "Description": "Deskripsi", "Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_": "Silahkan ikuti pola 3 angka, garis, diikuti oleh 4 angka.", "Investor_password": "Kata sandi investor", "Connection_error:_Please_check_your_internet_connection_": "Koneksi error: Silakan periksa koneksi internet Anda.", "The_Payment_Agent_facility_is_currently_not_available_in_your_country_": "Fasilitas Agen Pembayaran tidak tersedia pada negara anda.", "Asset_Index": "Indeks Aset", "Finish": "Selesai", "Select_your_underlying_asset": "Pilih aset dasar Anda", "Sell": "Jual", "Only_[_1]_are_allowed_": "Hanya [_1] dibenarkan.", "Male": "Pria", "days": "hari", "Upgrade_to_a_Real_Account": "Upgrade ke Akun Riil", "Deposits_and_withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Bagian deposit dan penarikan akun Anda tidak tersedia untuk sementara. Silahkan hubungi [_1] untuk pengaktifan.", "Low_Barrier": "Batasan Rendah", "Month": "Bulan", "Your_transaction_reference_is": "Referensi transaksi Anda adalah", "Verification_code_format_incorrect_": "Format kode verifikasi salah.", "Name": "Nama", "November": "Nopember", "second": "detik", "Loss": "Rugi", "Create_Account": "Daftar Akun", "Permissions": "Izin", "Your_account_is_currently_suspended__Only_withdrawals_are_now_permitted__For_further_information,_please_contact_[_1]_": "Saat ini akun Anda ditangguhkan. Hanya penarikan yang dapat Anda lakukan. Untuk informasi lanjut, silahkan hubungi [_1].", "Read": "Baca", "Time_out_must_be_after_today_": "Time out harus setelah hari ini.", "Sale_Price": "Harga Jual", "Please_enter_a_number_between_[_1]_": "Silakan masukkan nomor antara [_1].", "Wednesday": "Rabu", "Buy": "Beli", "Day": "Hari", "h": "j", "Trading_Times": "Waktu Trading", "Short": "Pendek", "An_additional_password_can_be_used_to_restrict_access_to_the_cashier_": "Kata sandi tambahan dapat digunakan untuk membatasi akses ke kasir.", "Shop": "Toko", "Number_of_ticks": "Jumlah tik", "Your_token_has_expired__Please_click_<a_href=\"[_1]\">here</a>_to_restart_the_verification_process_": "Token Anda telah berakhir. Silahkan klik <a href=\"[_1]\">disini</a> untuk memulai kembali proses verifikasi.", "This_field_is_required_": "Bagian ini diperlukan.", "Tuesday": "Selasa", "Not": "Bukan", "Should_be_between_[_1]_and_[_2]": "Harus antara [_1] dan [_2]", "The_maximum_number_of_tokens_([_1])_has_been_reached_": "Jumlah maksimum token ([_1]) telah tercapai.", "Contract_Sold": "Kontrak Terjual", "Explanation": "Penjelasan", "Investment_Account": "Akun Investasi", "Password_is_not_strong_enough_": "Kata sandi tidak cukup kuat.", "Contract": "Kontrak", "Only_numbers_and_spaces_are_allowed_": "Hanya nomor dan spasi diperbolehkan.", "All_barriers_in_this_trading_window_are_expired": "Semua batasan pada tampilan trading ini telah berakhir", "Sell_at_market": "Jual pada pasar", "Purchase_Price": "Harga Beli", "Walkthrough_Guide": "Panduan Langsung", "year": "tahun", "End_time_must_be_after_start_time_": "Waktu berakhir harus setelah waktu mulai.", "Open_a_Financial_Account": "Daftar Akun Finansial", "Current_Time": "Waktu Terkini", "Price": "Harga", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_": "Anda telah menarik dana sebesar [_1] [_2] dalam tempo [_3] hari terakhir.", "Your_session_duration_limit_will_end_in_[_1]_seconds_": "Batas durasi sesi Anda akan berakhir dalam [_1] detik.", "Please_complete_the_[_1]financial_assessment_form[_2]_to_lift_your_withdrawal_and_trading_limits_": "Silahkan lengkapi [_1]formulir penilaian finansial[_2] untuk meningkatkan batasan penarikan dan trading Anda.", "logout": "keluar", "Successful": "Berhasil", "Change_Password": "Perubahan Kata Sandi", "Friday": "Jum'at", "Sorry,_you_have_entered_an_incorrect_cashier_password": "Maaf, kata sandi yang Anda masukkan salah", "Minimum_of_[_1]_characters_required_": "Minimal [_1] karakter diperlukan.", "Credit/Debit": "Kredit/Debit" };
	texts_json['IT'] = { "Password_should_have_lower_and_uppercase_letters_with_numbers_": "La password deve contenere lettere minuscole e maiuscole con numeri.", "Ends_In/Out": "Termina In/Out", "Sorry,_an_error_occurred_while_processing_your_account_": "Siamo spiacenti, si è verificato un errore durante l'elaborazione del tuo account.", "Barrier": "Barriera", "Purchase_Time": "Orario d'acquisto", "May": "Mag", "Sale_Date": "Data della vendita", "Aug": "Ago", "Jun": "Giu", "April": "Aprile", "Profit_Table": "Tabella dei profitti", "Japan": "Giappone", "Processing_your_request___": "Elaborazione in corso della tua richiesta...", "Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Il tuo limite di prelievo è [_2] [_1] (oppure equivalente in altra valuta).", "False": "Falso", "June": "Giugno", "Closes_early_(at_18:00)": "Chiude in anticipo (alle 18:00)", "Only_letters,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Sono consentite solo lettere, spazi, trattini, punti e apostrofi.", "Please_log_in_": "Effettua il login.", "Contract_Confirmation": "Conferma del contratto", "Closed": "Chiuso", "January": "Gennaio", "October": "Ottobre", "space": "spazio", "Potential_Profit": "Profitto potenziale", "Congratulations!_Your_[_1]_Account_has_been_created_": "Congratulazioni! Il tuo account [_1] è stato creato.", "You_should_enter_[_1]_characters_": "Dovresti inserire [_1] caratteri.", "[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]": "[_1] [_2] sono stati accreditati sul tuo Account di moneta virtuale [_3]", "Your_changes_have_been_updated_successfully_": "Le tue modifiche sono state aggiornate con successo.", "Please_select_a_valid_date_": "Seleziona una data valida.", "Closes": "Chiude", "[_1]_[_2]_payout_if_[_3]_does_not_touch_Barrier_through_close_on_[_4]_": "Il payout di [_1] [_2] se [_3] non tocca la Barriera vicino a [_4].", "Matches/Differs": "Combacia/Differisce", "Tu": "Mar", "December": "Dicembre", "[_1]_and_[_2]_cannot_be_the_same_": "[_1] e 2% non possono essere uguali.", "Please_accept_the_terms_and_conditions_": "Accetta i termini e le condizioni.", "You_have_not_granted_access_to_any_applications_": "Non hai accesso ad alcuna applicazione.", "Christmas_Day": "Giorno di Natale", "Amount": "Importo", "Invalid_email_address": "Indirizzo email non valido", "March": "Marzo", "Next": "Successivo", "Admin": "Amministratore", "Return": "Rendimento", "Rise/Fall": "Rialzo/Ribasso", "Invalid_amount,_maximum_is": "Importo non valido, il massimo è", "Does_Not_Touch": "Non tocca", "Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_": "La tua password è stata ripristinata con successo. Effettua il login sul tuo account utilizzando la tua nuova password.", "All_markets_are_closed_now__Please_try_again_later_": "Al momento tutti i mercati sono chiusi. Si prega di riprovare più tardi.", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_click_<a_href=\"[_1]\">here</a>_": "Come da tua richiesta, la cassa è bloccata. Per sbloccarla, clicca <a href=\"[_1]\">qui</a>.", "Date_and_Time": "Data e orario", "Transaction_performed_by_[_1]_(App_ID:_[_2])": "Transazione eseguita da [_1] (ID dell'app ID: [_2])", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_": "Pertanto il tuo attuale prelievo massimo immediato (soggetto alla disponibilità di fondi sufficienti nell'account) è pari a [_1] [_2].", "New_password": "Nuova password", "This_feature_is_not_relevant_to_virtual-money_accounts_": "Questa funzione non è riferita agli account con denaro virtuale.", "Your_changes_have_been_updated_": "Le tue modifiche sono state aggiornate.", "Failed": "Non riuscito", "Sorry,_an_error_occurred_while_processing_your_request_": "Siamo spiacenti, si è verificato un errore durante l'elaborazione della tua richiesta.", "Saturday": "Sabato", "Exit_Spot_Time": "Orario del prezzo di uscita", "Select_your_trade_type": "Seleziona la tua tipologia di trade", "Date": "Data", "Open": "Apri", "Major_Pairs": "Coppie principali", "You_have_sold_this_contract_at_[_1]_[_2]": "Hai venduto questo contratto a [_1] [_2]", "Never": "Mai", "Today": "Oggi", "Select_your_market": "Seleziona il tuo mercato", "Weekday": "Giorno feriale", "Last_Used": "Ultimo utilizzato", "Please_select": "Seleziona", "Exclude_time_cannot_be_for_more_than_5_years_": "Il periodo di esclusione non può essere superiore a 5 anni.", "Never_Used": "Mai utilizzato", "Sorry,_this_feature_is_available_to_virtual_accounts_only_": "Siamo spiacenti, questa funzione è disponibile solo sugli account virtuali.", "There_was_an_error": "Si è verificato un errore", "Gaming_Account": "Account di gioco", "Invalid_amount,_minimum_is": "Importo non valido, il minimo è", "Total_Profit/Loss": "Profitto/Perdita totale", "Net_profit": "Profitto netto", "The_server_<a_href=\"[_1]\">endpoint</a>_is:_[_2]": "Il server <a href=\"[_1]\">finale</a> è: [_2]", "Entry_spot": "Punto d'ingresso", "Fridays": "Venerdì", "The_main_password_of_account_number_[_1]_has_been_changed_": "La password principale del numero di account [_1] è stata modificata.", "Deposit": "Deposita", "The_two_passwords_that_you_entered_do_not_match_": "Le due password inserite non combaciano.", "years": "anni", "Start_time": "Orario d'inizio", "Select_market": "Seleziona il mercato", "Fr": "Ven", "Your_account_has_no_Login/Logout_activity_": "Sul tuo account non c'è alcuna attività di Login/Logout.", "Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_": "Il tuo limite di prelievo giornaliero di [_1] è attualmente [_2] [_3] (oppure equivalente in un'altra valuta).", "[_1]_[_2]_payout_if_[_3]_ends_on_or_between_low_and_high_values_of_Barrier_at_close_on_[_4]_": "Il payout di [_1] [_2] se [_3] termina su o tra i valori inferiori e superiori del prezzo d'esercizio vicino a [_4].", "Charting_for_this_underlying_is_delayed": "I grafici per questo strumento sono differiti", "week": "settimana", "Lower": "Inferiore", "Jan": "Gen", "Chart": "Grafico", "Previous": "Precedente", "Jul": "Lug", "Virtual_money_credit_to_account": "Credito virtuale sull'account", "You_need_to_finish_all_20_questions_": "Devi completare tutte le 20 domande.", "Ends_Between": "Finisce tra", "You_have_already_withdrawn_[_1]_[_2]_": "Hai già prelevato [_1] [_2].", "Thursday": "Giovedì", "Please_select_a_valid_time_": "Seleziona un orario valido.", "Time_is_in_the_wrong_format_": "L'orario è in un formato errato.", "Digit": "Cifra", "This_is_a_staging_server_-_For_testing_purposes_only": "Questo è un server tecnico - Solo per scopo di test", "This_contract_won": "Questo contratto ha vinto", "Entry_Spot": "Punto d'ingresso", "Your_withdrawal_limit_is_[_1]_[_2]_": "Il tuo limite di prelievo è [_1] [_2].", "Withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "In questo momento non è consentito prelevare dal tuo account. Per sbloccarlo, contatta [_1].", "When_you_click_\"OK\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_": "Quando clicchi su \"OK\" verrai escluso dal trading sul sito fino alla data selezionata.", "Mo": "Lun", "Please_enter_an_integer_value": "Inserisci un numero intero", "Your_token_has_expired__Please_click_[_1]here[_2]_to_restart_the_verification_process_": "Il tuo token è scaduto. Clicca [_1]qui[_2] per riavviare la procedura di verifica.", "Remaining_Time": "Tempo residuo", "numbers": "numeri", "Waiting_for_entry_tick_": "In attesa del tick d'ingresso.", "Please_select_a_value": "Seleziona un valore", "Minute": "Minuto", "Reference_ID": "ID di riferimento", "Predict_the_direction<br_/>and_purchase": "Prevedi la direzione<br />e acquista", "Your_account_has_no_trading_activity_": "Sul tuo account non c'è alcuna attività di trading.", "New_token_created_": "Nuovo token creato.", "Percentage": "Percentuale", "Indicative": "Indicativo", "[_1]_withdrawal_from_account_number_[_2]_to_[_3]_is_done__Transaction_ID:_[_4]": "Il prelievo di [_1] dall'account numero [_2] su [_3] è stato eseguito. ID della transazione: [_4]", "July": "Luglio", "High_Barrier": "Barriera superiore", "September": "Settembre", "weeks": "settimane", "Lock_Cashier": "Blocca la Cassa", "Balance": "Saldo", "verification_token": "token di verifica", "Delete": "Elimina", "minute": "minuto", "True": "Vero", "Opens": "Apre", "Current_password": "Password attuale", "Remaining_time": "Tempo residuo", "Withdraw": "Preleva", "Score": "Punteggio", "High_Barrier_([_1])": "Barriera superiore ([_1])", "hours": "ore", "End_time": "Orario di fine", "minutes": "minuti", "Resale_not_offered": "La rivendita non è offerta", "Low_Barrier_([_1])": "Barriera inferiore ([_1])", "seconds": "secondi", "Last_Digit_Stats": "Statistiche sull'ultima cifra", "hour": "ora", "Touches": "Tocca", "Oct": "Ott", "Settles": "Liquida", "Should_be_a_valid_number": "Deve essere un numero valido", "Main_password": "Password principale", "Profit/Loss": "Profitto/Perdita", "Session_duration_limit_cannot_be_more_than_6_weeks_": "Il limite di durata della sessione non può essere superiore a 6 settimane.", "Exit_spot": "Prezzo di uscita", "Dec": "Dic", "Closes_early_(at_21:00)": "Chiude in anticipo (alle 21:00)", "Sep": "Sett", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_": "Hai già prelevato l'equivalente di [_1] [_2].", "month": "mese", "Update": "Aggiorna", "Hour": "Ora", "day": "giorno", "Profit": "Profitto", "Long": "A lungo", "Year": "Anno", "Final_price": "Prezzo finale", "Sa": "Sab", "Sell_time": "Orario di vendita", "Your_transaction_reference_number_is_[_1]": "Il tuo numero di riferimento per le transazioni è [_1]", "Portfolio": "Portafoglio", "Account_balance:": "Saldo dell'account:", "Only_numbers,_space,_and_hyphen_are_allowed_": "Sono consentiti solo numeri, spazi e trattini.", "This_symbol_is_not_active__Please_try_another_symbol_": "Questo simbolo non è attivo. Prova un altro simbolo.", "Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_": "Il Contratto verrá venduto al prezzo di mercato prevalente nel momento in cui i nostri server ricevono la richiesta. Tale prezzo può differire rispetto al prezzo indicato.", "Sorry,_this_feature_is_not_available_": "Siamo spiacenti, questa funzione non è disponibile.", "We": "Noi", "Status": "Stato", "Virtual_Account": "Account virtuale", "Monday": "Lunedì", "Th": "Gio", "Start_Time": "Orario di inizio", "There_was_some_invalid_character_in_an_input_field_": "Un campo di immissione testo conteneva uno o più caratteri non validi.", "Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_": "La tua richiesta di prelevare [_1] [_2] dal tuo account [_3] all'account dell'Agente di pagamento [_4] è stata elaborata con successo.", "Are_you_sure_that_you_want_to_permanently_revoke_access_to_application": "Sei sicuro di voler revocare definitivamente l'accesso all'applicazione", "Real_Account": "Account reale", "Revoke_access": "Revocare l'accesso", "Exclude_time_cannot_be_less_than_6_months_": "Il periodo di esclusione non può essere inferiore a 6 mesi.", "Your_settings_have_been_updated_successfully_": "Le tue impostazioni sono state aggiornate con successo.", "Real_Volatility": "Volatilità reale", "Contract_Information": "Informazioni del contratto", "Contract_is_not_started_yet": "Il contratto non è ancora iniziato", "Stays_In/Goes_Out": "Stays In (Rimane in) / Goes Out (Esce fuori)", "[_1]Authenticate_your_account[_2]_now_to_take_full_advantage_of_all_withdrawal_options_available_": "[_1]Convalida il tuo account[_2] ora per approfittare di tutte le opzioni di prelievo disponibili.", "Cashier": "Cassa", "Duration": "Durata", "Goes_Outside": "Esce fuori", "This_contract_lost": "Questo contratto ha perso", "Old_password_is_wrong_": "La password vecchia è errata.", "Sunday": "Domenica", "Upcoming_Events": "Prossimi eventi", "months": "mesi", "Current": "Attuale", "Sorry,_your_account_is_not_authorised_for_any_further_contract_purchases_": "Siamo spiacenti, il tuo account non è autorizzato per qualsiasi altro acquisto di contratti.", "Upgrade_to_a_Financial_Account": "Passa a un account finanziario", "letters": "lettere", "[_1]_deposit_from_[_2]_to_account_number_[_3]_is_done__Transaction_ID:_[_4]": "Il deposito di [_1] da [_2] sul numero di account [_3] è stato effettuato. ID della transazione: [_4]", "August": "Agosto", "Please_select_a_payment_agent": "Seleziona un agente di pagamento", "Resources": "Risorse", "Su": "Dom", "[_1]_days_[_2]_hours_[_3]_minutes": "[_1] giorni [_2] ore [_3] minuti", "Adjust_trade_parameters": "Regola i parametri di trading", "Barrier_Change": "Modifica della barriera", "email_address": "indirizzo email", "View": "Mostra", "You_did_not_change_anything_": "Non hai modificato nulla.", "Payments": "Pagamenti", "Note": "Nota", "Please_input_a_valid_date": "Inserisci una data valida", "Over/Under": "Sopra/Sotto", "Please_submit_a_valid_verification_token_": "Invia un token di verifica valido.", "Buy_price": "Prezzo d'acquisto", "February": "Febbraio", "IP_Address": "Indirizzo IP", "today,_Fridays": "oggi, Venerdì", "Total_Cost": "Costo totale", "Contract_ID": "ID del contratto", "Only_[_1]_decimal_points_are_allowed_": "Sono consentite solo [_1] cifre decimali.", "Your_trading_statistics_since_[_1]_": "Le tue statistiche di trading dal [_1].", "Are_you_sure_that_you_want_to_permanently_delete_token": "Sei sicuro di voler eliminare definitivamente il token", "Payment_Agent": "Agente di pagamento", "There_was_a_problem_accessing_the_server_": "Si è verificato un problema d'accesso al server.", "Barrier_([_1])": "Barriera ([_1])", "Now": "Adesso", "today": "oggi", "Action": "Azione", "Stake": "Puntata", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Pertanto il tuo attuale prelievo massimo immediato (soggetto alla disponibilità di fondi sufficienti nell'account) è pari a [_1] [_2] (o equivalente in un'altra valuta).", "There_was_a_problem_accessing_the_server_during_purchase_": "Durante l'acquisto si è verificato un problema d'accesso al server.", "Exit_Spot": "Prezzo di uscita", "Market_is_closed__Please_try_again_later_": "Il mercato è chiuso. Si prega di riprovare più tardi.", "Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_": "Il tuo account è stato completamente convalidato e sono stati rimossi i tuoi limiti di prelievo.", "Please_select_at_least_one_scope": "Seleziona almeno uno scopo", "Spot_Time": "Orario dello spot", "Potential_Payout": "Payout potenziale", "Questions": "Domande", "Higher/Lower": "High/Low", "Your_Application_is_Being_Processed_": "La tua richiesta è stata elaborata.", "Unlock_Cashier": "Sblocca Cassa", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_": "Come da tua richiesta, la cassa è bloccata. Per sbloccarla, inserisci la password.", "Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_": "La tua richiesta di trasferire [_1] [_2] da [_3] a [_4] è stata elaborata con successo.", "details": "dettagli", "Details": "Dettagli", "Insufficient_balance_": "Saldo non sufficiente.", "Contract_Expiry": "Scadenza del contratto", "Waiting_for_exit_tick_": "In attesa del tick d'uscita.", "[_1]_Please_click_the_link_below_to_restart_the_password_recovery_process__If_you_require_further_assistance,_please_contact_our_Customer_Support_": "[_1] clicca il link sottostante per riavviare la procedura di ripristino della password. Per ulteriore assistenza, contatta la nostra Assistenza Clienti.", "Statement": "Estratto", "Upgrade_to_a_Real_Account": "Passa a un account reale", "Deposits_and_withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "In questo momento sul tuo account non sono consentiti i depositi e i prelievi. Per sbloccarli, contatta [_1].", "days": "giorni", "Only_[_1]_are_allowed_": "Sono consentiti solo [_1].", "Sell": "Vendi", "second": "secondo", "November": "Novembre", "Name": "Nome", "Verification_code_format_incorrect_": "Formato del codice di verifica non corretto.", "Low_Barrier": "Barriera inferiore", "Month": "Mese", "Your_transaction_reference_is": "Il tuo riferimento per le transazioni è", "The_Payment_Agent_facility_is_currently_not_available_in_your_country_": "La funzione dell'Agente di pagamento al momento non è disponibile nel tuo paese.", "Description": "Descrizione", "Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_": "Segui il modello con 3 numeri, un trattino e 4 numeri.", "Ends_Outside": "Termina fuori", "End_Time": "Orario di fine", "Select_your_underlying_asset": "Scegli il tuo asset sottostante", "Ref_": "Rif.", "Finish": "Termina", "Asset_Index": "Indice degli asset", "Not": "No", "Tuesday": "Martedì", "Touch/No_Touch": "Touch/No touch", "This_field_is_required_": "Questo campo è obbligatorio.", "Number_of_ticks": "Numero di tick", "Your_token_has_expired__Please_click_<a_href=\"[_1]\">here</a>_to_restart_the_verification_process_": "Il tuo token è scaduto. Clicca <a href=\"[_1]\">qui</a> per riavviare la procedura di verifica.", "Password_is_not_strong_enough_": "La password non è sufficientemente forte.", "Explanation": "Spiegazione", "Contract_Sold": "Contratto venduto", "Investment_Account": "Account d'investimento", "The_maximum_number_of_tokens_([_1])_has_been_reached_": "Il numero massimo di token ([_1]) è stato raggiunto.", "Sale_Price": "Prezzo di vendita", "Read": "Leggi", "Your_account_is_currently_suspended__Only_withdrawals_are_now_permitted__For_further_information,_please_contact_[_1]_": "Al momento il tuo account è sospeso. Sono consentiti solo i prelievi. Per ulteriori informazioni, contatta [_1].", "Permissions": "Autorizzazioni", "Loss": "Perdita", "Create_Account": "Crea un account", "An_additional_password_can_be_used_to_restrict_access_to_the_cashier_": "Può essere utilizzata una password aggiuntiva per limitare l'accesso alla cassa.", "Short": "Breve", "Trading_Times": "Orari di trading", "Wednesday": "Mercoledì", "Buy": "Acquista", "Day": "Giorno", "Please_enter_a_number_between_[_1]_": "Inserisci un numero compreso tra [_1].", "Friday": "Venerdì", "Change_Password": "Modifica Password", "Successful": "Riuscito", "Credit/Debit": "Credito/Debito", "Minimum_of_[_1]_characters_required_": "Sono richiesti minimo [_1] caratteri.", "Sorry,_you_have_entered_an_incorrect_cashier_password": "Siamo spiacenti, hai inserito una password della cassa non corretta", "End_time_must_be_after_start_time_": "L'orario di fine deve essere successivo all'orario di inizio.", "year": "anno", "Walkthrough_Guide": "Guida dettagliata", "Purchase_Price": "Prezzo d'acquisto", "Sell_at_market": "Vendi sul mercato", "All_barriers_in_this_trading_window_are_expired": "Tutte le barriere in questa finestra di trading sono scadute", "Higher": "Superiore", "Only_numbers_and_spaces_are_allowed_": "Sono consentiti solo numeri e spazi.", "Contract": "Contratto", "Your_session_duration_limit_will_end_in_[_1]_seconds_": "Il limite di durata della tua sessione terminerà tra [_1] secondi.", "Price": "Prezzo", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_": "Hai già prelevato l'equivalente complessivo di [_1] [_2] negli ultimi [_3] giorni.", "Even/Odd": "Pari/Dispari", "Open_a_Financial_Account": "Apri un account finanziario", "Current_Time": "Orario attuale" };
	texts_json['PL'] = { "Please_input_a_valid_date": "Wpisz poprawną datę", "Your_account_is_restricted__Kindly_[_1]contact_customer_support[_2]_for_assistance_": "Na Twoje konto zostały nałożone ograniczenia. [_1]Skontaktuj się z obsługą klienta[_2], aby uzyskać pomoc.", "Note": "Uwaga", "mins": "min.", "Over/Under": "Ponad/poniżej", "email_address": "adres e-mail", "View": "Widok", "Barrier_Change": "Zmiana limitu", "Adjust_trade_parameters": "Dostosuj parametry handlowe", "You_have_reached_the_rate_limit_of_requests_per_second__Please_try_later_": "Osiągnięto maksymalną liczbę żądań na sekundę. Spróbuj jeszcze raz.", "Payments": "Płatności", "Please_<a_href=\"[_1]\">log_in</a>_to_view_this_page_": "<a href=\"[_1]\">Zaloguj się</a>, aby wyświetlić tę stronę.", "Payout": "Wypłata", "Browser": "Przeglądarka", "You_did_not_change_anything_": "Nic nie zostało zmienione.", "August": "Sierpień", "[_1]_deposit_from_[_2]_to_account_number_[_3]_is_done__Transaction_ID:_[_4]": "Dokonano wpłaty [_1] na konto o numerze [_3]. Identyfikator transakcji: [_4]", "letters": "litery", "Upgrade_to_a_Financial_Account": "Zmień na konto finansowe", "[_1]_days_[_2]_hours_[_3]_minutes": "[_1] dni [_2] godz. [_3] min", "Resources": "Środki", "The_email_address_provided_is_already_in_use__If_you_forgot_your_password,_please_try_our_<a_href=\"[_1]\">password_recovery_tool</a>_or_contact_our_customer_service_": "Podany adres e-mail jest już w użyciu. Jeżeli nie pamiętasz hasła, skorzystaj z opcji <a href=\"[_1]\">odzyskiwania hasła</a> lub skontaktuj się z obsługą klienta.", "Su": "Nd", "Please_select_a_payment_agent": "Proszę wybrać pośrednika płatności", "Upcoming_Events": "Nadchodzące wydarzenia", "months": "miesiące", "Current": "Obecne", "Sorry,_your_account_is_not_authorised_for_any_further_contract_purchases_": "Przepraszamy, Twoje konto nie ma uprawnień do kolejnych zakupów kontraktów.", "Payment_Agent": "Pośrednik płatności", "Please_[_1]accept_the_updated_Terms_and_Conditions[_2]_to_lift_your_withdrawal_and_trading_limits_": "Aby podnieść wysokość limitów wypłat i limitów handlowych, proszę [_1]zaakceptować zaktualizowany regulamin[_1].", "Are_you_sure_that_you_want_to_permanently_delete_token": "Czy na pewno chcesz trwale usunąć token", "Your_trading_statistics_since_[_1]_": "Twoje statystyki handlowe od [_1].", "today,_Fridays": "dziś, piątki", "IP_Address": "Adres IP", "Only_[_1]_decimal_points_are_allowed_": "Liczba dozwolonych miejsc po przecinku: [_1].", "Total_Cost": "Całkowity koszt", "Contract_ID": "Identyfikator kontraktu", "Please_submit_a_valid_verification_token_": "Proszę podać poprawny  token weryfikujący.", "{JAPAN_ONLY}Take_knowledge_test": "Take knowledge test", "February": "Luty", "Buy_price": "Cena kupna", "Th": "Cz", "Monday": "Poniedziałek", "Virtual_Account": "Konto wirtualne", "[_1]_[_2]_payout_if_[_3]_touches_Barrier_through_close_on_[_4]_": "Wypłata w wysokości [_2] [_1], jeśli [_3] osiągnie wartość limitu do momentu zamknięcia [_4].", "Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_": "Twój wniosek o wypłatę [_2] [_1] z Twojego konta [_3] na konto pośrednika płatności [_4] został zrealizowany.", "Start_Time": "Godzina rozpoczęcia", "There_was_some_invalid_character_in_an_input_field_": "Nieprawidłowy znak w polu formularza.", "Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_": "Kontrakty będą sprzedawane po obowiązującej cenie rynkowej po dotarciu wniosku na nasze serwery. Cena może różnić się od podanej ceny.", "This_symbol_is_not_active__Please_try_another_symbol_": "Ten symbol jest nieaktywny. Użyj innego symbolu.", "We": "Śr", "Sorry,_this_feature_is_not_available_": "Przepraszamy, wybrana funkcja jest niedostępna.", "Spot": "Cena aktualna", "Step": "Krok", "Your_transaction_reference_number_is_[_1]": "Numer referencyjny Twojej transakcji to [_1]", "Sell_time": "Godzina sprzedaży", "Equals": "Równa się", "Final_price": "Cena ostateczna", "Sa": "So", "Account_balance:": "Saldo konta:", "Only_numbers,_space,_and_hyphen_are_allowed_": "Dozwolone są tylko liczby, spacje i myślnik.", "Hour": "Godzina", "Update": "Aktualizuj", "Only_letters,_numbers,_and_hyphen_are_allowed_": "Dozwolone są tylko litery, cyfry i myślnik.", "Year": "Rok", "Long": "Długie", "Profit": "Zysk", "day": "dzień", "Goes_Outside": "Przekroczy", "Cashier": "Kasjer", "Duration": "Czas trwania", "Sunday": "Niedziela", "This_contract_lost": "Ten kontrakt przegrał", "Old_password_is_wrong_": "Stare hasło jest nieprawidłowe.", "Contract_is_not_started_yet": "Kontrakt jeszcze się nie rozpoczął", "Stays_In/Goes_Out": "Pozostanie w/przekroczy", "Your_settings_have_been_updated_successfully_": "Twoje ustawienia zostały pomyślnie zaktualizowane.", "Exclude_time_cannot_be_less_than_6_months_": "Czas wyłączenia nie może być krótszy niż 6 miesięcy.", "Revoke_access": "Zablokowanie dostępu", "Contract_Information": "Informacje o kontrakcie", "Real_Volatility": "Zmienność realna", "Real_Account": "Prawdziwe konto", "Are_you_sure_that_you_want_to_permanently_revoke_access_to_application": "Czy na pewno chcesz na stałe wyłączyć dostęp do aplikacji na stałe?", "h": "godz.", "Trading_Times": "Godziny handlu", "Short": "Krótkie", "An_additional_password_can_be_used_to_restrict_access_to_the_cashier_": "Dodatkowe hasło może być wykorzystane do ograniczania dostępu do sekcji Kasjer.", "Please_enter_a_number_between_[_1]_": "Proszę wpisać liczbę z przedziału [_1].", "Buy": "Kup", "Wednesday": "Środa", "Day": "Dzień", "Read": "Odczyt", "Sale_Price": "Cena sprzedaży", "Create_Account": "Załóż konto", "Loss": "Strata", "Permissions": "Pozwolenia", "Your_account_is_currently_suspended__Only_withdrawals_are_now_permitted__For_further_information,_please_contact_[_1]_": "Twoje konto jest obecnie zawieszone. Dozwolone jest jedynie dokonywanie wypłat. Aby uzyskać więcej informacji, skontaktuj się z [_1].", "Contract_Sold": "Kontrakt został sprzedany", "Explanation": "Wyjaśnienie", "Investment_Account": "Konto inwestycyjne", "Password_is_not_strong_enough_": "Hasło jest za słabe.", "Should_be_between_[_1]_and_[_2]": "Wartość powinna wynosić od [_1] do [_2]", "The_maximum_number_of_tokens_([_1])_has_been_reached_": "Maksymalna liczba tokenów ([_1]) została osiągnięta.", "Your_token_has_expired__Please_click_<a_href=\"[_1]\">here</a>_to_restart_the_verification_process_": "Twój token wygasł. Kliknij <a href=\"[_1]\">tutaj</a>, aby rozpocząć proces weryfikacyjny ponownie.", "Number_of_ticks": "Liczba najmniejszych przyrostów ceny", "This_field_is_required_": "To pole jest wymagane.", "Not": "Nie", "{JAPAN_ONLY}Sorry,_you_have_failed_the_test,_please_try_again_after_24_hours_": "Sorry, you have failed the test, please try again after 24 hours.", "Touch/No_Touch": "Osiągnie", "Tuesday": "Wtorek", "{JAPAN_ONLY}Knowledge_Test": "Knowledge Test", "Shop": "Sklep", "Your_session_duration_limit_will_end_in_[_1]_seconds_": "Limit czasu sesji zakończy się za [_1] s.", "Please_complete_the_[_1]financial_assessment_form[_2]_to_lift_your_withdrawal_and_trading_limits_": "Aby podnieść swoje limity wypłat i limity handlowe, wypełnij [_1]formularz oceny sytuacji finansowej[_2].", "Open_a_Financial_Account": "Otwórz konto finansowe", "Current_Time": "Obecny czas", "Even/Odd": "Parzysta/nieparzysta", "Price": "Cena", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_": "Łączny ekwiwalent [_2] [_1] został już wypłacony w ciągu ostatnich [_3] dni.", "Sell_at_market": "Sprzedawaj na rynku", "Purchase_Price": "Cena zakupu", "Walkthrough_Guide": "Przewodnik ogólny", "year": "rok", "End_time_must_be_after_start_time_": "Czas zakończenia musi być późniejszy niż czas rozpoczęcia.", "Contract": "Kontrakt", "Only_numbers_and_spaces_are_allowed_": "Dozwolone są liczby i spacje.", "Higher": "Wyższe", "All_barriers_in_this_trading_window_are_expired": "Wszystkie limity widoczne w tym oknie handlowania wygasły", "Minimum_of_[_1]_characters_required_": "Minimalna liczba znaków: [_1].", "Credit/Debit": "Winien/Ma", "Sorry,_you_have_entered_an_incorrect_cashier_password": "Przepraszamy, wpisano nieprawidłowe hasło do kasjera", "Change_Password": "Zmień hasło", "Friday": "piątek", "Successful": "Zakończono powodzeniem", "logout": "Wyloguj", "Contract_Expiry": "Wygaśnięcie kontraktu", "Insufficient_balance_": "Niewystarczające saldo.", "Details": "Szczegóły", "details": "szczegóły", "Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_": "Twój wniosek o przelanie [_2] [_1] z [_3] na [_4] został zrealizowany.", "Statement": "Oświadczenie", "Waiting_for_exit_tick_": "Oczekuje na końcową zmianę ceny.", "[_1]_Please_click_the_link_below_to_restart_the_password_recovery_process__If_you_require_further_assistance,_please_contact_our_Customer_Support_": "[_1] Aby rozpocząć proces odzyskiwania hasła, kliknij na poniższy link. Jeśli potrzebujesz pomocy, skontaktuj się z naszym działem obsługi klienta.", "Higher/Lower": "Wyższy/niższy", "Questions": "Pytania", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_": "Sekcja Kasjer została zablokowana na Twoją prośbę - jeśli chcesz ją odblokować, prosimy o podanie hasła.", "Unlock_Cashier": "Odblokuj sekcję Kasjer", "Your_Application_is_Being_Processed_": "Twój wniosek jest przetwarzany.", "Spot_Time": "Czas spot", "Please_select_at_least_one_scope": "Proszę wybrać przynajmniej jeden zakres", "Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_": "Twoje konto jest w pełni zweryfikowane, a Twój limit wypłat został zwiększony.", "Market_is_closed__Please_try_again_later_": "Rynek jest zamknięty. Prosimy spróbować później.", "Potential_Payout": "Możliwa wypłata", "Barrier_([_1])": "Limit ([_1])", "There_was_a_problem_accessing_the_server_": "Wystąpił błąd podczas uzyskiwania dostępu do serwera.", "today": "dziś", "Now": "Teraz", "There_was_a_problem_accessing_the_server_during_purchase_": "Wystąpił błąd podczas uzyskiwania dostępu do serwera w trakcie zakupu.", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Dlatego w chwili obecnej Twoja maksymalna natychmiastowa wypłata (o ile posiadasz na koncie wystarczające środki) wynosi [_2] [_1] (lub równoważność tej kwoty w innej walucie).", "Exit_Spot": "Pozycja wyjściowa", "Stake": "Stawka", "Action": "Czynności", "Select_your_underlying_asset": "Wybierz aktywa bazowe", "Asset_Index": "Indeks kapitałowy", "Finish": "Zakończ", "Investor_password": "Hasło inwestora", "Connection_error:_Please_check_your_internet_connection_": "Błąd połączenia: sprawdż połączenie internetowe", "The_Payment_Agent_facility_is_currently_not_available_in_your_country_": "Usługi pośredników płatności są obecnie niedostępne w Twoim kraju.", "End_Time": "Zakończenie", "Target": "Cel", "Description": "Opis", "Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_": "Proszę zastosować schemat: 3 cyfry, myślnik, 4 cyfry.", "Ends_Outside": "Kończy się poza", "November": "Listopad", "second": "sekunda", "Low_Barrier": "Dolny limit", "Your_transaction_reference_is": "Kod referencyjny Twojej transakcji to", "Month": "Miesiąc", "Verification_code_format_incorrect_": "Format kodu weryfikującego jest nieprawidłowy.", "Name": "Nazwisko", "Upgrade_to_a_Real_Account": "Uaktualnij do konta z prawdziwymi pieniędzmi", "Deposits_and_withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Wpłaty środków na konto i ich wypłaty są w tym momencie niemożliwe. Skontaktuj się z [_1], aby je odblokować.", "Sell": "Sprzedaj", "Only_[_1]_are_allowed_": "Dozwolone są tylko [_1].", "days": "dni", "New_Year's_Day": "Nowy Rok", "Real_Cent": "Prawdziwy cent", "Open": "Otwarcie", "Date": "Data", "[_1]_[_2]_payout_if_[_3]_ends_outside_low_and_high_values_of_Barrier_at_close_on_[_4]_": "Wypłata w wysokości [_2] [_1], jeśli [_3] będzie wartością w przedziale między dolną i górną wartością limitu w momencie zamknięcia [_4].", "[_1]_[_2]_payout_if_[_3]_stays_between_low_and_high_values_of_Barrier_through_close_on_[_4]_": "Wypłata w wysokości [_2] [_1], jeśli [_3] pozostanie w przedziale między dolną i górną wartością limitu w momencie zamknięcia [_4].", "Never": "Nigdy", "{JAPAN_ONLY}Please_complete_the_following_questions_": "Please complete the following questions.", "You_have_sold_this_contract_at_[_1]_[_2]": "Sprzedano ten kontrakt po cenie [_2] [_1]", "Major_Pairs": "Główne pary", "Saturday": "Sobota", "Sorry,_an_error_occurred_while_processing_your_request_": "Przepraszamy, podczas przetwarzania Twojego żądania wystąpił błąd.", "Failed": "Zakończone niepowodzeniem", "Select_your_trade_type": "Wybierz rodzaj zakładu", "Exit_Spot_Time": "Czas punktu wyjściowego", "Transaction_performed_by_[_1]_(App_ID:_[_2])": "Transakcja dokonana przez [_1] (App ID: [_2])", "Date_and_Time": "Data i godzina transakcji", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_click_<a_href=\"[_1]\">here</a>_": "Sekcja Kasjer została zablokowana na Twoją prośbę - jeśli chcesz ją odblokować, prosimy kliknąć <a href=\"[_1]\">tutaj</a>.", "Sorry,_account_signup_is_not_available_in_your_country__Please_contact_<a_href=\"[_1]\">customer_support</a>_for_more_information_": "Przepraszamy, rejestracja konta nie jest dostępna w Twoim kraju. Proszę skontaktować się z <a href=\"[_1]\">>działem obsługi klienta</a>, aby uzyskać więcej informacji.", "Your_changes_have_been_updated_": "Twoje zmiany zostały wprowadzone.", "This_feature_is_not_relevant_to_virtual-money_accounts_": "Ta funkcja nie jest dostępna dla kont z wirtualnymi pieniędzmi.", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_": "Dlatego w chwili obecnej Twoja maksymalna natychmiastowa wypłata (o ile posiadasz na koncie wystarczające środki) wynosi [_2] [_1].", "New_password": "Nowe hasło", "[_1]_[_2]_payout_if_[_3]_is_strictly_lower_than_Barrier_at_close_on_[_4]_": "Wypłata w wysokości [_2] [_1], jeśli [_3] jest wartością niższą niż wartość limitu w momencie zamknięcia [_4].", "Invalid_amount,_maximum_is": "Nieprawidłowa kwota, maksimum wynosi", "Return": "Zwrot", "Rise/Fall": "Wzrost/spadek", "All_markets_are_closed_now__Please_try_again_later_": "Wszystkie rynki są obecnie zamknięte. Prosimy spróbować później.", "Real_STP": "Prawdziwe konto STP", "Does_Not_Touch": "Nie osiąga", "Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_": "Twoje hasło zostało zresetowane. Zaloguj się na swoje konto, używając swojego nowego hasła.", "Fridays": "piątki", "Entry_spot": "Pozycja wejściowa", "years": "lat(a)", "Deposit": "Wpłata", "The_two_passwords_that_you_entered_do_not_match_": "Wprowadzone hasła nie są identyczne.", "The_main_password_of_account_number_[_1]_has_been_changed_": "Hasło główne do konta o numerze [_1] zostało zmienione.", "Gaming_Account": "Konto gracza", "Invalid_amount,_minimum_is": "Nieprawidłowa kwota, minimum wynosi", "There_was_an_error": "Wystąpił błąd", "The_server_<a_href=\"[_1]\">endpoint</a>_is:_[_2]": "<a href=\"[_1]\">Punkt końcowy</a> serwera to: [_2]", "Net_profit": "Zysk netto", "Total_Profit/Loss": "Całkowity zysk/ całkowita strata", "Exclude_time_cannot_be_for_more_than_5_years_": "Czas wyłączenia nie może być dłuższy niż 5 lat.", "Sorry,_this_feature_is_available_to_virtual_accounts_only_": "Przepraszamy, ta funkcja jest dostępna tylko dla kont wirtualnych.", "Never_Used": "Nigdy nie użyte", "Select_your_market": "Wybierz rynek", "Weekday": "Dzień roboczy", "Today": "Dziś", "Please_select": "Wybierz", "Last_Used": "Ostatnio używane", "January": "Styczeń", "Closed": "Zamknięte", "Contract_Confirmation": "Potwierdzenie kontraktu", "Please_log_in_": "Proszę się zalogować.", "Only_letters,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Dozwolone są tylko litery, spacja, myślniki, kropki i apostrof.", "Please_select_the_checkbox_": "Proszę zaznaczyć pole wyboru.", "space": "spacja", "October": "Październik", "Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Twój limit wypłat to [_2] [_1] (lub jego ekwiwalent w innej walucie).", "Processing_your_request___": "Twa przetwarzanie Twojego żądania...", "Japan": "Japonia", "June": "Czerwiec", "Closes_early_(at_18:00)": "Zamykane wcześnie (o 18:00)", "False": "Fałsz", "[_1]_[_2]_payout_if_[_3]_is_strictly_higher_than_or_equal_to_Barrier_at_close_on_[_4]_": "Wypłata w wysokości [_2] [_1], jeśli [_3] jest wartością wyższą niż wartość limitu lub równą tej wartości w momencie zamknięcia [_4].", "Jun": "Czerwiec", "Aug": "Sierpień", "Profit_Table": "Tabela zysków", "April": "Kwiecień", "Barrier": "Limit", "Sorry,_an_error_occurred_while_processing_your_account_": "Przepraszamy, wystąpił błąd podczas operacji na Twoim koncie.", "Ends_In/Out": "Zakończy się w/poza", "Password_should_have_lower_and_uppercase_letters_with_numbers_": "Hasło powinno zawierać wielkie i małe litery oraz cyfry.", "Sale_Date": "Data sprzedaży", "May": "Maj", "Purchase_Time": "Godzina zakupu", "Please_check_the_above_form_for_pending_errors_": "Zapoznaj się z listą nierozwiązanych błędów w powyższym formularzu.", "Christmas_Day": "Boże Narodzenie", "Next": "Następny", "Up/Down": "Góra/dół", "March": "Marzec", "Invalid_email_address": "Nieprawidłowy adres e-mail", "Amount": "Kwota", "{JAPAN_ONLY}Knowledge_Test_Result": "Knowledge Test Result", "[_1]_[_2]_payout_if_[_3]_goes_outside_of_low_and_high_values_of_Barrier_through_close_on_[_4]_": "Wypłata w wysokości [_2] [_1], jeśli [_3] będzie wartością nie mieszczącą się w przedziale między dolną i górną wartością limitu do momentu zamknięcia [_4].", "Please_[_1]complete_your_account_profile[_2]_to_lift_your_withdrawal_and_trading_limits_": "Aby podnieść wysokość limitów wypłat i limitów handlowych, [_1]uzupełnij swój profil[_1].", "You_have_not_granted_access_to_any_applications_": "Nie przyznano Ci dostępu do żadnej aplikacji.", "Please_select_a_valid_date_": "Proszę wybrać poprawną datę.", "Your_changes_have_been_updated_successfully_": "Zmiany zostały wprowadzone.", "[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]": "[_2] [_1] zostało odjęte z Twojego konta wirtualnego [_3]", "You_should_enter_[_1]_characters_": "Proszę wprowadzić następującą liczbę znaków: [_1].", "Congratulations!_Your_[_1]_Account_has_been_created_": "Gratulacje! Twoje konto [_1] zostało utworzone.", "Potential_Profit": "Możliwy zysk", "[_1]_and_[_2]_cannot_be_the_same_": "Wartości [_1] i [_2] nie mogą być takie same.", "Please_accept_the_terms_and_conditions_": "Proszę zaakceptować regulamin.", "December": "Grudzień", "Tu": "Wt", "Mar": "Marzec", "Matches/Differs": "Zgadza się/Różni się", "Feb": "Luty", "[_1]_[_2]_payout_if_[_3]_does_not_touch_Barrier_through_close_on_[_4]_": "Wypłata w wysokości [_2] [_1], jeśli [_3] nie osiągnie limitu aż do zamknięcia [_4].", "Closes": "Zamknięcie", "Current_password": "Aktualne hasło", "Opens": "Otwarcie", "True": "Prawda", "Tick": "Zmiana ceny", "weeks": "tygodnie", "minute": "min", "Delete": "Usuń", "Only_letters,_numbers,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Dozwolone są wyłącznie litery, cyfry, znak spacji, myślnik, kropka i apostrof.", "Balance": "Saldo", "Lock_Cashier": "Zablokuj sekcję Kasjer", "verification_token": "token weryfikacyjny", "July": "Lipiec", "[_1]_withdrawal_from_account_number_[_2]_to_[_3]_is_done__Transaction_ID:_[_4]": "Dokonano wypłaty [_1] z konta o numerze [_2] na konto [_3]. Identyfikator transakcji: [_4]", "High_Barrier": "Górny limit", "{JAPAN_ONLY}The_test_is_unavailable_now,_test_can_only_be_taken_again_on_next_business_day_with_respect_of_most_recent_test_": "The test is unavailable now, test can only be taken again on next business day with respect of most recent test.", "September": "Wrzesień", "Percentage": "Procent", "Asset": "Kapitał", "Indicative": "Orientacyjny", "Closes_early_(at_21:00)": "Zamykane wcześnie (o 21:00)", "Scopes": "Zakresy", "Dec": "Grudzień", "month": "miesiąc", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_": "Już wypłaciłeś/aś ekwiwalent [_2] [_1].", "Sep": "Wrzesień", "Touches": "Osiąga", "hour": "godzina", "Last_Digit_Stats": "Statystyki ostatniej cyfry", "Exit_spot": "Punkt wyjściowy", "Session_duration_limit_cannot_be_more_than_6_weeks_": "Limit czasu sesji nie może przekroczyć 6 tygodni.", "Main_password": "Hasło główne", "Profit/Loss": "Zysk/Strata", "min": "min.", "Should_be_a_valid_number": "Powinien to być prawidłowy numer", "Settles": "Rozliczenie", "Oct": "Październik", "Resale_not_offered": "Brak możliwości odsprzedaży", "minutes": "min", "hours": "godziny", "End_time": "Godzina zakończenia", "seconds": "sekundy", "Low_Barrier_([_1])": "Dolny limit ([_1])", "Should_be_less_than_[_1]": "Wartość powinna być mniejsza niż [_1]", "Remaining_time": "Pozostały czas", "High_Barrier_([_1])": "Górny limit ([_1])", "Score": "Wynik", "Withdraw": "Wypłata", "Time_is_in_the_wrong_format_": "Czas został podany w nieprawidłowym formacie.", "This_is_a_staging_server_-_For_testing_purposes_only": "To jest serwer testowy służący wyłącznie testowaniu", "Digit": "Cyfra", "You_have_already_withdrawn_[_1]_[_2]_": "Właśnie dokonano wypłaty [_2] [_1].", "Ends_Between": "Kończy się pomiędzy", "You_need_to_finish_all_20_questions_": "Należy odpowiedzieć na wszystkie 20 pytań.", "Stays_Between": "Pozostaje pomiędzy", "Please_select_a_valid_time_": "Proszę wybrać poprawny czas.", "Thursday": "Czwartek", "Jan": "Styczeń", "Chart": "Wykres", "Previous": "Poprzedni", "Lower": "Niższe", "week": "Tydzień", "from_[_1]_to_[_2]": "od [_1] do [_2]", "Virtual_money_credit_to_account": "Wirtualne pieniądze zostały zaksięgowane na koncie", "Jul": "Lipiec", "Fr": "Pt", "Select_market": "Wybierz rynek", "Start_time": "Godzina rozpoczęcia", "Nov": "Listopad", "Charting_for_this_underlying_is_delayed": "Dla tego rynku podstawowego wykresy są opóźnione", "[_1]_[_2]_payout_if_[_3]_ends_on_or_between_low_and_high_values_of_Barrier_at_close_on_[_4]_": "Wypłata w wysokości [_2] [_1], jeśli [_3] zatrzyma się pomiędzy dolną i górną wartością limitu w momencie zamknięcia [_4].", "Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_": "Twój [_1]-dniowy limit wypłat wynosi obecnie [_3] [_2] (Lub jego ekwiwalent w innej walucie).", "Apr": "Kwiecień", "Your_account_has_no_Login/Logout_activity_": "Na Twoim koncie nie odnotowano żadnej aktywności związanej z logowaniem/wylogowywaniem.", "Reference_ID": "ID referencyjne", "In/Out": "Zakłady w/poza", "Minute": "Minuta", "New_token_created_": "Utworzono nowy token.", "Your_account_has_no_trading_activity_": "NA Twoim koncie nie odnotowano żadnej aktywności handlowej.", "Predict_the_direction<br_/>and_purchase": "Oszacuj kierunek zmian<br />i kup", "Your_token_has_expired__Please_click_[_1]here[_2]_to_restart_the_verification_process_": "Twój token wygasł. Kliknij [_1]tutaj[_2], aby rozpocząć proces weryfikacyjny ponownie.", "Remaining_Time": "Pozostały czas", "Waiting_for_entry_tick_": "Oczekuje na pierwszą zmianę ceny.", "Please_select_a_value": "Proszę wybrać wartość", "numbers": "liczby", "Mo": "Pn", "When_you_click_\"OK\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_": "Po kliknięciu przycisku „OK” handlowanie na portalu nie będzie możliwe aż do wybranej daty.", "Withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Wypłaty środków z Twojego konta są w tym momencie niemożliwe. Skontaktuj się z [_1], aby je odblokować.", "Please_enter_an_integer_value": "Wpisz liczbę całkowitą", "Entry_Spot": "Pozycja wejściowa", "Trade": "Handluj", "This_contract_won": "Ten kontrakt wygrał", "Your_withdrawal_limit_is_[_1]_[_2]_": "Twój limit wypłat wynosi [_2] [_1]." };
	texts_json['PT'] = { "Predict_the_direction<br_/>and_purchase": "Preveja a direção<br />e compre", "Your_account_has_no_trading_activity_": "A sua conta não tem nenhuma atividade de negociação.", "New_token_created_": "Novo token criado.", "Reference_ID": "ID de referência", "In/Out": "Dentro/Fora", "Waiting_for_entry_tick_": "Aguardando tick de entrada.", "Please_select_a_value": "Selecione um valor", "numbers": "números", "Remaining_Time": "Tempo restante", "Please_enter_an_integer_value": "Insira um valor inteiro", "Withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Retiradas de sua conta não estão permitidas no momento. Por favor contate [_1] para desbloqueio.", "Mo": "Seg", "Your_withdrawal_limit_is_[_1]_[_2]_": "O seu limite de retiradas é [_1] [_2].", "Entry_Spot": "Preço de entrada", "Trade": "Negociar", "This_contract_won": "Esse contrato ganhou", "This_is_a_staging_server_-_For_testing_purposes_only": "Este é um servidor temporário - apenas para testes", "Thursday": "Quinta-feira", "You_need_to_finish_all_20_questions_": "É obrigatório completar as 20 perguntas.", "You_have_already_withdrawn_[_1]_[_2]_": "Você já retirou [_1] [_2].", "Virtual_money_credit_to_account": "Crédito de dinheiro virtual na conta", "week": "semana", "Previous": "Anterior", "Chart": "Gráfico", "Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_": "O seu limite de retiradas de [_1] dia(s) é atualmente [_2] [_3] (ou equivalente em outra moeda).", "Apr": "Abr", "Your_account_has_no_Login/Logout_activity_": "A sua conta não tem nenhuma atividade de login/sair.", "Charting_for_this_underlying_is_delayed": "Os gráficos para esta base estão com atraso", "Start_time": "Hora de início", "Fr": "Sex", "Select_market": "Selecione o mercado", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_": "Você já retirou o equivalente a [_1] [_2].", "Sep": "Set", "month": "mês", "Dec": "Dez", "Closes_early_(at_21:00)": "Fecha cedo (às 21:00)", "Settles": "Liquida", "Oct": "Out", "Exit_spot": "Preço de saída", "Profit/Loss": "Lucro/Perda", "Session_duration_limit_cannot_be_more_than_6_weeks_": "O limite de duração de sessões não pode ser superior a 6 semanas.", "hour": "hora", "Last_Digit_Stats": "Estatísticas do último dígito", "Low_Barrier_([_1])": "Barreira Baixa ([_1])", "seconds": "segundos", "End_time": "Hora de fim", "hours": "horas", "Resale_not_offered": "A revenda não está disponivel", "minutes": "minutos", "Withdraw": "Retirar", "High_Barrier_([_1])": "Barreira Alta ([_1])", "Score": "Classificação", "Remaining_time": "Tempo restante", "Tick": "Tique-taque", "Opens": "Abre", "True": "Verdadeiro", "Female": "Feminino", "Current_password": "Senha atual", "Only_letters,_numbers,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Apenas letras, números, espaços, hífenes, pontos e apóstrofes são permitidos.", "Delete": "Excluir", "Lock_Cashier": "Bloquear Caixa", "Balance": "Saldo", "verification_token": "token de verificação", "minute": "minuto", "weeks": "semanas", "September": "Setembro", "High_Barrier": "Barreira Alta", "July": "Julho", "Indicative": "Indicativo", "Asset": "Ativos", "Amount": "Quantia", "Up/Down": "Acima/Abaixo", "March": "Março", "Next": "Próximo", "Invalid_email_address": "Endereço de e-mail inválido", "Christmas_Day": "Dia de Natal", "Please_check_the_above_form_for_pending_errors_": "Consulte o formulário acima para erros subsistentes.", "You_have_not_granted_access_to_any_applications_": "Você não concedeu acesso a nenhum aplicativo.", "Feb": "Fev", "Matches/Differs": "Combina/Difere", "Closes": "Fecha", "[_1]_and_[_2]_cannot_be_the_same_": "[_1] e [_2] não podem ser iguais.", "Tu": "Qui", "December": "Dezembro", "[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]": "[_1] [_2] foram creditados na sua conta de dinheiro Virtual [_3]", "You_should_enter_[_1]_characters_": "Você dever inserir [_1] caracteres.", "Potential_Profit": "Lucro Potencial", "October": "Outubro", "space": "espaço", "Contract_Confirmation": "Confirmação de Contrato", "Please_log_in_": "Por favor, conecte-se.", "Forex": "Forex (Mercado de Câmbio)", "January": "Janeiro", "Closed": "Fechado", "Closes_early_(at_18:00)": "Fecha cedo (às 18:00)", "June": "Junho", "Japan": "Japão", "Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "O seu limite de retiradas é [_1] [_2] (ou equivalente em outra moeda).", "Processing_your_request___": "Processado o seu pedido...", "April": "Abril", "Profit_Table": "Tabela de Lucros", "Aug": "Ago", "Purchase_Time": "Hora da Compra", "May": "Maio", "Sale_Date": "Data de Venda", "Sorry,_an_error_occurred_while_processing_your_account_": "Lamentamos, ocorreu um erro durante o processamento da sua conta.", "Ends_In/Out": "Termina Dentro/Fora", "Password_should_have_lower_and_uppercase_letters_with_numbers_": "A senha deve conter letras minúsculas, maiúsculas e números.", "Barrier": "Barreira", "years": "anos", "The_two_passwords_that_you_entered_do_not_match_": "As palavras-chave que introduziu não coincidem.", "Deposit": "Depositar", "Entry_spot": "Preço de entrada", "Fridays": "Sexta-feira", "Total_Profit/Loss": "Lucro/Perda Total", "The_server_<a_href=\"[_1]\">endpoint</a>_is:_[_2]": "O terminal do <a href=\"[_1]\"> 1servidor</a> 2 é: [_2]", "Net_profit": "Lucro líquido", "Invalid_amount,_minimum_is": "Valor inválido, o mínimo é", "Gaming_Account": "Conta de Jogos", "There_was_an_error": "Houve um erro", "Sorry,_this_feature_is_available_to_virtual_accounts_only_": "Lamentamos, este recurso está disponível somente para contas virtuais.", "Never_Used": "Nunca utilizado", "Exclude_time_cannot_be_for_more_than_5_years_": "O tempo de exclusão não pode ser superior a 5 anos.", "Please_select": "Selecione", "Last_Used": "Última utilização", "Today": "Hoje", "Select_your_market": "Selecione o seu mercado", "Weekday": "Dia de semana", "You_have_sold_this_contract_at_[_1]_[_2]": "Você vendeu este contrato por [_1] [_2]", "Major_Pairs": "Pares Principais", "Never": "Nunca", "New_Year's_Day": "Dia de Ano Novo", "Date": "Data", "Open": "Abrir", "Exit_Spot_Time": "Hora do preço de saída", "Select_your_trade_type": "Selecione o tipo de negociação", "Sorry,_an_error_occurred_while_processing_your_request_": "Lamentamos, ocorreu um erro durante o processamento do seu pedido.", "Failed": "Falhou", "Saturday": "Sábado", "This_feature_is_not_relevant_to_virtual-money_accounts_": "Este recurso não é relevante para as contas de dinheiro virtual.", "Your_changes_have_been_updated_": "As suas alterações foram atualizadas.", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_": "Portanto, a sua retirada máxima imediata atual (sujeita à existência de fundos suficientes na sua conta) é [_1] [_2].", "New_password": "Nova senha", "Transaction_performed_by_[_1]_(App_ID:_[_2])": "Transação executada por [_1] (App ID: [_2])", "Date_and_Time": "Data e hora", "All_markets_are_closed_now__Please_try_again_later_": "Todos os mercados estão agora fechados. Tente novamente mais tarde.", "Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_": "A sua senha foi redefinida com sucesso. Por favor, inicie sessão na sua conta, usando a sua nova senha.", "Rise/Fall": "Sobe/Desce", "Return": "Prêmio", "Admin": "Administração", "Invalid_amount,_maximum_is": "Valor inválido, o máximo é", "Finish": "Terminar", "Asset_Index": "Índice de Ativos", "Select_your_underlying_asset": "Selecione o ativo subjacente", "Target": "Alvo", "Description": "Descrição", "Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_": "Siga o padrão: 3 números, um hífen, seguidos por 4 números.", "End_Time": "Hora final", "The_Payment_Agent_facility_is_currently_not_available_in_your_country_": "A opção Agentes de Pagamentos não está atualmente disponível no seu país.", "Connection_error:_Please_check_your_internet_connection_": "Erro de conexão: verifique a sua conexão com a internet.", "Verification_code_format_incorrect_": "Formato incorreto de código de verificação.", "Name": "Nome", "Your_transaction_reference_is": "A referência da sua transação é", "Low_Barrier": "Barreira Baixa", "Month": "Mês", "November": "Novembro", "second": "segundo", "Male": "Masculino", "Only_[_1]_are_allowed_": "Apenas [_1] são permitidos.", "days": "dias", "Sell": "Vender", "Upgrade_to_a_Real_Account": "Faça a atualização para uma Conta Real", "Deposits_and_withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Depósitos e retiradas de sua conta não estão permitidos no momento. Por favor contate [_1] para o desbloqueio.", "[_1]_Please_click_the_link_below_to_restart_the_password_recovery_process__If_you_require_further_assistance,_please_contact_our_Customer_Support_": "[_1] Clique no link abaixo para reiniciar o processo de recuperação de senha. Caso você necessite de assistência adicional, contate o Apoio ao Cliente.", "Statement": "Extrato", "Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_": "O seu pedido para transferir [_1] [_2] de [_3] para [_4] foi processado com sucesso.", "Contract_Expiry": "Validade do contrato", "Insufficient_balance_": "Saldo insuficiente.", "Details": "Dados", "details": "detalhes", "Your_Application_is_Being_Processed_": "A sua inscrição está sendo processado.", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_": "O seu caixa está bloqueado conforme pedido - para desbloqueá-lo, digite a senha.", "Unlock_Cashier": "Desbloquear o Caixa", "Questions": "Perguntas", "Higher/Lower": "Superior/Inferior", "Potential_Payout": "Possível Prêmio", "Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_": "A sua conta está totalmente autenticada e os seus limites de retirada de fundos foram aumentados.", "Market_is_closed__Please_try_again_later_": "O mercado está fechado. Tente novamente mais tarde.", "Spot_Time": "Hora à vista", "Please_select_at_least_one_scope": "Selecione pelo menos um escopo", "Action": "Ação", "There_was_a_problem_accessing_the_server_during_purchase_": "Ocorreu um problema ao aceder ao servidor durante a aquisição.", "Exit_Spot": "Preço de saída", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Portanto, a sua retirada máxima imediata atual (sujeito à existência de fundos suficientes na sua conta) é [_1] [_2] (ou equivalente em outra moeda).", "Stake": "Aposta", "There_was_a_problem_accessing_the_server_": "Ocorreu um problema ao aceder ao servidor.", "today": "hoje", "Barrier_([_1])": "Barreira ([_1])", "Now": "Agora", "Even/Odd": "Par/Ímpar", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_": "Você já retirou o equivalente a [_1] [_2] em agregado durante os últimos [_3] dias.", "Price": "Preço", "Current_Time": "Hora atual", "Open_a_Financial_Account": "Abrir uma conta financeira", "Your_session_duration_limit_will_end_in_[_1]_seconds_": "O limite de duração da sua sessão terminará em [_1] segundos.", "All_barriers_in_this_trading_window_are_expired": "Todas as barreiras nesta janela de negociação já expiraram", "Contract": "Contrato", "Walkthrough_Guide": "Guia passo a passo", "year": "ano", "End_time_must_be_after_start_time_": "A hora de fim tem de ser depois da hora de início.", "Sell_at_market": "Venda no mercado", "Purchase_Price": "Preço de Compra", "Sorry,_you_have_entered_an_incorrect_cashier_password": "Lamentamos, introduziu uma senha de caixa incorreta", "Minimum_of_[_1]_characters_required_": "Um mínimo de [_1] caracteres é necessário.", "Credit/Debit": "Crédito/Débito", "Successful": "Bem-sucedido", "Change_Password": "Alterar Senha", "Friday": "Sexta-feira", "Please_enter_a_number_between_[_1]_": "Digite um número entre [_1].", "Day": "Dia", "Buy": "Comprar", "Wednesday": "Quarta-feira", "An_additional_password_can_be_used_to_restrict_access_to_the_cashier_": "Uma senha adicional pode ser usada para restringir acesso ao caixa.", "Short": "Curto", "Trading_Times": "Horário de Negociação", "Your_account_is_currently_suspended__Only_withdrawals_are_now_permitted__For_further_information,_please_contact_[_1]_": "Sua conta está atualmente suspensa e apenas saques estão permitidos. Para mais informações, por favor contacte [_1].", "Loss": "Perda", "Permissions": "Permissões", "Sale_Price": "Preço de venda", "Read": "Ler", "The_maximum_number_of_tokens_([_1])_has_been_reached_": "O número máximo de tokens ([_1]) foi atingido.", "Password_is_not_strong_enough_": "A senha não é forte o suficiente.", "Explanation": "Explicação", "Contract_Sold": "Contrato vendido", "Investment_Account": "Conta de Investimento", "Shop": "Loja", "This_field_is_required_": "Este campo é obrigatório.", "Tuesday": "Terça-feira", "Touch/No_Touch": "Toca", "Number_of_ticks": "Número de tique-taques", "Old_password_is_wrong_": "A senha antiga está errada.", "This_contract_lost": "Esse contrato perdeu", "Sunday": "Domingo", "Duration": "Duração", "Cashier": "Caixa", "Stays_In/Goes_Out": "Fica dentro/Sai fora", "Contract_is_not_started_yet": "O contrato ainda não foi iniciado", "Contract_Information": "Informação do contrato", "Revoke_access": "Revogar acesso", "Exclude_time_cannot_be_less_than_6_months_": "O tempo de exclusão não pode ser inferior a seis meses.", "Real_Account": "Conta Real", "Are_you_sure_that_you_want_to_permanently_revoke_access_to_application": "Tem certeza que deseja revogar permanentemente o acesso ao aplicativo", "Start_Time": "Hora de Início", "There_was_some_invalid_character_in_an_input_field_": "Houve algum caractere inválido no campo de entradas.", "Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_": "O seu pedido para levantar [_1] [_2] da sua conta [_3] para a conta [_4] do Agente de Pagamentos foi processado com sucesso.", "Status": "Estado", "Monday": "Segunda-feira", "Th": "Qui", "Virtual_Account": "Conta Virtual", "Spot": "Preço atual", "Step": "Etapa", "Sorry,_this_feature_is_not_available_": "Este recurso não está disponível.", "We": "Qua", "This_symbol_is_not_active__Please_try_another_symbol_": "Este símbolo não está ativo. Experimente outro símbolo.", "Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_": "O contrato será vendido ao preço prevalecente do mercado no momento em que o pedido for recebido pelos nossos servidores. Esse preço pode ser diferente do preço indicado.", "Sell_time": "Hora de venda", "Sa": "Sáb", "Portfolio": "Portfólio", "Your_transaction_reference_number_is_[_1]": "O número de referência da sua transação é [_1]", "day": "dia", "Year": "Ano", "Long": "Longo", "Profit": "Lucro", "Hour": "Hora", "Only_letters,_numbers,_and_hyphen_are_allowed_": "Apenas letras, números e o hífen são permitidos.", "Update": "Atualização", "Payment_Agent": "Agente de pagamentos", "Your_trading_statistics_since_[_1]_": "As suas estatísticas de negociação desde [_1].", "Are_you_sure_that_you_want_to_permanently_delete_token": "Tem certeza que deseja excluir permanentemente o token", "Total_Cost": "Custo Total", "Contract_ID": "ID de contrato", "IP_Address": "Endereço IP", "February": "Fevereiro", "Over/Under": "Acima/Abaixo", "mins": "minutos", "Note": "Nota", "Please_input_a_valid_date": "Insira uma data válida", "Browser": "Navegador", "Payout": "Prêmio", "You_did_not_change_anything_": "Você não alterou nada.", "Payments": "Pagamentos", "View": "Ver", "email_address": "endereço de e-mail", "Adjust_trade_parameters": "Ajustar parâmetros de negociação", "Barrier_Change": "Alteração de barreira", "Please_select_a_payment_agent": "Selecione um agente de pagamentos", "Su": "Dom", "Resources": "Recursos", "Upgrade_to_a_Financial_Account": "Faça a atualização para uma Conta Financeira", "letters": "caracteres", "August": "Agosto", "months": "meses", "Current": "Atual", "Sorry,_your_account_is_not_authorised_for_any_further_contract_purchases_": "Lamentamos, a sua conta não está autorizada a mais compras de contratos.", "Upcoming_Events": "Próximos Eventos" };
	texts_json['RU'] = { "[_1]_[_2]_payout_if_[_3]_goes_outside_of_low_and_high_values_of_Barrier_through_close_on_[_4]_": "Получите выплату [_1] [_2], если [_3] выйдет за пределы верхнего и нижнего барьера на момент закрытия [_4].", "Should_be_more_than_[_1]": "Значение должно быть больше [_1]", "Please_check_the_above_form_for_pending_errors_": "Пожалуйста, исправьте указанные ошибки в форме выше.", "Christmas_Day": "Рождество", "Amount": "Количество", "Invalid_email_address": "Недействительный e-mail", "Next": "Далее", "Up/Down": "Вверх/Вниз", "March": "Март", "You_should_enter_[_1]_characters_": "Вы должны ввести [_1] символов.", "Congratulations!_Your_[_1]_Account_has_been_created_": "Поздравляем! Ваш счёт [_1] успешно открыт.", "Potential_Profit": "Потенциальная прибыль", "[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]": "[_1] [_2] было зачислено на Ваш Демо-счет [_3]", "Time_out_cannot_be_in_the_past_": "Перерыв не может быть в прошлом.", "Your_changes_have_been_updated_successfully_": "Ваши изменения успешно обновлены.", "Please_select_a_valid_date_": "Пожалуйста, выберите правильную дату.", "Closes": "Закрывается", "[_1]_[_2]_payout_if_[_3]_does_not_touch_Barrier_through_close_on_[_4]_": "Получите выплату [_1] [_2], если [_3] не коснётся заданного барьера на момент закрытия [_4].", "Feb": "Фев", "Matches/Differs": "Совпадение/Отличие", "Mar": "Мар", "December": "Декабрь", "Tu": "Вт", "[_1]_and_[_2]_cannot_be_the_same_": "[_1] и [_2] не могут совпадать.", "Please_accept_the_terms_and_conditions_": "Пожалуйста, примите правила и условия.", "You_have_not_granted_access_to_any_applications_": "У Вас нет доступа к приложениям.", "Please_[_1]complete_your_account_profile[_2]_to_lift_your_withdrawal_and_trading_limits_": "Пожалуйста, [_1]заполните свой профайл,[_2] чтобы снять торговые лимиты и ограничения на вывод.", "Japan": "Япония", "Processing_your_request___": "Обработка Вашего запроса...", "Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Ваш лимит на вывод составляет [_1] [_2] (или эквивалентную сумму в другой валюте).", "June": "Июнь", "Closes_early_(at_18:00)": "Закрывается рано (в 18:00)", "Please_log_in_": "Пожалуйста, войдите в систему.", "Only_letters,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Допускаются только буквы латинского алфавита, пробелы, дефисы, точки или апострофы.", "Forex": "Форекс", "Contract_Confirmation": "Подтверждение контракта", "Closed": "Закрыто", "January": "Январь", "Real_Standard": "Реальный стандартный", "October": "Октябрь", "space": "пробел", "Please_select_the_checkbox_": "Пожалуйста, выберите нужный ответ.", "Password_should_have_lower_and_uppercase_letters_with_numbers_": "Пароль должен содержать заглавные и строчные буквы и цифры.", "Ends_In/Out": "Закончится Внутри/Вне", "Sorry,_an_error_occurred_while_processing_your_account_": "Извините, произошла ошибка.", "Barrier": "Барьер", "Purchase_Time": "Время покупки", "May": "Май", "Sale_Date": "Дата продажи", "Aug": "Авг", "Jun": "Июн", "[_1]_[_2]_payout_if_[_3]_is_strictly_higher_than_or_equal_to_Barrier_at_close_on_[_4]_": "Получите выплату [_1] [_2], если [_3] будет находиться строго выше или на заданном барьере на момент окончания [_4].", "April": "Апрель", "PM": "вечера", "Profit_Table": "Анализ счета", "Token": "Ключ", "There_was_an_error": "Произошла ошибка", "Invalid_amount,_minimum_is": "Неправильная сумма. Минимум:", "Gaming_Account": "Игровой счет", "Total_Profit/Loss": "Общая прибыль/убыток", "Net_profit": "Чистая прибыль", "The_server_<a_href=\"[_1]\">endpoint</a>_is:_[_2]": "<a href=\"[_1]\">Конечная точка</a> сервера: [_2]", "Fridays": "пятница", "Entry_spot": "Входная котировка", "The_main_password_of_account_number_[_1]_has_been_changed_": "Основной пароль для счёта [_1] был изменён.", "Deposit": "Пополнение", "The_two_passwords_that_you_entered_do_not_match_": "Введенные пароли не совпадают.", "years": "год(а)/лет", "Today": "Cегодня", "Select_your_market": "Выбрать рынок", "Weekday": "День недели", "Last_Used": "Последние", "Please_select": "Выберите", "Exclude_time_cannot_be_for_more_than_5_years_": "Период ограничения не может быть больше 5 лет.", "Never_Used": "Никогда не использовался", "Sorry,_this_feature_is_available_to_virtual_accounts_only_": "Извините, эта опция доступна только для демо-счетов.", "Sorry,_an_error_occurred_while_processing_your_request_": "Извините, при обработке Вашего запроса произошла ошибка.", "Failed": "Возникла ошибка", "Saturday": "Суббота", "Exit_Spot_Time": "Время выходной котировки", "Time_out_cannot_be_more_than_6_weeks_": "Перерыв не может превышать 6 недель.", "Select_your_trade_type": "Выбрать тип контракта", "[_1]_[_2]_payout_if_[_3]_ends_outside_low_and_high_values_of_Barrier_at_close_on_[_4]_": "Получите выплату [_1] [_2], если [_3] завершит торговлю вне верхнего и нижнего барьера на момент закрытия [_4].", "Open": "Значение при открытии", "Date": "Дата", "Real_Cent": "Реальный центовый", "New_Year's_Day": "Новый год", "Major_Pairs": "Основные пары", "You_have_sold_this_contract_at_[_1]_[_2]": "Вы продали данный контракт по цене [_1] [_2]", "[_1]_[_2]_payout_if_[_3]_stays_between_low_and_high_values_of_Barrier_through_close_on_[_4]_": "Получите выплату [_1] [_2], если [_3] останется между заданным верхним и нижним барьером на момент закрытия [_4].", "Never": "Никогда", "Admin": "Администратор", "Rise/Fall": "Повышение/Падение", "Return": "Прибыль", "[_1]_[_2]_payout_if_[_3]_is_strictly_lower_than_Barrier_at_close_on_[_4]_": "Получите выплату [_1] [_2], если [_3] будет находиться строго ниже заданного ценового барьера на момент закрытия [_4].", "Invalid_amount,_maximum_is": "Неправильная сумма. Максимум:", "Does_Not_Touch": "не коснется", "Real_STP": "Реальный STP", "Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_": "Ваш пароль был изменен. Пожалуйста, зайдите на счет, используя новый пароль.", "All_markets_are_closed_now__Please_try_again_later_": "В данное время все рынки закрыты. Пожалуйста, попробуйте позже.", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_click_<a_href=\"[_1]\">here</a>_": "Ваша касса закрыта по Вашему запросу - для открытия, пожалуйста, нажмите <a href=\"[_1]\">сюда</a>.", "Date_and_Time": "Дата и время", "Transaction_performed_by_[_1]_(App_ID:_[_2])": "Транзакция проведена [_1] (App ID: [_2])", "New_password": "Новый пароль", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_": "Следовательно, Ваш максимальный лимит на вывод на данный момент составляет [_1] [_2].", "Your_changes_have_been_updated_": "Ваши изменения внесены успешно.", "This_feature_is_not_relevant_to_virtual-money_accounts_": "Данная функция недоступна на демо-счетах.", "Sorry,_account_signup_is_not_available_in_your_country__Please_contact_<a_href=\"[_1]\">customer_support</a>_for_more_information_": "Извините, регистрация счёта недоступна для граждан Вашей страны. Пожалуйста, свяжитесь с отделом <a href=\"[_1]\">поддержки клиентов</a> для получения дополнительной информации.", "Remaining_Time": "Оставшееся время", "Your_token_has_expired__Please_click_[_1]here[_2]_to_restart_the_verification_process_": "Срок действия Вашего ключа истёк. Пожалуйста, нажмите [_1]здесь[_2], чтобы повторно запустить процесс проверки.", "numbers": "цифры", "Waiting_for_entry_tick_": "В ожидании входного тика...", "Please_select_a_value": "Пожалуйста, выберите значение", "Minute": "Мин.", "In/Out": "Внутри/Вне", "Reference_ID": "Номер", "Predict_the_direction<br_/>and_purchase": "Предскажите направление движения<br />и купите", "New_token_created_": "Создан новый ключ.", "Your_account_has_no_trading_activity_": "На Вашем счету нет торговой деятельности.", "Trade": "Торговля", "This_contract_won": "Вы выиграли", "Entry_Spot": "Входная котировка", "Your_withdrawal_limit_is_[_1]_[_2]_": "Ваш лимит на вывод составляет [_1] [_2].", "Withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Вывод средств для Вашего счета в данный момент недоступен. Пожалуйста, свяжитесь с [_1] для разблокировки.", "When_you_click_\"OK\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_": "Когда Вы нажмёте \"ОК\", Вы будете отстранены от работы на сайте до окончания выбранной даты.", "Mo": "Пн", "Please_enter_an_integer_value": "Пожалуйста, введите целое число", "You_need_to_finish_all_20_questions_": "Вам необходимо ответить на 20 вопросов.", "Ends_Between": "закончится между", "You_have_already_withdrawn_[_1]_[_2]_": "Вы уже вывели со счета [_1] [_2].", "Thursday": "Четверг", "Please_select_a_valid_time_": "Пожалуйста, выберите правильное время.", "Stays_Between": "Останется между", "Time_is_in_the_wrong_format_": "Неправильный формат времени.", "This_is_a_staging_server_-_For_testing_purposes_only": "Это вспомогательный сервер, применяемый лишь для тестирования", "Digit": "Десятичн.", "Start_time": "Время начала", "Select_market": "Выбрать рынок", "Please_set_your_30-day_turnover_limit_in_our_[_1]self-exclusion_facilities[_2]_to_remove_deposit_limits_": "Пожалуйста, укажите 30-дневный лимит на объём покупок в настройках [_1]самоисключения,[_2] чтобы снять лимит на депозит.", "Fr": "Пт", "Apr": "Апр", "Your_account_has_no_Login/Logout_activity_": "На Вашем счету нет активности входов/выходов.", "Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_": "Ваш дневной [_1] лимит на вывод в настоящее время составляет [_2] [_3] (или эквивалентную сумму в другой валюте).", "[_1]_[_2]_payout_if_[_3]_ends_on_or_between_low_and_high_values_of_Barrier_at_close_on_[_4]_": "Получите выплату [_1] [_2], если [_3] завершит контракт на или между верхним или нижним барьером на момент закрытия [_4].", "Charting_for_this_underlying_is_delayed": "Графики для этого инструмента рисуются с задержкой", "Nov": "Ноя", "week": "нед.", "Please_set_[_1]country_of_residence[_2]_before_upgrading_to_a_real-money_account_": "Пожалуйста, укажите [_1]страну проживания[_2] до перехода на реальный счёт.", "Lower": "Ниже", "Jan": "Янв", "Chart": "График", "Previous": "Предыдущ.", "Jul": "Июл", "Virtual_money_credit_to_account": "Виртуальный кредит на счёт", "from_[_1]_to_[_2]": "от [_1] до [_2]", "Last_Digit_Stats": "Статистика последних тиков", "hour": "час.", "Demo": "Демо", "Touches": "Коснётся", "Settles": "Заканчивается", "Oct": "Окт", "Should_be_a_valid_number": "Введите правильное число", "Profit/Loss": "Плюс/Минус", "Main_password": "Основной пароль", "min": "мин.", "Session_duration_limit_cannot_be_more_than_6_weeks_": "Лимит на длительность сессии не может превышать 6 недель.", "Exit_spot": "Выходная котировка", "Dec": "Дек", "Scopes": "Сфера действия", "Closes_early_(at_21:00)": "Закрывается рано (в 21:00)", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_": "Вы уже вывели со счета сумму, эквивалентную [_1] [_2].", "Sep": "Сен", "month": "мес.", "Remaining_time": "Оставшееся время", "Withdraw": "Вывод", "High_Barrier_([_1])": "Верхний барьер ([_1])", "End_time": "Окончание", "hours": "час.", "minutes": "минут(ы)", "Resale_not_offered": "Продажа не предлагается", "Low_Barrier_([_1])": "Нижний Барьер ([_1])", "Should_be_less_than_[_1]": "Значение должно быть меньше [_1]", "seconds": "секунд(ы)", "weeks": "нед.", "Lock_Cashier": "Закрыть кассу паролем", "Balance": "Баланс", "verification_token": "проверочный ключ", "Only_letters,_numbers,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Разрешены только буквы, цифры, пробелы, дефис, точки и апостроф.", "Delete": "Удалить", "minute": "минут(ы)", "True": "Верно", "Opens": "Открывается", "Current_password": "Текущий пароль", "Tick": "Тики", "Asset": "Актив", "Percentage": "Проценты", "Indicative": "Ориентировочная цена", "[_1]_withdrawal_from_account_number_[_2]_to_[_3]_is_done__Transaction_ID:_[_4]": "Вывод средств [_1] со счёта [_2] на счёт [_3] завершен. Номер транзакции: [_4]", "July": "Июль", "September": "Сентябрь", "High_Barrier": "Верхний барьер", "Contract_is_not_started_yet": "Контракт ещё не начался", "[_1]Authenticate_your_account[_2]_now_to_take_full_advantage_of_all_withdrawal_options_available_": "[_1]Пройдите аутентификацию счёта,[_2] чтобы снять торговые лимиты и ограничения на вывод.", "Stays_In/Goes_Out": "Останется Внутри/Выйдет за пределы", "Cashier": "Касса", "Duration": "Длительность", "Goes_Outside": "выйдет за пределы", "Old_password_is_wrong_": "Старый пароль неверный.", "This_contract_lost": "Вы проиграли", "Sunday": "Воскресенье", "Are_you_sure_that_you_want_to_permanently_revoke_access_to_application": "Вы уверены, что хотите навсегда отказаться от доступа к приложению", "Real_Account": "Реальный счет", "Exclude_time_cannot_be_less_than_6_months_": "Период ограничения не может быть менее 6 месяцев.", "Revoke_access": "Отмена доступа", "Your_settings_have_been_updated_successfully_": "Ваши настройки обновлены успешно.", "Real_Volatility": "Реальный волатильный", "Contract_Information": "Детали контракта", "This_symbol_is_not_active__Please_try_another_symbol_": "Данный символ неактивен. Воспользуйтесь другим символом.", "Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_": "Контракт будет продан по цене, действующей на момент получения запроса нашими серверами. Эта цена может отличаться от указанной в настоящее время.", "Step": "Шаг", "Spot": "Спот-котировка", "We": "Ср", "Sorry,_this_feature_is_not_available_": "Извините, данная функция недоступна.", "[_1]_[_2]_payout_if_[_3]_touches_Barrier_through_close_on_[_4]_": "Получите выплату [_1] [_2], если [_3] коснётся заданного барьера к моменту закрытия [_4].", "Status": "Статус", "Virtual_Account": "Демо-счет", "Th": "Чт", "Monday": "Понедельник", "Start_Time": "Время начала", "There_was_some_invalid_character_in_an_input_field_": "Неразрешённый символ в поле ввода.", "Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_": "Ваш запрос на вывод [_1] [_2] с Вашего счета [_3] на счет платежного агента [_4] был выполнен успешно.", "Only_letters,_numbers,_and_hyphen_are_allowed_": "Разрешены только буквы, цифры и дефис.", "Update": "Обновить", "Hour": "Час.", "day": "дн.", "Profit": "Прибыль", "Year": "год", "Long": "Длинная позиция", "Sa": "Сб", "Final_price": "Итоговая цена", "Sell_time": "Время продажи", "Equals": "Равно", "Your_transaction_reference_number_is_[_1]": "Номер Вашей сделки [_1]", "Portfolio": "Портфель", "Only_numbers,_space,_and_hyphen_are_allowed_": "Разрешены только цифры, пробелы и дефисы.", "Account_balance:": "Баланс счета:", "Are_you_sure_that_you_want_to_permanently_delete_token": "Вы уверены, что хотите навсегда удалить ключ?", "Your_trading_statistics_since_[_1]_": "Ваша торговая статистика с [_1].", "Payment_Agent": "Платежный агент", "Please_[_1]accept_the_updated_Terms_and_Conditions[_2]_to_lift_your_withdrawal_and_trading_limits_": "Пожалуйста, [_1]примите Правила и условия,[_2] чтобы снять ограничения на торговые лимиты и вывод средств.", "Please_submit_a_valid_verification_token_": "Пожалуйста, введите правильный проверочный ключ.", "Buy_price": "Цена покупки", "February": "Февраль", "IP_Address": "IP-адрес", "today,_Fridays": "сегодня, по пятницам", "Total_Cost": "Общая стоимость", "Contract_ID": "ID контракта", "Only_[_1]_decimal_points_are_allowed_": "Разрешенное количество десятичных: [_1].", "You_have_reached_the_rate_limit_of_requests_per_second__Please_try_later_": "Вы достигли лимита курса или количества запросов в секунду. Пожалуйста, повторите попытку позже.", "Adjust_trade_parameters": "Изменить параметры контракта", "Barrier_Change": "Изменение барьера", "email_address": "эл. адрес", "View": "Просмотр", "Payout": "Выплата", "Browser": "Браузер", "You_did_not_change_anything_": "Вы не внесли никаких изменений.", "Please_<a_href=\"[_1]\">log_in</a>_to_view_this_page_": "Пожалуйста, <a href=\"[_1]\">войдите,</a> чтобы просмотреть данную страницу.", "Payments": "Платежи", "mins": "мин.", "Note": "Примечание", "Your_account_is_restricted__Kindly_[_1]contact_customer_support[_2]_for_assistance_": "Ваш счёт заблокирован. Пожалуйста, свяжитесь с нашей [_1]службой поддержки[_2] для получения дальнейшей помощи.", "Please_input_a_valid_date": "Пожалуйста, введите правильную дату", "Over/Under": "Над/Под", "Upcoming_Events": "Ближайшие события", "months": "мес.", "Current": "Текущие", "Sorry,_your_account_is_not_authorised_for_any_further_contract_purchases_": "Извините, Ваш счет не авторизован для дальнейшей покупки контрактов.", "Upgrade_to_a_Financial_Account": "Обновите до финансового счета", "letters": "буквы", "[_1]_deposit_from_[_2]_to_account_number_[_3]_is_done__Transaction_ID:_[_4]": "Вы успешно перевели средства [_1] со счёта [_2] на счёт [_3]. Номер транзакции: [_4]", "August": "Август", "Please_select_a_payment_agent": "Пожалуйста, выберите платежного агента", "The_email_address_provided_is_already_in_use__If_you_forgot_your_password,_please_try_our_<a_href=\"[_1]\">password_recovery_tool</a>_or_contact_our_customer_service_": "Указанный Вами электронный адрес уже используется для другого счёта. Если Вы забыли пароль к своему счету, пожалуйста, воспользуйтесь <a href=\"[_1]\">инструментом восстановления пароля</a> или свяжитесь с нашей службой поддержки.", "Resources": "Полезное", "Su": "Вс", "[_1]_days_[_2]_hours_[_3]_minutes": "[_1] дн. [_2] ч. [_3] мин.", "The_Payment_Agent_facility_is_currently_not_available_in_your_country_": "Оплата через платежного агента в данный момент недоступна для Вашей страны.", "Connection_error:_Please_check_your_internet_connection_": "Проблема со связью: пожалуйста, проверьте Ваше подключение к интернету.", "Investor_password": "Пароль инвестора", "Description": "Описание", "Ends_Outside": "закончится вне", "Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_": "Пожалуйста, следуйте данной схеме: 3 цифры, тире, а затем 4 цифры.", "Target": "Цель", "End_Time": "Окончание", "Select_your_underlying_asset": "Выбрать базовый актив", "Ref_": "Номер", "Finish": "Завершить", "Asset_Index": "Индекс активов", "Deposits_and_withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Внесение и вывод средств для Вашего счета в данный момент невозможны. Пожалуйста, свяжитесь с [_1] для разблокировки.", "Upgrade_to_a_Real_Account": "Открыть реальный счет", "days": "дн.", "Only_[_1]_are_allowed_": "Разрешены только [_1] и латинские буквы.", "Sell": "Продажа", "second": "секунд(ы)", "November": "Ноябрь", "Verification_code_format_incorrect_": "Неправильный формат кода проверки личности.", "Name": "Имя и фамилия", "Low_Barrier": "Нижний Барьер", "Your_transaction_reference_is": "Ссылка на Вашу сделку", "Month": "Месяц", "Questions": "Вопросы", "Higher/Lower": "Выше/Ниже", "Your_Application_is_Being_Processed_": "Ваша заявка обрабатывается.", "Unlock_Cashier": "Открыть кассу", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_": "Ваша касса закрыта по Вашему запросу – для открытия, пожалуйста, введите пароль.", "Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_": "Ваш запрос на перевод [_1] [_2] с [_3] на [_4] был выполнен успешно.", "details": "подробности", "Insufficient_balance_": "Недостаточно средств на счете.", "Details": "Подробности", "Contract_Expiry": "Срок истечения контракта", "Waiting_for_exit_tick_": "В ожидании выходного тика.", "[_1]_Please_click_the_link_below_to_restart_the_password_recovery_process__If_you_require_further_assistance,_please_contact_our_Customer_Support_": "[_1] Пожалуйста нажмите на ссылку ниже, чтобы повторно запустить процесс восстановления пароля. Если Вам нужна дополнительная помощь, пожалуйста, свяжитесь с нашей службой поддержки.", "Statement": "История счета", "There_was_a_problem_accessing_the_server_": "Возникла проблема с доступом к серверу.", "Barrier_([_1])": "Барьер ([_1])", "today": "сегодня", "Now": "Сейчас", "Action": "Акт", "Stake": "Ставка", "There_was_a_problem_accessing_the_server_during_purchase_": "Возникла проблема с доступом к серверу во время процесса покупки.", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Поэтому максимально возможная сумма к выводу на данный момент (если на счету есть средства) составляет [_1] [_2] (или эквивалентную сумму в другой валюте).", "Exit_Spot": "Выходная котировка", "Market_is_closed__Please_try_again_later_": "В данное время рынок закрыт. Пожалуйста, попробуйте позже.", "Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_": "Ваш счет полностью авторизован, и лимит на вывод был снят.", "Please_select_at_least_one_scope": "Пожалуйста, выберите минимум один параметр", "Spot_Time": "Спот-время", "Potential_Payout": "Потенциальная выплата", "End_time_must_be_after_start_time_": "Время окончания должно быть позднее времени начала.", "Walkthrough_Guide": "Краткий экскурс", "year": "год(а)/лет", "Purchase_Price": "Цена покупки", "Sell_at_market": "Продать по текущей цене", "All_barriers_in_this_trading_window_are_expired": "Все барьеры в данном торговом окне истекли", "Higher": "Выше", "Only_numbers_and_spaces_are_allowed_": "Разрешены только цифры и пробелы.", "Contract": "Контракт", "Please_complete_the_[_1]financial_assessment_form[_2]_to_lift_your_withdrawal_and_trading_limits_": "Прежде, чем продолжить, пожалуйста, заполните следующую [_1]форму финансовой оценки[_2].", "Your_session_duration_limit_will_end_in_[_1]_seconds_": "Ограничение на длительность сессии закончится через [_1] сек.", "Price": "Цена", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_": "Вы уже в целом вывели сумму, эквивалентную [_1] [_2] за последние [_3] суток.", "Even/Odd": "Чётное/Нечётное", "Current_Time": "Текущее время", "Open_a_Financial_Account": "Открыть финансовый счет", "Friday": "пятница", "Change_Password": "Сменить пароль", "logout": "выход", "Successful": "Успешно", "Credit/Debit": "Кредит/Дебет", "Minimum_of_[_1]_characters_required_": "Необходимо минимум [_1] знака(ов).", "AM": "утра", "Sorry,_you_have_entered_an_incorrect_cashier_password": "Извините, Вы ввели неверный пароль для раздела Касса", "Sale_Price": "Цена продажи", "Time_out_must_be_after_today_": "Перерыв должен быть позднее сегодняшней даты.", "Read": "Читать", "Your_account_is_currently_suspended__Only_withdrawals_are_now_permitted__For_further_information,_please_contact_[_1]_": "Ваш счет заблокирован. В данный момент Вам доступна только функция вывода средств. Для дальнейшей информации, пожалуйста, свяжитесь с [_1].", "Permissions": "Разрешения", "Loss": "Потери", "Create_Account": "Открыть счёт", "An_additional_password_can_be_used_to_restrict_access_to_the_cashier_": "Можно использовать дополнительный пароль для ограничения доступа к кассе.", "Short": "Короткая позиция", "h": "ч.", "Trading_Times": "Время открытия рынков", "Buy": "Покупка", "Wednesday": "Среда", "Day": "День", "Please_enter_a_number_between_[_1]_": "Пожалуйста, введите цифру между [_1].", "Touch/No_Touch": "Касание/Нет касания", "Not": "Не", "Tuesday": "Вторник", "This_field_is_required_": "Данное поле является необходимым.", "Your_token_has_expired__Please_click_<a_href=\"[_1]\">here</a>_to_restart_the_verification_process_": "Срок действия Вашего ключа истёк. Пожалуйста, нажмите <a href=\"[_1]\">здесь,</a> чтобы повторно запустить процесс проверки.", "Number_of_ticks": "Кол-во тиков", "Shop": "Магазин", "Password_is_not_strong_enough_": "Пароль недостаточно надёжный.", "Investment_Account": "Инвестиционный счет", "Contract_Sold": "Контракт продан", "Explanation": "Объяснение", "Should_be_between_[_1]_and_[_2]": "Допустимые значения: от [_1] до [_2]", "The_maximum_number_of_tokens_([_1])_has_been_reached_": "Достигнуто максимальное число ключей ([_1])." };
	texts_json['TH'] = { "October": "ตุลาคม", "space": "ช่องว่าง", "Please_select_the_checkbox_": "โปรดระบุค่าจากตัวเลือก", "Real_Standard": "มาตรฐานจริง", "Closed": "ปิด", "January": "มกราคม", "Forex": "ฟอเร็กซ์", "Only_letters,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "ตัวอักษร ช่องว่าง ขีดกลาง จุด และ เครื่องหมายวรรคตอน ( ' ) เท่านั้น ที่สามารถใช้ได้", "Please_log_in_": "โปรดเข้าสู่ระบบ", "Contract_Confirmation": "การยืนยันสัญญา", "June": "มิถุนายน", "Closes_early_(at_18:00)": "ปิดก่อนเวลา (เมื่อเวลา 18.00 น.)", "False": "ผิด", "Processing_your_request___": "กำลังดำเนินการตามความประสงค์ของท่าน", "Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "วงเงินการถอนของท่าน คือ [_1] [_2] (หรือเทียบเท่าในสกุลเงินอื่น)", "Japan": "ประเทศญี่ปุ่น", "PM": "น.", "Profit_Table": "ตารางกำไร", "April": "เมษายน", "[_1]_[_2]_payout_if_[_3]_is_strictly_higher_than_or_equal_to_Barrier_at_close_on_[_4]_": "[_1] [_2] ชำระเงิน เมื่อ [_3] มีมูลค่าเท่ากันหรือสูงกว่า Barrier ที่สิ้นสุดเมื่อ [_4]", "Aug": "ส.ค.", "Jun": "มิ.ย.", "Sale_Date": "วันที่ขาย", "May": "พ.ค.", "Purchase_Time": "เวลาซื้อ", "Password_should_have_lower_and_uppercase_letters_with_numbers_": "รหัสผ่านควรประกอบด้วยอักษรตัวเล็ก อักษรตัวใหญ่ และตัวเลข", "Sorry,_an_error_occurred_while_processing_your_account_": "ขออภัย มีความผิดพลาดเกิดขึ้นขณะที่ประมวลผลบัญชีของท่าน", "Invalid_email_address": "อีเมล์ไม่ถูกต้อง", "Next": "ถัดไป", "March": "มีนาคม", "Amount": "จำนวน", "Please_check_the_above_form_for_pending_errors_": "โปรดตรวจสอบแบบฟอร์มข้างต้นสำหรับรายการข้อผิดพลาด", "Christmas_Day": "วันคริสต์มาส", "Should_be_more_than_[_1]": "ควรมีค่ามากกว่า [_1]", "[_1]_[_2]_payout_if_[_3]_goes_outside_of_low_and_high_values_of_Barrier_through_close_on_[_4]_": "[_1] [_2] ชำระเงิน เมื่อ [_3] ออกนอกขอบเขตของ Barrier ต่ำและสูง กระทั่งสิ้นสุดที่ [_4]", "Please_[_1]complete_your_account_profile[_2]_to_lift_your_withdrawal_and_trading_limits_": "โปรด [_1]ปรับปรุงประวัติของท่าน[_2] เพื่อเพิ่มวงเงินการซื้อขายและการถอนเงินของท่าน", "You_have_not_granted_access_to_any_applications_": "ท่านไม่ได้รับอนุญาตให้เข้าใช้งานระบบใดๆ", "December": "ธันวาคม", "Tu": "อัง", "Please_accept_the_terms_and_conditions_": "โปรดยอมรับข้อตกลงและเงื่อนไข", "[_1]_and_[_2]_cannot_be_the_same_": "[_1] และ [_2] ไม่สามารถเป็นค่าเดียวกัน", "[_1]_[_2]_payout_if_[_3]_does_not_touch_Barrier_through_close_on_[_4]_": "[_1] [_2] ชำระเงิน เมื่อ [_3] ไม่แตะ Barrier กระทั่งสิ้นสุดที่ [_4]", "Closes": "ปิด", "Feb": "ก.พ.", "Mar": "มี.ค.", "Time_out_cannot_be_in_the_past_": "ช่วงเวลาที่ใช้อ้างอิงไม่สามารถเป็นเวลาในอดีต", "Please_select_a_valid_date_": "โปรดระบุวันที่ที่ถูกต้อง", "Your_changes_have_been_updated_successfully_": "การแก้ไขของท่านถูกดำเนินการเรียบร้อยแล้ว", "Congratulations!_Your_[_1]_Account_has_been_created_": "ขอแสดงความยินดี! บัญชีของท่าน [_1] ได้ถูกสร้างเรียบร้อยแล้ว", "You_should_enter_[_1]_characters_": "ท่านควรป้อนข้อมูล [_1] อักขระ", "Potential_Profit": "ประมาณการกำไร", "[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]": "[_1] [_2] ถูกเพิ่มแล้วที่บัญชีเสมือนของท่าน [_3]", "Never": "ไม่เคย", "[_1]_[_2]_payout_if_[_3]_stays_between_low_and_high_values_of_Barrier_through_close_on_[_4]_": "[_1] [_2] ชำระเงิน เมื่อ [_3] อยู่ระหว่างค่าต่ำและสูงของ Barrier กระทั่งสิ้นสุดเมื่อ [_4]", "Major_Pairs": "คู่หลัก", "You_have_sold_this_contract_at_[_1]_[_2]": "ท่าได้ขายสัญญานี้ที่ [_1] [_2]", "Date": "วันที่", "Open": "เปิด", "New_Year's_Day": "วันปีใหม่", "Real_Cent": "เงินจริง", "[_1]_[_2]_payout_if_[_3]_ends_outside_low_and_high_values_of_Barrier_at_close_on_[_4]_": "[_1] [_2] ชำระเงิน เมื่อ [_3] สิ้นสุดนอกขอบเขต Barrier ต่ำสุดและสูงสุดและสิ้นสุดที่ [_4]", "Time_out_cannot_be_more_than_6_weeks_": "ช่วงระยะเวลาอ้างอิงไม่สามารถมากกว่า 6 สัปดาห์", "Select_your_trade_type": "กำหนด ประเภทการเทรดของท่าน", "Exit_Spot_Time": "เวลาที่สปอตสิ้นสุด", "Saturday": "วันเสาร์", "Failed": "ล้มเหลว", "Sorry,_an_error_occurred_while_processing_your_request_": "ขออภัย มีความผิดพลาดเกิดขึ้นขณะที่ประมวลผลความประสงค์ของท่าน", "Sorry,_account_signup_is_not_available_in_your_country__Please_contact_<a_href=\"[_1]\">customer_support</a>_for_more_information_": "ขออภัย ยังไม่มีการบริการบัญชีในประเทศของท่าน โปรดติดต่อ <a href=\"[_1]\">ฝ่ายลูกค้าสัมพันธ์</a> สำหรับข้อมูลเพิ่มเติม", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_": "ดังนั้น วงเงินการถอนมากที่สุดของท่านขณะนี้ (หากบัญชีท่านมีวงเงินเพียงพอ) คือ [_1] [_2]", "New_password": "รหัสผ่านใหม่", "Your_changes_have_been_updated_": "การเปลี่ยนแปลงของท่านได้ถูกดำเนินการแล้ว", "This_feature_is_not_relevant_to_virtual-money_accounts_": "ฟังก์ชันนี้ไม่สัมพันธ์กับบัญชีเงินเสมือน", "Date_and_Time": "วันที่และเวลา", "Transaction_performed_by_[_1]_(App_ID:_[_2])": "ดำเนินธุรกรรมโดย [_1] (App ID: [_2])", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_click_<a_href=\"[_1]\">here</a>_": "การรับ/ชำระเงินของท่านถูกล็อก - หากประสงค์ปลดล็อก โปรดคลิก <a href=\"[_1]\">ที่นี่</a>", "Does_Not_Touch": "ไม่แตะ", "Real_STP": "STP จริง", "Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_": "รหัสผ่านของท่านได้ถูกกำหนดใหม่เรียบร้อยแล้ว โปรดเข้าสู่ระบบโดยการใช้รหัสผ่านใหม่ของท่าน", "All_markets_are_closed_now__Please_try_again_later_": "ตลาดได้ปิดทำการแล้ว กรุณาทำรายการใหม่ภายหลัง", "Invalid_amount,_maximum_is": "จำนวนไม่ถูกต้อง ค่าสูงสุด คือ", "[_1]_[_2]_payout_if_[_3]_is_strictly_lower_than_Barrier_at_close_on_[_4]_": "[_1] [_2] ชำระเงิน เมื่อ [_3] มีมูลค่าเท่ากันหรือต่ำกว่า Barrier ที่สิ้นสุด ณ [_4]", "Admin": "แอดมิน", "Return": "ผลตอบแทน", "Deposit": "ฝาก", "The_two_passwords_that_you_entered_do_not_match_": "รหัสผ่านที่ท่านป้อนสองครั้งไม่เหมือนกัน", "years": "ปี", "The_main_password_of_account_number_[_1]_has_been_changed_": "รหัสผ่านหลักของเลขที่บัญชี [_1] ได้มีการเปลี่ยนแปลงแล้ว", "Entry_spot": "สปอตเริ่มต้น", "Fridays": "วันศุกร์", "Net_profit": "กำไรสุทธิ", "The_server_<a_href=\"[_1]\">endpoint</a>_is:_[_2]": "เซิร์ฟเวอร์ <a href=\"[_1]\">จุดสิ้นสุด</a> คือ: [_2]", "Total_Profit/Loss": "รวมกำไร/ขาดทุน", "There_was_an_error": "มีความผิดพลาดเกิดขึ้น", "Invalid_amount,_minimum_is": "จำนวนไม่ถูกต้อง ค่าต่ำสุด คือ", "Gaming_Account": "บัญชีการพนัน", "Token": "โทเค่น", "Never_Used": "ไม่เคยใช้", "Sorry,_this_feature_is_available_to_virtual_accounts_only_": "ขออภัย ฟังก์ชันนี้มีให้ใช้งานเฉพาะบัญชีทดลองใช้เท่านั้น", "Exclude_time_cannot_be_for_more_than_5_years_": "เวลาพักไม่เกิน 5 ปี", "Last_Used": "ใช้ครั้งสุดท้าย", "Please_select": "โปรดระบุ", "Weekday": "วันธรรมดาที่ไม่ใช่วันเสาร์อาทิตย์", "Select_your_market": "กำหนด ตลาดของท่าน", "Today": "วันนี้", "Digit": "ตัวเลข", "This_is_a_staging_server_-_For_testing_purposes_only": "นี่คือ เซิร์ฟเวอร์สำหรับพัก เพื่อใช้ในการทดสอบเท่านั้น", "Time_is_in_the_wrong_format_": "เวลาอยู่ในรูปแบบที่ไม่ถูกต้อง", "Stays_Between": "อยู่ระหว่าง", "Please_select_a_valid_time_": "โปรดระบุเวลาที่ถูกต้อง", "Thursday": "วันพฤหัสบดี", "You_have_already_withdrawn_[_1]_[_2]_": "ท่านได้ถอน [_1] [_2]", "Ends_Between": "สิ้นสุดระหว่าง", "You_need_to_finish_all_20_questions_": "ท่านต้องตอบคำถาม 20 ข้อ ทุกข้อ", "from_[_1]_to_[_2]": "จาก [_1] ถึง [_2]", "Jul": "ก.ค.", "Virtual_money_credit_to_account": "เครดิตเงินเสมือนไปยังบัญชี", "Previous": "ก่อนหน้า", "Chart": "แผนภูมิ", "Jan": "ม.ค.", "week": "สัปดาห์", "Please_set_[_1]country_of_residence[_2]_before_upgrading_to_a_real-money_account_": "โปรดตั้งค่า [_1]ประเทศที่พำนัก[_2] ก่อนอัพเกรดเป็นบัญชีจริง", "Lower": "ต่ำกว่า", "Charting_for_this_underlying_is_delayed": "กราฟของผลิตภัณฑ์อ้างอิงนี้ล่าช้า", "Nov": "พ.ย.", "Your_account_has_no_Login/Logout_activity_": "บัญชีของท่านไม่มีประวัติ การเข้าใช้งานระบบ/การออกจากระบบ", "Apr": "เม.ย.", "Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_": "วงเงินการถอนเงินต่อวันของท่าน [_1] ในปัจจุบัน คือ [_2] [_3] (หรือเทียบเท่าในสกุลเงินอื่น)", "[_1]_[_2]_payout_if_[_3]_ends_on_or_between_low_and_high_values_of_Barrier_at_close_on_[_4]_": "[_1] [_2] ชำระเงิน เมื่อ [_3] สิ้นสุดหรืออยู่ระหว่างค่าต่ำสุดและค่าสูงสุดของ Barrier ณ เวลาปิดที่ [_4]", "Please_set_your_30-day_turnover_limit_in_our_[_1]self-exclusion_facilities[_2]_to_remove_deposit_limits_": "โปรดตั้งค่าวงเงินการซื้อขาย 30 วันของท่านจาก [_1]ตัวเลือกพักการซื้อขาย[_2] เพื่อลบวงเงินการฝากเงิน", "Select_market": "กำหนด ตลาด", "Fr": "ศ", "Start_time": "เวลาเริ่ม", "New_token_created_": "สร้างโทเค่นใหม่แล้ว", "Your_account_has_no_trading_activity_": "บัญชีของท่านไม่มีประวัติการซื้อขาย", "Predict_the_direction<br_/>and_purchase": "พยากรณ์ทิศทาง<br />และซื้อ", "Reference_ID": "หมายเลขอ้างอิง", "Minute": "นาที", "numbers": "ตัวเลข", "Waiting_for_entry_tick_": "กำลังรองช่วงราคาเริ่มต้น", "Please_select_a_value": "โปรดระบุค่า", "Remaining_Time": "เวลาที่เหลืออยู่", "Your_token_has_expired__Please_click_[_1]here[_2]_to_restart_the_verification_process_": "โทเค่นของท่านหมดอายุแล้ว โปรดคลิก [_1]ที่นี่[_2] เพื่อดำเนินกระบวนการตรวจสอบ", "Please_enter_an_integer_value": "โปรดป้อนจำนวนเต็ม", "Mo": "จ", "Withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "ในขณะนี้ บัญชีของท่านไม่ได้รับอนุญาตให้ดำเนินการถอนเงิน โปรดติดต่อ [_1] เพื่อปลดล็อค", "When_you_click_\"OK\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_": "เมื่อท่านเลือก \"OK\" ท่านจะถูกพักจากระบบซื้อขายกระทั่งวันที่ที่ท่านระบุ", "Your_withdrawal_limit_is_[_1]_[_2]_": "วงเงินการถอนของท่าน คือ [_1] [_2]", "Trade": "เทรด", "This_contract_won": "สัญญานี้กำไร", "Entry_Spot": "สปอตเริ่มต้น", "Current_password": "รหัสผ่านปัจจุบัน", "True": "จริง", "Female": "เพศหญิง", "Opens": "เปิด", "minute": "นาที", "Balance": "คงเหลือ", "verification_token": "โทเค่นเพื่อการตรวจสอบ", "Only_letters,_numbers,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "ตัวอักษร ตัวเลข ช่องว่าง ขีดกลาง จุด และ เครื่องหมายวรรคตอน ( ' ) เท่านั้น ที่สามารถใช้ได้", "Delete": "ลบ", "weeks": "สัปดาห์", "High_Barrier": "Barrier สูง", "September": "กันยายน", "[_1]_withdrawal_from_account_number_[_2]_to_[_3]_is_done__Transaction_ID:_[_4]": "[_1] ได้ถอนเงินจากเลขที่บัญชี [_2] ไปยัง [_3] เรียบร้อยแล้ว หมายเลขอ้างอิงธุรกรรม: [_4]", "July": "กรกฎาคม", "Indicative": "บ่งชี้", "Asset": "สินทรัพย์", "Percentage": "ร้อยละ", "month": "เดือน", "Sep": "ก.ย.", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_": "ท่านได้ถอน [_1] [_2] หรือเทียบเท่า", "Closes_early_(at_21:00)": "ปิดก่อนเวลา (เมื่อเวลา 21.00 น.)", "Dec": "ธ.ค.", "Scopes": "ขอบเขต", "Profit/Loss": "กำไร/ขาดทุน", "Main_password": "รหัสผ่านหลัก", "min": "ค่าต่ำสุด", "Session_duration_limit_cannot_be_more_than_6_weeks_": "รอบระยะเวลาการซื้อขายไม่สามารถมากกว่า 6 สัปดาห์", "Exit_spot": "สปอตสิ้นสุด", "Oct": "ต.ค.", "Settles": "ชำระเงิน", "Should_be_a_valid_number": "ควรเป็นตัวเลขที่ถูกต้อง", "Demo": "สาธิต", "Touches": "แตะ", "Last_Digit_Stats": "สถิติตัวเลขสุดท้าย", "hour": "ชั่วโมง", "seconds": "วินาที", "Should_be_less_than_[_1]": "ควรมีค่าน้อยกว่า [_1]", "Low_Barrier_([_1])": "Barrier ต่ำ ([_1])", "minutes": "นาที", "Resale_not_offered": "การขายสัญญาไม่ได้ถูกนำเสนอ", "End_time": "เวลาสิ้นสุด", "hours": "ชั่วโมง", "Score": "คะแนน", "High_Barrier_([_1])": "Barrier สูง ([_1])", "Withdraw": "ถอนเงิน", "Remaining_time": "เวลาที่เหลืออยู่", "Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_": "คำสั่งของท่านเพื่อถอน [_1] [_2] จากบัญชีของท่าน [_3] ให้ตัวแทนรับชำระเงิน [_4] บัญชีได้รับการประมวลผลสำเร็จ", "There_was_some_invalid_character_in_an_input_field_": "มีบางอักขระไม่ถูกต้องจากข้อมูลที่ป้อนเข้ามา", "Start_Time": "เวลาเริ่ม", "Virtual_Account": "บัญชีทดลองใช้", "Monday": "วันจันทร์", "Th": "พฤ", "[_1]_[_2]_payout_if_[_3]_touches_Barrier_through_close_on_[_4]_": "[_1] [_2] ชำระเงิน เมื่อ [_3] แตะ Barrier กระทั่งสิ้นสุดที่ [_4]", "Status": "สถานะ", "Sorry,_this_feature_is_not_available_": "ขออภัย ไม่สามารถใช้งานฟังก์ชันนี้ได้", "We": "พวกเรา", "Step": "ขั้น", "Spot": "สปอต", "Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_": "สัญญาจะถูกจำหน่ายที่ราคาทั่วไปของตลาดเมื่อระบบซื้อขายได้รับการแจ้งความจำนง ราคานี้อาจจะแตกต่างจากราคาที่ระบุ", "This_symbol_is_not_active__Please_try_another_symbol_": "ไม่มีสัญลักษณ์นี้ โปรดลองสัญลักษณ์อื่น", "Account_balance:": "ยอดคงเหลือในบัญชี:", "Only_numbers,_space,_and_hyphen_are_allowed_": "ตัวเลข ช่องว่าง และเครื่องหมายขีดกลางเท่านั้นที่อนุญาต", "Portfolio": "พอร์ตโฟลิโอ", "Your_transaction_reference_number_is_[_1]": "หมายเลขอ้างอิงของธุรกรรมของท่าน คือ [_1]", "Final_price": "ราคาสุดท้าย", "Sa": "ส", "Equals": "เท่ากับ", "Sell_time": "เวลาที่ขาย", "Profit": "กำไร", "Year": "ปี", "day": "วัน", "Only_letters,_numbers,_and_hyphen_are_allowed_": "ตัวอักษร ตัวเลข และเครื่องหมายขีดกลางเท่านั้นที่อนุญาต", "Update": "การปรับปรุง", "Hour": "ชั่วโมง", "Sunday": "วันอาทิตย์", "Old_password_is_wrong_": "รหัสผ่านเก่าไม่ถูกต้อง", "This_contract_lost": "สัญญานี้ขาดทุน", "Goes_Outside": "ออกนอกขอบเขต", "Cashier": "แคชเชียร์", "Duration": "ระยะเวลา", "Contract_is_not_started_yet": "สัญญายังไม่เริ่ม", "Contract_Information": "ข้อมูลสัญญา", "Real_Volatility": "ความผันผวนจริง", "Your_settings_have_been_updated_successfully_": "การตั้งค่าของท่านถูกดำเนินการเรียบร้อยแล้ว", "Revoke_access": "การเพิกถอนการเข้าถึง", "Exclude_time_cannot_be_less_than_6_months_": "เวลาพักไม่น้อยกว่า 6 เดือน", "Are_you_sure_that_you_want_to_permanently_revoke_access_to_application": "ท่านแน่ใจใช่ไหมที่จะยกเลิกการเข้าใช้ระบบถาวร", "Real_Account": "บัญชีจริง", "Over/Under": "สูงกว่า/ต่ำกว่า", "Please_input_a_valid_date": "โปรดป้อนวันที่ที่ถูกต้อง", "Note": "บันทึก", "mins": "นาที", "Your_account_is_restricted__Kindly_[_1]contact_customer_support[_2]_for_assistance_": "บัญชีของท่านถูกระงับ โปรด [_1]ติดต่อฝ่ายลูกค้าสัมพันธ์[_2] เพื่อดำเนินการต่อไป", "Please_<a_href=\"[_1]\">log_in</a>_to_view_this_page_": "โปรด <a href=\"[_1]\">เข้าสู่ระบบ</a> เพื่อเรียกดูหน้านี้", "Payments": "การชำระเงิน", "Payout": "การชำระเงิน", "Browser": "เบราเซอร์", "You_did_not_change_anything_": "ท่านไม่ได้แก้ไขค่าใดๆ", "Adjust_trade_parameters": "ปรับแต่งตัวแปรของการเทรด", "Barrier_Change": "ค่า Barrier เปลี่ยนแปลง", "email_address": "อีเมล์", "View": "ดู", "You_have_reached_the_rate_limit_of_requests_per_second__Please_try_later_": "ท่านได้ใช้อัตราการส่งคำสั่งต่อวินาทีเกินที่กำหนด กรุณาลองใหม่ภายหลัง", "The_email_address_provided_is_already_in_use__If_you_forgot_your_password,_please_try_our_<a_href=\"[_1]\">password_recovery_tool</a>_or_contact_our_customer_service_": "อีเมล์ของท่านถูกลงทะเบียนไว้กับผู้ใช้งานอีกบัญชีหนึ่ง หากท่านลืมรหัสผ่านของบัญชีที่ท่านมีอยู่ โปรด <a href=\"[_1]\">เรียกใช้การกู้คืนรหัสผ่าน</a> หรือ ติดต่อเจ้าหน้าที่บริการลูกค้า", "Resources": "แหล่งข้อมูล", "Su": "อา", "[_1]_days_[_2]_hours_[_3]_minutes": "[_1] วัน [_2] ชั่วโมง [_3] นาที", "Please_select_a_payment_agent": "โปรดระบุตัวแทนรับชำระเงิน", "August": "สิงหาคม", "[_1]_deposit_from_[_2]_to_account_number_[_3]_is_done__Transaction_ID:_[_4]": "[_1] ได้ฝากเงินจาก [_2] ไปยังเลขที่บัญชี [_3] เรียบร้อยแล้ว หมายเลขอ้างอิงธุรกรรม: [_4]", "Upgrade_to_a_Financial_Account": "อัพเกรดเป็นบัญชีทางการเงิน", "letters": "ตัวอักษร", "months": "เดือน", "Current": "ปัจจุบัน", "Sorry,_your_account_is_not_authorised_for_any_further_contract_purchases_": "ขออภัย บัญชีของท่านไม่ได้รับอนุญาตในการซื้อสัญญาเพิ่ม", "Upcoming_Events": "กิจกรรมในอนาคต", "Please_[_1]accept_the_updated_Terms_and_Conditions[_2]_to_lift_your_withdrawal_and_trading_limits_": "โปรด [_1]ยอมรับข้อตกลงและเงื่อนไข[_2] เพื่อเพิ่มวงเงินการซื้อขายและการถอนเงินของท่าน", "Payment_Agent": "ตัวแทนรับชำระเงิน", "Your_trading_statistics_since_[_1]_": "สถิติการซื้อขายของท่านตั้งแต่ [_1]", "Are_you_sure_that_you_want_to_permanently_delete_token": "ท่านแน่ใจใช่ไหมที่จะลบโทเค่นถาวร", "Only_[_1]_decimal_points_are_allowed_": "ทศนิยม [_1] หลัก เท่านั้น", "Contract_ID": "หมายเลขสัญญา", "Total_Cost": "ราคารวม", "today,_Fridays": "วันนี้วันศุกร์", "Buy_price": "ราคาซื้อ", "February": "กุมภาพันธ์", "Please_submit_a_valid_verification_token_": "โปรดส่งโทเค่นที่ถูกต้องเพื่อการตรวจสอบ", "Statement": "รายงานทางการเงิน", "Waiting_for_exit_tick_": "กำลังรอช่วงราคาสุดท้าย", "[_1]_Please_click_the_link_below_to_restart_the_password_recovery_process__If_you_require_further_assistance,_please_contact_our_Customer_Support_": "[_1] โปรดคลิกที่ลิงค์ด้านล่างเพื่อเริ่มกระบวนการกู้คืนรหัสผ่าน หากท่านต้องการความช่วยเหลือ โปรดติดต่อฝ่ายบริการลูกค้าของเรา", "details": "รายละเอียด", "Contract_Expiry": "วันหมดอายุสัญญา", "Insufficient_balance_": "ยอดคงเหลือไม่เพียงพอ", "Details": "รายละเอียด", "Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_": "คำสั่งของท่านในการโอน [_1] [_2] จาก [_3] ไป [_4] ได้ดำเนินการสำเร็จแล้ว", "Unlock_Cashier": "ปลดล็อกแคชเชียร์", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_": "การรับ/ชำระเงินของท่านถูกล็อกตามความประสงค์ของท่าน - หากประสงค์ปลดล็อก โปรดป้อนรหัสผ่าน", "Your_Application_is_Being_Processed_": "ใบสมัครของท่านอยู่ในกระบวนการพิจารณา", "Higher/Lower": "สูงกว่า/ต่ำกว่า", "Questions": "คำถาม", "Potential_Payout": "ประมาณการจำนวนเงินที่ชำระ", "Please_select_at_least_one_scope": "โปรดระบุค่าอย่างน้อยหนึ่งขอบเขต", "Spot_Time": "เวลาสปอต", "Market_is_closed__Please_try_again_later_": "ตลาดได้ปิดทำการแล้ว กรุณาทำรายการใหม่ภายหลัง", "Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_": "บัญชีของท่านได้รับการยืนยันตัวตนอย่างสมบูรณ์แล้ว และวงเงินการถอนเงินของท่านได้รับการยกระดับโดยการเพิ่มวงเงินแล้ว", "Stake": "วางเงิน", "There_was_a_problem_accessing_the_server_during_purchase_": "มีปัญหาเกิดขึ้นในการเข้าถึงเซิร์ฟเวอร์ขณะส่งคำสั่งซื้อ", "Exit_Spot": "สปอตสิ้นสุด", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "ดังนั้น วงเงินการถอนมากที่สุดของท่านขณะนี้ (หากบัญชีท่านมีวงเงินเพียงพอ) คือ [_1] [_2] (หรือเทียบเท่าในสกุลเงินอื่น)", "Action": "การกระทำ", "Now": "ขณะนี้", "There_was_a_problem_accessing_the_server_": "มีปัญหาในการเข้าถึงเครื่องแม่ข่าย", "today": "วันนี้", "Asset_Index": "ดัชนีสินทรัพย์", "Finish": "เสร็จสิ้น", "Ref_": "อ้างอิง", "Select_your_underlying_asset": "กำหนด ผลิตภัณฑ์อ้างอิงของท่าน", "End_Time": "เวลาสิ้นสุด", "Description": "รายละเอียด", "Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_": "โปรดป้อนข้อมูลในรูปแบบ ตัวเลข 3 หลัก ขีดกลาง และตามด้วย ตัวเลข 4 หลักสุดท้าย", "Ends_Outside": "สิ้นสุดภายนอก", "Target": "เป้าหมาย", "Connection_error:_Please_check_your_internet_connection_": "การเชื่อมต่อมีความผิดพลาด: โปรดตรวจสอบการเชื่อมต่ออินเทอร์เน็ตของท่าน", "Investor_password": "รหัสผ่านของผู้ลงทุน", "The_Payment_Agent_facility_is_currently_not_available_in_your_country_": "ขณะนี้ไม่มีบริการตัวแทนรับชำระเงินในประเทศของท่าน", "Low_Barrier": "Barrier ต่ำ", "Your_transaction_reference_is": "เลขที่อ้างอิงของธุรกรรมของท่าน คือ", "Month": "เดือน", "Name": "ชื่อ", "Verification_code_format_incorrect_": "รูปแบบของรหัสตรวจสอบไม่ถูกต้อง", "second": "วินาที", "November": "พฤศจิกายน", "Sell": "ขาย", "days": "วัน", "Only_[_1]_are_allowed_": "มีเพียง [_1] ที่จัดให้", "Male": "เพศชาย", "Upgrade_to_a_Real_Account": "อัพเกรดเป็นบัญชีจริง", "Deposits_and_withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "ท่านไม่ได้รับอนุญาตในการดำเนินการฝากเงินและการถอนเงินในบัญชีของท่านในขณะนี้ โปรดติดต่อ [_1] เพื่อปลดล็อค", "Wednesday": "วันพุธ", "Buy": "ซื้อ", "Day": "วัน", "Please_enter_a_number_between_[_1]_": "โปรดป้อนตัวเลขระหว่าง [_1]", "h": "ชม.", "Trading_Times": "เวลาซื้อขาย", "An_additional_password_can_be_used_to_restrict_access_to_the_cashier_": "รหัสผ่านเพิ่มนี้สามารถใช้เพื่อเข้าถึงส่วนของแคชเชียร์", "Permissions": "สิทธิ์", "Loss": "เสีย", "Create_Account": "สร้างบัญชี", "Your_account_is_currently_suspended__Only_withdrawals_are_now_permitted__For_further_information,_please_contact_[_1]_": "ในขณะนี้บัญชีของท่านถูกพักชั่วคราว ท่านสามารถทำรายการถอนได้เท่านั้น หากต้องการข้อมูล โปรดติดต่อ [_1]", "Time_out_must_be_after_today_": "ช่วงเวลาอ้างอิงต้องเริ่มในวันพรุ่งนี้", "Read": "อ่าน", "Sale_Price": "ราคาขาย", "Should_be_between_[_1]_and_[_2]": "ต้องมีค่าระหว่าง [_1] และ [_2]", "The_maximum_number_of_tokens_([_1])_has_been_reached_": "จำนวนมากที่สุดของโทเค่น ([_1]) ถูกใช้หมดแล้ว", "Contract_Sold": "สัญญาที่ถูกจำหน่าย", "Investment_Account": "บัญชีเพื่อการลงทุน", "Explanation": "คำอธิบาย", "Password_is_not_strong_enough_": "รหัสผ่านไม่ปลอดภัยเท่าที่ควร", "Shop": "ร้าน", "Number_of_ticks": "จำนวนของช่วงราคา", "Your_token_has_expired__Please_click_<a_href=\"[_1]\">here</a>_to_restart_the_verification_process_": "โทเค่นของท่านหมดอายุแล้ว โปรดคลิก<a href=\"[_1]\">ที่นี่</a> เพื่อดำเนินกระบวนการตรวจสอบ", "Tuesday": "วันอังคาร", "Not": "ไม่", "This_field_is_required_": "ข้อมูลในช่องนี้จำเป็นต้องมี", "Current_Time": "เวลาปัจจุบัน:", "Open_a_Financial_Account": "เปิดบัญชีทางการเงิน 1 บัญชี", "Price": "ราคา", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_": "ท่านได้ถอน [_1] [_2] หรือเทียบเท่า ในช่วง [_3] วันที่ผ่านมา", "Even/Odd": "คู่/คี่", "Your_session_duration_limit_will_end_in_[_1]_seconds_": "เวลาการซื้อขายของท่านจะสิ้นสุดภายใน [_1] วินาที", "Please_complete_the_[_1]financial_assessment_form[_2]_to_lift_your_withdrawal_and_trading_limits_": "โปรดบันทึกผล [_1]แบบฟอร์มการประเมินทางการเงิน[_2] เพื่อเพิ่มวงเงินการซื้อขายและการถอนเงินของท่าน", "Higher": "สูงกว่า", "Only_numbers_and_spaces_are_allowed_": "ตัวเลข และช่องว่างเท่านั้นที่อนุญาต", "Contract": "สัญญา", "All_barriers_in_this_trading_window_are_expired": "รายการ Barrier ทั้งหมดในหน้าต่างซื้อขายนี้หมดอายุ", "Purchase_Price": "ราคาซื้อ", "Sell_at_market": "ขาย ณ ตลาด", "End_time_must_be_after_start_time_": "เวลาสิ้นสุดต้องเป็นเวลาภายหลังเวลาเริ่มต้น", "Walkthrough_Guide": "คู่มือแนะนำการใช้งาน", "year": "ปี", "Sorry,_you_have_entered_an_incorrect_cashier_password": "ขออภัยค่ะ ท่านป้อนรหัสผ่านแคชเชียร์ไม่ถูกต้อง", "AM": "น.", "Credit/Debit": "เครดิต/เดบิต", "Minimum_of_[_1]_characters_required_": "จำนวนตัวอักขระน้อยที่สุดที่ต้องการ คือ [_1]", "logout": "ออกจากระบบ", "Successful": "เรียบร้อยแล้ว", "Friday": "วันศุกร์", "Change_Password": "เปลี่ยนรหัสผ่าน" };
	texts_json['VI'] = { "Dec": "Tháng 12", "Closes_early_(at_21:00)": "Kết thúc sớm (lúc 21:00)", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_": "Bạn đã rút số tiền tương đương [_1] [_2].", "Sep": "Tháng Chín", "month": "tháng", "hour": "giờ", "Last_Digit_Stats": "Dữ liệu Chữ số Cuối cùng", "Demo": "Thử nghiệm", "Touches": "Chạm", "Should_be_a_valid_number": "Nên là một số hợp lệ", "Settles": "Quyết toán", "Oct": "Tháng Mười", "Exit_spot": "Giá giao ngay thoát ra", "Profit/Loss": "Lợi nhuận/Thua lỗ", "Main_password": "Mật khẩu chính", "Session_duration_limit_cannot_be_more_than_6_weeks_": "Giới hạn thời hạn phiên không thể nhiều hơn 6 tuần.", "min": "tối thiểu", "End_time": "Thời gian Kết thúc", "hours": "giờ", "Resale_not_offered": "Bán lại không được cho phép", "minutes": "phút", "Should_be_less_than_[_1]": "Nên là ít hơn so với [_1]", "Low_Barrier_([_1])": "Rào cản Thấp ([_1])", "seconds": "giây", "Remaining_time": "Thời gian còn lại", "Withdraw": "Rút tiền", "High_Barrier_([_1])": "Rào cản Cao ([_1])", "Score": "Điểm số", "True": "Đúng", "Opens": "Mở", "Female": "Nữ", "Current_password": "Mật khẩu hiện tại", "Tick": "Giây", "weeks": "tuần", "Only_letters,_numbers,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Chỉ chữ cái, số, khoảng trắng, dấu gạch nối, dấu chấm, và dấu gạch ngang được cho phép.", "Delete": "Xóa", "Lock_Cashier": "Khóa quầy Thu ngân", "Balance": "Số dư tài khoản", "verification_token": "chuỗi số xác minh", "minute": "phút", "July": "Tháng Bảy", "[_1]_withdrawal_from_account_number_[_2]_to_[_3]_is_done__Transaction_ID:_[_4]": "% 1 rút khỏi số tài khoản% 2 đến% 3 được thực hiện. ID giao dịch:% 4", "September": "Tháng Chín", "High_Barrier": "Rào cản Cao", "Asset": "Tài sản", "Indicative": "Chỉ thị", "Minute": "Phút", "Reference_ID": "Tài khoản tham khảo", "In/Out": "Trong/Ngoài", "Predict_the_direction<br_/>and_purchase": "Dự đoán khuynh hướng<br />và trả giá", "Your_account_has_no_trading_activity_": "Không có hoạt động giao dịch nào trên tài khoản của bạn.", "New_token_created_": "Token mới đã được tạo.", "Remaining_Time": "Thời gian còn lại", "Your_token_has_expired__Please_click_[_1]here[_2]_to_restart_the_verification_process_": "Chuỗi xác nhận của bạn đã hết hiệu lực. Xin vui lòng nhấp chuột vào [_1]đây[_2] để khởi động lại quá trình xác minh.", "Please_select_a_value": "Vui lòng chọn một giá trị", "Waiting_for_entry_tick_": "Vui lòng đợi cho đến phiên gia nhập.", "numbers": "các số", "When_you_click_\"OK\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_": "Khi bạn nhấp vào \"OK\" bạn sẽ bị loại bỏ khỏi giao dịch trên trang web tới ngày được chọn.", "Withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Rút tiền tại tài khoản của bạn không được phép tại thời điểm này. Xin vui lòng liên hệ với [_1] để mở khóa.", "Please_enter_an_integer_value": "Vui lòng nhập giá trị số nguyên", "Entry_Spot": "Giá khởi điểm", "This_contract_won": "Hợp đồng này đã thắng", "Trade": "Giao dịch", "Your_withdrawal_limit_is_[_1]_[_2]_": "Giới hạn rút tiền của bạn là [_1] [_2].", "Time_is_in_the_wrong_format_": "Thời gian ở sai định dạng.", "This_is_a_staging_server_-_For_testing_purposes_only": "Đây là một máy chủ dàn dựng - chỉ cho mục đích chỉ thử nghiệm", "Ends_Between": "Kết thúc giữa", "You_need_to_finish_all_20_questions_": "Bạn phải hoàn thành toàn bộ 20 câu hỏi.", "You_have_already_withdrawn_[_1]_[_2]_": "Bạn vừa rút [_1] [_2].", "Thursday": "Thứ Năm", "Please_select_a_valid_time_": "Vui lòng chọn một thời gian hợp lệ.", "Stays_Between": "Nằm giữa", "Lower": "Thấp hơn", "week": "tuần", "Previous": "Trước", "Chart": "Biểu đồ", "Jan": "Tháng Một", "Jul": "Tháng Bảy", "Virtual_money_credit_to_account": "Tín dụng tiền ảo cho tài khoản", "from_[_1]_to_[_2]": "từ [_1] đến [_2]", "Start_time": "Thời gian bắt đầu", "Fr": "Thứ 6", "Select_market": "Chọn thị trường", "[_1]_[_2]_payout_if_[_3]_ends_on_or_between_low_and_high_values_of_Barrier_at_close_on_[_4]_": "[_1] [_2] thanh toán nếu [_3] kết thúc vào hoặc giữa cao và thấp giá trị của các rào cản lúc đóng trên [_4].", "Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_": "Hạn mức rút tiền ngày [_1] của bạn hiện là [_2] [_3] (hoặc tương đương với đồng tiền khác).", "Apr": "Tháng 4", "Your_account_has_no_Login/Logout_activity_": "Không có hoạt động Đăng nhập/Đăng xuất nào trên tài khoản của bạn.", "Nov": "Tháng Mười một", "Charting_for_this_underlying_is_delayed": "Biểu đồ cho tài sản cơ sở này bị hoãn", "Fridays": "Thứ Sáu", "Entry_spot": "Giá khởi điểm", "The_main_password_of_account_number_[_1]_has_been_changed_": "Mật khẩu chính của tài khoản số [_1] đã bị thay đổi.", "years": "năm", "The_two_passwords_that_you_entered_do_not_match_": "Hai mật khẩu bạn vừa nhập không khớp với nhau.", "Deposit": "Gửi tiền", "Token": "Mã Token", "Gaming_Account": "Tài khoản Cá cược", "Invalid_amount,_minimum_is": "Số tiền không hợp lệ, tối thiểu là", "There_was_an_error": "Đã có lỗi xảy ra", "Total_Profit/Loss": "Tổng Lợi nhuận/Thua lỗ", "The_server_<a_href=\"[_1]\">endpoint</a>_is:_[_2]": "Máy chủ <a href=\"[_1]\">điểm cuối</a> là: [_2]", "Net_profit": "Lợi nhuận thuần", "Exclude_time_cannot_be_for_more_than_5_years_": "Thời gian loại trừ không thể nhiều hơn 5 năm.", "Sorry,_this_feature_is_available_to_virtual_accounts_only_": "Rất tiếc, tính năng này chỉ khả dụng với tài khoản tiền ảo.", "Never_Used": "Chưa bao giờ Sử dụng", "Today": "Hôm nay", "Weekday": "Ngày trong tuần", "Select_your_market": "Chọn thị trường của bạn", "Please_select": "Vui lòng chọn", "Last_Used": "Lần sử dụng cuối cùng", "[_1]_[_2]_payout_if_[_3]_ends_outside_low_and_high_values_of_Barrier_at_close_on_[_4]_": "[_1] [_2] thanh toán nếu [_3] kết thúc bên ngoài thấp và cao giá trị của các hàng rào tại đóng trên [_4].", "New_Year's_Day": "Ngày của năm mới", "Real_Cent": "Xu thật", "Date": "Ngày", "Open": "Mở", "You_have_sold_this_contract_at_[_1]_[_2]": "Bạn đã bán hợp đồng này với mức [_1] [_2]", "Major_Pairs": "Cặp tiền tệ chính", "Never": "Chưa bao giờ", "[_1]_[_2]_payout_if_[_3]_stays_between_low_and_high_values_of_Barrier_through_close_on_[_4]_": "[_1] [_2] thanh toán nếu [_3] vẫn giữa cao và thấp giá trị của các rào cản thông qua gần với [_4].", "{JAPAN_ONLY}Please_complete_the_following_questions_": "{CHỈ DÀNH CHO THỊ TRƯỜNG NHẬT BẢN}Vui lòng hoàn thành những câu hỏi sau đây.", "Failed": "Thất bại", "Sorry,_an_error_occurred_while_processing_your_request_": "Rất tiếc, đã xảy ra lỗi khi đang xử lý yêu cầu của bạn.", "Saturday": "Thứ Bảy", "Exit_Spot_Time": "Giá Giao ngay Thoát ra", "Select_your_trade_type": "Chọn loại giao dịch của bạn", "Time_out_cannot_be_more_than_6_weeks_": "Thời hạn kết thúc không thể lớn hơn 6 tuần.", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_click_<a_href=\"[_1]\">here</a>_": "Quỹ đã bị khóa theo yêu cầu của bạn - để mở khóa, vui lòng nhấn <a href=\"[_1]\">vào đây </a>.", "Transaction_performed_by_[_1]_(App_ID:_[_2])": "Giao dịch thực hiện bởi [_1] (ID ứng dụng: [_2])", "Date_and_Time": "Ngày và Thời gian", "This_feature_is_not_relevant_to_virtual-money_accounts_": "Đặc điểm này không liên quan tới tài khoản tiền ảo.", "Your_changes_have_been_updated_": "Những thay đổi của bạn đã được cập nhật.", "New_password": "Mật khẩu mới", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_": "Vì vậy khoản tiền rút tối đa hiện giờ của bạn (nói tới tài khoản đang có tiền được rút) là [_1] [_2].", "Sorry,_account_signup_is_not_available_in_your_country__Please_contact_<a_href=\"[_1]\">customer_support</a>_for_more_information_": "Xin lỗi, tài khoản đăng ký là không có sẵn ở quốc gia của bạn. Xin vui lòng liên hệ với <a href=\"[_1]\"> hỗ trợ khách hàng</a> để biết thêm thông tin.", "Rise/Fall": "Tăng/Giảm", "Return": "Lợi nhuận", "Admin": "Quản trị viên", "Invalid_amount,_maximum_is": "Số tiền không hợp lệ, tối đa là", "[_1]_[_2]_payout_if_[_3]_is_strictly_lower_than_Barrier_at_close_on_[_4]_": "[_1] [_2] thanh toán nếu [_3] là nghiêm thấp hơn so với các rào cản lúc gần với [_4].", "All_markets_are_closed_now__Please_try_again_later_": "Tất cả các thị trường đều đã đóng cửa. Vui lòng thử lại sau.", "Does_Not_Touch": "Không được chạm", "Real_STP": "STP thực", "Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_": "Mật khẩu của bạn đã được thiết lập lại thành công. Vui lòng dùng mật khẩu mới đăng nhập vào tài khoản của bạn.", "Please_check_the_above_form_for_pending_errors_": "Vui lòng kiểm tra các mục nêu trên cho những lỗi đang chờ xử lý.", "Christmas_Day": "Lễ Giáng Sinh", "Amount": "Số tiền", "Up/Down": "Lên/Xuống", "Next": "Tiếp theo", "March": "Tháng Ba", "Invalid_email_address": "Địa chỉ email không hợp lệ", "[_1]_[_2]_payout_if_[_3]_goes_outside_of_low_and_high_values_of_Barrier_through_close_on_[_4]_": "[_1] [_2] thanh toán nếu [_3] đi bên ngoài thấp và cao các giá trị của các rào cản thông qua gần với [_4].", "{JAPAN_ONLY}Knowledge_Test_Result": "{CHỈ DÀNH CHO THỊ TRƯỜNG NHẬT BẢN}Kết quả Bài Kiểm tra Kiến thức", "Should_be_more_than_[_1]": "Nên là nhiều hơn so với [_1]", "You_have_not_granted_access_to_any_applications_": "Bạn không được phép truy cập bất kỳ một ứng dụng nào.", "Please_[_1]complete_your_account_profile[_2]_to_lift_your_withdrawal_and_trading_limits_": "Xin [_1] vui lòng hoàn thành hồ sơ tài khoản [_2] của bạn để nâng mức rút tiền và các giới hạn giao dịch.", "[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]": "[_1] [_2] vừa được cộng thêm vào tài khoản tiền Ảo [_3] của bạn", "Potential_Profit": "Lợi nhuận Tiềm năng", "Congratulations!_Your_[_1]_Account_has_been_created_": "Xin chúc mừng! Tài khoản [_1] của bạn đã được tạo.", "You_should_enter_[_1]_characters_": "Bạn nên nhập vào [_1] ký tự.", "Your_changes_have_been_updated_successfully_": "Các thay đổi của bạn đã được cập nhật thành công.", "Please_select_a_valid_date_": "Vui lòng chọn một ngày hợp lệ.", "Time_out_cannot_be_in_the_past_": "Thời hạn kết thúc không thể tồn tại trong quá khứ.", "Mar": "Tháng Ba", "Matches/Differs": "Phù hợp/Khác", "Feb": "Tháng Hai", "[_1]_[_2]_payout_if_[_3]_does_not_touch_Barrier_through_close_on_[_4]_": "[_1] [_2] thanh toán nếu [_3] không chạm vào các rào cản thông qua đóng trên [_4].", "Closes": "Kết thúc", "[_1]_and_[_2]_cannot_be_the_same_": "[_1] và [_2] không thể giống nhau.", "Please_accept_the_terms_and_conditions_": "Xin vui lòng chấp nhận các điều khoản và điều kiện.", "December": "Tháng 12", "Contract_Confirmation": "Xác nhận Hợp đồng", "Only_letters,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "Chỉ chữ cái, khoảng trống, dấu nối, thời gian và dấu nháy đơn được cho phép.", "Forex": "Thị trường ngoại hối", "Please_log_in_": "Vui lòng đăng nhập.", "January": "Tháng Một", "Closed": "Đã đóng", "Real_Standard": "Tiêu chuẩn thực", "Please_select_the_checkbox_": "Vui lòng chọn hộp tích.", "October": "Tháng Mười", "space": "khoảng cách", "Japan": "Nhật Bản", "Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Giới hạn rút tiền của bạn là [_1] [_2] (hoặc tương đương với đồng tiền khác).", "Processing_your_request___": "Đang xử lý yêu cầu của bạn...", "False": "Sai", "June": "Tháng Sáu", "Closes_early_(at_18:00)": "Kết thúc sớm (tại 18:00)", "Jun": "Tháng Sáu", "Aug": "Tháng 8", "[_1]_[_2]_payout_if_[_3]_is_strictly_higher_than_or_equal_to_Barrier_at_close_on_[_4]_": "[_1] [_2] thanh toán nếu [_3] là nghiêm chỉnh cao hơn hoặc bằng hàng rào tại gần với [_4].", "April": "Tháng 4", "Profit_Table": "Bảng Lợi nhuận", "Ends_In/Out": "Kết thúc Trong/Ngoài", "Sorry,_an_error_occurred_while_processing_your_account_": "Xin lỗi, Lỗi xảy ra trong khi đang xử lý tài khoản của bạn.", "Password_should_have_lower_and_uppercase_letters_with_numbers_": "Mật khẩu nên bao gồm cả chữ hoa, chữ thường và con số.", "Barrier": "Rào cản", "Purchase_Time": "Thời gian Mua", "May": "Tháng Năm", "Sale_Date": "Ngày Bán hàng", "Please_complete_the_[_1]financial_assessment_form[_2]_to_lift_your_withdrawal_and_trading_limits_": "Xin vui lòng hoàn tất mẫu đánh giá tài chính [_1] [_2] để nâng rút tiền của bạn và kinh doanh các giới hạn.", "Your_session_duration_limit_will_end_in_[_1]_seconds_": "Giới hạn phiên giao dịch của bạn sẽ kết thúc trong [_1] giây nữa.", "Even/Odd": "Hòa vốn/ Số dư", "Price": "Giá", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_": "Bạn đã rút số tiền tương đương với [_1] [_2] trong tổng số hơn [_3] ngày qua.", "Open_a_Financial_Account": "Mở một Tài khoản Tài chính", "Current_Time": "Thời gian hiện tại", "year": "năm", "Walkthrough_Guide": "Hướng dẫn tổng quan", "End_time_must_be_after_start_time_": "Thời gian kết thúc phải sau thời gian bắt đầu.", "Sell_at_market": "Bán tại thị trường", "Purchase_Price": "Giá Mua", "All_barriers_in_this_trading_window_are_expired": "Tất cả các rào cản trong cửa sổ giao dịch này đã hết hạn", "Contract": "Hợp đồng", "Higher": "Cao hơn", "Only_numbers_and_spaces_are_allowed_": "Chỉ số và khoảng trắng là được phép.", "Minimum_of_[_1]_characters_required_": "Tối thiểu [_1] các kí tự cần thiết.", "Credit/Debit": "Tín dụng/Ghi nợ", "Sorry,_you_have_entered_an_incorrect_cashier_password": "Xin lỗi, bạn đã nhập sai mật khẩu thu ngân", "Change_Password": "Thay đổi Mật khẩu", "Friday": "Thứ Sáu", "Successful": "Thành công", "Short": "Ngắn", "An_additional_password_can_be_used_to_restrict_access_to_the_cashier_": "Mật khẩu phụ có thể dùng để hạn chế truy cập vào khu thu ngân.", "Trading_Times": "Thời gian Giao dịch", "Please_enter_a_number_between_[_1]_": "Vui lòng nhập một số giữa [_1].", "Buy": "Mua", "Wednesday": "Thứ Tư", "Day": "Ngày", "Sale_Price": "Giá Bán hàng", "Read": "Đọc", "Time_out_must_be_after_today_": "Thời hạn kết thúc phải sau hôm nay.", "Your_account_is_currently_suspended__Only_withdrawals_are_now_permitted__For_further_information,_please_contact_[_1]_": "Tài khoản của bạn hiện đang bị khóa. Chỉ tính năng rút tiền được cho phép. Để biết thêm chi tiết, xin vui lòng liên hệ với [_1].", "Create_Account": "Tạo Tài khoản", "Loss": "Thất thoát", "Permissions": "Quyền hạn", "Password_is_not_strong_enough_": "Mật khẩu không đủ mạnh.", "Investment_Account": "Tài khoản Đầu tư", "Contract_Sold": "Hợp đồng đã được bán", "Explanation": "Giải thích", "The_maximum_number_of_tokens_([_1])_has_been_reached_": "Đã đạt đến độ dài tối đa của mã token ([_1]).", "Should_be_between_[_1]_and_[_2]": "Nên ở giữa [_1] và [_2]", "This_field_is_required_": "Lĩnh vực này được yêu cầu.", "Not": "Không", "Touch/No_Touch": "Chạm/Không Chạm", "Tuesday": "Thứ Ba", "Number_of_ticks": "Số điểm", "Your_token_has_expired__Please_click_<a_href=\"[_1]\">here</a>_to_restart_the_verification_process_": "Chuỗi xác nhận của bạn đã hết hiệu lực. Xin vui lòng nhấp chuột vào <a chref=\"[_1]\">đây</a> để khởi động lại quá trình xác minh.", "Shop": "Cửa hàng", "Select_your_underlying_asset": "Chọn tài sản cơ sở của bạn", "Ref_": "Tham khảo.", "{JAPAN_ONLY}Your_Application_has_Been_Processed__Please_Re-Login_to_Access_Your_Real-Money_Account_": "{CHỈ ĐỐI VỚI NHẬT BẢN} Ứng dụng của bạn đã xử lý. Xin vui lòng đăng nhập lại để truy cập vào tài khoản tiền thực của bạn.", "Finish": "Kết thúc", "Asset_Index": "Chỉ số tài sản", "The_Payment_Agent_facility_is_currently_not_available_in_your_country_": "Các cơ sở đại lý thanh toán hiện không có trong đất nước của bạn.", "Investor_password": "Mật khẩu của nhà đầu tư", "Connection_error:_Please_check_your_internet_connection_": "Lỗi kết nối: xin vui lòng kiểm tra kết nối internet của bạn.", "Target": "Mục tiêu", "Description": "Mô tả", "Ends_Outside": "Kết thúc bên ngoài", "Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_": "Vui lòng tuân theo cấu trúc 3 số, dấu gạch ngang, tiếp theo là 4 số.", "End_Time": "Thời gian Kết thúc", "November": "Tháng Mười một", "second": "giây", "Name": "Tên", "Verification_code_format_incorrect_": "Định dạng của mã xác thực không chính xác.", "Low_Barrier": "Rào cản Thấp", "Your_transaction_reference_is": "Tham chiếu giao dịch của bạn là", "Month": "Tháng", "Upgrade_to_a_Real_Account": "Nâng cấp lên Tài khoản Thực", "Deposits_and_withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "Chức năng gửi tiền và rút tiền tại tài khoản của bạn không được phép tại thời điểm này. Xin vui lòng liên hệ với [_1] để mở khóa.", "Only_[_1]_are_allowed_": "Chỉ có [_1] được cho phép.", "days": "ngày", "Sell": "Bán", "Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_": "Yêu cầu chuyển [_1] [_2] từ [_3] sang [_4] đã được xử lý thành công.", "Insufficient_balance_": "Số dư tài khoản không đủ.", "Details": "Chi tiết", "Contract_Expiry": "Hợp đồng đã hết hạn", "details": "chi tiết", "[_1]_Please_click_the_link_below_to_restart_the_password_recovery_process__If_you_require_further_assistance,_please_contact_our_Customer_Support_": "[_1] Vui lòng nhấn vào đường dẫn dưới đây để bắt đầu lại quá trình khôi phục mật khẩu. Nếu bạn cần thêm trợ giúp, vui lòng liên hệ với Trung tâm hỗ trợ khách hàng của chúng tôi.", "Waiting_for_exit_tick_": "Vui lòng đợi cho dấu tích thoát.", "Statement": "Tuyên bố", "Questions": "Câu hỏi", "Higher/Lower": "Cao hơn/Thấp hơn", "Your_Application_is_Being_Processed_": "Ứng dụng của bạn đang được xử lý.", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_": "Quỹ đã được khóa theo yêu cầu của bạn - để mở khóa, vui lòng điền mật khẩu.", "Unlock_Cashier": "Mở khóa Thu ngân", "Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_": "Tài khoản của bạn được xác thực đầy đủ và mức giới hạn rút tiền của bạn đã được nâng lên.", "Market_is_closed__Please_try_again_later_": "Thị trường đã đóng cửa. Vui lòng thử lại sau.", "Spot_Time": "Thời điểm làm giá", "Please_select_at_least_one_scope": "Vui lòng chọn ít nhất một phạm vi", "Potential_Payout": "Tiền thưởng Tiềm năng", "There_was_a_problem_accessing_the_server_": "Có lỗi khi truy cập máy chủ.", "Barrier_([_1])": "Rào cản ([_1])", "today": "hôm nay", "Now": "Bây giờ", "Action": "Hành động", "There_was_a_problem_accessing_the_server_during_purchase_": "Có lỗi trung cập vào máy chủ khi mua.", "Exit_Spot": "Giá Giao ngay thoát ra", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "Vì vậy khoản tiền rút tối đa hiện giờ của bạn (tài khoản đang có tiền được rút) là [_1] [_2] (hoặc đồng tiền khác có giá trị tương đương).", "Stake": "Đơn vị vốn, cổ phiếu", "Payment_Agent": "Đại lý Thanh toán", "Please_[_1]accept_the_updated_Terms_and_Conditions[_2]_to_lift_your_withdrawal_and_trading_limits_": "Xin [_1] vui lòng chấp nhận cập nhật các điều khoản và điều kiện [_2] để nâng mức tiền rút và giới hạn giao dịch.", "Your_trading_statistics_since_[_1]_": "Số liệu thống kê giao dịch của bạn kể từ [_1].", "Are_you_sure_that_you_want_to_permanently_delete_token": "Bạn có chắc chắn muốn xóa vĩnh viễn token", "IP_Address": "Địa chỉ IP", "today,_Fridays": "hôm nay, Thứ Sáu", "Total_Cost": "Tổng Chi phí", "Contract_ID": "Mã Hợp đồng", "Only_[_1]_decimal_points_are_allowed_": "Chỉ cho phép [_1] số thập phân sau dấu phẩy.", "Please_submit_a_valid_verification_token_": "Vui lòng nhập một mã thông báo xác nhận hợp lệ.", "February": "Tháng Hai", "Buy_price": "Giá mua", "Your_account_is_restricted__Kindly_[_1]contact_customer_support[_2]_for_assistance_": "Tài khoản của bạn bị hạn chế. [_1] vui lòng liên hệ hỗ trợ khách hàng [_2] để được hỗ trợ.", "Note": "Chú ý", "mins": "phút", "Please_input_a_valid_date": "Vui lòng nhập ngày hợp lệ", "Over/Under": "Trên/Dưới", "You_have_reached_the_rate_limit_of_requests_per_second__Please_try_later_": "Bạn đã đạt đến giới hạn số lượng lệnh có thể mỗi giây. Xin vui lòng thử lại sau.", "View": "Xem", "email_address": "địa chỉ hòm thư", "Barrier_Change": "Giới hạn Thay đổi", "Adjust_trade_parameters": "Điều giới hạn giao dịch", "Browser": "Duyệt tìm", "Payout": "Tiền thưởng", "You_did_not_change_anything_": "Bạn chưa thay đổi bất cứ nội dung nào.", "Payments": "Thanh toán", "Please_<a_href=\"[_1]\">log_in</a>_to_view_this_page_": "Xin <a href=\"[_1]\"> vui lòng đăng nhập</a> để xem trang này.", "letters": "các ký tự", "Upgrade_to_a_Financial_Account": "Nâng cấp lên Tài khoản Tài chính", "[_1]_deposit_from_[_2]_to_account_number_[_3]_is_done__Transaction_ID:_[_4]": "tiền gửi [_1] từ [_2] đến tài khoản số [_3] được thực hiện. Giao dịch ID: [_4]", "August": "Tháng 8", "Please_select_a_payment_agent": "Vui lòng chọn một đại lý thanh toán", "[_1]_days_[_2]_hours_[_3]_minutes": "[_1] ngày [_2] giờ [_3] phút", "The_email_address_provided_is_already_in_use__If_you_forgot_your_password,_please_try_our_<a_href=\"[_1]\">password_recovery_tool</a>_or_contact_our_customer_service_": "Địa chỉ thư điện tử cung cấp đang được sử dụng. Nếu bạn quên mật khẩu của bạn, hãy thử <a href=\"[_1]\"> công cụ phục hồi mật khẩu của chúng tôi</a> hoặc liên hệ với dịch vụ khách hàng của chúng tôi.", "Resources": "Nguồn", "Upcoming_Events": "Sự kiện sắp diễn ra", "Current": "Tiền tệ", "Sorry,_your_account_is_not_authorised_for_any_further_contract_purchases_": "Xin lỗi, tài khoản của bạn không có quyền mua thêm hợp đồng.", "months": "tháng", "Duration": "Khoảng thời gian", "Cashier": "Thu ngân", "Goes_Outside": "Đi ra ngoài", "Old_password_is_wrong_": "Mật khẩu cũ không đúng.", "This_contract_lost": "Hợp đồng này đã bị lỗ", "Sunday": "Chủ nhật", "Contract_is_not_started_yet": "Hợp đồng chưa được bắt đầu", "Stays_In/Goes_Out": "Vẫn ở trong /Đi ra Ngoài", "Revoke_access": "Hủy bỏ truy cập", "Exclude_time_cannot_be_less_than_6_months_": "Thời gian loại trừ không thể ít hơn 6 tháng.", "Your_settings_have_been_updated_successfully_": "Thiết lập của bạn đã được cập nhật thành công.", "Real_Volatility": "Biến động thực", "Contract_Information": "Thông tin của Hợp đồng", "Real_Account": "Tài khoản Thực", "Are_you_sure_that_you_want_to_permanently_revoke_access_to_application": "Bạn có chắc chắn muốn thu hồi quyền truy cập vào ứng dụng vĩnh viễn", "Status": "Tình trạng", "[_1]_[_2]_payout_if_[_3]_touches_Barrier_through_close_on_[_4]_": "[_1] [_2] thanh toán nếu [_3] chạm hàng rào thông qua gần với [_4].", "Monday": "Thứ Hai", "Virtual_Account": "Tài khoản Ảo", "Start_Time": "Thời gian bắt đầu", "There_was_some_invalid_character_in_an_input_field_": "Có một vài ký tự không hợp lệ với dữ liệu nhập vào.", "Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_": "Yêu cầu rút tiền [_1] [_2] từ tài khoản [_3] của bạn và chuyển tới tài khoản Đại lý Thanh toán [_4] đã được xử lý thành công.", "This_symbol_is_not_active__Please_try_another_symbol_": "Biểu tượng này là không hoạt động. Hãy thử một biểu tượng khác.", "Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_": "Hợp đồng sẽ được bán ở giá thị trường hiện hành khi máy chủ nhận được yêu cầu. Giá này có thể khác với giá đã được chỉ định.", "Spot": "Giao ngay", "Step": "Bước", "We": "Chúng tôi", "Sorry,_this_feature_is_not_available_": "Xin lỗi, đặc tính này không có.", "Sell_time": "Thời gian Bán", "Equals": "Tương đương", "Final_price": "Giá cuối cùng", "Your_transaction_reference_number_is_[_1]": "Số tham chiếu giao dịch của bạn là [_1]", "Portfolio": "Hồ sơ", "Only_numbers,_space,_and_hyphen_are_allowed_": "Chỉ số, khoảng trắng và dấu nối là được phép.", "Account_balance:": "Số dư tài khoản:", "Hour": "Giờ", "Only_letters,_numbers,_and_hyphen_are_allowed_": "Chỉ các chữ cái, số và dấu nối là được phép.", "Update": "Cập nhật", "day": "ngày", "Year": "Năm", "Long": "Dài", "Profit": "Lợi nhuận" };
	texts_json['JA'] = { "Please_enter_an_integer_value": "半角で数値をご入力して下さい", "Mo": "月", "Withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "お客様の口座の出金手続きは現在許可されていません。解除するには[_1]までご連絡ください。", "When_you_click_\"OK\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_": "\"Ok\"をクリックすると、選択した日付までこのサイトでのトレードができなくなります。", "Your_withdrawal_limit_is_[_1]_[_2]_": "お客さまの出金限度額は[_1] [_2]です。限度額以上の出金額をご希望される場合は、本人確認が必要となりますので\nカスタマーサポートへご連絡ください。", "Trade": "トレード", "This_contract_won": "このトレードは勝ち判定", "Entry_Spot": "取引開始時刻直後のティック", "New_token_created_": "新しいトークンが作成されました。", "Your_account_has_no_trading_activity_": "取引履歴はありません", "Predict_the_direction<br_/>and_purchase": "方向性<br />を予測して購入", "In/Out": "レンジ", "Reference_ID": "約定番号", "Minute": "分", "numbers": "数字", "Please_select_a_value": "値を選択してください。", "Waiting_for_entry_tick_": "エントリーTickを検出中です・・・", "Your_token_has_expired__Please_click_[_1]here[_2]_to_restart_the_verification_process_": "ワンタイムパスワードの有効期限が切れています。再度、[_1]「最初からやり直し」[_2] をクリックしてワンタイムパスワードを発行して下さい。", "Remaining_Time": "満期までの残り時間", "from_[_1]_to_[_2]": "[_1]から[_2]まで", "Virtual_money_credit_to_account": "バーチャルマネーを入金", "Jul": "7", "Chart": "チャート", "Jan": "1", "Previous": "戻る", "week": "週間", "Please_set_[_1]country_of_residence[_2]_before_upgrading_to_a_real-money_account_": "リアル口座へアップグレードされる前に%居住国[_2]を設定してください。", "Lower": "LOW", "Charting_for_this_underlying_is_delayed": "この対象のチャート表示は不可能です", "Nov": "11", "Apr": "4", "Your_account_has_no_Login/Logout_activity_": "お客さまのご口座はログイン/ログアウトのアクティビティはございません。", "Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_": "お客さまの[_1]日の出金限度額は現在[_2] [_3]です。限度額以上の出金額をご希望される場合、本人確認が必要となります。", "[_1]_[_2]_payout_if_[_3]_ends_on_or_between_low_and_high_values_of_Barrier_at_close_on_[_4]_": "[_3]のEND-INは、判定時刻([_4])の時点で上限バリア未満かつ下限バリア以上であると予測", "Please_set_your_30-day_turnover_limit_in_our_[_1]self-exclusion_facilities[_2]_to_remove_deposit_limits_": "入金制限を解除するには、[_1]自己制限[_2]から30日の取引数量限度額を設定してください。", "Select_market": "取引市場を選択", "Fr": "金", "Start_time": "開始時間", "This_is_a_staging_server_-_For_testing_purposes_only": "これはテストを目的としたステージングサーバーです", "Digit": "数字", "Time_is_in_the_wrong_format_": "開始時間に間違った値になっております", "Stays_Between": "STAY-IN", "{JAPAN_ONLY}Congratulations,_you_have_pass_the_test,_our_Customer_Support_will_contact_you_shortly_": "おめでとうございます。テストに合格されましたので、カスタマーサポートよりメールにて口座開設の次のステップについてご連絡させていただきます。", "Please_select_a_valid_time_": "有効な時間を選択してください", "Thursday": "木", "You_have_already_withdrawn_[_1]_[_2]_": "現在までの出金額は[_1] [_2]です。", "Ends_Between": "END-IN", "You_need_to_finish_all_20_questions_": "まだ、無解答の問題があります。", "seconds": "秒", "Should_be_less_than_[_1]": "[_1]より低い必要があります。", "Low_Barrier_([_1])": "下限バリア", "minutes": "分", "Resale_not_offered": "満期までの2分は売却取引不可", "End_time": "終了時間", "hours": "時間", "Score": "スコア", "High_Barrier_([_1])": "上限バリア", "Withdraw": "出金", "Remaining_time": "満期までの残り時間", "month": "ヶ月", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_": "[_1] [_2] と同等の金額を既に出金されています。", "Sep": "9", "Closes_early_(at_21:00)": "判定時刻:21:00", "Dec": "12", "Scopes": "範囲", "Profit/Loss": "損益", "Main_password": "メインパスワード", "Session_duration_limit_cannot_be_more_than_6_weeks_": "セッション期間制限は7週間以上に設定できません。", "min": "最小値", "Exit_spot": "判定レート", "Settles": "決済時間", "Oct": "10", "Should_be_a_valid_number": "有効な数字を入力してください", "Demo": "デモ", "Touches": "TOUCH", "Last_Digit_Stats": "下一桁ステータス", "hour": "時間", "{JAPAN_ONLY}The_test_is_unavailable_now,_test_can_only_be_taken_again_on_next_business_day_with_respect_of_most_recent_test_": "現在テストを受験いただけません。前回のテストの翌営業日に再度受験いただけます。", "High_Barrier": "上限バリア", "September": "９月", "[_1]_withdrawal_from_account_number_[_2]_to_[_3]_is_done__Transaction_ID:_[_4]": "口座番号[_2]から[_3]へのご出金が完了しました。取引参照ID：[_4]", "July": "７月", "Indicative": "参考売却金額", "Asset": "取引対象", "Percentage": "割合", "Current_password": "現在のパスワード", "True": "正", "Female": "女性", "Opens": "取引開始時間", "minute": "分", "verification_token": "ワンタイムパスワード", "Balance": "口座残高", "Lock_Cashier": "入出金をロック", "Delete": "消去", "Only_letters,_numbers,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "文字、数字、スペース、ハイフン(-)、ピリオド(.)、アポストロフィ(')のみご利用いただけます。", "weeks": "週間", "Please_[_1]complete_your_account_profile[_2]_to_lift_your_withdrawal_and_trading_limits_": "出金制限及び取引制限を解除するには、[_1]口座情報の入力を完了[_2]していただく必要があります。", "You_have_not_granted_access_to_any_applications_": "アプリケーションへのアクセス権限がありません。", "December": "１２月", "Tu": "火", "Please_accept_the_terms_and_conditions_": "利用規約に同意していただく必要があります。", "[_1]_and_[_2]_cannot_be_the_same_": "[_1] と [_2]を同じ内容にすることはできません。", "Closes": "取引終了時間", "[_1]_[_2]_payout_if_[_3]_does_not_touch_Barrier_through_close_on_[_4]_": "[_3]のNO-TOUCHは、取引期間([_4])が終了するまでにバリア価格に達しないと予測", "Matches/Differs": "MATCH/DIFFER", "Mar": "3", "Feb": "2", "Time_out_cannot_be_in_the_past_": "終了時間を過去の時間に設定することはできません。", "Your_changes_have_been_updated_successfully_": "設定が正しく更新されました。", "Please_select_a_valid_date_": "有効な日付を選択してください", "Congratulations!_Your_[_1]_Account_has_been_created_": "おめでとうございます！[_1]口座の作成が完了しました。", "You_should_enter_[_1]_characters_": "[_1]文字でご入力ください", "Potential_Profit": "期待利益", "[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]": "[_1] [_2]をデモ口座[_3]に付与されました", "Invalid_email_address": "無効なEメールアドレス", "Up/Down": "ラダー", "March": "３月", "Next": "次", "Amount": "金額", "Christmas_Day": "クリスマス", "Please_check_the_above_form_for_pending_errors_": "未入力の項目がありますのでご確認ください", "Should_be_more_than_[_1]": "[_1]を上回る必要があります", "[_1]_[_2]_payout_if_[_3]_goes_outside_of_low_and_high_values_of_Barrier_through_close_on_[_4]_": "[_3]のBREAK-OUTは、取引期間中([_4])に上限バリア以上もしくは下限バリア以下になると予測", "{JAPAN_ONLY}Knowledge_Test_Result": "知識確認テスト結果", "Profit_Table": "取引明細", "PM": "午後", "April": "４月", "[_1]_[_2]_payout_if_[_3]_is_strictly_higher_than_or_equal_to_Barrier_at_close_on_[_4]_": "[_3]のラダーHIGHは、判定時刻([_4])の時点でバリア価格以上であると予測", "Aug": "8", "Jun": "6", "Sale_Date": "売却/判定時刻", "May": "5", "{JAPAN_ONLY}Dear_customer,_you've_already_completed_the_knowledge_test,_please_proceed_to_next_step_": "お客さまへ\n\n既に知識確認テストは完了しています。送信済みのメールを確認の上、口座開設の手続きを進めてください。", "Purchase_Time": "購入時間", "Barrier": "バリア価格", "Password_should_have_lower_and_uppercase_letters_with_numbers_": "大文字と小文字を含む英字と数字を組み合わせる必要があります", "Sorry,_an_error_occurred_while_processing_your_account_": "通信エラーが発生しましたので、再度ページの読み込みをしてください", "Ends_In/Out": "END-IN/END-OUT", "space": "スペース", "October": "１０月", "Please_select_the_checkbox_": "チェックボックスを選択してください", "Real_Standard": "リアル スタンダード", "Closed": "終了", "January": "１月", "Forex": "外国為替", "Only_letters,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "文字、スペース、ハイフン、ピリオド、アポストロフィのみご利用いただけます。", "Please_log_in_": "ログインをしてください。", "Contract_Confirmation": "トレード確定", "June": "６月", "Closes_early_(at_18:00)": "判定時刻:18:00", "False": "誤", "Processing_your_request___": "ただいま処理中です。しばらくお待ち下さい。", "Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "お客さまの出金限度額は ¥ [_2] です。限度額以上の出金額をご希望される場合は、本人確認が必要となりますのでカスタマーサポートへご連絡ください。", "Japan": "日本", "Never_Used": "使用されることはありません。", "Sorry,_this_feature_is_available_to_virtual_accounts_only_": "申し訳ございません。この機能はデモ口座のみでご利用頂けます。", "Exclude_time_cannot_be_for_more_than_5_years_": "6年以上の除外期間は設定することはできません。", "Last_Used": "最後に使用したもの", "Please_select": "選択して下さい", "Weekday": "平日", "Select_your_market": "取引市場を選択", "Today": "本日", "The_two_passwords_that_you_entered_do_not_match_": "入力頂いたパスワードと一致しません。", "Deposit": "入金", "years": "年", "The_main_password_of_account_number_[_1]_has_been_changed_": "口座番号 [_1]のメインパスワード変更を承りました。", "Entry_spot": "取引時刻直後のティック", "Fridays": "金曜日", "Net_profit": "純利益", "The_server_<a_href=\"[_1]\">endpoint</a>_is:_[_2]": "サーバーの <a href=\"[_1]\">エンドポイント</a> : [_2]", "Total_Profit/Loss": "合計　損益", "There_was_an_error": "エラーが発生しました", "Invalid_amount,_minimum_is": "無効な値です。最小", "Gaming_Account": "ゲームアカウント", "Token": "トークン", "Sorry,_account_signup_is_not_available_in_your_country__Please_contact_<a_href=\"[_1]\">customer_support</a>_for_more_information_": "申し訳ございませんが、お客様の国では口座の開設ができません。詳細については<a href=\"[_1]\">カスタマーサポート</a>までお問い合わせください。", "New_password": "新しいパスワード", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_": "現在、出金可能な限度額（口座残高が不足していない場合）は¥ [_2]となります。", "Your_changes_have_been_updated_": "変更が更新されました。", "This_feature_is_not_relevant_to_virtual-money_accounts_": "この機能は、デモ口座ではご利用頂けません。", "Date_and_Time": "日時", "Transaction_performed_by_[_1]_(App_ID:_[_2])": "[_1](App ID:[_2])によって取引が実行されました", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_click_<a_href=\"[_1]\">here</a>_": "お客様の入出金はリクエストによりロックしました。 - 解除するには<a href=\"[_1]\">こちらをクリック</a>してください。", "Real_STP": "リアルSTP", "Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_": "パスワードの再設定を完了しました。新しいパスワードでログインしてください。", "Does_Not_Touch": "NO-TOUCH", "All_markets_are_closed_now__Please_try_again_later_": "営業時間外のためご利用になれません。", "[_1]_[_2]_payout_if_[_3]_is_strictly_lower_than_Barrier_at_close_on_[_4]_": "[_3]のラダーLOWは、判定時刻([_4])の時点でバリア価格未満であると予測", "Invalid_amount,_maximum_is": "無効な値です。最大はXXXです。", "Admin": "管理者", "Return": "リターン率", "Rise/Fall": "ラダー", "[_1]_[_2]_payout_if_[_3]_stays_between_low_and_high_values_of_Barrier_through_close_on_[_4]_": "[_3]のSTAY-INは取引期間中([_4])に上限バリア未満かつ下限バリア超過を維持すると予測", "Never": "決してありません", "{JAPAN_ONLY}Please_complete_the_following_questions_": "知識確認テスト用ディスクレーマー", "Major_Pairs": "主要通貨ペア", "You_have_sold_this_contract_at_[_1]_[_2]": "[_1] [_2]でこのトレードを売却しました", "Date": "日付", "New_Year's_Day": "元旦", "Real_Cent": "リアルセント", "[_1]_[_2]_payout_if_[_3]_ends_outside_low_and_high_values_of_Barrier_at_close_on_[_4]_": "[_3]のEND-OUTは、判定時刻([_4])の時点で上限バリア以上もしくは下限バリア未満であるとを予測", "Select_your_trade_type": "取引タイプを選択して下さい", "Time_out_cannot_be_more_than_6_weeks_": "終了時間を6週間以上先には設定できません。", "Exit_Spot_Time": "売却/判定時刻", "Saturday": "土", "Failed": "失敗しました", "Sorry,_an_error_occurred_while_processing_your_request_": "通信エラーが発生しましたので、再度ページの読み込みをしてください", "Low_Barrier": "下限バリア", "Your_transaction_reference_is": "トレード参照番号：", "Month": "月", "Name": "お名前", "Verification_code_format_incorrect_": "ワンタイムパスワードの形式が不適切です。", "second": "秒", "{JAPAN_ONLY}Dear_customer,_you_are_not_allowed_to_take_knowledge_test_until_[_1]__Last_test_taken_at_[_2]_": "お客さまへ\n\n現在、知識確認テストの受験を行うことができません。[_1]以降に再受験してください。前回受験日[_2]", "November": "１１月", "Sell": "売却", "days": "日", "Male": "男性", "Only_[_1]_are_allowed_": "[_1]のみご利用いただけます。", "Upgrade_to_a_Real_Account": "リアル口座へアップグレード", "Deposits_and_withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "お客様の口座への入出金手続きは、現在許可されていません。解除するには[_1]までご連絡ください。", "Asset_Index": "取引期間データ", "Finish": "完了", "{JAPAN_ONLY}Your_Application_has_Been_Processed__Please_Re-Login_to_Access_Your_Real-Money_Account_": "リアル口座開設は完了致しました。使用するには再度ログインが必要となります。", "Ref_": "約定番号", "Select_your_underlying_asset": "原資産を選択して下さい", "End_Time": "判定時刻", "Ends_Outside": "END-OUT", "Description": "取引内容", "Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_": "ハイフンを入れて半角で入力してください", "Target": "ターゲット", "Connection_error:_Please_check_your_internet_connection_": "接続エラー：インターネット接続状況をご確認ください。", "Investor_password": "トレーダーパスワード", "The_Payment_Agent_facility_is_currently_not_available_in_your_country_": "その決済サービスは、お客さまのお住まいの国では現在ご利用いただけません。", "Potential_Payout": "ペイアウト", "Please_select_at_least_one_scope": "範囲を1つ以上選択してください", "Spot_Time": "スポットタイム", "Market_is_closed__Please_try_again_later_": "営業時間外のためご利用になれません。", "Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_": "お客さまのご口座はアップグレード済みですので、ご出金制限が引き上げられました。", "Stake": "購入価格", "Exit_Spot": "判定レート", "There_was_a_problem_accessing_the_server_during_purchase_": "購入時にサーバーアクセスのエラーが発生がしました。", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "そのため、現在即座にご出金いただける限度金額（ただし、ご口座残高が不足していない場合）は[_1] [_2]までです。", "Action": "売買", "today": "本日", "There_was_a_problem_accessing_the_server_": "サーバーアクセスにエラーが発生しました。", "Barrier_([_1])": "バリア価格", "Statement": "口座残高", "Waiting_for_exit_tick_": "イグジットTickを検出中です・・・", "[_1]_Please_click_the_link_below_to_restart_the_password_recovery_process__If_you_require_further_assistance,_please_contact_our_Customer_Support_": "[_1]下記リンクをクリックしてパスワードの再設定を再度お試しください。サポートが必要な場合は、 カスタマーサポートまでご連絡ください。", "details": "詳細", "Insufficient_balance_": "口座残高が不足しています", "Contract_Expiry": "取引終了", "Details": "お客さま基本情報", "Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_": "[_3]から[_4]へのご送金[_1] [_2]リクエストが正常に処理されました。", "Unlock_Cashier": "入出金ロック解除", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_": "お客様のキャッシャーはリクエストにより、ロックされました。 - 解除するにはパスワードをご入力ください。", "Your_Application_is_Being_Processed_": "お客さまの口座開設申込書類の処理中です。", "Higher/Lower": "ラダーLOW/ラダーHIGH", "Questions": "問題", "Sorry,_you_have_entered_an_incorrect_cashier_password": "申し訳ございませんが、ご入力頂いた入出金パスワードに誤りがあります", "AM": "午前", "Credit/Debit": "支払/受取", "Minimum_of_[_1]_characters_required_": "[_1]文字以上でご入力ください。", "Successful": "成功しました", "logout": "ログアウト", "Friday": "金曜日", "Change_Password": "パスワード変更", "Current_Time": "現在時刻：", "Open_a_Financial_Account": "金融口座の開設", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_": "直近[_3]日間に累計[_1] [_2] と同等の金額を既に出金されています。", "Price": "売却/ペイアウト金額", "Even/Odd": "偶数/奇数", "Your_session_duration_limit_will_end_in_[_1]_seconds_": "お客様の取引継続時間制限は[_1]秒後に終了します。", "Please_complete_the_[_1]financial_assessment_form[_2]_to_lift_your_withdrawal_and_trading_limits_": "取引上限と出金限度額を引き上げるには下記財務評価書にご記入をお願いします。", "Higher": "HIGH", "Only_numbers_and_spaces_are_allowed_": "数字とスペースのみご利用いただけます。", "Contract": "トレード", "All_barriers_in_this_trading_window_are_expired": "すべてのバリア価格は権利行使済みです", "Purchase_Price": "購入金額", "Sell_at_market": "売却", "End_time_must_be_after_start_time_": "取引終了時間は明日以降として設定して下さい。", "year": "年", "Walkthrough_Guide": "チュートリアルガイド", "Should_be_between_[_1]_and_[_2]": "投資は、[_1]から[_2]の間である必要があります。", "The_maximum_number_of_tokens_([_1])_has_been_reached_": "トークンの最大数([_1]) に達しました。", "Contract_Sold": "売却", "Investment_Account": "投資口座", "Explanation": "取引概要", "Password_is_not_strong_enough_": "パスワード強度が十分ではありません。", "{JAPAN_ONLY}Knowledge_Test": "知識確認テスト", "Shop": "ショップ", "Your_token_has_expired__Please_click_<a_href=\"[_1]\">here</a>_to_restart_the_verification_process_": "ワンタイムパスワードの有効期限が切れています。再度、<a href=\"[_1]\">「最初からやり直し」</a> をクリックしてワンタイムパスワードを発行して下さい。", "Number_of_ticks": "Tickの総数", "{JAPAN_ONLY}Sorry,_you_have_failed_the_test,_please_try_again_after_24_hours_": "残念ながら、合格点に達しませんでした。24時間以降（週末を除く）に再受験してください。", "Not": "ない", "Tuesday": "火", "Touch/No_Touch": "TOUCH/NO-TOUCH", "This_field_is_required_": "この項目は必須です。", "Buy": "購入", "Wednesday": "水", "Day": "日", "Please_enter_a_number_between_[_1]_": "[_1]の間の数字を入力してください。", "Trading_Times": "トレード対応時間", "h": "時間", "Short": "ショート", "An_additional_password_can_be_used_to_restrict_access_to_the_cashier_": "入出金へのアクセスを制限するために、追加パスワードを使用することができます。", "Permissions": "アクセス許可", "Create_Account": "デモ口座開設", "Loss": "損益", "Your_account_is_currently_suspended__Only_withdrawals_are_now_permitted__For_further_information,_please_contact_[_1]_": "現在お客様の口座は、一時的にご利用いただけません。詳細は、[_1]までご連絡ください。", "Time_out_must_be_after_today_": "終了時間は明日以降として設定して下さい。", "Read": "読む", "Sale_Price": "売却 / ペイアウト金額", "Contract_Information": "約定済み通知", "Real_Volatility": "リアル ボラティリティ", "Your_settings_have_been_updated_successfully_": "設定は正しく更新されました。", "Revoke_access": "アクセス権の取消", "Exclude_time_cannot_be_less_than_6_months_": "5ヶ月以下の除外時間を設定することはできません。", "Are_you_sure_that_you_want_to_permanently_revoke_access_to_application": "アプリケーションへのアクセスを完全に削除してもよろしいですか？", "Real_Account": "リアル口座番号", "Sunday": "日", "Old_password_is_wrong_": "旧パスワードの値が不正です。", "This_contract_lost": "このトレードは負け判定", "Goes_Outside": "BREAK-OUT", "Duration": "取引期間", "Cashier": "入出金", "[_1]Authenticate_your_account[_2]_now_to_take_full_advantage_of_all_withdrawal_options_available_": "出金制限及び取引制限を解除するには、[_1]口座認証[_2]をしていただく必要があります。", "Stays_In/Goes_Out": "STAY-IN/BREAK-OUT", "Contract_is_not_started_yet": "トレードはまだ開始していません", "Only_numbers,_space,_and_hyphen_are_allowed_": "数字、スペース、ハイフンのみご利用いただけます。", "Account_balance:": "口座残高：", "Your_transaction_reference_number_is_[_1]": "決済の参照番号は[_1]です", "Portfolio": "ポジション一覧", "Final_price": "最終価格", "Sa": "土", "Sell_time": "売却時間", "Equals": "等しい", "Profit": "利益", "Long": "ロング", "Year": "年", "day": "日", "Only_letters,_numbers,_and_hyphen_are_allowed_": "文字、数字、ハイフンのみご利用いただけます。", "Update": "更新", "Hour": "時間", "Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_": "お客さまのご口座[_3]から決済サービス[_4]口座へ[_1] [_2]の出金リクエストが正常に処理されました。", "There_was_some_invalid_character_in_an_input_field_": "入力された文字に使用できない文字が含まれています。", "Start_Time": "取引開始時刻", "Virtual_Account": "デモ口座番号", "Th": "木", "Monday": "月", "[_1]_[_2]_payout_if_[_3]_touches_Barrier_through_close_on_[_4]_": "[_3]のTOUCHは、取引期間([_4])が終了するまでバリア価格に達すると予測", "Status": "金融資産", "Sorry,_this_feature_is_not_available_": "申し訳ございませんが、この機能はご利用いただけません。", "We": "水", "Step": "ステップ", "Spot": "スポットレート", "Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_": "当社のサーバがリクエストを受理した時点での市場価格で売却取引が成立します。実際の約定価格と注文時の表示価格と異なる場合があります。", "This_symbol_is_not_active__Please_try_another_symbol_": "このシンボルは現在ご利用いただけません。他のシンボルでお試しください。", "Only_[_1]_decimal_points_are_allowed_": "小数点以下[_1]桁のみご利用いただけます。", "Total_Cost": "合計投資額", "Contract_ID": "トレード ID", "today,_Fridays": "本日：金曜日", "IP_Address": "IPアドレス", "Buy_price": "購入金額（単価）", "February": "２月", "Please_submit_a_valid_verification_token_": "有効なワンタイムパスワードを送信してください。", "{JAPAN_ONLY}Take_knowledge_test": "知識確認テストを受ける", "Please_[_1]accept_the_updated_Terms_and_Conditions[_2]_to_lift_your_withdrawal_and_trading_limits_": "出金制限及び取引制限を解除するには、[_1]改訂版利用規約に同意[_2]いただく必要があります。", "Payment_Agent": "決済サービス", "Are_you_sure_that_you_want_to_permanently_delete_token": "トークンを完全に削除してもよろしいですか？", "Your_trading_statistics_since_[_1]_": "[_1]からのお取引統計情報", "Su": "日", "The_email_address_provided_is_already_in_use__If_you_forgot_your_password,_please_try_our_<a_href=\"[_1]\">password_recovery_tool</a>_or_contact_our_customer_service_": "ご入力いただいたメールアドレスは既に他のログインIDで使用されています。パスワードをお忘れの場合は、<a href=\"[_1]\">こちら</a>からパスワードを再発行して頂くか、カスタマーサポートまでご連絡下さい。", "Resources": "取引参考情報", "[_1]_days_[_2]_hours_[_3]_minutes": "[_1]日 [_2]時間 [_3]分", "Please_select_a_payment_agent": "決済サービスを選択してください。", "August": "８月", "[_1]_deposit_from_[_2]_to_account_number_[_3]_is_done__Transaction_ID:_[_4]": "[_2]から口座番号[_3]への入金が完了しました。取引参照ID：[_4]", "Upgrade_to_a_Financial_Account": "金融口座へアップグレード", "letters": "文字", "Current": "現在", "Sorry,_your_account_is_not_authorised_for_any_further_contract_purchases_": "申し訳ございませんが、これ以上のトレードの購入を可能にする権限がお客さまのご口座に存在しておりません。", "months": "ヶ月", "Upcoming_Events": "取引時間短縮日及び祝日", "Over/Under": "以上/以下", "Please_input_a_valid_date": "有効な日にちを入力して下さい。", "Note": "注意", "mins": "分", "Your_account_is_restricted__Kindly_[_1]contact_customer_support[_2]_for_assistance_": "お客さまの口座は、現在ご利用制限が掛っております。<a href=\"[_1]\">カスタマーサポート</a>までご連絡下さい。", "Please_<a_href=\"[_1]\">log_in</a>_to_view_this_page_": "現在、ログアウトの状態です。ご利用頂くためには再度<a href=\"[_1]\">ログイン</a>をしてください。", "Payments": "アフィリエイト報酬の支払いについて", "You_did_not_change_anything_": "変更はありません。", "Browser": "ブラウザ", "Payout": "ペイアウト", "Adjust_trade_parameters": "取引期間を選択して頂き購入希望ロット数を入力して下さい。", "Barrier_Change": "バリア値の変更", "email_address": "メールアドレス", "View": "表示", "You_have_reached_the_rate_limit_of_requests_per_second__Please_try_later_": "ページを更新して頂くか、もう一度お試しください。" };
	texts_json['ZH_CN'] = { "Old_password_is_wrong_": "旧密码不正确。", "This_contract_lost": "此合约亏损", "Sunday": "周日", "Duration": "期限", "Cashier": "收银台", "Goes_Outside": "处于区间之外", "[_1]Authenticate_your_account[_2]_now_to_take_full_advantage_of_all_withdrawal_options_available_": "立刻进行[_1]账户验证[_2]，以获得取款选项的所有优惠。", "Stays_In/Goes_Out": "“保持在范围之内/超出范围之外”", "Contract_is_not_started_yet": "合约还未开始", "Real_Volatility": "真实波动率", "Contract_Information": "合约信息", "Revoke_access": "撤销访问权限", "Exclude_time_cannot_be_less_than_6_months_": "禁止时间不能少于6个月。", "Your_settings_have_been_updated_successfully_": "您的设置已成功更新。", "Real_Account": "真实账户", "Are_you_sure_that_you_want_to_permanently_revoke_access_to_application": "确定要永久废除应用程序访问权限吗", "There_was_some_invalid_character_in_an_input_field_": "某字段的输入字符无效。", "Start_Time": "开始时间", "Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_": "您从 [_3] 账户提取 [_1] [_2] 到支付代理 [_4]账户的请求已成功处理。", "Status": "统计", "[_1]_[_2]_payout_if_[_3]_touches_Barrier_through_close_on_[_4]_": "[_4]闭市时如果[_3]触及障碍价格，可获取[_1] [_2] 赔付额。", "Monday": "星期一", "Th": "星期四", "Virtual_Account": "虚拟账户", "Spot": "现价", "Step": "步骤", "Sorry,_this_feature_is_not_available_": "对不起，此功能不可用。", "We": "星期三", "This_symbol_is_not_active__Please_try_another_symbol_": "这是个非活跃符号。请试另一符号。", "Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_": "合约将在我们服务器收到请求时，以当时的市场价格卖出。此价格可能与报价有差异。", "Only_numbers,_space,_and_hyphen_are_allowed_": "只允许数字、空格和连字符。", "Account_balance:": "账户余额：", "Equals": "相等于", "Sell_time": "卖出时间", "Final_price": "最终价格", "Sa": "星期六", "Your_transaction_reference_number_is_[_1]": "您的交易参考号是 [_1]", "Portfolio": "投资组合", "day": "天", "Long": "长仓", "Year": "年", "Profit": "利润", "Hour": "小时", "Only_letters,_numbers,_and_hyphen_are_allowed_": "只允许字母、数字和连字符。", "Update": "更新", "Please_[_1]accept_the_updated_Terms_and_Conditions[_2]_to_lift_your_withdrawal_and_trading_limits_": "请[_1]接受更新条款和条件[_2]，以提高存取款限额。", "Payment_Agent": "付款代理", "Your_trading_statistics_since_[_1]_": "您自 [_1] 至今的交易统计。", "Are_you_sure_that_you_want_to_permanently_delete_token": "确定要永久删除令牌吗", "Contract_ID": "合约编号", "Total_Cost": "成本总计", "Only_[_1]_decimal_points_are_allowed_": "只允许 % 个小数位。", "IP_Address": "IP 地址", "today,_Fridays": "今天、周五", "February": "二月", "Buy_price": "买入价", "Please_submit_a_valid_verification_token_": "请提交有效的验证令牌。", "Over/Under": "大于/小于", "Your_account_is_restricted__Kindly_[_1]contact_customer_support[_2]_for_assistance_": "您的账户已被限制。请[_1]联系客服部[_2]，以获得帮助。", "mins": "分钟", "Note": "附注", "Please_input_a_valid_date": "请输入有效日期", "Payout": "赔付", "Browser": "浏览器", "You_did_not_change_anything_": "您没作任何更改。", "Payments": "支付", "Please_<a_href=\"[_1]\">log_in</a>_to_view_this_page_": "要查看此页面请先<a href=\"[_1]\">登录</a>。", "You_have_reached_the_rate_limit_of_requests_per_second__Please_try_later_": "您已达每秒钟提呈请求的最高限率。请稍后重试。", "email_address": "电子邮件地址", "View": "查看", "Adjust_trade_parameters": "调整交易参数", "Barrier_Change": "障碍变更", "Please_select_a_payment_agent": "请选择支付代理", "[_1]_days_[_2]_hours_[_3]_minutes": "[_1] 天 [_2] 小时 [_3] 分钟", "The_email_address_provided_is_already_in_use__If_you_forgot_your_password,_please_try_our_<a_href=\"[_1]\">password_recovery_tool</a>_or_contact_our_customer_service_": "所提供的电子邮件地址已经在使用。如果忘了密码，请尝试使用我们的<a href=\"[_1]\">密码恢复工具</a>或联系客服部。", "Su": "星期日", "Resources": "资源", "letters": "信件", "Upgrade_to_a_Financial_Account": "升级到金融账户", "August": "八月", "[_1]_deposit_from_[_2]_to_account_number_[_3]_is_done__Transaction_ID:_[_4]": "已完成从[_2]至账号[_3]的[_1]存款。交易编号: [_4]", "Sorry,_your_account_is_not_authorised_for_any_further_contract_purchases_": "对不起，您的账户无权进一步买入任何合约。", "Current": "当前", "months": "月份", "Upcoming_Events": "未来事件", "Finish": "完成", "Asset_Index": "资产指数", "Select_your_underlying_asset": "选择基础资产", "Ref_": "参考", "Target": "目标", "Description": "说明", "Ends_Outside": "区间之外结束", "Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_": "请按照以下格式填写：3个数字，1个短划线，加上4个数字。", "End_Time": "结束时间", "The_Payment_Agent_facility_is_currently_not_available_in_your_country_": "您的国家无可用支付代理设施。", "Investor_password": "投资者密码", "Connection_error:_Please_check_your_internet_connection_": "连接错误：请检查您网络连接。", "Verification_code_format_incorrect_": "验证码格式不正确。", "Name": "姓名", "Your_transaction_reference_is": "您的交易参考号是", "Low_Barrier": "低障碍", "Month": "月份", "November": "十一月", "second": "秒", "Only_[_1]_are_allowed_": "只允许 [_1] 。", "days": "天", "Sell": "卖出", "Upgrade_to_a_Real_Account": "升级到真实账户", "Deposits_and_withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "您的账户现时无法存取款。请联系[_1]进行解锁。", "Waiting_for_exit_tick_": "正在等待退场跳动点。", "[_1]_Please_click_the_link_below_to_restart_the_password_recovery_process__If_you_require_further_assistance,_please_contact_our_Customer_Support_": "[_1] 请点击以下链接重启密码恢复过程。如果需要帮助，请联系客服部。", "Statement": "账单", "Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_": "您从 [_3] 转账 [_1][_2] 到 [_4] 的请求已成功处理。", "Details": "详情", "Insufficient_balance_": "余额不足。", "Contract_Expiry": "合约到期日", "details": "详情", "Your_Application_is_Being_Processed_": "您的申请已经处理完成。", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_": "根据您的请求，您的收银台已被锁定 - 如需解除锁定，请输入密码。", "Unlock_Cashier": "解锁收银台", "Questions": "问题", "Higher/Lower": "“高于/低于”", "Potential_Payout": "可能的赔付额", "Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_": "您的账户已经得到完全验证，且您的取款限额已经取消。", "Market_is_closed__Please_try_again_later_": "市场已关闭。请稍后重试。", "Spot_Time": "现货时间", "Please_select_at_least_one_scope": "请选择至少一个范围", "Action": "操作", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "因此您当前的即时最高取款额（要求您的账户有充足资金）为[_1] [_2]（或其他等值货币）。", "There_was_a_problem_accessing_the_server_during_purchase_": "买入时服务器访问发生问题。", "Exit_Spot": "退市现价", "Stake": "投注资金", "There_was_a_problem_accessing_the_server_": "服务器访问发生问题。", "Barrier_([_1])": "障碍([_1])", "today": "今天", "Now": "现在", "Even/Odd": "偶/奇", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_": "过去 [_3] 天里您已累计提取 [_1] [_2] 的等值。", "Price": "价格", "Current_Time": "当前时间", "Open_a_Financial_Account": "开设金融账户", "Please_complete_the_[_1]financial_assessment_form[_2]_to_lift_your_withdrawal_and_trading_limits_": "请完成[_1]财务评估表格[_2]，以便提升您的取款和交易限额 。", "Your_session_duration_limit_will_end_in_[_1]_seconds_": "交易期持续时间限制将于[_1]秒内结束。", "All_barriers_in_this_trading_window_are_expired": "此交易窗口的所有障碍已过期", "Contract": "合约", "Higher": "高于", "Only_numbers_and_spaces_are_allowed_": "只允许数字和空格。", "Walkthrough_Guide": "攻略指南", "year": "年", "End_time_must_be_after_start_time_": "结束时间必须在开始时间之后。", "Sell_at_market": "按市价卖出", "Purchase_Price": "买入价格", "Sorry,_you_have_entered_an_incorrect_cashier_password": "对不起，您输入的收银台密码不正确", "Minimum_of_[_1]_characters_required_": "需至少[_1] 个字符。", "Credit/Debit": "借方/贷方", "AM": "上午", "logout": "注销", "Successful": "成功", "Change_Password": "更改密码", "Friday": "星期五", "Please_enter_a_number_between_[_1]_": "请输入[_1]之间的数字。", "Buy": "买入", "Wednesday": "星期三", "Day": "天", "Short": "短仓", "An_additional_password_can_be_used_to_restrict_access_to_the_cashier_": "可使用额外密码来限制对收银台的访问。", "h": "小时", "Trading_Times": "交易时间", "Your_account_is_currently_suspended__Only_withdrawals_are_now_permitted__For_further_information,_please_contact_[_1]_": "您的账户已被暂时禁用，现仅允许取款。欲知详情，请联系 [_1]。", "Loss": "亏损", "Create_Account": "开立账户", "Permissions": "权限", "Sale_Price": "卖出价格", "Read": "阅读", "Time_out_must_be_after_today_": "到期时间必须在今日之后。", "The_maximum_number_of_tokens_([_1])_has_been_reached_": "已达令牌 ([_1]) 最大限数。", "Should_be_between_[_1]_and_[_2]": "须在[_1] 与 [_2]之间", "Password_is_not_strong_enough_": "密码安全度不够。", "Contract_Sold": "售出合约", "Investment_Account": "投资账户", "Explanation": "说明", "Shop": "商店", "This_field_is_required_": "此字段为必填项。", "Tuesday": "星期二", "Not": "不", "Touch/No_Touch": "触及/未触及", "Number_of_ticks": "跳动点数目", "Your_token_has_expired__Please_click_<a_href=\"[_1]\">here</a>_to_restart_the_verification_process_": "您的令牌已过期。请点击<a href=\"[_1]\">此处</a>重启验证程序。", "Amount": "金额", "Up/Down": "涨/跌", "Next": "下一页", "March": "三月", "Invalid_email_address": "无效的电子邮件地址", "Christmas_Day": "圣诞节", "Please_check_the_above_form_for_pending_errors_": "请检查以上表格是否有待定错误。", "Should_be_more_than_[_1]": "必须大于 [_1]", "[_1]_[_2]_payout_if_[_3]_goes_outside_of_low_and_high_values_of_Barrier_through_close_on_[_4]_": "[_4]闭市时如果[_3]价在障碍价格最低和最高价位范围外，可获取[_1] [_2] 赔付额。", "You_have_not_granted_access_to_any_applications_": "您没有访问任何应用程序的权限。", "Please_[_1]complete_your_account_profile[_2]_to_lift_your_withdrawal_and_trading_limits_": "请[_1]完成账户资料[_2]，以提高取款和交易限额。", "Mar": "三月", "Matches/Differs": "符合/相差", "Feb": "二月", "Closes": "收盘", "[_1]_[_2]_payout_if_[_3]_does_not_touch_Barrier_through_close_on_[_4]_": "[_4]闭市时如果[_3]未触及障碍价格，可获取[_1] [_2]的赔付额。", "[_1]_and_[_2]_cannot_be_the_same_": "[_1] 和 [_2] 不可相同。", "Please_accept_the_terms_and_conditions_": "请接受条款和条件。", "December": "十二月", "Tu": "星期二", "[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]": "[_1] [_2] 已记入您的虚拟资金账户[_3]", "Potential_Profit": "潜在利润", "Congratulations!_Your_[_1]_Account_has_been_created_": "恭喜! 您已成功开立[_1]账户。", "You_should_enter_[_1]_characters_": "您必须输入[_1]个字符。", "Please_select_a_valid_date_": "请选择ั有效日期。", "Your_changes_have_been_updated_successfully_": "您的更改已成功更新。", "Time_out_cannot_be_in_the_past_": "到期时间不可为过去式。", "Real_Standard": "真实标准", "Please_select_the_checkbox_": "请选择复选框。", "space": "空间", "October": "十月", "Contract_Confirmation": "合约确认", "Only_letters,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "只允许字母、空格、连字符、句号和省略号。", "Please_log_in_": "请登录。", "Forex": "外汇", "January": "一月", "Closed": "收盘", "June": "六月", "Closes_early_(at_18:00)": "收盘提前（至18:00）", "Japan": "日本", "Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "您的取款限额为 [_1] [_2] (或其他货币的等值 ）。", "Processing_your_request___": "您的请求在处理中...", "April": "四月", "Profit_Table": "利润表", "PM": "下午", "Jun": "六月", "Aug": "八月", "[_1]_[_2]_payout_if_[_3]_is_strictly_higher_than_or_equal_to_Barrier_at_close_on_[_4]_": "[_4]闭市时如果[_3]严格高于或相等于障碍价格，可获取[_1] [_2] 赔付额。", "Purchase_Time": "买入时间", "Sale_Date": "卖出日期", "May": "五月", "Ends_In/Out": "“范围之内/之外”收盘", "Sorry,_an_error_occurred_while_processing_your_account_": "对不起，您的账户处理发生错误。", "Password_should_have_lower_and_uppercase_letters_with_numbers_": "密码须包含大小写字母与数字。", "Barrier": "障碍", "The_main_password_of_account_number_[_1]_has_been_changed_": "[_1]账号的主密码已更改。", "years": "年", "The_two_passwords_that_you_entered_do_not_match_": "两次输入的密码不一致。", "Deposit": "存款", "Fridays": "星期五", "Entry_spot": "入市现价", "Total_Profit/Loss": "利润/亏损合计", "The_server_<a_href=\"[_1]\">endpoint</a>_is:_[_2]": "服务器<a href=\"[_1]\">终端</a>是: [_2]", "Net_profit": "净收益", "Token": "令牌", "Gaming_Account": "博彩账户", "Invalid_amount,_minimum_is": "无效金额，最小金额是", "There_was_an_error": "出现错误", "Sorry,_this_feature_is_available_to_virtual_accounts_only_": "对不起，此功能仅适用虚拟账户。", "Never_Used": "从未使用过", "Exclude_time_cannot_be_for_more_than_5_years_": "禁止时间不能超过5年。", "Please_select": "请选择", "Last_Used": "上一次使用", "Today": "今天", "Weekday": "交易日", "Select_your_market": "选择市场", "You_have_sold_this_contract_at_[_1]_[_2]": "您已经以 [_1] [_2] 卖出此合约", "Major_Pairs": "主要货币对", "[_1]_[_2]_payout_if_[_3]_stays_between_low_and_high_values_of_Barrier_through_close_on_[_4]_": "[_4]闭市时如果[_3]在障碍价格最低和最高价位范围内，可获取[_1] [_2] 赔付额。", "Never": "从未", "[_1]_[_2]_payout_if_[_3]_ends_outside_low_and_high_values_of_Barrier_at_close_on_[_4]_": "[_4]闭市时如果[_3]平仓价在障碍价格最低和最高价位范围外，可获取[_1] [_2] 赔付额。", "New_Year's_Day": "元旦", "Real_Cent": "真实美分", "Open": "开盘", "Date": "日期", "Exit_Spot_Time": "退市现价时间", "Time_out_cannot_be_more_than_6_weeks_": "到期时间不能大于 6周。", "Select_your_trade_type": "选择交易类型", "Failed": "失败", "Sorry,_an_error_occurred_while_processing_your_request_": "对不起，您的请求处理发生错误。", "Saturday": "周六", "This_feature_is_not_relevant_to_virtual-money_accounts_": "此功能不适用于虚拟资金账户。", "Your_changes_have_been_updated_": "您的更改已成功更新。", "New_password": "新密码", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_": "因此，您当前可即时提取的最大金额（要求您的帐户有足够资金）为 [_1] [_2]。", "Sorry,_account_signup_is_not_available_in_your_country__Please_contact_<a_href=\"[_1]\">customer_support</a>_for_more_information_": "对不起，您的国家不可注册账户。欲知详情，请联系<a href=\"[_1]\">客服部</a>。", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_click_<a_href=\"[_1]\">here</a>_": "根据您的请求，您的收银台已被锁定 - 如需解除锁定，请点击<a href=\"[_1]\">此处</a>。", "Transaction_performed_by_[_1]_(App_ID:_[_2])": "交易执行者为[_1] (应用程序 ID: [_2])", "Date_and_Time": "日期和时间", "All_markets_are_closed_now__Please_try_again_later_": "所有市场现已关闭。请稍后重试。", "Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_": "您的密码已成功重置。请用新密码登录您的账户。", "Real_STP": "真实STP", "Does_Not_Touch": "未触及", "Return": "回报", "Rise/Fall": "上涨/下跌", "Admin": "管理中心", "Invalid_amount,_maximum_is": "无效金额，最大金额是", "[_1]_[_2]_payout_if_[_3]_is_strictly_lower_than_Barrier_at_close_on_[_4]_": "[_4]闭市时如果[_3]严格低于障碍价格，可获取[_1] [_2] 赔付额。", "Predict_the_direction<br_/>and_purchase": "预测价格走向<br />并购入", "Your_account_has_no_trading_activity_": "您的账户无交易活动。", "New_token_created_": "已创建新口令牌。", "Minute": "分钟", "Reference_ID": "参考编号", "In/Out": "“范围之内/之外”", "Please_select_a_value": "请选择一个数值", "Waiting_for_entry_tick_": "正在等待进场跳动点。", "numbers": "号码", "Your_token_has_expired__Please_click_[_1]here[_2]_to_restart_the_verification_process_": "您的令牌已过期。请点击[_1]此处[_2]重启验证程序。", "Remaining_Time": "剩余时间", "Please_enter_an_integer_value": "请输入整数", "When_you_click_\"OK\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_": "当您点选“OK”后，您将被禁止在此网站交易，直到选定期限结束为止。", "Withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "您的账户现时无法取款。请联系[_1]进行解锁。", "Mo": "星期一", "Your_withdrawal_limit_is_[_1]_[_2]_": "您的取款限额是 [_1] [_2]。", "Entry_Spot": "入市现价", "Trade": "交易", "This_contract_won": "此合约获利", "Digit": "数字期权", "This_is_a_staging_server_-_For_testing_purposes_only": "这是分期服务器 -仅用于测试目的", "Time_is_in_the_wrong_format_": "时间格式错误。", "Thursday": "星期四", "Stays_Between": "位于区间之内", "Please_select_a_valid_time_": "请选择ั有效时间。", "You_need_to_finish_all_20_questions_": "必须答复全部20个问题。", "Ends_Between": "区间之内结束", "You_have_already_withdrawn_[_1]_[_2]_": "您已提取[_1] [_2]。", "Jul": "七月", "Virtual_money_credit_to_account": "虚拟资金进入账户", "from_[_1]_to_[_2]": "从[_1]到[_2]", "Lower": "低于", "Please_set_[_1]country_of_residence[_2]_before_upgrading_to_a_real-money_account_": "升级到真实资金账户前请先设置[_1]居住国[_2]。", "week": "周", "Chart": "图表", "Jan": "一月", "Previous": "之前", "Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_": "您的 [_1] 天取款限额目前为 [_2] [_3] （或其他货币的等值）。", "[_1]_[_2]_payout_if_[_3]_ends_on_or_between_low_and_high_values_of_Barrier_at_close_on_[_4]_": "[_4]闭市时如果[_3]平仓价相等于或介于障碍价格最低和最高价位间，可获取[_1] [_2] 赔付额。", "Apr": "四月", "Your_account_has_no_Login/Logout_activity_": "您的账户无交易活动。", "Nov": "十一月", "Charting_for_this_underlying_is_delayed": "此标的资产的图表数据存在延迟", "Start_time": "开始时间", "Fr": "星期五", "Select_market": "选择市场", "Please_set_your_30-day_turnover_limit_in_our_[_1]self-exclusion_facilities[_2]_to_remove_deposit_limits_": "请到[_1]自我禁止工具[_2]设置30天交易限额，以移除存款限额。", "Sep": "九月", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_": "您已提取 [_1] [_2] 的等值。", "month": "月份", "Scopes": "范围", "Dec": "十二月", "Closes_early_(at_21:00)": "收盘提前（至21:00）", "Should_be_a_valid_number": "必须是有效号码", "Oct": "十月", "Settles": "结算", "Exit_spot": "退市现价", "Main_password": "主密码", "Profit/Loss": "利润/亏损", "min": "最小", "Session_duration_limit_cannot_be_more_than_6_weeks_": "交易期持续时间限制不能大于 6周。", "hour": "小时", "Last_Digit_Stats": "最后数字的统计数据", "Demo": "演示", "Touches": "触及", "Low_Barrier_([_1])": "低障碍([_1])", "Should_be_less_than_[_1]": "必须少于[_1]", "seconds": "秒", "hours": "小时", "End_time": "结束时间", "Resale_not_offered": "不提供转售", "minutes": "分钟", "Withdraw": "取款", "High_Barrier_([_1])": "高障碍([_1])", "Remaining_time": "剩余时间", "Tick": "跳动点", "Opens": "开盘", "Female": "女", "Current_password": "当前密码", "Delete": "删除", "Only_letters,_numbers,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "只允许使用字母、数字、空格、连字符、句点和省略号。", "verification_token": "验证令牌", "Balance": "余额", "Lock_Cashier": "锁定收银台", "minute": "分钟", "weeks": "周", "September": "九月", "High_Barrier": "高障碍", "July": "七月", "[_1]_withdrawal_from_account_number_[_2]_to_[_3]_is_done__Transaction_ID:_[_4]": "已完成从账号[_2]至[_3]的[_1]提款。交易编号: [_4]交易编号：[_4]", "Indicative": "指示性", "Percentage": "百分比", "Asset": "资产" };
	texts_json['ZH_TW'] = { "Closes_early_(at_18:00)": "收盤提前（至18:00）", "June": "六月", "Japan": "日本", "Processing_your_request___": "您的要求在處理中...", "Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "您的取款限額為 [_1] [_2]（或其他貨幣的等值）。", "Real_Standard": "真實標準", "space": "空間", "October": "十月", "Please_select_the_checkbox_": "請選擇核取方塊。", "Only_letters,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "只允許字母、空格、連字號、句號和所有格號。", "Forex": "外匯", "Please_log_in_": "請登入。", "Contract_Confirmation": "合約確認", "Closed": "已收盤", "January": "一月", "Purchase_Time": "買入時間", "May": "五月", "Sale_Date": "賣出日期", "Password_should_have_lower_and_uppercase_letters_with_numbers_": "密碼須包含大小寫字母與數字。", "Ends_In/Out": "收盤價在「範圍之內/之外」", "Sorry,_an_error_occurred_while_processing_your_account_": "對不起，在處理您的帳戶時出錯。", "Barrier": "障礙", "April": "四月", "Profit_Table": "利潤表", "PM": "下午", "Aug": "八月", "Jun": "六月", "[_1]_[_2]_payout_if_[_3]_is_strictly_higher_than_or_equal_to_Barrier_at_close_on_[_4]_": "[_4]閉市時如果[_3]嚴格高於或相等於障礙價格，可獲取[_1] [_2] 賠付額。", "Should_be_more_than_[_1]": "必須大於[_1]", "[_1]_[_2]_payout_if_[_3]_goes_outside_of_low_and_high_values_of_Barrier_through_close_on_[_4]_": "[_4]閉市時如果[_3]價在障礙價格最低和最高價位範圍外，可獲取[_1] [_2] 賠付額。", "Amount": "金額", "Invalid_email_address": "無效的電子郵件地址", "Up/Down": "漲/跌", "Next": "下一頁", "March": "三月", "Please_check_the_above_form_for_pending_errors_": "請檢查以上表格是否有待定錯誤。", "Christmas_Day": "聖誕節", "[_1]_[_2]_payout_if_[_3]_does_not_touch_Barrier_through_close_on_[_4]_": "[_4]閉市時如果[_3]未觸及障礙價格，可獲取[_1] [_2]的賠付額。", "Closes": "收盤", "Matches/Differs": "相符/差異", "Mar": "三月", "Feb": "二月", "Tu": "星期二", "December": "十二月", "Please_accept_the_terms_and_conditions_": "請接受條款和條件。", "[_1]_and_[_2]_cannot_be_the_same_": "[_1] 和 [_2] 不可相同。", "Potential_Profit": "潛在利潤", "Congratulations!_Your_[_1]_Account_has_been_created_": "恭喜! 您已成功開立[_1]帳戶。", "You_should_enter_[_1]_characters_": "您必須輸入[_1]個字元。", "[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]": " [_1] [_2]已記入您的虛擬資金帳戶 [_3]", "Time_out_cannot_be_in_the_past_": "到期時間不可為過去式。", "Please_select_a_valid_date_": "請選擇有效日期。", "Your_changes_have_been_updated_successfully_": "您的更改已成功更新。", "You_have_not_granted_access_to_any_applications_": "您未獲權限存取任何應用程式。", "Please_[_1]complete_your_account_profile[_2]_to_lift_your_withdrawal_and_trading_limits_": "請[_1]完成帳戶資料[_2]，以提高取款和交易限額。", "Exit_Spot_Time": "退市現價時間", "Select_your_trade_type": "選取交易類型", "Time_out_cannot_be_more_than_6_weeks_": "到期時間不能大於6週。", "Failed": "失敗", "Sorry,_an_error_occurred_while_processing_your_request_": "對不起，在處理您的請求時發生錯誤。", "Saturday": "星期六", "Major_Pairs": "主要貨幣對", "You_have_sold_this_contract_at_[_1]_[_2]": "您已經以 [_1] [_2] 賣出此合約", "[_1]_[_2]_payout_if_[_3]_stays_between_low_and_high_values_of_Barrier_through_close_on_[_4]_": "[_4]閉市時如果[_3]在障礙價格最低和最高價位範圍內，可獲取[_1] [_2] 賠付額。", "Never": "從未", "[_1]_[_2]_payout_if_[_3]_ends_outside_low_and_high_values_of_Barrier_at_close_on_[_4]_": "[_4]閉市時如果[_3]平倉價在障礙價格最低和最高價位範圍外，可獲取[_1] [_2] 賠付額。", "Date": "日期", "Open": "開盤", "New_Year's_Day": "新年", "Real_Cent": "真實美分", "Real_STP": "真實STP", "Does_Not_Touch": "未觸及", "Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_": "您的密碼已成功重設。請用新密碼登入您的帳戶。", "All_markets_are_closed_now__Please_try_again_later_": "所有市場現已關閉。請稍後重試。", "Admin": "管理中心", "Rise/Fall": "「上漲/下跌」合約", "Return": "回報", "Invalid_amount,_maximum_is": "無效金額，最大是", "[_1]_[_2]_payout_if_[_3]_is_strictly_lower_than_Barrier_at_close_on_[_4]_": "[_4]閉市時如果[_3]嚴格低於障礙價格，可獲取[_1] [_2] 賠付額。", "New_password": "新密碼", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_": "因此您目前的即時最高取款額（要求您的帳戶有充足資金）為[_1] [_2]。", "This_feature_is_not_relevant_to_virtual-money_accounts_": "此功能不適用於虛擬資金帳戶。", "Your_changes_have_been_updated_": "您的更改已成功更新。", "Sorry,_account_signup_is_not_available_in_your_country__Please_contact_<a_href=\"[_1]\">customer_support</a>_for_more_information_": "對不起，您的國家不能註冊帳戶。欲知詳細資訊，請聯繫<a href=\"[_1]\">客服部</a>。", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_click_<a_href=\"[_1]\">here</a>_": "根據您的要求，您的收銀台已被鎖定- 如需解除鎖定，請點選<a href=\"[_1]\">此處</a>。", "Date_and_Time": "日期和時間", "Transaction_performed_by_[_1]_(App_ID:_[_2])": "交易執行者為[_1] (應用程式 ID: [_2])", "Total_Profit/Loss": "利潤/虧損合計", "Net_profit": "淨收益", "The_server_<a_href=\"[_1]\">endpoint</a>_is:_[_2]": "伺服器<a href=\"[_1]\">終端</a>是: [_2]", "Token": "權杖", "There_was_an_error": "出現錯誤", "Gaming_Account": "博彩帳戶", "Invalid_amount,_minimum_is": "無效金額，最小是", "The_main_password_of_account_number_[_1]_has_been_changed_": "[_1]帳號的主密碼已更改。", "Deposit": "存款", "The_two_passwords_that_you_entered_do_not_match_": "兩次輸入的密碼不相符。", "years": "年", "Fridays": "星期五", "Entry_spot": "入市現價", "Last_Used": "最近一次使用", "Please_select": "請選擇", "Today": "今天", "Weekday": "交易日", "Select_your_market": "選擇您的市場", "Never_Used": "從未使用過", "Sorry,_this_feature_is_available_to_virtual_accounts_only_": "對不起，此功能僅適用虛擬帳戶。", "Exclude_time_cannot_be_for_more_than_5_years_": "禁止時間不能超過5年。", "Thursday": "星期四", "Stays_Between": "位於區間之內", "Please_select_a_valid_time_": "請選擇有效時間。", "Ends_Between": "區間之內結束", "You_need_to_finish_all_20_questions_": "必須答覆全部20個問題。", "You_have_already_withdrawn_[_1]_[_2]_": "您已提取 [_1] [_2]。", "Digit": "數字期權", "This_is_a_staging_server_-_For_testing_purposes_only": "這是分期伺服器，僅用於測試目的", "Time_is_in_the_wrong_format_": "時間格式錯誤。", "Your_account_has_no_Login/Logout_activity_": "您的帳戶沒有登入/登出活動。", "Apr": "四月", "Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_": "您的 [_1] 天取款限額目前為 [_2] [_3]（或其他貨幣的等值）。", "[_1]_[_2]_payout_if_[_3]_ends_on_or_between_low_and_high_values_of_Barrier_at_close_on_[_4]_": "[_4]閉市時如果[_3]平倉價相等於或介於障礙價格最低和最高價位間，可獲取[_1] [_2] 賠付額。", "Charting_for_this_underlying_is_delayed": "此標的資產的圖表資料已延遲", "Nov": "十一月", "Start_time": "開始時間", "Please_set_your_30-day_turnover_limit_in_our_[_1]self-exclusion_facilities[_2]_to_remove_deposit_limits_": "請到[_1]自我限制工具[_2]設定30天交易限額，以移除存款限額。", "Select_market": "選擇市場", "Fr": "星期五", "Virtual_money_credit_to_account": "虛擬資金存入帳戶", "Jul": "七月", "from_[_1]_to_[_2]": "從[_1]到[_2]", "week": "週", "Please_set_[_1]country_of_residence[_2]_before_upgrading_to_a_real-money_account_": "升級到真實資金帳戶前請先設定[_1]居住國[_2]。", "Lower": "低於", "Chart": "圖表", "Previous": "之前", "Jan": "一月", "numbers": "號碼", "Waiting_for_entry_tick_": "等待買入價跳動。", "Please_select_a_value": "請選擇一個數值", "Your_token_has_expired__Please_click_[_1]here[_2]_to_restart_the_verification_process_": "您的權杖已過期。請點選[_1]此處[_2]重啟驗證程序。", "Remaining_Time": "剩餘時間", "Predict_the_direction<br_/>and_purchase": "預測價格走向<br />並購入", "Your_account_has_no_trading_activity_": "您的帳號沒有交易活動。", "New_token_created_": "已建立新權杖。", "Minute": "分鐘", "In/Out": "「範圍之內/之外」", "Reference_ID": "身份參考號", "Your_withdrawal_limit_is_[_1]_[_2]_": "您的取款限額是[_1] [_2]。", "This_contract_won": "此合約獲利", "Trade": "交易", "Entry_Spot": "入市現價", "Please_enter_an_integer_value": "請輸入整數", "Withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "您的帳戶現時無法取款。請聯繫 [_1]進行解鎖。", "When_you_click_\"OK\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_": "當您點選「OK」後，您將被禁止在此網站交易，直到選定期限結束為止。", "Mo": "星期一", "Balance": "餘額", "Lock_Cashier": "鎖定收銀台", "verification_token": "驗證權杖", "Only_letters,_numbers,_space,_hyphen,_period,_and_apostrophe_are_allowed_": "只允許使用字母、數字、空格、連字號、句號和所有格號。", "Delete": "刪除", "minute": "分鐘", "weeks": "週", "Tick": "跳動點", "Opens": "開盤", "Current_password": "目前密碼", "Indicative": "指示性", "Asset": "資產", "Percentage": "百分比", "September": "九月", "High_Barrier": "高障礙", "[_1]_withdrawal_from_account_number_[_2]_to_[_3]_is_done__Transaction_ID:_[_4]": "已完成從賬號[_2]至[_3]的[_1]提款。交易編號: [_4]", "July": "七月", "Settles": "結算", "Oct": "十月", "Should_be_a_valid_number": "必須是有效號碼", "Main_password": "主密碼", "Profit/Loss": "利潤/虧損", "Session_duration_limit_cannot_be_more_than_6_weeks_": "交易期持續時間限制不能大於6週。", "min": "最小", "Exit_spot": "退市現價", "Last_Digit_Stats": "最後數字的統計資料", "hour": "小時", "Demo": "展示", "Touches": "觸及", "Sep": "九月", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_": "您已提取 [_1] [_2] 的等值。", "month": "月份", "Dec": "十二月", "Scopes": "範圍", "Closes_early_(at_21:00)": "收盤提前（至21:00）", "Withdraw": "取款", "High_Barrier_([_1])": "高障礙([_1])", "Remaining_time": "剩餘時間", "Low_Barrier_([_1])": "低障礙 ([_1])", "Should_be_less_than_[_1]": "必須大於[_1]", "seconds": "秒", "hours": "小時", "End_time": "結束時間", "minutes": "分鐘", "Resale_not_offered": "不提供轉售", "Step": "步驟", "Spot": "現價", "We": "星期三", "Sorry,_this_feature_is_not_available_": "對不起，此功能不可用。", "This_symbol_is_not_active__Please_try_another_symbol_": "這是個非活躍符號。請試用另一符號。", "Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_": "合約將在我們伺服器收到要求時以當時的市場價格賣出。此價格可能會與報價有差異。", "There_was_some_invalid_character_in_an_input_field_": "某字欄的輸入字元無效。", "Start_Time": "開始時間", "Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_": "您從 [_3] 帳戶提取[_1] [_2] 到付款代理 [_4] 帳戶的要求已成功處理。", "[_1]_[_2]_payout_if_[_3]_touches_Barrier_through_close_on_[_4]_": "[_4]閉市時如果[_3]觸及障礙價格，可獲取[_1] [_2] 賠付額。", "Status": "狀況", "Virtual_Account": "虛擬帳戶", "Th": "星期四", "Monday": "星期一", "day": "天", "Profit": "利潤", "Long": "長倉", "Year": "年", "Only_letters,_numbers,_and_hyphen_are_allowed_": "只允許字母、數字和連字符。", "Update": "更新", "Hour": "小時", "Account_balance:": "帳戶餘額：", "Only_numbers,_space,_and_hyphen_are_allowed_": "只允許數字、空格和連字符。", "Final_price": "最終價格", "Sa": "星期六", "Equals": "等於", "Sell_time": "賣出時間", "Your_transaction_reference_number_is_[_1]": "您的交易號是 [_1]", "Portfolio": "投資組合", "Stays_In/Goes_Out": "「保持在範圍之內/超出範圍之外」", "[_1]Authenticate_your_account[_2]_now_to_take_full_advantage_of_all_withdrawal_options_available_": "立刻進行[_1]帳戶驗證[_2]，以獲得取款選項的所有優惠。", "Contract_is_not_started_yet": "合約尚未開始", "Old_password_is_wrong_": "舊密碼不正確。", "This_contract_lost": "此合約虧損", "Sunday": "星期日", "Duration": "期限", "Cashier": "收銀台", "Goes_Outside": "處於區間之外", "Are_you_sure_that_you_want_to_permanently_revoke_access_to_application": "確定要永久廢除應用程式存取權限嗎", "Real_Account": "真實帳戶", "Real_Volatility": "真實波動性", "Contract_Information": "合約確認", "Revoke_access": "撤銷存取權限", "Exclude_time_cannot_be_less_than_6_months_": "禁止時間不能少於6個月。", "Your_settings_have_been_updated_successfully_": "您的設定已成功更新。", "Payout": "賠付", "Browser": "瀏覽", "You_did_not_change_anything_": "您沒做任何更改。", "Please_<a_href=\"[_1]\">log_in</a>_to_view_this_page_": "要查看此頁面，請先<a href=\"[_1]\">登入</a>。", "Payments": "支付", "You_have_reached_the_rate_limit_of_requests_per_second__Please_try_later_": "您已達每秒鐘提呈請求的最高限率。請稍後重試。", "Adjust_trade_parameters": "調整交易參數", "Barrier_Change": "障礙變更", "email_address": "電子郵件地址", "View": "檢視", "Over/Under": "大於/小於", "Note": "備註", "mins": "分鐘", "Your_account_is_restricted__Kindly_[_1]contact_customer_support[_2]_for_assistance_": "您的帳戶已被限制交易。請[_1]聯繫客服部[_2]，以取得協助。", "Please_input_a_valid_date": "請輸入有效日期", "Sorry,_your_account_is_not_authorised_for_any_further_contract_purchases_": "對不起，您的帳戶沒有進一步買入任何合約的權限。", "Current": "目前", "months": "月份", "Upcoming_Events": "未來事件", "Please_select_a_payment_agent": "請選擇付款代理", "The_email_address_provided_is_already_in_use__If_you_forgot_your_password,_please_try_our_<a_href=\"[_1]\">password_recovery_tool</a>_or_contact_our_customer_service_": "所提供的電子郵件地址已經在使用。如果忘了密碼，請嘗試使用我們的<a href=\"[_1]\">密碼恢復工具</a>或聯繫客服部。", "Su": "星期日", "Resources": "資源", "[_1]_days_[_2]_hours_[_3]_minutes": "[_1] 天 [_2] 小時 [_3] 分鐘", "letters": "字母", "Upgrade_to_a_Financial_Account": "升級到金融帳戶", "[_1]_deposit_from_[_2]_to_account_number_[_3]_is_done__Transaction_ID:_[_4]": "已完成從[_2]至帳號[_3]的[_1]存款。交易編號: [_4]", "August": "八月", "Your_trading_statistics_since_[_1]_": "您自 [_1] 至今的交易統計。", "Are_you_sure_that_you_want_to_permanently_delete_token": "確定要永久刪除權杖嗎", "Please_[_1]accept_the_updated_Terms_and_Conditions[_2]_to_lift_your_withdrawal_and_trading_limits_": "請[_1]接受條款和條件[_2]，以提高存取款限額。", "Payment_Agent": "付款代理", "Buy_price": "買入價", "February": "二月", "Please_submit_a_valid_verification_token_": "請提交有效的驗證權杖。", "Contract_ID": "合約編號", "Total_Cost": "成本總計", "Only_[_1]_decimal_points_are_allowed_": "只允許小數點后%位。", "IP_Address": "IP地址", "today,_Fridays": "今天、週五", "Your_Application_is_Being_Processed_": "您的申請已經處理完成。", "Unlock_Cashier": "解鎖收銀台", "Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_": "根據您的請求，您的收銀台已被鎖定- 如需解除鎖定，請輸入密碼。", "Questions": "問題", "Higher/Lower": "「高於/低於」", "[_1]_Please_click_the_link_below_to_restart_the_password_recovery_process__If_you_require_further_assistance,_please_contact_our_Customer_Support_": "[_1] 請點選以下連結重啟密碼恢復過程。如需要幫助，請聯繫我們的客服部。", "Waiting_for_exit_tick_": "等待賣出價跳動。", "Statement": "帳單", "Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_": "您從[_3] 轉帳[_1][_2] 到[_4] 的要求已成功處理。", "details": "詳細資料", "Insufficient_balance_": "餘額不足。", "Contract_Expiry": "合約已到期", "Details": "詳細資料", "Action": "動作", "Stake": "投注資金", "There_was_a_problem_accessing_the_server_during_purchase_": "買入時伺服器存取出了問題。", "Exit_Spot": "退市現價", "Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_": "因此您目前的即時最高取款額（要求您的帳戶有充足資金）為 [_1] [_2]（或其他等值貨幣)。", "There_was_a_problem_accessing_the_server_": "伺服器存取出了問題。", "Barrier_([_1])": "障礙 ([_1])", "Now": "現在", "today": "今天", "Potential_Payout": "可能的賠付額", "Market_is_closed__Please_try_again_later_": "市場已關閉。請稍後重試。", "Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_": "您的帳戶已經得到完全驗證，且您的取款限額已經取消。", "Please_select_at_least_one_scope": "請選擇至少一個範圍", "Spot_Time": "現貨時間", "Description": "描述", "Ends_Outside": "區間之外結束", "Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_": "請依照此模式:3個數字，一破折號，接着是4個數字。", "Target": "目標", "End_Time": "結束時間", "The_Payment_Agent_facility_is_currently_not_available_in_your_country_": "目前您的國家無可用付款代理設施。", "Connection_error:_Please_check_your_internet_connection_": "連接錯誤:請檢查您的網絡連接。", "Investor_password": "投資者密碼", "Finish": "完成", "Asset_Index": "資產指數", "Select_your_underlying_asset": "選擇標的資產", "Ref_": "參考", "days": "天", "Only_[_1]_are_allowed_": "只允許 [_1] 。", "Sell": "賣出", "Deposits_and_withdrawal_for_your_account_is_not_allowed_at_this_moment__Please_contact_[_1]_to_unlock_it_": "您的帳戶現時無法存取款。請聯繫 [_1]進行解鎖。", "Upgrade_to_a_Real_Account": "升級到真實帳戶", "Verification_code_format_incorrect_": "驗證碼格式不正確。", "Name": "姓名", "Low_Barrier": "低障礙", "Your_transaction_reference_is": "您的交易參考號是", "Month": "月份", "second": "秒", "November": "十一月", "Your_account_is_currently_suspended__Only_withdrawals_are_now_permitted__For_further_information,_please_contact_[_1]_": "您的帳戶已被暫時禁用。現僅允許取款。欲知詳情，請聯繫[_1]。", "Permissions": "權限", "Loss": "虧損", "Create_Account": "開立帳戶", "Sale_Price": "賣出價格", "Time_out_must_be_after_today_": "到期時間必須在今日之後。", "Read": "閱讀", "Buy": "買入", "Day": "天", "Wednesday": "星期三", "Please_enter_a_number_between_[_1]_": "請輸入[_1]之間的數字。", "Short": "短倉", "An_additional_password_can_be_used_to_restrict_access_to_the_cashier_": "可使用額外密碼來限制對收銀台的存取。", "h": "小時", "Trading_Times": "交易時間", "Shop": "商店", "Not": "不", "Tuesday": "星期二", "Touch/No_Touch": "觸及/未觸及", "This_field_is_required_": "此為必填欄位。", "Number_of_ticks": "跳動點數目", "Your_token_has_expired__Please_click_<a_href=\"[_1]\">here</a>_to_restart_the_verification_process_": "您的權杖已過期。請點選<a href=\"[_1]\">此處</a>重啟驗證程序。", "Should_be_between_[_1]_and_[_2]": "須在[_1] 與 [_2]之間", "The_maximum_number_of_tokens_([_1])_has_been_reached_": "已達權杖 ([_1]) 最大限數。", "Password_is_not_strong_enough_": "密碼安全度不夠。", "Explanation": "說明", "Contract_Sold": "售出合約", "Investment_Account": "投資帳戶", "All_barriers_in_this_trading_window_are_expired": "此交易窗口的所有障礙已過期", "Higher": "高於", "Only_numbers_and_spaces_are_allowed_": "只允許數字和空格。", "Contract": "合約", "End_time_must_be_after_start_time_": "結束時間必須開始時間之後。", "year": "年", "Walkthrough_Guide": "攻略指南", "Purchase_Price": "買入價格", "Sell_at_market": "按市價賣出", "You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_": "過去 [_3] 天裡您已累計提取 [_1] [_2] 的等值。", "Price": "價格", "Even/Odd": "偶/奇", "Open_a_Financial_Account": "開設金融帳戶", "Current_Time": "目前時間", "Please_complete_the_[_1]financial_assessment_form[_2]_to_lift_your_withdrawal_and_trading_limits_": "請完成[_1]財務評估表格[_2]，以便提升您的取款和交易限額。", "Your_session_duration_limit_will_end_in_[_1]_seconds_": "交易期持續時間限制將於[_1]秒內結束。", "logout": "登出", "Successful": "成功", "Friday": "星期五", "Change_Password": "更改密碼", "Sorry,_you_have_entered_an_incorrect_cashier_password": "對不起，您輸入的收銀台密碼不正確", "Credit/Debit": "借記/貸記", "Minimum_of_[_1]_characters_required_": "需至少[_1] 個字元。", "AM": "上午" };

	module.exports = {
	    texts_json: texts_json
	};

/***/ },
/* 430 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Cookies = __webpack_require__(422);

	var emailRot13 = function emailRot13(str) {
	    return str.replace(/[a-zA-Z]/g, function (c) {
	        var c2 = c.charCodeAt(0) + 13;
	        return String.fromCharCode((c <= 'Z' ? 90 : 122) >= c2 ? c2 : c2 - 26);
	    });
	};

	// hide and show hedging value if trading purpose is set to hedging
	var detectHedging = function detectHedging($purpose, $hedging) {
	    $purpose.change(function () {
	        if ($purpose.val() === 'Hedging') {
	            $hedging.setVisibility(1);
	        } else {
	            $hedging.setVisibility(0);
	        }
	    });
	};

	var jqueryuiTabsToDropdown = function jqueryuiTabsToDropdown($container) {
	    var $ddl = $('<select/>');
	    $container.find('li a').each(function () {
	        $ddl.append($('<option/>', { text: $(this).text(), value: $(this).attr('href') }));
	    });
	    $ddl.change(function () {
	        $container.find('li a[href="' + $(this).val() + '"]').click();
	    });
	    return $ddl;
	};

	// use function to generate elements and append them
	// element is select and element to append is option
	var appendTextValueChild = function appendTextValueChild(element, text, value, disabled, el_class) {
	    if (element && !element.nodeName) {
	        if (typeof element === 'string') {
	            element = document.getElementById(element);
	        } else {
	            element = undefined;
	        }
	    }
	    if (!element) return;
	    element.appendChild(makeOption(text, value, disabled, el_class));
	};

	var makeOption = function makeOption(text, value, disabled, el_class) {
	    var option = document.createElement('option');
	    option.text = text;
	    // setting null value helps with detecting required error
	    // on 'Please select' options
	    // that have no value of their own
	    option.value = value || '';
	    if (disabled && disabled.toLowerCase() === 'disabled') {
	        option.setAttribute('disabled', 'disabled');
	    }
	    if (el_class) {
	        option.className = el_class;
	    }
	    return option;
	};

	/*
	 * function to check if element is visible or not
	 *
	 * alternative to jquery $('#id').is(':visible')
	 */
	var isVisible = function isVisible(elem) {
	    return !(!elem || elem.offsetWidth === 0 && elem.offsetHeight === 0);
	};

	/*
	 * function to check if browser supports the type date/time
	 * send a wrong val in case browser 'pretends' to support
	 */
	var checkInput = function checkInput(type, wrong_val) {
	    var input = document.createElement('input');
	    input.setAttribute('type', type);
	    input.setAttribute('value', wrong_val);
	    return input.value !== wrong_val;
	};

	/*
	 * function to check if new date is selected using native picker
	 * if yes, update the data-value. if no, return false.
	 */
	var dateValueChanged = function dateValueChanged(element, type) {
	    if (element.getAttribute('data-value') === element.value) {
	        return false;
	    }
	    if (element.getAttribute('type') === type) {
	        element.setAttribute('data-value', element.value);
	    }
	    return true;
	};

	var selectorExists = function selectorExists(element) {
	    return typeof element !== 'undefined' && element !== null;
	};

	var getSetElementValue = function getSetElementValue(element, text, type) {
	    // eslint-disable-line consistent-return
	    if (selectorExists(element)) {
	        if (typeof text === 'undefined') return element[type];
	        // else
	        element[type] = text;
	    }
	};

	module.exports = {
	    getLoginToken: function getLoginToken() {
	        return Cookies.get('login');
	    },
	    emailRot13: emailRot13,
	    detectHedging: detectHedging,
	    jqueryuiTabsToDropdown: jqueryuiTabsToDropdown,
	    appendTextValueChild: appendTextValueChild,
	    makeOption: makeOption,
	    isVisible: isVisible,
	    checkInput: checkInput,
	    dateValueChanged: dateValueChanged,
	    selectorExists: selectorExists,
	    elementTextContent: function elementTextContent(element, text) {
	        return getSetElementValue(element, text, 'textContent');
	    },
	    elementInnerHtml: function elementInnerHtml(element, text) {
	        return getSetElementValue(element, text, 'innerHTML');
	    }
	};

/***/ },
/* 431 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Cookies = __webpack_require__(422);

	/*
	 * Configuration values needed in js codes
	 *
	 * NOTE:
	 * Please use the following command to avoid accidentally committing personal changes
	 * git update-index --assume-unchanged src/javascript/config.js
	 *
	 */

	var getAppId = function getAppId() {
	    return window.localStorage.getItem('config.app_id') || (/staging\.binary\.com/i.test(window.location.hostname) ? '1098' : '3638');
	};

	var getSocketURL = function getSocketURL() {
	    var server_url = window.localStorage.getItem('config.server_url');
	    if (!server_url) {
	        var loginid = Cookies.get('loginid'),
	            isReal = loginid && !/^VRT/.test(loginid),
	            toGreenPercent = { real: 100, virtual: 0, logged_out: 0 },
	            // default percentage
	        categoryMap = ['real', 'virtual', 'logged_out'],
	            randomPercent = Math.random() * 100,
	            percentValues = Cookies.get('connection_setup'); // set by GTM

	        // override defaults by cookie values
	        if (percentValues && percentValues.indexOf(',') > 0) {
	            var cookie_percents = percentValues.split(',');
	            categoryMap.map(function (cat, idx) {
	                if (cookie_percents[idx] && !isNaN(cookie_percents[idx])) {
	                    toGreenPercent[cat] = +cookie_percents[idx].trim();
	                }
	            });
	        }

	        server_url = (/staging\.binary\.com/i.test(window.location.hostname) ? 'blue' : isReal ? randomPercent < toGreenPercent.real ? 'green' : 'blue' : loginid ? randomPercent < toGreenPercent.virtual ? 'green' : 'blue' : randomPercent < toGreenPercent.logged_out ? 'green' : 'blue') + '.binaryws.com';
	    }
	    return 'wss://' + server_url + '/websockets/v3';
	};

	module.exports = {
	    getAppId: getAppId,
	    getSocketURL: getSocketURL
	};

/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var localize = __webpack_require__(428).localize;
	var LocalStore = __webpack_require__(421).LocalStore;
	var formatMoney = __webpack_require__(433).formatMoney;

	var RealityCheckData = function () {
	    'use strict';

	    var reality_object = {};

	    var resetInvalid = function resetInvalid() {
	        var ack = get('ack');
	        var interval = +get('interval');
	        if (ack !== 0 && ack !== 1) {
	            set('ack', 0);
	        }
	        if (!interval) {
	            set('interval', 600000);
	        }
	    };

	    var summaryData = function summaryData(data) {
	        var start_time = moment.utc(new Date(data.start_time * 1000));
	        var current_time = moment.utc();

	        var session_duration = moment.duration(current_time.diff(start_time));
	        var duration_string = localize('[_1] days [_2] hours [_3] minutes', [session_duration.get('days'), session_duration.get('hours'), session_duration.get('minutes')]);

	        var turnover = +data.buy_amount + +data.sell_amount;
	        var profit_loss = +data.sell_amount - +data.buy_amount;

	        var start_time_string = localize('Your trading statistics since [_1].', [start_time.format('YYYY-MM-DD HH:mm:ss') + ' GMT']);
	        return {
	            start_time_string: start_time_string,
	            login_time: start_time.format('YYYY-MM-DD HH:mm:ss') + ' GMT',
	            current_time: current_time.format('YYYY-MM-DD HH:mm:ss') + ' GMT',
	            session_duration: duration_string,
	            loginid: data.loginid,
	            currency: data.currency,
	            turnover: formatMoney(data.currency, +turnover, 1),
	            profit_loss: formatMoney(data.currency, +profit_loss, 1),
	            contracts_bought: data.buy_count,
	            contracts_sold: data.sell_count,
	            open_contracts: data.open_contract_count,
	            potential_profit: formatMoney(data.currency, +data.potential_profit, 1)
	        };
	    };

	    var set = function set(key, value) {
	        reality_object[key] = value;
	        return LocalStore.set('client.reality_check.' + key, value);
	    };

	    // use this function to get variables that have values
	    var get = function get(key) {
	        var value = reality_object[key] || LocalStore.get('client.reality_check.' + key) || '';
	        if (+value === 1 || +value === 0 || value === 'true' || value === 'false') {
	            value = JSON.parse(value || false);
	        }
	        return value;
	    };

	    var clear_storage_values = function clear_storage_values() {
	        // clear all reality check values from local storage
	        Object.keys(localStorage).forEach(function (c) {
	            if (/^client\.reality_check\./.test(c)) {
	                LocalStore.set(c, '');
	            }
	        });
	    };

	    return {
	        resetInvalid: resetInvalid,
	        summaryData: summaryData,
	        set: set,
	        get: get,
	        clear: clear_storage_values
	    };
	}();

	module.exports = RealityCheckData;

/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var jpClient = __webpack_require__(425).jpClient;
	var getLanguage = __webpack_require__(424).get;

	var formatMoney = function formatMoney(currency_value, amount, exclude_currency) {
	    var is_bitcoin = /xbt/i.test(currency_value);
	    var is_jp = jpClient();
	    var decimal_places = is_bitcoin ? 6 : is_jp ? 0 : 2;
	    var money = void 0;
	    if (amount) amount = String(amount).replace(/,/g, '');
	    if (typeof Intl !== 'undefined' && currency_value && !is_bitcoin && amount) {
	        var options = exclude_currency ? { minimumFractionDigits: decimal_places, maximumFractionDigits: decimal_places } : { style: 'currency', currency: currency_value };
	        var language = getLanguage().toLowerCase();
	        money = new Intl.NumberFormat(language.replace('_', '-'), options).format(amount);
	    } else {
	        var updated_amount = void 0,
	            sign = '';
	        if (is_jp) {
	            updated_amount = parseInt(amount);
	            if (Number(updated_amount) < 0) {
	                sign = '-';
	            }
	        } else {
	            updated_amount = parseFloat(amount).toFixed(decimal_places);
	        }
	        updated_amount = addComma(updated_amount, decimal_places);
	        if (exclude_currency) {
	            money = updated_amount;
	        } else {
	            var symbol = map_currency[currency_value];
	            money = symbol ? sign + symbol + updated_amount : currency_value + ' ' + updated_amount;
	        }
	    }
	    return money;
	};

	var addComma = function addComma(num, decimal_points) {
	    var number = String(num || 0).replace(/,/g, '') * 1;
	    return number.toFixed(decimal_points || 2).toString().replace(/(^|[^\w.])(\d{4,})/g, function ($0, $1, $2) {
	        return $1 + $2.replace(/\d(?=(?:\d\d\d)+(?!\d))/g, '$&,');
	    });
	};

	// Taken with modifications from:
	//    https://github.com/bengourley/currency-symbol-map/blob/master/map.js
	// When we need to handle more currencies please look there.
	var map_currency = {
	    USD: '$',
	    GBP: '£',
	    AUD: 'A$',
	    EUR: '€',
	    JPY: '¥',
	    XBT: '₿'
	};

	module.exports = {
	    formatMoney: formatMoney,
	    formatCurrency: function formatCurrency(currency) {
	        return map_currency[currency];
	    }
	};

/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var localize = __webpack_require__(428).localize;

	/*
	 * Notifications manages various notification messages
	 *
	 */

	var MBNotifications = function () {
	    'use strict';

	    /*
	     * options: Object {
	     *     text       : {string}  message text to display
	     *     uid        : {string}  unique id to prevent duplicating the same message and also used to hide the message
	     *     dismissible: {boolean} dismissible messages can be hidden by client
	     * }
	     */

	    var showErrorMessage = function showErrorMessage(options) {
	        var $note_wrapper = getContainer();
	        var $this_uid = $note_wrapper.find('#' + options.uid);

	        if (!options.uid || $this_uid.length === 0) {
	            $note_wrapper.prepend(generateMessage(options));
	        } else if ($this_uid.html() !== options.text) {
	            $this_uid.replaceWith(generateMessage(options));
	        }

	        $.scrollTo($note_wrapper, 500, { offset: -5 });
	        hideSpinnerShowTrading();
	    };

	    var generateMessage = function generateMessage(options) {
	        var $message = $('<div class="notice-msg center-text' + (options.dismissible ? ' dismissible' : '') + '"\n            ' + (options.uid ? ' id="' + options.uid + '"' : '') + '>' + localize(options.text) + '\n                ' + (options.dismissible ? '<div class="notification-dismiss">x</div>' : '') + '\n            </div>');

	        if (options.dismissible) {
	            $message.click(function () {
	                dismissMessage(this);
	            });
	        }

	        return $message;
	    };

	    var hideErrorMessage = function hideErrorMessage(uid) {
	        if (uid) {
	            getContainer().find('#' + uid).remove();
	        }
	    };

	    var dismissMessage = function dismissMessage(obj) {
	        $(obj).remove();
	    };

	    var getContainer = function getContainer() {
	        return $('#notifications_wrapper');
	    };

	    var hideSpinnerShowTrading = function hideSpinnerShowTrading() {
	        $('.barspinner').setVisibility(0);
	        $('.mb-trading-wrapper').setVisibility(1);
	    };

	    return {
	        show: showErrorMessage,
	        hide: hideErrorMessage,

	        hideSpinnerShowTrading: hideSpinnerShowTrading
	    };
	}();

	module.exports = MBNotifications;

/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var ViewPopupUI = __webpack_require__(436);
	var BinarySocket = __webpack_require__(427);
	var Highchart = __webpack_require__(438);
	var TickDisplay = __webpack_require__(460);
	var showLocalTimeOnHover = __webpack_require__(463).showLocalTimeOnHover;
	var toJapanTimeIfNeeded = __webpack_require__(463).toJapanTimeIfNeeded;
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var isEmptyObject = __webpack_require__(417).isEmptyObject;
	var formatMoney = __webpack_require__(433).formatMoney;

	var ViewPopup = function () {
	    'use strict';

	    var contract_id = void 0,
	        contract = void 0,
	        is_sold = void 0,
	        is_sell_clicked = void 0,
	        chart_started = void 0,
	        chart_init = void 0,
	        chart_updated = void 0;
	    var $container = void 0,
	        $loading = void 0,
	        btn_view = void 0;

	    var popupbox_id = 'inpage_popup_content_box';
	    var wrapper_id = 'sell_content_wrapper';
	    var hidden_class = 'invisible';

	    var init = function init(button) {
	        btn_view = button;
	        contract_id = $(btn_view).attr('contract_id');
	        contract = {};
	        is_sold = false;
	        is_sell_clicked = false;
	        chart_started = false;
	        chart_init = false;
	        chart_updated = false;
	        $container = '';

	        if (btn_view) {
	            ViewPopupUI.disableButton($(btn_view));
	            ViewPopupUI.cleanup();
	        }

	        getContract();

	        setLoadingState(true);
	    };

	    var responseContract = function responseContract(response) {
	        if (!response.proposal_open_contract || isEmptyObject(response.proposal_open_contract)) {
	            showErrorPopup(response);
	            return;
	        }
	        // In case of error such as legacy shortcode, this call is returning the error message
	        // but no error field. To specify those cases, we check for other fields existence
	        if (!response.proposal_open_contract.hasOwnProperty('shortcode')) {
	            showErrorPopup(response, response.proposal_open_contract.validation_error);
	            return;
	        }

	        $.extend(contract, response.proposal_open_contract);

	        if (contract && document.getElementById(wrapper_id)) {
	            update();
	            return;
	        }

	        showContract();
	    };

	    var showContract = function showContract() {
	        setLoadingState(false);

	        if (!$container) {
	            $container = makeTemplate();
	        }

	        containerSetText('trade_details_contract_id', contract.contract_id);

	        containerSetText('trade_details_start_date', toJapanTimeIfNeeded(epochToDateTime(contract.date_start)));
	        if (document.getElementById('trade_details_end_date')) containerSetText('trade_details_end_date', toJapanTimeIfNeeded(epochToDateTime(contract.date_expiry)));
	        containerSetText('trade_details_payout', formatMoney(contract.currency, contract.payout));
	        containerSetText('trade_details_purchase_price', formatMoney(contract.currency, contract.buy_price));

	        updateTimers();
	        update();
	        ViewPopupUI.repositionConfirmation();

	        if (State.get('is_mb_trading')) {
	            State.call('ViewPopup.onDisplayed');
	        }
	    };

	    var update = function update() {
	        var final_price = contract.sell_price || contract.bid_price;
	        var is_started = !contract.is_forward_starting || contract.current_spot_time > contract.date_start;
	        var user_sold = contract.sell_time && contract.sell_time < contract.date_expiry;
	        var is_ended = contract.is_settleable || contract.is_sold || user_sold;
	        var indicative_price = final_price && is_ended ? contract.sell_price || contract.bid_price : contract.bid_price ? contract.bid_price : null;

	        if (contract.barrier_count > 1) {
	            containerSetText('trade_details_barrier', contract.high_barrier, '', true);
	            containerSetText('trade_details_barrier_low', contract.low_barrier, '', true);
	        } else if (contract.barrier) {
	            containerSetText('trade_details_barrier', contract.entry_tick_time ? contract.contract_type === 'DIGITMATCH' ? localize('Equals') + ' ' + contract.barrier : contract.contract_type === 'DIGITDIFF' ? localize('Not') + ' ' + contract.barrier : contract.barrier : '-', '', true);
	        }

	        var current_spot = !is_ended ? contract.current_spot : user_sold ? '' : contract.exit_tick;
	        var current_spot_time = !is_ended ? contract.current_spot_time : user_sold ? '' : contract.exit_tick_time;

	        if (current_spot) {
	            containerSetText('trade_details_current_spot', current_spot);
	        } else {
	            $('#trade_details_current_spot').parent().setVisibility(0);
	        }

	        if (current_spot_time) {
	            containerSetText('trade_details_current_date', toJapanTimeIfNeeded(epochToDateTime(current_spot_time)));
	        } else {
	            $('#trade_details_current_date').parent().setVisibility(0);
	        }

	        containerSetText('trade_details_ref_id', contract.transaction_ids.buy + (contract.transaction_ids.sell ? ' - ' + contract.transaction_ids.sell : ''));
	        containerSetText('trade_details_indicative_price', indicative_price ? formatMoney(contract.currency, indicative_price) : '-');

	        var profit_loss = void 0,
	            percentage = void 0;

	        if (final_price) {
	            profit_loss = final_price - contract.buy_price;
	            percentage = formatMoney(contract.currency, profit_loss * 100 / contract.buy_price, 1);
	            containerSetText('trade_details_profit_loss', formatMoney(contract.currency, profit_loss) + '<span>(' + (percentage > 0 ? '+' : '') + percentage + '%)</span>', { class: profit_loss >= 0 ? 'profit' : 'loss' });
	        } else {
	            containerSetText('trade_details_profit_loss', '-', { class: 'loss' });
	        }

	        if (!is_started) {
	            containerSetText('trade_details_entry_spot', '-');
	            containerSetText('trade_details_message', localize('Contract is not started yet'));
	        } else {
	            if (contract.entry_spot > 0) {
	                containerSetText('trade_details_entry_spot', contract.entry_spot);
	            }
	            containerSetText('trade_details_message', contract.validation_error ? contract.validation_error : '&nbsp;');
	        }

	        if (!chart_started && !contract.tick_count) {
	            if (!chart_init) {
	                chart_init = true;
	                Highchart.showChart(contract);
	            }
	            Highchart.showChart(contract, 'update');
	            if (contract.entry_tick_time) {
	                chart_started = true;
	            }
	        } else if (contract.tick_count && !chart_updated) {
	            TickDisplay.updateChart('', contract);
	            chart_updated = true;
	        }

	        if (!is_sold && user_sold) {
	            is_sold = true;
	            if (!contract.tick_count) Highchart.showChart(contract, 'update');
	        }
	        if (is_ended) {
	            contractEnded(parseFloat(profit_loss) >= 0);
	            if (contract.is_valid_to_sell && contract.is_settleable && !contract.is_sold && !is_sell_clicked) {
	                ViewPopupUI.forgetStreams();
	                BinarySocket.send({ sell_expired: 1 }).then(function (response) {
	                    getContract(response);
	                });
	            }
	            if (!contract.tick_count) Highchart.showChart(contract, 'update');
	        }

	        if (!contract.is_valid_to_sell) {
	            $container.find('#errMsg').setVisibility(0);
	        }

	        sellSetVisibility(!is_sell_clicked && !is_sold && !is_ended && +contract.is_valid_to_sell === 1);
	        contract.chart_validation_error = contract.validation_error;
	        contract.validation_error = '';
	    };

	    var updateTimers = function updateTimers() {
	        var update_time = function update_time() {
	            var now = Math.max(Math.ceil((window.time || 0) / 1000), contract.current_spot_time || 0);
	            containerSetText('trade_details_live_date', toJapanTimeIfNeeded(epochToDateTime(now)));
	            showLocalTimeOnHover('#trade_details_live_date');

	            var is_started = !contract.is_forward_starting || contract.current_spot_time > contract.date_start;
	            var is_ended = contract.is_settleable || contract.is_sold;
	            if ((!is_started || is_ended || now >= contract.date_expiry) && document.getElementById('trade_details_live_remaining')) {
	                containerSetText('trade_details_live_remaining', '-');
	            } else {
	                var remained = contract.date_expiry - now,
	                    days = 0;
	                var day_seconds = 24 * 60 * 60;
	                if (remained > day_seconds) {
	                    days = Math.floor(remained / day_seconds);
	                    remained %= day_seconds;
	                }
	                if (document.getElementById('trade_details_live_remaining')) {
	                    containerSetText('trade_details_live_remaining', (days > 0 ? days + ' ' + localize(days > 1 ? 'days' : 'day') + ', ' : '') + moment(remained * 1000).utc().format('HH:mm:ss'));
	                }
	            }
	        };
	        update_time();

	        clearInterval(window.ViewPopupTimerInterval);
	        window.ViewPopupTimerInterval = setInterval(update_time, 500);
	    };

	    var contractEnded = function contractEnded() {
	        containerSetText('trade_details_current_title', localize(contract.sell_spot_time < contract.date_expiry ? 'Contract Sold' : 'Contract Expiry'));
	        containerSetText('trade_details_spot_label', localize('Exit Spot'));
	        containerSetText('trade_details_spottime_label', localize('Exit Spot Time'));
	        containerSetText('trade_details_indicative_label', localize('Price'));
	        // show validation error if contract is not settled yet
	        if (!(contract.is_settleable && !contract.is_sold)) {
	            containerSetText('trade_details_message', '&nbsp;');
	        }
	        $container.find('#errMsg').setVisibility(0);
	        sellSetVisibility(false);
	        // showWinLossStatus(is_win);
	    };

	    var makeTemplate = function makeTemplate() {
	        $container = $('<div/>').append($('<div/>', { id: wrapper_id }));

	        var longcode = contract.longcode;

	        $container.prepend($('<div/>', { id: 'sell_bet_desc', class: 'popup_bet_desc drag-handle', text: longcode }));
	        var $sections = $('<div/>').append($('<div class="gr-row container"><div id="sell_details_chart_wrapper" class="gr-8 gr-12-m"></div><div id="sell_details_table" class="gr-4 gr-12-m"></div></div>'));

	        $sections.find('#sell_details_table').append($('<table>\n            <tr id="contract_tabs"><th colspan="2" id="contract_information_tab">' + localize('Contract Information') + '</th></tr>\n            <tbody id="contract_information_content">\n            ' + createRow('Contract ID', '', 'trade_details_contract_id') + '\n            ' + createRow('Reference ID', '', 'trade_details_ref_id') + '\n            ' + createRow('Start Time', '', 'trade_details_start_date') + '\n            ' + (!contract.tick_count ? createRow('End Time', '', 'trade_details_end_date') + createRow('Remaining Time', '', 'trade_details_live_remaining') : '') + '\n            ' + createRow('Entry Spot', '', 'trade_details_entry_spot') + '\n            ' + createRow(contract.barrier_count > 1 ? 'High Barrier' : /^DIGIT(MATCH|DIFF)$/.test(contract.contract_type) ? 'Target' : 'Barrier', '', 'trade_details_barrier', true) + '\n            ' + (contract.barrier_count > 1 ? createRow('Low Barrier', '', 'trade_details_barrier_low', true) : '') + '\n            ' + createRow('Potential Payout', '', 'trade_details_payout') + '\n            ' + createRow('Purchase Price', '', 'trade_details_purchase_price') + '\n            </tbody>\n            <th colspan="2" id="barrier_change" class="invisible">' + localize('Barrier Change') + '</th>\n            <tbody id="barrier_change_content" class="invisible"></tbody>\n            <tr><th colspan="2" id="trade_details_current_title">' + localize('Current') + '</th></tr>\n            <tbody id="trade_information_content">\n            ' + createRow('Spot', 'trade_details_spot_label', 'trade_details_current_spot') + '\n            ' + createRow('Spot Time', 'trade_details_spottime_label', 'trade_details_current_date') + '\n            ' + createRow('Current Time', '', 'trade_details_live_date') + '\n            ' + createRow('Indicative', 'trade_details_indicative_label', 'trade_details_indicative_price') + '\n            ' + createRow('Profit/Loss', '', 'trade_details_profit_loss') + '\n            <tr><td colspan="2" class="last_cell" id="trade_details_message">&nbsp;</td></tr>\n            </tbody>\n            </table>\n            <div id="errMsg" class="notice-msg ' + hidden_class + '"></div>\n            <div id="trade_details_bottom"><div id="contract_sell_wrapper" class="' + hidden_class + '"></div><div id="contract_sell_message"></div><div id="contract_win_status" class="' + hidden_class + '"></div></div>'));

	        $sections.find('#sell_details_chart_wrapper').html($('<div/>', { id: contract.tick_count ? 'tick_chart' : 'analysis_live_chart', class: 'live_chart_wrapper' }));

	        $container.find('#' + wrapper_id).append($sections.html()).append($('<div/>', { id: 'errMsg', class: 'notice-msg ' + hidden_class }));

	        ViewPopupUI.showInpagePopup('<div class="' + popupbox_id + '">' + $container.html() + '</div>', '', '#sell_bet_desc');
	        return $('#' + wrapper_id);
	    };

	    var createRow = function createRow(label, label_id, value_id, is_hidden, value) {
	        return '<tr' + (is_hidden ? ' class="' + hidden_class + '"' : '') + '><td' + (label_id ? ' id="' + label_id + '"' : '') + '>' + localize(label) + '</td><td' + (value_id ? ' id="' + value_id + '"' : '') + '>' + (value || '') + '</td></tr>';
	    };

	    var epochToDateTime = function epochToDateTime(epoch) {
	        return moment.utc(epoch * 1000).format('YYYY-MM-DD HH:mm:ss');
	    };

	    // ===== Tools =====
	    var containerSetText = function containerSetText(id, string, attributes, is_visible) {
	        if (!$container || $container.length === 0) {
	            $container = $('#' + wrapper_id);
	        }

	        var $target = $container.find('#' + id);
	        if ($target && $target.length > 0) {
	            $target.html(string);
	            if (attributes) $target.attr(attributes);
	            if (is_visible) $target.parent('tr').setVisibility(1);
	        }
	    };

	    var setLoadingState = function setLoadingState(show_loading) {
	        if (show_loading) {
	            $loading = $('#trading_init_progress');
	            if ($loading.length) {
	                $loading.show();
	            }
	        } else {
	            if ($loading.length) {
	                $loading.hide();
	            }
	            if (btn_view) {
	                ViewPopupUI.enableButton($(btn_view));
	            }
	        }
	    };

	    var showMessagePopup = function showMessagePopup(message, title, msg_class) {
	        setLoadingState(false);
	        var $con = $('<div/>');
	        $con.prepend($('<div/>', { id: 'sell_bet_desc', class: 'popup_bet_desc drag-handle', text: localize(title) }));
	        $con.append($('<div/>', { id: wrapper_id }).append($('<div/>', { class: msg_class, html: localize(message) })));
	        ViewPopupUI.showInpagePopup('<div class="' + popupbox_id + '">' + $con.html() + '</div>', 'message_popup', '#sell_bet_desc');
	    };

	    var showErrorPopup = function showErrorPopup(response, message) {
	        message = message || 'Sorry, an error occurred while processing your request.';
	        showMessagePopup(localize(message), 'There was an error', 'notice-msg');
	        console.log(response);
	    };

	    var sellSetVisibility = function sellSetVisibility(show) {
	        var sell_wrapper_id = 'sell_at_market_wrapper';
	        var sell_button_id = 'sell_at_market';
	        var is_exist = $container.find('#' + sell_wrapper_id).length > 0;
	        if (show) {
	            if (is_exist) return;

	            $container.find('#contract_sell_wrapper').setVisibility(1).append($('<div/>', { id: sell_wrapper_id }).append($('<button/>', { id: sell_button_id, class: 'button', text: localize('Sell at market') })).append($('<div/>', { class: 'note' }).append($('<strong/>', { text: localize('Note') + ': ' })).append($('<span/>', { text: localize('Contract will be sold at the prevailing market price when the request is received by our servers. This price may differ from the indicated price.') }))));

	            $container.find('#' + sell_button_id).unbind('click').click(function (e) {
	                e.preventDefault();
	                e.stopPropagation();
	                is_sell_clicked = true;
	                sellSetVisibility(false);
	                BinarySocket.send({ sell: contract_id, price: contract.bid_price }).then(function (response) {
	                    responseSell(response);
	                });
	            });
	        } else {
	            if (!is_exist) return;
	            $container.find('#' + sell_button_id).unbind('click');
	            $container.find('#' + sell_wrapper_id).remove();
	        }
	    };

	    // ===== Requests & Responses =====
	    // ----- Get Contract -----
	    var getContract = function getContract(option) {
	        if (contract_id) {
	            ViewPopupUI.forgetStreams();
	            var req = {
	                proposal_open_contract: 1,
	                contract_id: contract_id,
	                subscribe: 1
	            };
	            if (option === 'no-subscribe') delete req.subscribe;
	            BinarySocket.send(req, { callback: responseProposal });
	        }
	    };

	    var responseSell = function responseSell(response) {
	        if (response.hasOwnProperty('error')) {
	            if (response.error.code === 'NoOpenPosition') {
	                getContract();
	            } else {
	                $container.find('#errMsg').text(response.error.message).setVisibility(1);
	            }
	            sellSetVisibility(true);
	            is_sell_clicked = false;
	            return;
	        }
	        ViewPopupUI.forgetStreams();
	        $container.find('#errMsg').setVisibility(0);
	        sellSetVisibility(false);
	        if (is_sell_clicked) {
	            containerSetText('contract_sell_message', localize('You have sold this contract at [_1] [_2]', [contract.currency, response.sell.sold_for]) + '\n                <br />\n                ' + localize('Your transaction reference number is [_1]', [response.sell.transaction_id]));
	        }
	        getContract('no-subscribe');
	    };

	    var responseProposal = function responseProposal(response) {
	        if (response.error) {
	            if (response.error.code !== 'AlreadySubscribed' && response.echo_req.contract_id === contract_id) {
	                showErrorPopup(response, response.error.message);
	            }
	            return;
	        }
	        if (response.proposal_open_contract.contract_id === contract_id) {
	            ViewPopupUI.storeSubscriptionID(response.proposal_open_contract.id);
	            responseContract(response);
	        } else {
	            BinarySocket.send({ forget: response.proposal_open_contract.id });
	        }
	        var dates = ['#trade_details_start_date', '#trade_details_end_date', '#trade_details_current_date', '#trade_details_live_date'];
	        for (var i = 0; i < dates.length; i++) {
	            showLocalTimeOnHover(dates[i]);
	            $(dates[i]).attr('data-balloon-pos', 'left');
	        }
	    };

	    var viewOnClick = function viewOnClick(container_selector) {
	        $(container_selector).on('click', '.open_contract_details', function (e) {
	            e.preventDefault();
	            init(this);
	        });
	    };

	    var viewButtonOnClick = function viewButtonOnClick(container_selector) {
	        $(container_selector).on('click', '.open_contract_details', function (e) {
	            e.preventDefault();
	            init(this);
	        });
	    };

	    return {
	        init: init,
	        viewButtonOnClick: viewButtonOnClick,
	        viewOnClick: viewOnClick
	    };
	}();

	module.exports = ViewPopup;

/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var MBDefaults = __webpack_require__(416);
	var Defaults = __webpack_require__(437);
	var BinarySocket = __webpack_require__(427);
	var State = __webpack_require__(421).State;
	var getHighestZIndex = __webpack_require__(417).getHighestZIndex;

	var ViewPopupUI = function () {
	    'use strict';

	    var $container = void 0,
	        stream_ids = void 0,
	        chart_stream_ids = void 0,
	        chart_underlying = void 0;

	    var init = function init() {
	        $container = null;
	    };

	    var container = function container(refresh) {
	        if (refresh) {
	            if ($container) {
	                $container.remove();
	            }
	            $container = null;
	        }
	        if (!$container) {
	            var $con = $('<div class="inpage_popup_container" id="sell_popup_container"><a class="close"></a><div class="inpage_popup_content"></div></div>');
	            $con.hide();
	            var onClose = function onClose() {
	                cleanup();
	                $(document).off('keydown');
	                $(window).off('popstate', onClose);
	            };
	            $con.find('a.close').on('click', onClose);
	            $(document).on('keydown', function (e) {
	                if (e.which === 27) onClose();
	            });
	            $(window).on('popstate', onClose);
	            $container = $con;
	        }
	        return $container;
	    };

	    var cleanup = function cleanup() {
	        forgetStreams();
	        forgetChartStreams();
	        clearTimer();
	        closeContainer();
	        init();
	        $(window).off('resize', function () {
	            repositionConfirmation();
	        });
	    };

	    var forgetStreams = function forgetStreams() {
	        while (stream_ids && stream_ids.length > 0) {
	            var id = stream_ids.pop();
	            if (id && id.length > 0) {
	                BinarySocket.send({ forget: id });
	            }
	        }
	    };

	    var forgetChartStreams = function forgetChartStreams() {
	        if (State.get('is_trading') || State.get('is_mb_trading') || State.get('is_beta_trading')) {
	            var underlying = State.get('is_mb_trading') ? MBDefaults.get('underlying') : Defaults.get('underlying');
	            if (underlying === chart_underlying) {
	                return;
	            }
	        }
	        while (chart_stream_ids && chart_stream_ids.length > 0) {
	            var id = chart_stream_ids.pop();
	            if (id && id.length > 0) {
	                BinarySocket.send({ forget: id });
	            }
	        }
	    };

	    var clearTimer = function clearTimer() {
	        if (window.ViewPopupTimerInterval) {
	            clearInterval(window.ViewPopupTimerInterval);
	            window.ViewPopupTimerInterval = undefined;
	        }
	    };

	    var closeContainer = function closeContainer() {
	        if ($container) {
	            $container.hide().remove();
	            $('.popup_page_overlay').hide().remove();
	            $container = null;
	        }
	        $('html').removeClass('no-scroll');
	    };

	    var disableButton = function disableButton(button) {
	        $('.open_contract_details[disabled]').each(function () {
	            enableButton($(this));
	        });
	        button.attr('disabled', 'disabled');
	        button.fadeTo(0, 0.5);
	    };

	    var enableButton = function enableButton(button) {
	        button.removeAttr('disabled');
	        button.fadeTo(0, 1);
	    };

	    var showInpagePopup = function showInpagePopup(data, containerClass, dragHandle) {
	        var con = container(true);
	        if (containerClass) {
	            con.addClass(containerClass);
	        }
	        if (data) {
	            $('.inpage_popup_content', con).html(data);
	        }

	        var body = $(document.body);
	        con.css('position', 'fixed').css('z-index', getHighestZIndex() + 100);
	        body.append(con);
	        con.show();
	        $('#contract_tabs').click(function () {
	            $('#contract_information_content').toggle();
	        });
	        $('#trade_details_current_title').click(function () {
	            $('#trade_information_content').toggle();
	        });
	        // $('html').addClass('no-scroll');
	        $(document.body).append($('<div/>', { class: 'popup_page_overlay' }));
	        $('.popup_page_overlay').click(function () {
	            container().find('a.close').click();
	        });
	        con.draggable({
	            stop: function stop() {
	                repositionConfirmationOnDrag();
	            },
	            handle: dragHandle,
	            scroll: false
	        });
	        $(dragHandle).disableSelection();
	        repositionConfirmation();
	        $(window).resize(function () {
	            repositionConfirmation();
	        });
	        return con;
	    };

	    var repositionConfirmationOnDrag = function repositionConfirmationOnDrag() {
	        var con = container();
	        var offset = con.offset();
	        var win_ = $(window);
	        // top
	        if (offset.top < win_.scrollTop()) {
	            con.offset({ top: win_.scrollTop() });
	        }
	        // left
	        if (offset.left < 0) {
	            con.offset({ left: 0 });
	        }
	        // right
	        if (offset.left > win_.width() - con.width()) {
	            con.offset({ left: win_.width() - con.width() });
	        }
	    };

	    var repositionConfirmation = function repositionConfirmation(x, y) {
	        var con = container();
	        var win_ = $(window);
	        var x_min = 0,
	            y_min = 500;
	        if (win_.width() < 767) {
	            // To be responsive, on mobiles and phablets we show popup as full screen.
	            x_min = 0;
	            y_min = 0;
	        }
	        if (x === undefined) {
	            x = Math.max(Math.floor((win_.width() - win_.scrollLeft() - con.width()) / 2), x_min) + win_.scrollLeft();
	        }
	        if (y === undefined) {
	            y = Math.min(Math.floor((win_.height() - con.height()) / 2), y_min) + win_.scrollTop();
	            if (y < win_.scrollTop()) {
	                y = win_.scrollTop();
	            }
	        }
	        con.offset({ left: x, top: y });
	        repositionConfirmationOnDrag();
	    };

	    // ===== Dispatch =====
	    var storeSubscriptionID = function storeSubscriptionID(id, underlying) {
	        if (!stream_ids && !underlying) {
	            stream_ids = [];
	        }
	        if (!chart_stream_ids) {
	            chart_stream_ids = [];
	        }
	        if (underlying) {
	            chart_underlying = underlying;
	        }
	        if (id && id.length > 0) {
	            if (!underlying && $.inArray(id, stream_ids) < 0) {
	                stream_ids.push(id);
	            } else if (underlying && $.inArray(id, chart_stream_ids) < 0) {
	                chart_stream_ids.push(id);
	            }
	        }
	    };

	    return {
	        cleanup: cleanup,
	        forgetStreams: forgetStreams,
	        disableButton: disableButton,
	        enableButton: enableButton,
	        showInpagePopup: showInpagePopup,
	        repositionConfirmation: repositionConfirmation,
	        storeSubscriptionID: storeSubscriptionID
	    };
	}();

	module.exports = ViewPopupUI;

/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Url = __webpack_require__(423);
	var isEmptyObject = __webpack_require__(417).isEmptyObject;
	var isVisible = __webpack_require__(430).isVisible;
	var State = __webpack_require__(421).State;

	/*
	 * Handles trading page default values
	 *
	 * Priorities:
	 * 1. Client's input: on each change to form, it will reflect to both query string & session storage
	 * 2. Query string parameters: will change session storage values
	 * 3. Session storage values: if none of the above, it will be the source
	 *
	 */

	var Defaults = function () {
	    'use strict';

	    var params = {};
	    var getDefault = function getDefault(key) {
	        var p_value = params[key] || Url.param(key);
	        var s_value = sessionStorage.getItem(key);
	        if (p_value && (!s_value || p_value !== s_value)) {
	            sessionStorage.setItem(key, p_value);
	        }
	        if (!p_value && s_value) {
	            setDefault(key, s_value);
	        }
	        return p_value || s_value;
	    };

	    var setDefault = function setDefault(key, value) {
	        if (!key) return;
	        value = value || '';
	        if (isEmptyObject(params)) params = Url.paramsHash();
	        if (params[key] !== value) {
	            params[key] = value;
	            // to increase speed, do not set values when form is still loading
	            if (!isVisible(document.getElementById('trading_init_progress'))) {
	                sessionStorage.setItem(key, value);
	                updateURL();
	            }
	        }
	    };

	    var removeDefault = function removeDefault() {
	        for (var _len = arguments.length, keys = Array(_len), _key = 0; _key < _len; _key++) {
	            keys[_key] = arguments[_key];
	        }

	        if (isEmptyObject(params)) params = Url.paramsHash();
	        var is_updated = false;
	        keys.forEach(function (key) {
	            if (key in params) {
	                sessionStorage.removeItem(key);
	                delete params[key];
	                is_updated = true;
	            }
	        });
	        if (is_updated) {
	            updateURL();
	        }
	    };

	    var updateAll = function updateAll() {
	        Object.keys(params).forEach(function (key) {
	            sessionStorage.setItem(key, params[key]);
	        });
	        updateURL();
	    };

	    var updateURL = function updateURL() {
	        if (!State.get('is_trading') && !State.get('is_beta_trading')) return;
	        var updated_url = '' + window.location.origin + window.location.pathname + '?' + Url.paramsHashToString(params);
	        window.history.replaceState({ url: updated_url }, null, updated_url);
	    };

	    return {
	        get: getDefault,
	        set: setDefault,
	        update: updateAll,
	        remove: removeDefault,
	        clear: function clear() {
	            params = {};
	        }
	    };
	}();

	module.exports = Defaults;

/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Highcharts = __webpack_require__(439);
	var HighchartUI = __webpack_require__(440);
	var MBContract = __webpack_require__(304);
	var GetTicks = __webpack_require__(441);
	var BinarySocket = __webpack_require__(427);
	var ViewPopupUI = __webpack_require__(436);
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var jpClient = __webpack_require__(425).jpClient;
	__webpack_require__(454)(Highcharts);

	var Highchart = function () {
	    var chart = void 0,
	        options = void 0,
	        response_id = void 0,
	        contract = void 0,
	        request = void 0,
	        min_point = void 0,
	        max_point = void 0,
	        lines_drawn = void 0;

	    var start_time = void 0,
	        purchase_time = void 0,
	        now_time = void 0,
	        end_time = void 0,
	        entry_tick_time = void 0,
	        is_sold = void 0,
	        sell_time = void 0,
	        sell_spot_time = void 0,
	        is_settleable = void 0,
	        exit_tick_time = void 0,
	        exit_time = void 0,
	        underlying = void 0,
	        margin = void 0;

	    var is_initialized = void 0,
	        is_chart_delayed = void 0,
	        is_chart_subscribed = void 0,
	        stop_streaming = void 0,
	        is_contracts_for_send = void 0,
	        is_history_send = void 0,
	        is_entry_tick_barrier_selected = void 0;

	    var initOnce = function initOnce() {
	        chart = options = response_id = contract = request = min_point = max_point = '';
	        lines_drawn = [];

	        is_initialized = is_chart_delayed = is_chart_subscribed = stop_streaming = is_contracts_for_send = is_history_send = is_entry_tick_barrier_selected = false;
	    };

	    var initializeValues = function initializeValues() {
	        start_time = parseInt(contract.date_start);
	        purchase_time = parseInt(contract.purchase_time);
	        now_time = parseInt(contract.current_spot_time);
	        end_time = parseInt(contract.date_expiry);
	        entry_tick_time = parseInt(contract.entry_tick_time);
	        is_sold = contract.is_sold;
	        sell_time = parseInt(contract.sell_time);
	        sell_spot_time = parseInt(contract.sell_spot_time);
	        is_settleable = contract.is_settleable;
	        exit_tick_time = parseInt(contract.exit_tick_time);
	        exit_time = parseInt(is_sold && sell_time < end_time ? sell_spot_time : exit_tick_time || end_time);
	        underlying = contract.underlying;
	    };

	    // initialize the chart only once with ticks or candles data
	    var initChart = function initChart(init_options) {
	        var data = [],
	            type = '',
	            i = void 0;

	        var pushTicks = function pushTicks(time, price) {
	            // we need to add the marker as we are pushing the data points
	            // since for large arrays, data doesn't get pushed to series[0].data
	            // and we can't update markers if data is empty
	            time = parseInt(time);
	            var is_match_entry = time === entry_tick_time;
	            var is_match_exit = time === exit_tick_time;
	            var tick_type = is_match_entry ? 'entry' : 'exit';
	            data.push({
	                x: time * 1000,
	                y: price * 1,
	                marker: is_match_entry || is_match_exit ? HighchartUI.getMarkerObject(tick_type) : ''
	            });
	        };

	        var history = '',
	            candles = '';
	        if (init_options.history) {
	            // indicates line chart
	            type = 'line';
	            history = init_options.history;
	            var times = history.times;
	            var prices = history.prices;
	            if (is_chart_delayed) {
	                for (i = 0; i < times.length; ++i) {
	                    pushTicks(times[i], prices[i]);
	                }
	            } else if (min_point && max_point) {
	                var current_time = void 0;
	                for (i = 0; i < times.length; ++i) {
	                    current_time = parseInt(times[i]);
	                    // only display the first tick before entry spot and one tick after exit spot
	                    // as well as the set of ticks between them
	                    if (current_time >= min_point && current_time <= max_point) {
	                        pushTicks(current_time, prices[i]);
	                    }
	                }
	            }
	        } else if (init_options.candles) {
	            // indicates candle chart
	            candles = init_options.candles;
	            type = 'candlestick';
	            data = candles.map(function (c) {
	                return [c.epoch * 1000, c.open * 1, c.high * 1, c.low * 1, c.close * 1];
	            });
	        }

	        // element where chart is to be displayed
	        var el = document.getElementById('analysis_live_chart');
	        if (!el) return null;

	        var JPClient = jpClient();
	        HighchartUI.setLabels(is_chart_delayed);
	        HighchartUI.setChartOptions({
	            height: el.parentElement.offsetHeight,
	            title: localize(init_options.title),
	            JPClient: JPClient,
	            decimals: history ? history.prices[0] : candles[0].open,
	            type: type,
	            data: data,
	            entry_time: entry_tick_time ? entry_tick_time * 1000 : start_time * 1000,
	            exit_time: exit_time ? exit_time * 1000 : null,
	            user_sold: userSold()
	        });
	        Highcharts.setOptions(HighchartUI.getHighchartOptions(JPClient));

	        if (!el) return null;
	        var new_chart = Highcharts.StockChart(el, HighchartUI.getChartOptions());
	        is_initialized = true;
	        return new_chart;
	    };

	    // type 'x' is used to draw lines such as start and end times
	    // type 'y' is used to draw lines such as barrier
	    var addPlotLine = function addPlotLine(params, type) {
	        chart[type + 'Axis'][0].addPlotLine(HighchartUI.getPlotlineOptions(params, type));
	        if (userSold()) {
	            HighchartUI.replaceExitLabelWithSell(chart.subtitle.element);
	        }
	    };

	    var handleResponse = function handleResponse(response) {
	        var type = response.msg_type;
	        var error = response.error;
	        if (/(history|candles|tick|ohlc)/.test(type) && !error) {
	            response_id = response[type].id;
	            // send view popup the response ID so view popup can forget the calls if it's closed before contract ends
	            if (response_id) ViewPopupUI.storeSubscriptionID(response_id, underlying);
	            options = { title: contract.display_name };
	            options[type] = response[type];
	            var history = response.history;
	            var candles = response.candles;
	            var tick = response.tick;
	            var ohlc = response.ohlc;
	            if (history || candles) {
	                var length = (history ? history.times : candles).length;
	                if (length === 0) {
	                    HighchartUI.showError('missing');
	                    return;
	                }
	                if (history) {
	                    var history_times = history.times;
	                    getMinHistory(history_times);
	                    getMaxHistory(history_times);
	                } else if (candles) {
	                    getMinCandle(candles);
	                    getMaxCandle(candles);
	                }
	                // only initialize chart if it hasn't already been initialized
	                if (!chart && !is_initialized) {
	                    chart = initChart(options);
	                    if (!chart) return;

	                    if (purchase_time !== start_time) {
	                        drawLineX({
	                            value: purchase_time,
	                            label: localize('Purchase Time'),
	                            color: '#7cb5ec'
	                        });
	                    }

	                    // second condition is used to make sure contracts that have purchase time
	                    // but are sold before the start time don't show start time
	                    if (!is_sold || is_sold && sell_time && sell_time > start_time) {
	                        drawLineX({ value: start_time });
	                    }
	                }
	            } else if ((tick || ohlc) && !stop_streaming) {
	                if (chart && chart.series) {
	                    updateChart(options);
	                }
	            }
	            if (entry_tick_time && !is_entry_tick_barrier_selected) {
	                selectEntryTickBarrier();
	            }
	            if (is_sold || is_settleable) {
	                updateZone('exit');
	                endContract();
	            }
	        } else if (type === 'ticks_history' && error) {
	            HighchartUI.showError('', error.message);
	        }
	    };

	    var showChart = function showChart(proposal_contract, update) {
	        contract = proposal_contract;
	        initializeValues();
	        if (!update) {
	            initOnce();
	        }
	        if (!chart && !is_history_send) {
	            requestData(update || '');
	        } else if (chart && entry_tick_time && !is_entry_tick_barrier_selected) {
	            selectEntryTickBarrier();
	        }
	        if (chart && (is_sold || is_settleable)) {
	            updateZone('exit');
	            endContract();
	        }
	    };

	    var requestData = function requestData(update) {
	        var calculate_granularity = calculateGranularity();
	        var granularity = calculate_granularity[0];
	        var duration = calculate_granularity[1];
	        margin = granularity === 0 ? Math.max(300, 30 * duration / (60 * 60) || 0) : 3 * granularity;

	        request = {
	            ticks_history: underlying,
	            start: ((purchase_time || start_time) - margin).toFixed(0), /* load more ticks first */
	            end: end_time ? (end_time + margin).toFixed(0) : 'latest',
	            style: granularity === 0 ? 'ticks' : 'candles',
	            count: 4999, /* maximum number of ticks possible */
	            adjust_start_time: 1
	        };

	        if (is_sold && sell_time < end_time) {
	            request.end = sell_spot_time ? (parseInt(sell_spot_time) + margin).toFixed(0) : 'latest';
	        }

	        // switch start and end if start is after end
	        if (!isNaN(request.end) && request.start > request.end) {
	            request.end = [request.start, request.start = request.end][0];
	        }

	        if (granularity !== 0) {
	            request.granularity = granularity;
	        }

	        if (!is_settleable && !sell_spot_time && window.time.valueOf() / 1000 < end_time && !is_chart_subscribed) {
	            request.subscribe = 1;
	        }

	        var contracts_response = State.get('is_mb_trading') ? MBContract.getContractsResponse() : State.get(['response', 'contracts_for']);
	        var stored_delay = sessionStorage.getItem('license.' + underlying);

	        if (contracts_response && contracts_response.echo_req.contracts_for === underlying) {
	            delayedChart(contracts_response);
	        } else if (stored_delay) {
	            handleDelay(stored_delay);
	            sendTickRequest();
	        } else if (!is_contracts_for_send && update === '') {
	            BinarySocket.send({ contracts_for: underlying }).then(function (response) {
	                var error = response.error;
	                if (!error || error.code && error.code === 'InvalidSymbol') {
	                    delayedChart(response);
	                }
	            });
	            is_contracts_for_send = true;
	        }
	    };

	    var delayedChart = function delayedChart(contracts_response) {
	        if (contracts_response.contracts_for && contracts_response.contracts_for.feed_license) {
	            var license = contracts_response.contracts_for.feed_license;
	            handleDelay(license);
	            saveFeedLicense(contracts_response.echo_req.contracts_for, license);
	        }
	        sendTickRequest();
	    };

	    var sendTickRequest = function sendTickRequest() {
	        if (!entry_tick_time && !is_chart_delayed && start_time && window.time.unix() >= parseInt(start_time)) {
	            HighchartUI.showError('', localize('Waiting for entry tick.'));
	        } else if (!is_history_send) {
	            is_history_send = true;
	            if (request.subscribe) is_chart_subscribed = true;
	            // BinarySocket.send(request, { callback: handleResponse });
	            GetTicks.request('', request, handleResponse);
	        }
	    };

	    var handleDelay = function handleDelay(feed_license) {
	        if (feed_license !== 'realtime') {
	            if (!is_settleable) {
	                request.end = 'latest';
	            }
	            delete request.subscribe;
	            is_chart_delayed = true;
	        }
	    };

	    // update the color zones with the correct entry_tick_time and draw barrier
	    var selectEntryTickBarrier = function selectEntryTickBarrier() {
	        if (chart && entry_tick_time && !is_entry_tick_barrier_selected) {
	            is_entry_tick_barrier_selected = true;
	            drawBarrier();
	            updateZone('entry');
	            selectTick(entry_tick_time, 'entry');
	        }
	    };

	    var updateZone = function updateZone(type) {
	        if (chart && type && !userSold()) {
	            var value = type === 'entry' ? entry_tick_time : exit_time;
	            chart.series[0].zones[type === 'entry' ? 0 : 1].value = value * 1000;
	        }
	    };

	    var drawBarrier = function drawBarrier() {
	        if (chart.yAxis[0].plotLinesAndBands.length === 0) {
	            var barrier = contract.barrier;
	            var high_barrier = contract.high_barrier;
	            var low_barrier = contract.low_barrier;
	            if (barrier) {
	                addPlotLine({ id: 'barrier', value: barrier * 1, label: localize('Barrier ([_1])', [barrier]), dashStyle: 'Dot' }, 'y');
	            } else if (high_barrier && low_barrier) {
	                addPlotLine({ id: 'high_barrier', value: high_barrier * 1, label: localize('High Barrier ([_1])', [high_barrier]), dashStyle: 'Dot' }, 'y');
	                addPlotLine({ id: 'low_barrier', value: low_barrier * 1, label: localize('Low Barrier ([_1])', [low_barrier]), dashStyle: 'Dot' }, 'y');
	            }
	        }
	    };

	    // set an orange circle on the entry/exit tick
	    var selectTick = function selectTick(value, tick_type) {
	        if (chart && value && tick_type && (options.tick || options.history) && chart.series[0].data.length !== 0) {
	            var data = chart.series[0].data;
	            if (!data || data.length === 0) return;
	            var current_data = void 0;
	            for (var i = data.length - 1; i >= 0; i--) {
	                current_data = data[i];
	                if (current_data && current_data.x && value * 1000 === current_data.x) {
	                    current_data.update({ marker: HighchartUI.getMarkerObject(tick_type) });
	                }
	            }
	        }
	    };

	    // calculate where to display the minimum value of the x-axis of the chart for line chart
	    var getMinHistory = function getMinHistory(history_times) {
	        var history_times_length = history_times.length;
	        var history_times_int = void 0;
	        for (var i = 0; i < history_times_length; i++) {
	            history_times_int = parseInt(history_times[i]);
	            if (entry_tick_time && history_times_int === entry_tick_time || purchase_time && start_time > purchase_time && history_times_int === purchase_time || history_times_int < purchase_time && parseInt(history_times[i === history_times_length - 1 ? i : i + 1]) > purchase_time) {
	                // set the chart to display from the tick before entry_tick_time or purchase_time
	                min_point = parseInt(history_times[i === 0 ? i : i - 1]);
	                break;
	            }
	        }
	        if (!min_point) min_point = parseInt(history_times[0]);
	    };

	    // calculate where to display the maximum value of the x-axis of the chart for line chart
	    var getMaxHistory = function getMaxHistory(history_times) {
	        var end = end_time;
	        if (sell_spot_time && (sell_time || sell_spot_time) < end_time) {
	            end = sell_spot_time;
	        } else if (exit_tick_time) {
	            end = exit_tick_time;
	        }

	        var history_times_length = history_times.length;
	        if (is_settleable || is_sold) {
	            for (var i = history_times_length - 1; i >= 0; i--) {
	                if (parseInt(history_times[i]) === end) {
	                    max_point = parseInt(history_times[i === history_times_length - 1 ? i : i + 1]);
	                    break;
	                }
	            }
	        }
	        setMaxForDelayedChart(history_times, history_times_length);
	    };

	    // calculate where to display the minimum value of the x-axis of the chart for candle
	    var getMinCandle = function getMinCandle(candles) {
	        var candle_before_time = function candle_before_time(value) {
	            return value && current_candle && parseInt(current_candle.epoch) <= value && candles[i === candles_length - 1 ? i : i + 1].epoch > value;
	        };
	        var i = void 0,
	            current_candle = void 0;
	        var candles_length = candles.length;
	        for (i = 1; i < candles_length; i++) {
	            current_candle = candles[i];
	            if (candle_before_time(entry_tick_time) || candle_before_time(purchase_time)) {
	                // set the chart to display from the candle before entry_tick_time or purchase_time
	                min_point = parseInt(candles[i - 1].epoch);
	                break;
	            }
	        }
	    };

	    // calculate where to display the maximum value of the x-axis of the chart for candle
	    var getMaxCandle = function getMaxCandle(candles) {
	        var end = sell_spot_time && sell_time < end_time ? sell_spot_time : end_time;
	        var candle_length = candles.length;
	        var current_candle = void 0,
	            next_candle = void 0;
	        if (is_settleable || is_sold) {
	            for (var i = candle_length - 2; i >= 0; i--) {
	                current_candle = candles[i];
	                next_candle = candles[i + 1];
	                if (!current_candle) return;
	                if (parseInt(next_candle.epoch) < end) {
	                    max_point = end_time;
	                    break;
	                }
	                if (parseInt(current_candle.epoch) <= end && parseInt(next_candle.epoch) > end) {
	                    max_point = parseInt(next_candle.epoch);
	                    break;
	                }
	            }
	        }
	        setMaxForDelayedChart(candles, candle_length);
	    };

	    var setMaxForDelayedChart = function setMaxForDelayedChart(array, array_length) {
	        if (is_chart_delayed) {
	            var last_epoch = parseInt(array[array_length - 1].epoch);
	            if (last_epoch > start_time) {
	                max_point = last_epoch;
	            } else {
	                max_point = start_time;
	            }
	        }
	        if (!max_point) max_point = end_time;
	    };

	    var drawLineX = function drawLineX(properties) {
	        if (chart && properties.value && !new RegExp(properties.value).test(lines_drawn)) {
	            addPlotLine({
	                value: properties.value * 1000,
	                label: properties.label || '',
	                textLeft: properties.text_left === 'textLeft',
	                dashStyle: properties.dash_style || '',
	                color: properties.color || ''
	            }, 'x');
	            lines_drawn.push(properties.value);
	        }
	    };

	    // draw the last line, mark the exit tick, and forget the streams
	    var endContract = function endContract() {
	        if (chart && !stop_streaming) {
	            drawLineX({
	                value: userSold() ? sell_time : end_time,
	                text_left: 'textLeft',
	                dash_style: 'Dash'
	            });
	            if (exit_tick_time) {
	                selectTick(exit_tick_time, 'exit');
	            }
	            if (!contract.sell_spot && !contract.exit_tick) {
	                if ($('#waiting_exit_tick').length === 0) {
	                    $('#trade_details_message').append($('<div/>', { id: 'waiting_exit_tick', text: localize('Waiting for exit tick.') }));
	                }
	            } else {
	                $('#waiting_exit_tick').remove();
	            }
	            setStopStreaming();
	        }
	    };

	    var setStopStreaming = function setStopStreaming() {
	        if (chart && (is_sold || is_settleable) && chart.series && chart.series[0].options.data.length > 0) {
	            var data = chart.series[0].options.data;
	            var last_data = data[data.length - 1];
	            var i = 2;
	            while (last_data.y === null) {
	                last_data = data[data.length - i];
	                i++;
	            }
	            var last = parseInt(last_data.x || last_data[0]);
	            if (last > end_time * 1000 || last > (sell_time || sell_spot_time) * 1000) {
	                stop_streaming = true;
	            } else {
	                // add a null point if the last tick is before end time to bring end time line into view
	                var time = userSold() ? sell_time || sell_spot_time : end_time;
	                chart.series[0].addPoint({ x: ((time || window.time.unix()) + margin) * 1000, y: null });
	            }
	        }
	    };

	    var calculateGranularity = function calculateGranularity() {
	        var duration = Math.min(exit_time, now_time) - (purchase_time || start_time);
	        var granularity = void 0;
	        // days * hours * minutes * seconds
	        if (duration <= 60 * 60) granularity = 0; // less than 1 hour
	        else if (duration <= 2 * 60 * 60) granularity = 120; // 2 hours
	            else if (duration <= 6 * 60 * 60) granularity = 600; // 6 hours
	                else if (duration <= 24 * 60 * 60) granularity = 900; // 1 day
	                    else if (duration <= 5 * 24 * 60 * 60) granularity = 3600; // 5 days
	                        else if (duration <= 30 * 24 * 60 * 60) granularity = 14400; // 30 days
	                            else granularity = 86400; // more than 30 days

	        return [granularity, duration];
	    };

	    // add new data points to the chart
	    var updateChart = function updateChart(update_options) {
	        var granularity = calculateGranularity()[0];
	        var series = chart.series[0];
	        if (granularity === 0) {
	            var data = update_options.tick;
	            chart.series[0].addPoint({ x: data.epoch * 1000, y: data.quote * 1 });
	        } else {
	            var c = update_options.ohlc;
	            var last = series.data[series.data.length - 1];
	            if (!c || !last) return;
	            var ohlc = [c.open_time * 1000, c.open * 1, c.high * 1, c.low * 1, c.close * 1];

	            if (last.x !== ohlc[0]) {
	                series.addPoint(ohlc, true, true);
	            } else {
	                last.update(ohlc, true);
	            }
	        }
	    };

	    var saveFeedLicense = function saveFeedLicense(save_contract, license) {
	        var regex = new RegExp('license.' + contract);
	        var match_found = false;

	        for (var i = 0; i < sessionStorage.length; i++) {
	            if (regex.test(sessionStorage.key(i))) {
	                match_found = true;
	                break;
	            }
	        }

	        if (!match_found) {
	            sessionStorage.setItem('license.' + save_contract, license);
	        }
	    };

	    var userSold = function userSold() {
	        return sell_time && sell_time < end_time || !sell_time && sell_spot_time && sell_spot_time < end_time;
	    };

	    return {
	        showChart: showChart
	    };
	}();

	module.exports = Highchart;

/***/ },
/* 439 */
/***/ function(module, exports) {

	/*
	 Highstock JS v5.0.9 (2017-03-08)

	 (c) 2009-2016 Torstein Honsi

	 License: www.highcharts.com/license
	*/
	(function(K,a){"object"===typeof module&&module.exports?module.exports=K.document?a(K):a:K.Highcharts=a(K)})("undefined"!==typeof window?window:this,function(K){K=function(){var a=window,D=a.document,A=a.navigator&&a.navigator.userAgent||"",G=D&&D.createElementNS&&!!D.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect,H=/(edge|msie|trident)/i.test(A)&&!window.opera,w=!G,k=/Firefox/.test(A),t=k&&4>parseInt(A.split("Firefox/")[1],10);return a.Highcharts?a.Highcharts.error(16,!0):{product:"Highstock",
	version:"5.0.9",deg2rad:2*Math.PI/360,doc:D,hasBidiBug:t,hasTouch:D&&void 0!==D.documentElement.ontouchstart,isMS:H,isWebKit:/AppleWebKit/.test(A),isFirefox:k,isTouchDevice:/(Mobile|Android|Windows Phone)/.test(A),SVG_NS:"http://www.w3.org/2000/svg",chartCount:0,seriesTypes:{},symbolSizes:{},svg:G,vml:w,win:a,charts:[],marginNames:["plotTop","marginRight","marginBottom","plotLeft"],noop:function(){}}}();(function(a){var D=[],A=a.charts,G=a.doc,H=a.win;a.error=function(w,k){w=a.isNumber(w)?"Highcharts error #"+
	w+": www.highcharts.com/errors/"+w:w;if(k)throw Error(w);H.console&&console.log(w)};a.Fx=function(a,k,t){this.options=k;this.elem=a;this.prop=t};a.Fx.prototype={dSetter:function(){var a=this.paths[0],k=this.paths[1],t=[],x=this.now,p=a.length,m;if(1===x)t=this.toD;else if(p===k.length&&1>x)for(;p--;)m=parseFloat(a[p]),t[p]=isNaN(m)?a[p]:x*parseFloat(k[p]-m)+m;else t=k;this.elem.attr("d",t,null,!0)},update:function(){var a=this.elem,k=this.prop,t=this.now,x=this.options.step;if(this[k+"Setter"])this[k+
	"Setter"]();else a.attr?a.element&&a.attr(k,t,null,!0):a.style[k]=t+this.unit;x&&x.call(a,t,this)},run:function(a,k,t){var w=this,p=function(a){return p.stopped?!1:w.step(a)},m;this.startTime=+new Date;this.start=a;this.end=k;this.unit=t;this.now=this.start;this.pos=0;p.elem=this.elem;p.prop=this.prop;p()&&1===D.push(p)&&(p.timerId=setInterval(function(){for(m=0;m<D.length;m++)D[m]()||D.splice(m--,1);D.length||clearInterval(p.timerId)},13))},step:function(a){var k=+new Date,w,x=this.options;w=this.elem;
	var p=x.complete,m=x.duration,e=x.curAnim,d;if(w.attr&&!w.element)w=!1;else if(a||k>=m+this.startTime){this.now=this.end;this.pos=1;this.update();a=e[this.prop]=!0;for(d in e)!0!==e[d]&&(a=!1);a&&p&&p.call(w);w=!1}else this.pos=x.easing((k-this.startTime)/m),this.now=this.start+(this.end-this.start)*this.pos,this.update(),w=!0;return w},initPath:function(w,k,t){function x(a){var b,h;for(C=a.length;C--;)b="M"===a[C]||"L"===a[C],h=/[a-zA-Z]/.test(a[C+3]),b&&h&&a.splice(C+1,0,a[C+1],a[C+2],a[C+1],a[C+
	2])}function p(a,f){for(;a.length<u;){a[0]=f[u-a.length];var h=a.slice(0,b);[].splice.apply(a,[0,0].concat(h));q&&(h=a.slice(a.length-b),[].splice.apply(a,[a.length,0].concat(h)),C--)}a[0]="M"}function m(a,f){for(var h=(u-a.length)/b;0<h&&h--;)c=a.slice().splice(a.length/r-b,b*r),c[0]=f[u-b-h*b],z&&(c[b-6]=c[b-2],c[b-5]=c[b-1]),[].splice.apply(a,[a.length/r,0].concat(c)),q&&h--}k=k||"";var e,d=w.startX,l=w.endX,z=-1<k.indexOf("C"),b=z?7:3,u,c,C;k=k.split(" ");t=t.slice();var q=w.isArea,r=q?2:1,h;
	z&&(x(k),x(t));if(d&&l){for(C=0;C<d.length;C++)if(d[C]===l[0]){e=C;break}else if(d[0]===l[l.length-d.length+C]){e=C;h=!0;break}void 0===e&&(k=[])}k.length&&a.isNumber(e)&&(u=t.length+e*r*b,h?(p(k,t),m(t,k)):(p(t,k),m(k,t)));return[k,t]}};a.extend=function(a,k){var w;a||(a={});for(w in k)a[w]=k[w];return a};a.merge=function(){var w,k=arguments,t,x={},p=function(m,e){var d,l;"object"!==typeof m&&(m={});for(l in e)e.hasOwnProperty(l)&&(d=e[l],a.isObject(d,!0)&&"renderTo"!==l&&"number"!==typeof d.nodeType?
	m[l]=p(m[l]||{},d):m[l]=e[l]);return m};!0===k[0]&&(x=k[1],k=Array.prototype.slice.call(k,2));t=k.length;for(w=0;w<t;w++)x=p(x,k[w]);return x};a.pInt=function(a,k){return parseInt(a,k||10)};a.isString=function(a){return"string"===typeof a};a.isArray=function(a){a=Object.prototype.toString.call(a);return"[object Array]"===a||"[object Array Iterator]"===a};a.isObject=function(w,k){return w&&"object"===typeof w&&(!k||!a.isArray(w))};a.isNumber=function(a){return"number"===typeof a&&!isNaN(a)};a.erase=
	function(a,k){for(var w=a.length;w--;)if(a[w]===k){a.splice(w,1);break}};a.defined=function(a){return void 0!==a&&null!==a};a.attr=function(w,k,t){var x,p;if(a.isString(k))a.defined(t)?w.setAttribute(k,t):w&&w.getAttribute&&(p=w.getAttribute(k));else if(a.defined(k)&&a.isObject(k))for(x in k)w.setAttribute(x,k[x]);return p};a.splat=function(w){return a.isArray(w)?w:[w]};a.syncTimeout=function(a,k,t){if(k)return setTimeout(a,k,t);a.call(0,t)};a.pick=function(){var a=arguments,k,t,x=a.length;for(k=
	0;k<x;k++)if(t=a[k],void 0!==t&&null!==t)return t};a.css=function(w,k){a.isMS&&!a.svg&&k&&void 0!==k.opacity&&(k.filter="alpha(opacity\x3d"+100*k.opacity+")");a.extend(w.style,k)};a.createElement=function(w,k,t,x,p){w=G.createElement(w);var m=a.css;k&&a.extend(w,k);p&&m(w,{padding:0,border:"none",margin:0});t&&m(w,t);x&&x.appendChild(w);return w};a.extendClass=function(w,k){var t=function(){};t.prototype=new w;a.extend(t.prototype,k);return t};a.pad=function(a,k,t){return Array((k||2)+1-String(a).length).join(t||
	0)+a};a.relativeLength=function(a,k){return/%$/.test(a)?k*parseFloat(a)/100:parseFloat(a)};a.wrap=function(a,k,t){var x=a[k];a[k]=function(){var a=Array.prototype.slice.call(arguments),m=arguments,e=this;e.proceed=function(){x.apply(e,arguments.length?arguments:m)};a.unshift(x);a=t.apply(this,a);e.proceed=null;return a}};a.getTZOffset=function(w){var k=a.Date;return 6E4*(k.hcGetTimezoneOffset&&k.hcGetTimezoneOffset(w)||k.hcTimezoneOffset||0)};a.dateFormat=function(w,k,t){if(!a.defined(k)||isNaN(k))return a.defaultOptions.lang.invalidDate||
	"";w=a.pick(w,"%Y-%m-%d %H:%M:%S");var x=a.Date,p=new x(k-a.getTZOffset(k)),m,e=p[x.hcGetHours](),d=p[x.hcGetDay](),l=p[x.hcGetDate](),z=p[x.hcGetMonth](),b=p[x.hcGetFullYear](),u=a.defaultOptions.lang,c=u.weekdays,C=u.shortWeekdays,q=a.pad,x=a.extend({a:C?C[d]:c[d].substr(0,3),A:c[d],d:q(l),e:q(l,2," "),w:d,b:u.shortMonths[z],B:u.months[z],m:q(z+1),y:b.toString().substr(2,2),Y:b,H:q(e),k:e,I:q(e%12||12),l:e%12||12,M:q(p[x.hcGetMinutes]()),p:12>e?"AM":"PM",P:12>e?"am":"pm",S:q(p.getSeconds()),L:q(Math.round(k%
	1E3),3)},a.dateFormats);for(m in x)for(;-1!==w.indexOf("%"+m);)w=w.replace("%"+m,"function"===typeof x[m]?x[m](k):x[m]);return t?w.substr(0,1).toUpperCase()+w.substr(1):w};a.formatSingle=function(w,k){var t=/\.([0-9])/,x=a.defaultOptions.lang;/f$/.test(w)?(t=(t=w.match(t))?t[1]:-1,null!==k&&(k=a.numberFormat(k,t,x.decimalPoint,-1<w.indexOf(",")?x.thousandsSep:""))):k=a.dateFormat(w,k);return k};a.format=function(w,k){for(var t="{",x=!1,p,m,e,d,l=[],z;w;){t=w.indexOf(t);if(-1===t)break;p=w.slice(0,
	t);if(x){p=p.split(":");m=p.shift().split(".");d=m.length;z=k;for(e=0;e<d;e++)z=z[m[e]];p.length&&(z=a.formatSingle(p.join(":"),z));l.push(z)}else l.push(p);w=w.slice(t+1);t=(x=!x)?"}":"{"}l.push(w);return l.join("")};a.getMagnitude=function(a){return Math.pow(10,Math.floor(Math.log(a)/Math.LN10))};a.normalizeTickInterval=function(w,k,t,x,p){var m,e=w;t=a.pick(t,1);m=w/t;k||(k=p?[1,1.2,1.5,2,2.5,3,4,5,6,8,10]:[1,2,2.5,5,10],!1===x&&(1===t?k=a.grep(k,function(a){return 0===a%1}):.1>=t&&(k=[1/t])));
	for(x=0;x<k.length&&!(e=k[x],p&&e*t>=w||!p&&m<=(k[x]+(k[x+1]||k[x]))/2);x++);return e=a.correctFloat(e*t,-Math.round(Math.log(.001)/Math.LN10))};a.stableSort=function(a,k){var t=a.length,x,p;for(p=0;p<t;p++)a[p].safeI=p;a.sort(function(a,e){x=k(a,e);return 0===x?a.safeI-e.safeI:x});for(p=0;p<t;p++)delete a[p].safeI};a.arrayMin=function(a){for(var k=a.length,t=a[0];k--;)a[k]<t&&(t=a[k]);return t};a.arrayMax=function(a){for(var k=a.length,t=a[0];k--;)a[k]>t&&(t=a[k]);return t};a.destroyObjectProperties=
	function(a,k){for(var t in a)a[t]&&a[t]!==k&&a[t].destroy&&a[t].destroy(),delete a[t]};a.discardElement=function(w){var k=a.garbageBin;k||(k=a.createElement("div"));w&&k.appendChild(w);k.innerHTML=""};a.correctFloat=function(a,k){return parseFloat(a.toPrecision(k||14))};a.setAnimation=function(w,k){k.renderer.globalAnimation=a.pick(w,k.options.chart.animation,!0)};a.animObject=function(w){return a.isObject(w)?a.merge(w):{duration:w?500:0}};a.timeUnits={millisecond:1,second:1E3,minute:6E4,hour:36E5,
	day:864E5,week:6048E5,month:24192E5,year:314496E5};a.numberFormat=function(w,k,t,x){w=+w||0;k=+k;var p=a.defaultOptions.lang,m=(w.toString().split(".")[1]||"").length,e,d;-1===k?k=Math.min(m,20):a.isNumber(k)||(k=2);d=(Math.abs(w)+Math.pow(10,-Math.max(k,m)-1)).toFixed(k);m=String(a.pInt(d));e=3<m.length?m.length%3:0;t=a.pick(t,p.decimalPoint);x=a.pick(x,p.thousandsSep);w=(0>w?"-":"")+(e?m.substr(0,e)+x:"");w+=m.substr(e).replace(/(\d{3})(?=\d)/g,"$1"+x);k&&(w+=t+d.slice(-k));return w};Math.easeInOutSine=
	function(a){return-.5*(Math.cos(Math.PI*a)-1)};a.getStyle=function(w,k){return"width"===k?Math.min(w.offsetWidth,w.scrollWidth)-a.getStyle(w,"padding-left")-a.getStyle(w,"padding-right"):"height"===k?Math.min(w.offsetHeight,w.scrollHeight)-a.getStyle(w,"padding-top")-a.getStyle(w,"padding-bottom"):(w=H.getComputedStyle(w,void 0))&&a.pInt(w.getPropertyValue(k))};a.inArray=function(a,k){return k.indexOf?k.indexOf(a):[].indexOf.call(k,a)};a.grep=function(a,k){return[].filter.call(a,k)};a.find=function(a,
	k){return[].find.call(a,k)};a.map=function(a,k){for(var t=[],x=0,p=a.length;x<p;x++)t[x]=k.call(a[x],a[x],x,a);return t};a.offset=function(a){var k=G.documentElement;a=a.getBoundingClientRect();return{top:a.top+(H.pageYOffset||k.scrollTop)-(k.clientTop||0),left:a.left+(H.pageXOffset||k.scrollLeft)-(k.clientLeft||0)}};a.stop=function(a,k){for(var t=D.length;t--;)D[t].elem!==a||k&&k!==D[t].prop||(D[t].stopped=!0)};a.each=function(a,k,t){return Array.prototype.forEach.call(a,k,t)};a.addEvent=function(w,
	k,t){function x(a){a.target=a.srcElement||H;t.call(w,a)}var p=w.hcEvents=w.hcEvents||{};w.addEventListener?w.addEventListener(k,t,!1):w.attachEvent&&(w.hcEventsIE||(w.hcEventsIE={}),w.hcEventsIE[t.toString()]=x,w.attachEvent("on"+k,x));p[k]||(p[k]=[]);p[k].push(t);return function(){a.removeEvent(w,k,t)}};a.removeEvent=function(w,k,t){function x(a,d){w.removeEventListener?w.removeEventListener(a,d,!1):w.attachEvent&&(d=w.hcEventsIE[d.toString()],w.detachEvent("on"+a,d))}function p(){var a,d;if(w.nodeName)for(d in k?
	(a={},a[k]=!0):a=e,a)if(e[d])for(a=e[d].length;a--;)x(d,e[d][a])}var m,e=w.hcEvents,d;e&&(k?(m=e[k]||[],t?(d=a.inArray(t,m),-1<d&&(m.splice(d,1),e[k]=m),x(k,t)):(p(),e[k]=[])):(p(),w.hcEvents={}))};a.fireEvent=function(w,k,t,x){var p;p=w.hcEvents;var m,e;t=t||{};if(G.createEvent&&(w.dispatchEvent||w.fireEvent))p=G.createEvent("Events"),p.initEvent(k,!0,!0),a.extend(p,t),w.dispatchEvent?w.dispatchEvent(p):w.fireEvent(k,p);else if(p)for(p=p[k]||[],m=p.length,t.target||a.extend(t,{preventDefault:function(){t.defaultPrevented=
	!0},target:w,type:k}),k=0;k<m;k++)(e=p[k])&&!1===e.call(w,t)&&t.preventDefault();x&&!t.defaultPrevented&&x(t)};a.animate=function(w,k,t){var x,p="",m,e,d;a.isObject(t)||(x=arguments,t={duration:x[2],easing:x[3],complete:x[4]});a.isNumber(t.duration)||(t.duration=400);t.easing="function"===typeof t.easing?t.easing:Math[t.easing]||Math.easeInOutSine;t.curAnim=a.merge(k);for(d in k)a.stop(w,d),e=new a.Fx(w,t,d),m=null,"d"===d?(e.paths=e.initPath(w,w.d,k.d),e.toD=k.d,x=0,m=1):w.attr?x=w.attr(d):(x=parseFloat(a.getStyle(w,
	d))||0,"opacity"!==d&&(p="px")),m||(m=k[d]),m&&m.match&&m.match("px")&&(m=m.replace(/px/g,"")),e.run(x,m,p)};a.seriesType=function(w,k,t,x,p){var m=a.getOptions(),e=a.seriesTypes;m.plotOptions[w]=a.merge(m.plotOptions[k],t);e[w]=a.extendClass(e[k]||function(){},x);e[w].prototype.type=w;p&&(e[w].prototype.pointClass=a.extendClass(a.Point,p));return e[w]};a.uniqueKey=function(){var a=Math.random().toString(36).substring(2,9),k=0;return function(){return"highcharts-"+a+"-"+k++}}();H.jQuery&&(H.jQuery.fn.highcharts=
	function(){var w=[].slice.call(arguments);if(this[0])return w[0]?(new (a[a.isString(w[0])?w.shift():"Chart"])(this[0],w[0],w[1]),this):A[a.attr(this[0],"data-highcharts-chart")]});G&&!G.defaultView&&(a.getStyle=function(w,k){var t={width:"clientWidth",height:"clientHeight"}[k];if(w.style[k])return a.pInt(w.style[k]);"opacity"===k&&(k="filter");if(t)return w.style.zoom=1,Math.max(w[t]-2*a.getStyle(w,"padding"),0);w=w.currentStyle[k.replace(/\-(\w)/g,function(a,p){return p.toUpperCase()})];"filter"===
	k&&(w=w.replace(/alpha\(opacity=([0-9]+)\)/,function(a,p){return p/100}));return""===w?1:a.pInt(w)});Array.prototype.forEach||(a.each=function(a,k,t){for(var x=0,p=a.length;x<p;x++)if(!1===k.call(t,a[x],x,a))return x});Array.prototype.indexOf||(a.inArray=function(a,k){var t,x=0;if(k)for(t=k.length;x<t;x++)if(k[x]===a)return x;return-1});Array.prototype.filter||(a.grep=function(a,k){for(var t=[],x=0,p=a.length;x<p;x++)k(a[x],x)&&t.push(a[x]);return t});Array.prototype.find||(a.find=function(a,k){var t,
	x=a.length;for(t=0;t<x;t++)if(k(a[t],t))return a[t]})})(K);(function(a){var D=a.each,A=a.isNumber,G=a.map,H=a.merge,w=a.pInt;a.Color=function(k){if(!(this instanceof a.Color))return new a.Color(k);this.init(k)};a.Color.prototype={parsers:[{regex:/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,parse:function(a){return[w(a[1]),w(a[2]),w(a[3]),parseFloat(a[4],10)]}},{regex:/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,parse:function(a){return[w(a[1]),
	w(a[2]),w(a[3]),1]}}],names:{white:"#ffffff",black:"#000000"},init:function(k){var t,x,p,m;if((this.input=k=this.names[k]||k)&&k.stops)this.stops=G(k.stops,function(e){return new a.Color(e[1])});else if(k&&"#"===k[0]&&(t=k.length,k=parseInt(k.substr(1),16),7===t?x=[(k&16711680)>>16,(k&65280)>>8,k&255,1]:4===t&&(x=[(k&3840)>>4|(k&3840)>>8,(k&240)>>4|k&240,(k&15)<<4|k&15,1])),!x)for(p=this.parsers.length;p--&&!x;)m=this.parsers[p],(t=m.regex.exec(k))&&(x=m.parse(t));this.rgba=x||[]},get:function(a){var k=
	this.input,x=this.rgba,p;this.stops?(p=H(k),p.stops=[].concat(p.stops),D(this.stops,function(m,e){p.stops[e]=[p.stops[e][0],m.get(a)]})):p=x&&A(x[0])?"rgb"===a||!a&&1===x[3]?"rgb("+x[0]+","+x[1]+","+x[2]+")":"a"===a?x[3]:"rgba("+x.join(",")+")":k;return p},brighten:function(a){var k,x=this.rgba;if(this.stops)D(this.stops,function(p){p.brighten(a)});else if(A(a)&&0!==a)for(k=0;3>k;k++)x[k]+=w(255*a),0>x[k]&&(x[k]=0),255<x[k]&&(x[k]=255);return this},setOpacity:function(a){this.rgba[3]=a;return this}};
	a.color=function(k){return new a.Color(k)}})(K);(function(a){var D,A,G=a.addEvent,H=a.animate,w=a.attr,k=a.charts,t=a.color,x=a.css,p=a.createElement,m=a.defined,e=a.deg2rad,d=a.destroyObjectProperties,l=a.doc,z=a.each,b=a.extend,u=a.erase,c=a.grep,C=a.hasTouch,q=a.inArray,r=a.isArray,h=a.isFirefox,E=a.isMS,f=a.isObject,v=a.isString,n=a.isWebKit,y=a.merge,L=a.noop,F=a.pick,I=a.pInt,g=a.removeEvent,J=a.stop,Q=a.svg,P=a.SVG_NS,M=a.symbolSizes,S=a.win;D=a.SVGElement=function(){return this};D.prototype=
	{opacity:1,SVG_NS:P,textProps:"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline".split(" "),init:function(a,g){this.element="span"===g?p(g):l.createElementNS(this.SVG_NS,g);this.renderer=a},animate:function(B,g,b){g=a.animObject(F(g,this.renderer.globalAnimation,!0));0!==g.duration?(b&&(g.complete=b),H(this,B,g)):(this.attr(B,null,b),g.step&&g.step.call(this));return this},colorGradient:function(B,g,b){var f=this.renderer,
	h,n,c,d,J,F,E,v,q,N,u,l=[],I;B.linearGradient?n="linearGradient":B.radialGradient&&(n="radialGradient");if(n){c=B[n];J=f.gradients;E=B.stops;N=b.radialReference;r(c)&&(B[n]=c={x1:c[0],y1:c[1],x2:c[2],y2:c[3],gradientUnits:"userSpaceOnUse"});"radialGradient"===n&&N&&!m(c.gradientUnits)&&(d=c,c=y(c,f.getRadialAttr(N,d),{gradientUnits:"userSpaceOnUse"}));for(u in c)"id"!==u&&l.push(u,c[u]);for(u in E)l.push(E[u]);l=l.join(",");J[l]?N=J[l].attr("id"):(c.id=N=a.uniqueKey(),J[l]=F=f.createElement(n).attr(c).add(f.defs),
	F.radAttr=d,F.stops=[],z(E,function(B){0===B[1].indexOf("rgba")?(h=a.color(B[1]),v=h.get("rgb"),q=h.get("a")):(v=B[1],q=1);B=f.createElement("stop").attr({offset:B[0],"stop-color":v,"stop-opacity":q}).add(F);F.stops.push(B)}));I="url("+f.url+"#"+N+")";b.setAttribute(g,I);b.gradient=l;B.toString=function(){return I}}},applyTextOutline:function(a){var B=this.element,g,b,f,h;-1!==a.indexOf("contrast")&&(a=a.replace(/contrast/g,this.renderer.getContrast(B.style.fill)));this.fakeTS=!0;this.ySetter=this.xSetter;
	g=[].slice.call(B.getElementsByTagName("tspan"));a=a.split(" ");b=a[a.length-1];(f=a[0])&&"none"!==f&&(f=f.replace(/(^[\d\.]+)(.*?)$/g,function(a,B,g){return 2*B+g}),z(g,function(a){"highcharts-text-outline"===a.getAttribute("class")&&u(g,B.removeChild(a))}),h=B.firstChild,z(g,function(a,g){0===g&&(a.setAttribute("x",B.getAttribute("x")),g=B.getAttribute("y"),a.setAttribute("y",g||0),null===g&&B.setAttribute("y",0));a=a.cloneNode(1);w(a,{"class":"highcharts-text-outline",fill:b,stroke:b,"stroke-width":f,
	"stroke-linejoin":"round"});B.insertBefore(a,h)}))},attr:function(a,g,b,f){var B,h=this.element,n,c=this,y;"string"===typeof a&&void 0!==g&&(B=a,a={},a[B]=g);if("string"===typeof a)c=(this[a+"Getter"]||this._defaultGetter).call(this,a,h);else{for(B in a)g=a[B],y=!1,f||J(this,B),this.symbolName&&/^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(B)&&(n||(this.symbolAttr(a),n=!0),y=!0),!this.rotation||"x"!==B&&"y"!==B||(this.doTransform=!0),y||(y=this[B+"Setter"]||this._defaultSetter,y.call(this,
	g,B,h),this.shadows&&/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(B)&&this.updateShadows(B,g,y));this.doTransform&&(this.updateTransform(),this.doTransform=!1)}b&&b();return c},updateShadows:function(a,g,b){for(var B=this.shadows,f=B.length;f--;)b.call(B[f],"height"===a?Math.max(g-(B[f].cutHeight||0),0):"d"===a?this.d:g,a,B[f])},addClass:function(a,g){var B=this.attr("class")||"";-1===B.indexOf(a)&&(g||(a=(B+(B?" ":"")+a).replace("  "," ")),this.attr("class",a));return this},hasClass:function(a){return-1!==
	w(this.element,"class").indexOf(a)},removeClass:function(a){w(this.element,"class",(w(this.element,"class")||"").replace(a,""));return this},symbolAttr:function(a){var B=this;z("x y r start end width height innerR anchorX anchorY".split(" "),function(g){B[g]=F(a[g],B[g])});B.attr({d:B.renderer.symbols[B.symbolName](B.x,B.y,B.width,B.height,B)})},clip:function(a){return this.attr("clip-path",a?"url("+this.renderer.url+"#"+a.id+")":"none")},crisp:function(a,g){var B,b={},f;g=g||a.strokeWidth||0;f=Math.round(g)%
	2/2;a.x=Math.floor(a.x||this.x||0)+f;a.y=Math.floor(a.y||this.y||0)+f;a.width=Math.floor((a.width||this.width||0)-2*f);a.height=Math.floor((a.height||this.height||0)-2*f);m(a.strokeWidth)&&(a.strokeWidth=g);for(B in a)this[B]!==a[B]&&(this[B]=b[B]=a[B]);return b},css:function(a){var B=this.styles,g={},f=this.element,h,n="",c=!B,y=["textOverflow","width"];a&&a.color&&(a.fill=a.color);if(B)for(h in a)a[h]!==B[h]&&(g[h]=a[h],c=!0);if(c){B&&(a=b(B,g));B=this.textWidth=a&&a.width&&"auto"!==a.width&&"text"===
	f.nodeName.toLowerCase()&&I(a.width);this.styles=a;B&&!Q&&this.renderer.forExport&&delete a.width;if(E&&!Q)x(this.element,a);else{B=function(a,B){return"-"+B.toLowerCase()};for(h in a)-1===q(h,y)&&(n+=h.replace(/([A-Z])/g,B)+":"+a[h]+";");n&&w(f,"style",n)}this.added&&("text"===this.element.nodeName&&this.renderer.buildText(this),a&&a.textOutline&&this.applyTextOutline(a.textOutline))}return this},strokeWidth:function(){return this["stroke-width"]||0},on:function(a,g){var B=this,b=B.element;C&&"click"===
	a?(b.ontouchstart=function(a){B.touchEventFired=Date.now();a.preventDefault();g.call(b,a)},b.onclick=function(a){(-1===S.navigator.userAgent.indexOf("Android")||1100<Date.now()-(B.touchEventFired||0))&&g.call(b,a)}):b["on"+a]=g;return this},setRadialReference:function(a){var B=this.renderer.gradients[this.element.gradient];this.element.radialReference=a;B&&B.radAttr&&B.animate(this.renderer.getRadialAttr(a,B.radAttr));return this},translate:function(a,g){return this.attr({translateX:a,translateY:g})},
	invert:function(a){this.inverted=a;this.updateTransform();return this},updateTransform:function(){var a=this.translateX||0,g=this.translateY||0,b=this.scaleX,f=this.scaleY,h=this.inverted,n=this.rotation,c=this.element;h&&(a+=this.width,g+=this.height);a=["translate("+a+","+g+")"];h?a.push("rotate(90) scale(-1,1)"):n&&a.push("rotate("+n+" "+(c.getAttribute("x")||0)+" "+(c.getAttribute("y")||0)+")");(m(b)||m(f))&&a.push("scale("+F(b,1)+" "+F(f,1)+")");a.length&&c.setAttribute("transform",a.join(" "))},
	toFront:function(){var a=this.element;a.parentNode.appendChild(a);return this},align:function(a,g,b){var B,f,h,n,c={};f=this.renderer;h=f.alignedObjects;var y,d;if(a){if(this.alignOptions=a,this.alignByTranslate=g,!b||v(b))this.alignTo=B=b||"renderer",u(h,this),h.push(this),b=null}else a=this.alignOptions,g=this.alignByTranslate,B=this.alignTo;b=F(b,f[B],f);B=a.align;f=a.verticalAlign;h=(b.x||0)+(a.x||0);n=(b.y||0)+(a.y||0);"right"===B?y=1:"center"===B&&(y=2);y&&(h+=(b.width-(a.width||0))/y);c[g?
	"translateX":"x"]=Math.round(h);"bottom"===f?d=1:"middle"===f&&(d=2);d&&(n+=(b.height-(a.height||0))/d);c[g?"translateY":"y"]=Math.round(n);this[this.placed?"animate":"attr"](c);this.placed=!0;this.alignAttr=c;return this},getBBox:function(a,g){var B,f=this.renderer,h,n=this.element,c=this.styles,y,d=this.textStr,J,E=f.cache,r=f.cacheKeys,v;g=F(g,this.rotation);h=g*e;y=c&&c.fontSize;void 0!==d&&(v=d.toString(),-1===v.indexOf("\x3c")&&(v=v.replace(/[0-9]/g,"0")),v+=["",g||0,y,c&&c.width,c&&c.textOverflow].join());
	v&&!a&&(B=E[v]);if(!B){if(n.namespaceURI===this.SVG_NS||f.forExport){try{(J=this.fakeTS&&function(a){z(n.querySelectorAll(".highcharts-text-outline"),function(B){B.style.display=a})})&&J("none"),B=n.getBBox?b({},n.getBBox()):{width:n.offsetWidth,height:n.offsetHeight},J&&J("")}catch(U){}if(!B||0>B.width)B={width:0,height:0}}else B=this.htmlGetBBox();f.isSVG&&(a=B.width,f=B.height,c&&"11px"===c.fontSize&&17===Math.round(f)&&(B.height=f=14),g&&(B.width=Math.abs(f*Math.sin(h))+Math.abs(a*Math.cos(h)),
	B.height=Math.abs(f*Math.cos(h))+Math.abs(a*Math.sin(h))));if(v&&0<B.height){for(;250<r.length;)delete E[r.shift()];E[v]||r.push(v);E[v]=B}}return B},show:function(a){return this.attr({visibility:a?"inherit":"visible"})},hide:function(){return this.attr({visibility:"hidden"})},fadeOut:function(a){var B=this;B.animate({opacity:0},{duration:a||150,complete:function(){B.attr({y:-9999})}})},add:function(a){var g=this.renderer,B=this.element,b;a&&(this.parentGroup=a);this.parentInverted=a&&a.inverted;
	void 0!==this.textStr&&g.buildText(this);this.added=!0;if(!a||a.handleZ||this.zIndex)b=this.zIndexSetter();b||(a?a.element:g.box).appendChild(B);if(this.onAdd)this.onAdd();return this},safeRemoveChild:function(a){var g=a.parentNode;g&&g.removeChild(a)},destroy:function(){var a=this.element||{},g=this.renderer.isSVG&&"SPAN"===a.nodeName&&this.parentGroup,b,f;a.onclick=a.onmouseout=a.onmouseover=a.onmousemove=a.point=null;J(this);this.clipPath&&(this.clipPath=this.clipPath.destroy());if(this.stops){for(f=
	0;f<this.stops.length;f++)this.stops[f]=this.stops[f].destroy();this.stops=null}this.safeRemoveChild(a);for(this.destroyShadows();g&&g.div&&0===g.div.childNodes.length;)a=g.parentGroup,this.safeRemoveChild(g.div),delete g.div,g=a;this.alignTo&&u(this.renderer.alignedObjects,this);for(b in this)delete this[b];return null},shadow:function(a,g,b){var B=[],f,h,n=this.element,c,y,d,J;if(!a)this.destroyShadows();else if(!this.shadows){y=F(a.width,3);d=(a.opacity||.15)/y;J=this.parentInverted?"(-1,-1)":
	"("+F(a.offsetX,1)+", "+F(a.offsetY,1)+")";for(f=1;f<=y;f++)h=n.cloneNode(0),c=2*y+1-2*f,w(h,{isShadow:"true",stroke:a.color||"#000000","stroke-opacity":d*f,"stroke-width":c,transform:"translate"+J,fill:"none"}),b&&(w(h,"height",Math.max(w(h,"height")-c,0)),h.cutHeight=c),g?g.element.appendChild(h):n.parentNode.insertBefore(h,n),B.push(h);this.shadows=B}return this},destroyShadows:function(){z(this.shadows||[],function(a){this.safeRemoveChild(a)},this);this.shadows=void 0},xGetter:function(a){"circle"===
	this.element.nodeName&&("x"===a?a="cx":"y"===a&&(a="cy"));return this._defaultGetter(a)},_defaultGetter:function(a){a=F(this[a],this.element?this.element.getAttribute(a):null,0);/^[\-0-9\.]+$/.test(a)&&(a=parseFloat(a));return a},dSetter:function(a,g,b){a&&a.join&&(a=a.join(" "));/(NaN| {2}|^$)/.test(a)&&(a="M 0 0");b.setAttribute(g,a);this[g]=a},dashstyleSetter:function(a){var g,B=this["stroke-width"];"inherit"===B&&(B=1);if(a=a&&a.toLowerCase()){a=a.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot",
	"3,1,1,1").replace("shortdot","1,1,").replace("shortdash","3,1,").replace("longdash","8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");for(g=a.length;g--;)a[g]=I(a[g])*B;a=a.join(",").replace(/NaN/g,"none");this.element.setAttribute("stroke-dasharray",a)}},alignSetter:function(a){this.element.setAttribute("text-anchor",{left:"start",center:"middle",right:"end"}[a])},opacitySetter:function(a,g,b){this[g]=a;b.setAttribute(g,a)},titleSetter:function(a){var g=this.element.getElementsByTagName("title")[0];
	g||(g=l.createElementNS(this.SVG_NS,"title"),this.element.appendChild(g));g.firstChild&&g.removeChild(g.firstChild);g.appendChild(l.createTextNode(String(F(a),"").replace(/<[^>]*>/g,"")))},textSetter:function(a){a!==this.textStr&&(delete this.bBox,this.textStr=a,this.added&&this.renderer.buildText(this))},fillSetter:function(a,g,b){"string"===typeof a?b.setAttribute(g,a):a&&this.colorGradient(a,g,b)},visibilitySetter:function(a,g,b){"inherit"===a?b.removeAttribute(g):b.setAttribute(g,a)},zIndexSetter:function(a,
	g){var b=this.renderer,f=this.parentGroup,B=(f||b).element||b.box,h,n=this.element,c;h=this.added;var y;m(a)&&(n.zIndex=a,a=+a,this[g]===a&&(h=!1),this[g]=a);if(h){(a=this.zIndex)&&f&&(f.handleZ=!0);g=B.childNodes;for(y=0;y<g.length&&!c;y++)f=g[y],h=f.zIndex,f!==n&&(I(h)>a||!m(a)&&m(h)||0>a&&!m(h)&&B!==b.box)&&(B.insertBefore(n,f),c=!0);c||B.appendChild(n)}return c},_defaultSetter:function(a,g,b){b.setAttribute(g,a)}};D.prototype.yGetter=D.prototype.xGetter;D.prototype.translateXSetter=D.prototype.translateYSetter=
	D.prototype.rotationSetter=D.prototype.verticalAlignSetter=D.prototype.scaleXSetter=D.prototype.scaleYSetter=function(a,g){this[g]=a;this.doTransform=!0};D.prototype["stroke-widthSetter"]=D.prototype.strokeSetter=function(a,g,b){this[g]=a;this.stroke&&this["stroke-width"]?(D.prototype.fillSetter.call(this,this.stroke,"stroke",b),b.setAttribute("stroke-width",this["stroke-width"]),this.hasStroke=!0):"stroke-width"===g&&0===a&&this.hasStroke&&(b.removeAttribute("stroke"),this.hasStroke=!1)};A=a.SVGRenderer=
	function(){this.init.apply(this,arguments)};A.prototype={Element:D,SVG_NS:P,init:function(a,g,b,f,c,y){var B;f=this.createElement("svg").attr({version:"1.1","class":"highcharts-root"}).css(this.getStyle(f));B=f.element;a.appendChild(B);-1===a.innerHTML.indexOf("xmlns")&&w(B,"xmlns",this.SVG_NS);this.isSVG=!0;this.box=B;this.boxWrapper=f;this.alignedObjects=[];this.url=(h||n)&&l.getElementsByTagName("base").length?S.location.href.replace(/#.*?$/,"").replace(/<[^>]*>/g,"").replace(/([\('\)])/g,"\\$1").replace(/ /g,
	"%20"):"";this.createElement("desc").add().element.appendChild(l.createTextNode("Created with Highstock 5.0.9"));this.defs=this.createElement("defs").add();this.allowHTML=y;this.forExport=c;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.setSize(g,b,!1);var d;h&&a.getBoundingClientRect&&(g=function(){x(a,{left:0,top:0});d=a.getBoundingClientRect();x(a,{left:Math.ceil(d.left)-d.left+"px",top:Math.ceil(d.top)-d.top+"px"})},g(),this.unSubPixelFix=G(S,"resize",g))},getStyle:function(a){return this.style=
	b({fontFamily:'"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',fontSize:"12px"},a)},setStyle:function(a){this.boxWrapper.css(this.getStyle(a))},isHidden:function(){return!this.boxWrapper.getBBox().width},destroy:function(){var a=this.defs;this.box=null;this.boxWrapper=this.boxWrapper.destroy();d(this.gradients||{});this.gradients=null;a&&(this.defs=a.destroy());this.unSubPixelFix&&this.unSubPixelFix();return this.alignedObjects=null},createElement:function(a){var g=new this.Element;
	g.init(this,a);return g},draw:L,getRadialAttr:function(a,g){return{cx:a[0]-a[2]/2+g.cx*a[2],cy:a[1]-a[2]/2+g.cy*a[2],r:g.r*a[2]}},buildText:function(a){var g=a.element,b=this,f=b.forExport,h=F(a.textStr,"").toString(),n=-1!==h.indexOf("\x3c"),B=g.childNodes,y,d,J,E,v=w(g,"x"),r=a.styles,q=a.textWidth,u=r&&r.lineHeight,e=r&&r.textOutline,C=r&&"ellipsis"===r.textOverflow,L=r&&"nowrap"===r.whiteSpace,m=r&&r.fontSize,p,k=B.length,r=q&&!a.added&&this.box,t=function(a){var f;f=/(px|em)$/.test(a&&a.style.fontSize)?
	a.style.fontSize:m||b.style.fontSize||12;return u?I(u):b.fontMetrics(f,a.getAttribute("style")?a:g).h};p=[h,C,L,u,e,m,q].join();if(p!==a.textCache){for(a.textCache=p;k--;)g.removeChild(B[k]);n||e||C||q||-1!==h.indexOf(" ")?(y=/<.*class="([^"]+)".*>/,d=/<.*style="([^"]+)".*>/,J=/<.*href="(http[^"]+)".*>/,r&&r.appendChild(g),h=n?h.replace(/<(b|strong)>/g,'\x3cspan style\x3d"font-weight:bold"\x3e').replace(/<(i|em)>/g,'\x3cspan style\x3d"font-style:italic"\x3e').replace(/<a/g,"\x3cspan").replace(/<\/(b|strong|i|em|a)>/g,
	"\x3c/span\x3e").split(/<br.*?>/g):[h],h=c(h,function(a){return""!==a}),z(h,function(h,n){var B,c=0;h=h.replace(/^\s+|\s+$/g,"").replace(/<span/g,"|||\x3cspan").replace(/<\/span>/g,"\x3c/span\x3e|||");B=h.split("|||");z(B,function(h){if(""!==h||1===B.length){var r={},F=l.createElementNS(b.SVG_NS,"tspan"),u,I;y.test(h)&&(u=h.match(y)[1],w(F,"class",u));d.test(h)&&(I=h.match(d)[1].replace(/(;| |^)color([ :])/,"$1fill$2"),w(F,"style",I));J.test(h)&&!f&&(w(F,"onclick",'location.href\x3d"'+h.match(J)[1]+
	'"'),x(F,{cursor:"pointer"}));h=(h.replace(/<(.|\n)*?>/g,"")||" ").replace(/&lt;/g,"\x3c").replace(/&gt;/g,"\x3e");if(" "!==h){F.appendChild(l.createTextNode(h));c?r.dx=0:n&&null!==v&&(r.x=v);w(F,r);g.appendChild(F);!c&&n&&(!Q&&f&&x(F,{display:"block"}),w(F,"dy",t(F)));if(q){r=h.replace(/([^\^])-/g,"$1- ").split(" ");u=1<B.length||n||1<r.length&&!L;for(var e,z,m=[],p=t(F),N=a.rotation,k=h,M=k.length;(u||C)&&(r.length||m.length);)a.rotation=0,e=a.getBBox(!0),z=e.width,!Q&&b.forExport&&(z=b.measureSpanWidth(F.firstChild.data,
	a.styles)),e=z>q,void 0===E&&(E=e),C&&E?(M/=2,""===k||!e&&.5>M?r=[]:(k=h.substring(0,k.length+(e?-1:1)*Math.ceil(M)),r=[k+(3<q?"\u2026":"")],F.removeChild(F.firstChild))):e&&1!==r.length?(F.removeChild(F.firstChild),m.unshift(r.pop())):(r=m,m=[],r.length&&!L&&(F=l.createElementNS(P,"tspan"),w(F,{dy:p,x:v}),I&&w(F,"style",I),g.appendChild(F)),z>q&&(q=z)),r.length&&F.appendChild(l.createTextNode(r.join(" ").replace(/- /g,"-")));a.rotation=N}c++}}})}),E&&a.attr("title",a.textStr),r&&r.removeChild(g),
	e&&a.applyTextOutline&&a.applyTextOutline(e)):g.appendChild(l.createTextNode(h.replace(/&lt;/g,"\x3c").replace(/&gt;/g,"\x3e")))}},getContrast:function(a){a=t(a).rgba;return 510<a[0]+a[1]+a[2]?"#000000":"#FFFFFF"},button:function(a,g,f,h,n,c,d,J,r){var B=this.label(a,g,f,r,null,null,null,null,"button"),F=0;B.attr(y({padding:8,r:2},n));var v,q,u,l;n=y({fill:"#f7f7f7",stroke:"#cccccc","stroke-width":1,style:{color:"#333333",cursor:"pointer",fontWeight:"normal"}},n);v=n.style;delete n.style;c=y(n,{fill:"#e6e6e6"},
	c);q=c.style;delete c.style;d=y(n,{fill:"#e6ebf5",style:{color:"#000000",fontWeight:"bold"}},d);u=d.style;delete d.style;J=y(n,{style:{color:"#cccccc"}},J);l=J.style;delete J.style;G(B.element,E?"mouseover":"mouseenter",function(){3!==F&&B.setState(1)});G(B.element,E?"mouseout":"mouseleave",function(){3!==F&&B.setState(F)});B.setState=function(a){1!==a&&(B.state=F=a);B.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-"+["normal","hover","pressed","disabled"][a||
	0]);B.attr([n,c,d,J][a||0]).css([v,q,u,l][a||0])};B.attr(n).css(b({cursor:"default"},v));return B.on("click",function(a){3!==F&&h.call(B,a)})},crispLine:function(a,g){a[1]===a[4]&&(a[1]=a[4]=Math.round(a[1])-g%2/2);a[2]===a[5]&&(a[2]=a[5]=Math.round(a[2])+g%2/2);return a},path:function(a){var g={fill:"none"};r(a)?g.d=a:f(a)&&b(g,a);return this.createElement("path").attr(g)},circle:function(a,g,b){a=f(a)?a:{x:a,y:g,r:b};g=this.createElement("circle");g.xSetter=g.ySetter=function(a,g,b){b.setAttribute("c"+
	g,a)};return g.attr(a)},arc:function(a,g,b,h,n,c){f(a)?(h=a,g=h.y,b=h.r,a=h.x):h={innerR:h,start:n,end:c};a=this.symbol("arc",a,g,b,b,h);a.r=b;return a},rect:function(a,g,b,h,n,c){n=f(a)?a.r:n;var B=this.createElement("rect");a=f(a)?a:void 0===a?{}:{x:a,y:g,width:Math.max(b,0),height:Math.max(h,0)};void 0!==c&&(a.strokeWidth=c,a=B.crisp(a));a.fill="none";n&&(a.r=n);B.rSetter=function(a,g,b){w(b,{rx:a,ry:a})};return B.attr(a)},setSize:function(a,g,b){var h=this.alignedObjects,f=h.length;this.width=
	a;this.height=g;for(this.boxWrapper.animate({width:a,height:g},{step:function(){this.attr({viewBox:"0 0 "+this.attr("width")+" "+this.attr("height")})},duration:F(b,!0)?void 0:0});f--;)h[f].align()},g:function(a){var g=this.createElement("g");return a?g.attr({"class":"highcharts-"+a}):g},image:function(a,g,h,f,n){var c={preserveAspectRatio:"none"};1<arguments.length&&b(c,{x:g,y:h,width:f,height:n});c=this.createElement("image").attr(c);c.element.setAttributeNS?c.element.setAttributeNS("http://www.w3.org/1999/xlink",
	"href",a):c.element.setAttribute("hc-svg-href",a);return c},symbol:function(a,g,h,f,n,c){var y=this,B,d=this.symbols[a],J=m(g)&&d&&this.symbols[a](Math.round(g),Math.round(h),f,n,c),r=/^url\((.*?)\)$/,E,v;d?(B=this.path(J),B.attr("fill","none"),b(B,{symbolName:a,x:g,y:h,width:f,height:n}),c&&b(B,c)):r.test(a)&&(E=a.match(r)[1],B=this.image(E),B.imgwidth=F(M[E]&&M[E].width,c&&c.width),B.imgheight=F(M[E]&&M[E].height,c&&c.height),v=function(){B.attr({width:B.width,height:B.height})},z(["width","height"],
	function(a){B[a+"Setter"]=function(a,g){var b={},h=this["img"+g],f="width"===g?"translateX":"translateY";this[g]=a;m(h)&&(this.element&&this.element.setAttribute(g,h),this.alignByTranslate||(b[f]=((this[g]||0)-h)/2,this.attr(b)))}}),m(g)&&B.attr({x:g,y:h}),B.isImg=!0,m(B.imgwidth)&&m(B.imgheight)?v():(B.attr({width:0,height:0}),p("img",{onload:function(){var a=k[y.chartIndex];0===this.width&&(x(this,{position:"absolute",top:"-999em"}),l.body.appendChild(this));M[E]={width:this.width,height:this.height};
	B.imgwidth=this.width;B.imgheight=this.height;B.element&&v();this.parentNode&&this.parentNode.removeChild(this);y.imgCount--;if(!y.imgCount&&a&&a.onload)a.onload()},src:E}),this.imgCount++));return B},symbols:{circle:function(a,g,b,h){return this.arc(a+b/2,g+h/2,b/2,h/2,{start:0,end:2*Math.PI,open:!1})},square:function(a,g,b,h){return["M",a,g,"L",a+b,g,a+b,g+h,a,g+h,"Z"]},triangle:function(a,g,b,h){return["M",a+b/2,g,"L",a+b,g+h,a,g+h,"Z"]},"triangle-down":function(a,g,b,h){return["M",a,g,"L",a+b,
	g,a+b/2,g+h,"Z"]},diamond:function(a,g,b,h){return["M",a+b/2,g,"L",a+b,g+h/2,a+b/2,g+h,a,g+h/2,"Z"]},arc:function(a,g,b,h,f){var n=f.start,c=f.r||b,y=f.r||h||b,d=f.end-.001;b=f.innerR;h=f.open;var B=Math.cos(n),J=Math.sin(n),F=Math.cos(d),d=Math.sin(d);f=f.end-n<Math.PI?0:1;c=["M",a+c*B,g+y*J,"A",c,y,0,f,1,a+c*F,g+y*d];m(b)&&c.push(h?"M":"L",a+b*F,g+b*d,"A",b,b,0,f,0,a+b*B,g+b*J);c.push(h?"":"Z");return c},callout:function(a,g,b,h,f){var n=Math.min(f&&f.r||0,b,h),c=n+6,y=f&&f.anchorX;f=f&&f.anchorY;
	var d;d=["M",a+n,g,"L",a+b-n,g,"C",a+b,g,a+b,g,a+b,g+n,"L",a+b,g+h-n,"C",a+b,g+h,a+b,g+h,a+b-n,g+h,"L",a+n,g+h,"C",a,g+h,a,g+h,a,g+h-n,"L",a,g+n,"C",a,g,a,g,a+n,g];y&&y>b?f>g+c&&f<g+h-c?d.splice(13,3,"L",a+b,f-6,a+b+6,f,a+b,f+6,a+b,g+h-n):d.splice(13,3,"L",a+b,h/2,y,f,a+b,h/2,a+b,g+h-n):y&&0>y?f>g+c&&f<g+h-c?d.splice(33,3,"L",a,f+6,a-6,f,a,f-6,a,g+n):d.splice(33,3,"L",a,h/2,y,f,a,h/2,a,g+n):f&&f>h&&y>a+c&&y<a+b-c?d.splice(23,3,"L",y+6,g+h,y,g+h+6,y-6,g+h,a+n,g+h):f&&0>f&&y>a+c&&y<a+b-c&&d.splice(3,
	3,"L",y-6,g,y,g-6,y+6,g,b-n,g);return d}},clipRect:function(g,b,h,f){var n=a.uniqueKey(),c=this.createElement("clipPath").attr({id:n}).add(this.defs);g=this.rect(g,b,h,f,0).add(c);g.id=n;g.clipPath=c;g.count=0;return g},text:function(a,g,b,h){var f=!Q&&this.forExport,n={};if(h&&(this.allowHTML||!this.forExport))return this.html(a,g,b);n.x=Math.round(g||0);b&&(n.y=Math.round(b));if(a||0===a)n.text=a;a=this.createElement("text").attr(n);f&&a.css({position:"absolute"});h||(a.xSetter=function(a,g,b){var h=
	b.getElementsByTagName("tspan"),f,n=b.getAttribute(g),c;for(c=0;c<h.length;c++)f=h[c],f.getAttribute(g)===n&&f.setAttribute(g,a);b.setAttribute(g,a)});return a},fontMetrics:function(a,g){a=a||g&&g.style&&g.style.fontSize||this.style&&this.style.fontSize;a=/px/.test(a)?I(a):/em/.test(a)?parseFloat(a)*(g?this.fontMetrics(null,g.parentNode).f:16):12;g=24>a?a+3:Math.round(1.2*a);return{h:g,b:Math.round(.8*g),f:a}},rotCorr:function(a,g,b){var h=a;g&&b&&(h=Math.max(h*Math.cos(g*e),4));return{x:-a/3*Math.sin(g*
	e),y:h}},label:function(h,f,n,c,d,J,F,r,E){var B=this,v=B.g("button"!==E&&"label"),q=v.text=B.text("",0,0,F).attr({zIndex:1}),u,l,I=0,e=3,C=0,L,Q,P,p,k,x={},t,M,N=/^url\((.*?)\)$/.test(c),w=N,S,R,O,T;E&&v.addClass("highcharts-"+E);w=N;S=function(){return(t||0)%2/2};R=function(){var a=q.element.style,g={};l=(void 0===L||void 0===Q||k)&&m(q.textStr)&&q.getBBox();v.width=(L||l.width||0)+2*e+C;v.height=(Q||l.height||0)+2*e;M=e+B.fontMetrics(a&&a.fontSize,q).b;w&&(u||(v.box=u=B.symbols[c]||N?B.symbol(c):
	B.rect(),u.addClass(("button"===E?"":"highcharts-label-box")+(E?" highcharts-"+E+"-box":"")),u.add(v),a=S(),g.x=a,g.y=(r?-M:0)+a),g.width=Math.round(v.width),g.height=Math.round(v.height),u.attr(b(g,x)),x={})};O=function(){var a=C+e,g;g=r?0:M;m(L)&&l&&("center"===k||"right"===k)&&(a+={center:.5,right:1}[k]*(L-l.width));if(a!==q.x||g!==q.y)q.attr("x",a),void 0!==g&&q.attr("y",g);q.x=a;q.y=g};T=function(a,g){u?u.attr(a,g):x[a]=g};v.onAdd=function(){q.add(v);v.attr({text:h||0===h?h:"",x:f,y:n});u&&m(d)&&
	v.attr({anchorX:d,anchorY:J})};v.widthSetter=function(g){L=a.isNumber(g)?g:null};v.heightSetter=function(a){Q=a};v["text-alignSetter"]=function(a){k=a};v.paddingSetter=function(a){m(a)&&a!==e&&(e=v.padding=a,O())};v.paddingLeftSetter=function(a){m(a)&&a!==C&&(C=a,O())};v.alignSetter=function(a){a={left:0,center:.5,right:1}[a];a!==I&&(I=a,l&&v.attr({x:P}))};v.textSetter=function(a){void 0!==a&&q.textSetter(a);R();O()};v["stroke-widthSetter"]=function(a,g){a&&(w=!0);t=this["stroke-width"]=a;T(g,a)};
	v.strokeSetter=v.fillSetter=v.rSetter=function(a,g){"fill"===g&&a&&(w=!0);T(g,a)};v.anchorXSetter=function(a,g){d=a;T(g,Math.round(a)-S()-P)};v.anchorYSetter=function(a,g){J=a;T(g,a-p)};v.xSetter=function(a){v.x=a;I&&(a-=I*((L||l.width)+2*e));P=Math.round(a);v.attr("translateX",P)};v.ySetter=function(a){p=v.y=Math.round(a);v.attr("translateY",p)};var A=v.css;return b(v,{css:function(a){if(a){var g={};a=y(a);z(v.textProps,function(b){void 0!==a[b]&&(g[b]=a[b],delete a[b])});q.css(g)}return A.call(v,
	a)},getBBox:function(){return{width:l.width+2*e,height:l.height+2*e,x:l.x-e,y:l.y-e}},shadow:function(a){a&&(R(),u&&u.shadow(a));return v},destroy:function(){g(v.element,"mouseenter");g(v.element,"mouseleave");q&&(q=q.destroy());u&&(u=u.destroy());D.prototype.destroy.call(v);v=B=R=O=T=null}})}};a.Renderer=A})(K);(function(a){var D=a.attr,A=a.createElement,G=a.css,H=a.defined,w=a.each,k=a.extend,t=a.isFirefox,x=a.isMS,p=a.isWebKit,m=a.pInt,e=a.SVGRenderer,d=a.win,l=a.wrap;k(a.SVGElement.prototype,
	{htmlCss:function(a){var b=this.element;if(b=a&&"SPAN"===b.tagName&&a.width)delete a.width,this.textWidth=b,this.updateTransform();a&&"ellipsis"===a.textOverflow&&(a.whiteSpace="nowrap",a.overflow="hidden");this.styles=k(this.styles,a);G(this.element,a);return this},htmlGetBBox:function(){var a=this.element;"text"===a.nodeName&&(a.style.position="absolute");return{x:a.offsetLeft,y:a.offsetTop,width:a.offsetWidth,height:a.offsetHeight}},htmlUpdateTransform:function(){if(this.added){var a=this.renderer,
	b=this.element,d=this.translateX||0,c=this.translateY||0,l=this.x||0,q=this.y||0,r=this.textAlign||"left",h={left:0,center:.5,right:1}[r],E=this.styles;G(b,{marginLeft:d,marginTop:c});this.shadows&&w(this.shadows,function(a){G(a,{marginLeft:d+1,marginTop:c+1})});this.inverted&&w(b.childNodes,function(h){a.invertChild(h,b)});if("SPAN"===b.tagName){var f=this.rotation,v=m(this.textWidth),n=E&&E.whiteSpace,y=[f,r,b.innerHTML,this.textWidth,this.textAlign].join();y!==this.cTT&&(E=a.fontMetrics(b.style.fontSize).b,
	H(f)&&this.setSpanRotation(f,h,E),G(b,{width:"",whiteSpace:n||"nowrap"}),b.offsetWidth>v&&/[ \-]/.test(b.textContent||b.innerText)&&G(b,{width:v+"px",display:"block",whiteSpace:n||"normal"}),this.getSpanCorrection(b.offsetWidth,E,h,f,r));G(b,{left:l+(this.xCorr||0)+"px",top:q+(this.yCorr||0)+"px"});p&&(E=b.offsetHeight);this.cTT=y}}else this.alignOnAdd=!0},setSpanRotation:function(a,b,u){var c={},l=x?"-ms-transform":p?"-webkit-transform":t?"MozTransform":d.opera?"-o-transform":"";c[l]=c.transform=
	"rotate("+a+"deg)";c[l+(t?"Origin":"-origin")]=c.transformOrigin=100*b+"% "+u+"px";G(this.element,c)},getSpanCorrection:function(a,b,d){this.xCorr=-a*d;this.yCorr=-b}});k(e.prototype,{html:function(a,b,d){var c=this.createElement("span"),u=c.element,q=c.renderer,r=q.isSVG,h=function(a,b){w(["opacity","visibility"],function(h){l(a,h+"Setter",function(a,h,f,c){a.call(this,h,f,c);b[f]=h})})};c.textSetter=function(a){a!==u.innerHTML&&delete this.bBox;u.innerHTML=this.textStr=a;c.htmlUpdateTransform()};
	r&&h(c,c.element.style);c.xSetter=c.ySetter=c.alignSetter=c.rotationSetter=function(a,b){"align"===b&&(b="textAlign");c[b]=a;c.htmlUpdateTransform()};c.attr({text:a,x:Math.round(b),y:Math.round(d)}).css({fontFamily:this.style.fontFamily,fontSize:this.style.fontSize,position:"absolute"});u.style.whiteSpace="nowrap";c.css=c.htmlCss;r&&(c.add=function(a){var b,d=q.box.parentNode,n=[];if(this.parentGroup=a){if(b=a.div,!b){for(;a;)n.push(a),a=a.parentGroup;w(n.reverse(),function(a){var f,y=D(a.element,
	"class");y&&(y={className:y});b=a.div=a.div||A("div",y,{position:"absolute",left:(a.translateX||0)+"px",top:(a.translateY||0)+"px",display:a.display,opacity:a.opacity,pointerEvents:a.styles&&a.styles.pointerEvents},b||d);f=b.style;k(a,{on:function(){c.on.apply({element:n[0].div},arguments);return a},translateXSetter:function(b,g){f.left=b+"px";a[g]=b;a.doTransform=!0},translateYSetter:function(b,g){f.top=b+"px";a[g]=b;a.doTransform=!0}});h(a,f)})}}else b=d;b.appendChild(u);c.added=!0;c.alignOnAdd&&
	c.htmlUpdateTransform();return c});return c}})})(K);(function(a){var D,A,G=a.createElement,H=a.css,w=a.defined,k=a.deg2rad,t=a.discardElement,x=a.doc,p=a.each,m=a.erase,e=a.extend;D=a.extendClass;var d=a.isArray,l=a.isNumber,z=a.isObject,b=a.merge;A=a.noop;var u=a.pick,c=a.pInt,C=a.SVGElement,q=a.SVGRenderer,r=a.win;a.svg||(A={docMode8:x&&8===x.documentMode,init:function(a,b){var h=["\x3c",b,' filled\x3d"f" stroked\x3d"f"'],c=["position: ","absolute",";"],n="div"===b;("shape"===b||n)&&c.push("left:0;top:0;width:1px;height:1px;");
	c.push("visibility: ",n?"hidden":"visible");h.push(' style\x3d"',c.join(""),'"/\x3e');b&&(h=n||"span"===b||"img"===b?h.join(""):a.prepVML(h),this.element=G(h));this.renderer=a},add:function(a){var b=this.renderer,h=this.element,c=b.box,n=a&&a.inverted,c=a?a.element||a:c;a&&(this.parentGroup=a);n&&b.invertChild(h,c);c.appendChild(h);this.added=!0;this.alignOnAdd&&!this.deferUpdateTransform&&this.updateTransform();if(this.onAdd)this.onAdd();this.className&&this.attr("class",this.className);return this},
	updateTransform:C.prototype.htmlUpdateTransform,setSpanRotation:function(){var a=this.rotation,b=Math.cos(a*k),f=Math.sin(a*k);H(this.element,{filter:a?["progid:DXImageTransform.Microsoft.Matrix(M11\x3d",b,", M12\x3d",-f,", M21\x3d",f,", M22\x3d",b,", sizingMethod\x3d'auto expand')"].join(""):"none"})},getSpanCorrection:function(a,b,f,c,n){var h=c?Math.cos(c*k):1,d=c?Math.sin(c*k):0,r=u(this.elemHeight,this.element.offsetHeight),v;this.xCorr=0>h&&-a;this.yCorr=0>d&&-r;v=0>h*d;this.xCorr+=d*b*(v?1-
	f:f);this.yCorr-=h*b*(c?v?f:1-f:1);n&&"left"!==n&&(this.xCorr-=a*f*(0>h?-1:1),c&&(this.yCorr-=r*f*(0>d?-1:1)),H(this.element,{textAlign:n}))},pathToVML:function(a){for(var b=a.length,h=[];b--;)l(a[b])?h[b]=Math.round(10*a[b])-5:"Z"===a[b]?h[b]="x":(h[b]=a[b],!a.isArc||"wa"!==a[b]&&"at"!==a[b]||(h[b+5]===h[b+7]&&(h[b+7]+=a[b+7]>a[b+5]?1:-1),h[b+6]===h[b+8]&&(h[b+8]+=a[b+8]>a[b+6]?1:-1)));return h.join(" ")||"x"},clip:function(a){var b=this,h;a?(h=a.members,m(h,b),h.push(b),b.destroyClip=function(){m(h,
	b)},a=a.getCSS(b)):(b.destroyClip&&b.destroyClip(),a={clip:b.docMode8?"inherit":"rect(auto)"});return b.css(a)},css:C.prototype.htmlCss,safeRemoveChild:function(a){a.parentNode&&t(a)},destroy:function(){this.destroyClip&&this.destroyClip();return C.prototype.destroy.apply(this)},on:function(a,b){this.element["on"+a]=function(){var a=r.event;a.target=a.srcElement;b(a)};return this},cutOffPath:function(a,b){var h;a=a.split(/[ ,]/);h=a.length;if(9===h||11===h)a[h-4]=a[h-2]=c(a[h-2])-10*b;return a.join(" ")},
	shadow:function(a,b,f){var h=[],n,d=this.element,r=this.renderer,F,q=d.style,g,J=d.path,l,e,E,C;J&&"string"!==typeof J.value&&(J="x");e=J;if(a){E=u(a.width,3);C=(a.opacity||.15)/E;for(n=1;3>=n;n++)l=2*E+1-2*n,f&&(e=this.cutOffPath(J.value,l+.5)),g=['\x3cshape isShadow\x3d"true" strokeweight\x3d"',l,'" filled\x3d"false" path\x3d"',e,'" coordsize\x3d"10 10" style\x3d"',d.style.cssText,'" /\x3e'],F=G(r.prepVML(g),null,{left:c(q.left)+u(a.offsetX,1),top:c(q.top)+u(a.offsetY,1)}),f&&(F.cutOff=l+1),g=['\x3cstroke color\x3d"',
	a.color||"#000000",'" opacity\x3d"',C*n,'"/\x3e'],G(r.prepVML(g),null,null,F),b?b.element.appendChild(F):d.parentNode.insertBefore(F,d),h.push(F);this.shadows=h}return this},updateShadows:A,setAttr:function(a,b){this.docMode8?this.element[a]=b:this.element.setAttribute(a,b)},classSetter:function(a){(this.added?this.element:this).className=a},dashstyleSetter:function(a,b,f){(f.getElementsByTagName("stroke")[0]||G(this.renderer.prepVML(["\x3cstroke/\x3e"]),null,null,f))[b]=a||"solid";this[b]=a},dSetter:function(a,
	b,f){var h=this.shadows;a=a||[];this.d=a.join&&a.join(" ");f.path=a=this.pathToVML(a);if(h)for(f=h.length;f--;)h[f].path=h[f].cutOff?this.cutOffPath(a,h[f].cutOff):a;this.setAttr(b,a)},fillSetter:function(a,b,f){var h=f.nodeName;"SPAN"===h?f.style.color=a:"IMG"!==h&&(f.filled="none"!==a,this.setAttr("fillcolor",this.renderer.color(a,f,b,this)))},"fill-opacitySetter":function(a,b,f){G(this.renderer.prepVML(["\x3c",b.split("-")[0],' opacity\x3d"',a,'"/\x3e']),null,null,f)},opacitySetter:A,rotationSetter:function(a,
	b,f){f=f.style;this[b]=f[b]=a;f.left=-Math.round(Math.sin(a*k)+1)+"px";f.top=Math.round(Math.cos(a*k))+"px"},strokeSetter:function(a,b,f){this.setAttr("strokecolor",this.renderer.color(a,f,b,this))},"stroke-widthSetter":function(a,b,f){f.stroked=!!a;this[b]=a;l(a)&&(a+="px");this.setAttr("strokeweight",a)},titleSetter:function(a,b){this.setAttr(b,a)},visibilitySetter:function(a,b,f){"inherit"===a&&(a="visible");this.shadows&&p(this.shadows,function(h){h.style[b]=a});"DIV"===f.nodeName&&(a="hidden"===
	a?"-999em":0,this.docMode8||(f.style[b]=a?"visible":"hidden"),b="top");f.style[b]=a},xSetter:function(a,b,f){this[b]=a;"x"===b?b="left":"y"===b&&(b="top");this.updateClipping?(this[b]=a,this.updateClipping()):f.style[b]=a},zIndexSetter:function(a,b,f){f.style[b]=a}},A["stroke-opacitySetter"]=A["fill-opacitySetter"],a.VMLElement=A=D(C,A),A.prototype.ySetter=A.prototype.widthSetter=A.prototype.heightSetter=A.prototype.xSetter,A={Element:A,isIE8:-1<r.navigator.userAgent.indexOf("MSIE 8.0"),init:function(a,
	b,f){var h,n;this.alignedObjects=[];h=this.createElement("div").css({position:"relative"});n=h.element;a.appendChild(h.element);this.isVML=!0;this.box=n;this.boxWrapper=h;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.setSize(b,f,!1);if(!x.namespaces.hcv){x.namespaces.add("hcv","urn:schemas-microsoft-com:vml");try{x.createStyleSheet().cssText="hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } "}catch(y){x.styleSheets[0].cssText+=
	"hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } "}}},isHidden:function(){return!this.box.offsetWidth},clipRect:function(a,b,f,c){var h=this.createElement(),d=z(a);return e(h,{members:[],count:0,left:(d?a.x:a)+1,top:(d?a.y:b)+1,width:(d?a.width:f)-1,height:(d?a.height:c)-1,getCSS:function(a){var b=a.element,h=b.nodeName,g=a.inverted,f=this.top-("shape"===h?b.offsetTop:0),n=this.left,b=n+this.width,c=f+this.height,f={clip:"rect("+Math.round(g?
	n:f)+"px,"+Math.round(g?c:b)+"px,"+Math.round(g?b:c)+"px,"+Math.round(g?f:n)+"px)"};!g&&a.docMode8&&"DIV"===h&&e(f,{width:b+"px",height:c+"px"});return f},updateClipping:function(){p(h.members,function(a){a.element&&a.css(h.getCSS(a))})}})},color:function(b,c,f,d){var h=this,y,r=/^rgba/,F,q,g="none";b&&b.linearGradient?q="gradient":b&&b.radialGradient&&(q="pattern");if(q){var J,v,u=b.linearGradient||b.radialGradient,l,e,B,C,E,z="";b=b.stops;var m,k=[],x=function(){F=['\x3cfill colors\x3d"'+k.join(",")+
	'" opacity\x3d"',B,'" o:opacity2\x3d"',e,'" type\x3d"',q,'" ',z,'focus\x3d"100%" method\x3d"any" /\x3e'];G(h.prepVML(F),null,null,c)};l=b[0];m=b[b.length-1];0<l[0]&&b.unshift([0,l[1]]);1>m[0]&&b.push([1,m[1]]);p(b,function(g,b){r.test(g[1])?(y=a.color(g[1]),J=y.get("rgb"),v=y.get("a")):(J=g[1],v=1);k.push(100*g[0]+"% "+J);b?(B=v,C=J):(e=v,E=J)});if("fill"===f)if("gradient"===q)f=u.x1||u[0]||0,b=u.y1||u[1]||0,l=u.x2||u[2]||0,u=u.y2||u[3]||0,z='angle\x3d"'+(90-180*Math.atan((u-b)/(l-f))/Math.PI)+'"',
	x();else{var g=u.r,t=2*g,w=2*g,A=u.cx,D=u.cy,H=c.radialReference,K,g=function(){H&&(K=d.getBBox(),A+=(H[0]-K.x)/K.width-.5,D+=(H[1]-K.y)/K.height-.5,t*=H[2]/K.width,w*=H[2]/K.height);z='src\x3d"'+a.getOptions().global.VMLRadialGradientURL+'" size\x3d"'+t+","+w+'" origin\x3d"0.5,0.5" position\x3d"'+A+","+D+'" color2\x3d"'+E+'" ';x()};d.added?g():d.onAdd=g;g=C}else g=J}else r.test(b)&&"IMG"!==c.tagName?(y=a.color(b),d[f+"-opacitySetter"](y.get("a"),f,c),g=y.get("rgb")):(g=c.getElementsByTagName(f),
	g.length&&(g[0].opacity=1,g[0].type="solid"),g=b);return g},prepVML:function(a){var b=this.isIE8;a=a.join("");b?(a=a.replace("/\x3e",' xmlns\x3d"urn:schemas-microsoft-com:vml" /\x3e'),a=-1===a.indexOf('style\x3d"')?a.replace("/\x3e",' style\x3d"display:inline-block;behavior:url(#default#VML);" /\x3e'):a.replace('style\x3d"','style\x3d"display:inline-block;behavior:url(#default#VML);')):a=a.replace("\x3c","\x3chcv:");return a},text:q.prototype.html,path:function(a){var b={coordsize:"10 10"};d(a)?b.d=
	a:z(a)&&e(b,a);return this.createElement("shape").attr(b)},circle:function(a,b,f){var c=this.symbol("circle");z(a)&&(f=a.r,b=a.y,a=a.x);c.isCircle=!0;c.r=f;return c.attr({x:a,y:b})},g:function(a){var b;a&&(b={className:"highcharts-"+a,"class":"highcharts-"+a});return this.createElement("div").attr(b)},image:function(a,b,f,c,n){var h=this.createElement("img").attr({src:a});1<arguments.length&&h.attr({x:b,y:f,width:c,height:n});return h},createElement:function(a){return"rect"===a?this.symbol(a):q.prototype.createElement.call(this,
	a)},invertChild:function(a,b){var f=this;b=b.style;var h="IMG"===a.tagName&&a.style;H(a,{flip:"x",left:c(b.width)-(h?c(h.top):1),top:c(b.height)-(h?c(h.left):1),rotation:-90});p(a.childNodes,function(b){f.invertChild(b,a)})},symbols:{arc:function(a,b,f,c,n){var h=n.start,d=n.end,r=n.r||f||c;f=n.innerR;c=Math.cos(h);var q=Math.sin(h),g=Math.cos(d),J=Math.sin(d);if(0===d-h)return["x"];h=["wa",a-r,b-r,a+r,b+r,a+r*c,b+r*q,a+r*g,b+r*J];n.open&&!f&&h.push("e","M",a,b);h.push("at",a-f,b-f,a+f,b+f,a+f*g,
	b+f*J,a+f*c,b+f*q,"x","e");h.isArc=!0;return h},circle:function(a,b,f,c,n){n&&w(n.r)&&(f=c=2*n.r);n&&n.isCircle&&(a-=f/2,b-=c/2);return["wa",a,b,a+f,b+c,a+f,b+c/2,a+f,b+c/2,"e"]},rect:function(a,b,c,d,n){return q.prototype.symbols[w(n)&&n.r?"callout":"square"].call(0,a,b,c,d,n)}}},a.VMLRenderer=D=function(){this.init.apply(this,arguments)},D.prototype=b(q.prototype,A),a.Renderer=D);q.prototype.measureSpanWidth=function(a,b){var c=x.createElement("span");a=x.createTextNode(a);c.appendChild(a);H(c,
	b);this.box.appendChild(c);b=c.offsetWidth;t(c);return b}})(K);(function(a){function D(){var p=a.defaultOptions.global,m=x.moment;if(p.timezone){if(m)return function(a){return-m.tz(a,p.timezone).utcOffset()};a.error(25)}return p.useUTC&&p.getTimezoneOffset}function A(){var p=a.defaultOptions.global,m,e=p.useUTC,d=e?"getUTC":"get",l=e?"setUTC":"set";a.Date=m=p.Date||x.Date;m.hcTimezoneOffset=e&&p.timezoneOffset;m.hcGetTimezoneOffset=D();m.hcMakeTime=function(a,b,d,c,l,q){var r;e?(r=m.UTC.apply(0,arguments),
	r+=w(r)):r=(new m(a,b,t(d,1),t(c,0),t(l,0),t(q,0))).getTime();return r};H("Minutes Hours Day Date Month FullYear".split(" "),function(a){m["hcGet"+a]=d+a});H("Milliseconds Seconds Minutes Hours Date Month FullYear".split(" "),function(a){m["hcSet"+a]=l+a})}var G=a.color,H=a.each,w=a.getTZOffset,k=a.merge,t=a.pick,x=a.win;a.defaultOptions={colors:"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),symbols:["circle","diamond","square","triangle","triangle-down"],
	lang:{loading:"Loading...",months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),weekdays:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),decimalPoint:".",numericSymbols:"kMGTPE".split(""),resetZoom:"Reset zoom",resetZoomTitle:"Reset zoom level 1:1",thousandsSep:" "},global:{useUTC:!0,VMLRadialGradientURL:"http://code.highcharts.com/5.0.9/gfx/vml-radial-gradient.png"},
	chart:{borderRadius:0,defaultSeriesType:"line",ignoreHiddenSeries:!0,spacing:[10,10,15,10],resetZoomButton:{theme:{zIndex:20},position:{align:"right",x:-10,y:10}},width:null,height:null,borderColor:"#335cad",backgroundColor:"#ffffff",plotBorderColor:"#cccccc"},title:{text:"Chart title",align:"center",margin:15,widthAdjust:-44},subtitle:{text:"",align:"center",widthAdjust:-44},plotOptions:{},labels:{style:{position:"absolute",color:"#333333"}},legend:{enabled:!0,align:"center",layout:"horizontal",
	labelFormatter:function(){return this.name},borderColor:"#999999",borderRadius:0,navigation:{activeColor:"#003399",inactiveColor:"#cccccc"},itemStyle:{color:"#333333",fontSize:"12px",fontWeight:"bold"},itemHoverStyle:{color:"#000000"},itemHiddenStyle:{color:"#cccccc"},shadow:!1,itemCheckboxStyle:{position:"absolute",width:"13px",height:"13px"},squareSymbol:!0,symbolPadding:5,verticalAlign:"bottom",x:0,y:0,title:{style:{fontWeight:"bold"}}},loading:{labelStyle:{fontWeight:"bold",position:"relative",
	top:"45%"},style:{position:"absolute",backgroundColor:"#ffffff",opacity:.5,textAlign:"center"}},tooltip:{enabled:!0,animation:a.svg,borderRadius:3,dateTimeLabelFormats:{millisecond:"%A, %b %e, %H:%M:%S.%L",second:"%A, %b %e, %H:%M:%S",minute:"%A, %b %e, %H:%M",hour:"%A, %b %e, %H:%M",day:"%A, %b %e, %Y",week:"Week from %A, %b %e, %Y",month:"%B %Y",year:"%Y"},footerFormat:"",padding:8,snap:a.isTouchDevice?25:10,backgroundColor:G("#f7f7f7").setOpacity(.85).get(),borderWidth:1,headerFormat:'\x3cspan style\x3d"font-size: 10px"\x3e{point.key}\x3c/span\x3e\x3cbr/\x3e',
	pointFormat:'\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e {series.name}: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e',shadow:!0,style:{color:"#333333",cursor:"default",fontSize:"12px",pointerEvents:"none",whiteSpace:"nowrap"}},credits:{enabled:!0,href:"http://www.highcharts.com",position:{align:"right",x:-10,verticalAlign:"bottom",y:-5},style:{cursor:"pointer",color:"#999999",fontSize:"9px"},text:"Highcharts.com"}};a.setOptions=function(p){a.defaultOptions=k(!0,a.defaultOptions,p);A();
	return a.defaultOptions};a.getOptions=function(){return a.defaultOptions};a.defaultPlotOptions=a.defaultOptions.plotOptions;A()})(K);(function(a){var D=a.arrayMax,A=a.arrayMin,G=a.defined,H=a.destroyObjectProperties,w=a.each,k=a.erase,t=a.merge,x=a.pick;a.PlotLineOrBand=function(a,m){this.axis=a;m&&(this.options=m,this.id=m.id)};a.PlotLineOrBand.prototype={render:function(){var a=this,m=a.axis,e=m.horiz,d=a.options,l=d.label,z=a.label,b=d.to,u=d.from,c=d.value,C=G(u)&&G(b),q=G(c),r=a.svgElem,h=!r,
	E=[],f,v=d.color,n=x(d.zIndex,0),y=d.events,E={"class":"highcharts-plot-"+(C?"band ":"line ")+(d.className||"")},L={},F=m.chart.renderer,I=C?"bands":"lines",g=m.log2lin;m.isLog&&(u=g(u),b=g(b),c=g(c));q?(E={stroke:v,"stroke-width":d.width},d.dashStyle&&(E.dashstyle=d.dashStyle)):C&&(v&&(E.fill=v),d.borderWidth&&(E.stroke=d.borderColor,E["stroke-width"]=d.borderWidth));L.zIndex=n;I+="-"+n;(v=m[I])||(m[I]=v=F.g("plot-"+I).attr(L).add());h&&(a.svgElem=r=F.path().attr(E).add(v));if(q)E=m.getPlotLinePath(c,
	r.strokeWidth());else if(C)E=m.getPlotBandPath(u,b,d);else return;if(h&&E&&E.length){if(r.attr({d:E}),y)for(f in d=function(g){r.on(g,function(b){y[g].apply(a,[b])})},y)d(f)}else r&&(E?(r.show(),r.animate({d:E})):(r.hide(),z&&(a.label=z=z.destroy())));l&&G(l.text)&&E&&E.length&&0<m.width&&0<m.height&&!E.flat?(l=t({align:e&&C&&"center",x:e?!C&&4:10,verticalAlign:!e&&C&&"middle",y:e?C?16:10:C?6:-4,rotation:e&&!C&&90},l),this.renderLabel(l,E,C,n)):z&&z.hide();return a},renderLabel:function(a,m,e,d){var l=
	this.label,z=this.axis.chart.renderer;l||(l={align:a.textAlign||a.align,rotation:a.rotation,"class":"highcharts-plot-"+(e?"band":"line")+"-label "+(a.className||"")},l.zIndex=d,this.label=l=z.text(a.text,0,0,a.useHTML).attr(l).add(),l.css(a.style));d=[m[1],m[4],e?m[6]:m[1]];m=[m[2],m[5],e?m[7]:m[2]];e=A(d);z=A(m);l.align(a,!1,{x:e,y:z,width:D(d)-e,height:D(m)-z});l.show()},destroy:function(){k(this.axis.plotLinesAndBands,this);delete this.axis;H(this)}};a.AxisPlotLineOrBandExtension={getPlotBandPath:function(a,
	m){m=this.getPlotLinePath(m,null,null,!0);(a=this.getPlotLinePath(a,null,null,!0))&&m?(a.flat=a.toString()===m.toString(),a.push(m[4],m[5],m[1],m[2],"z")):a=null;return a},addPlotBand:function(a){return this.addPlotBandOrLine(a,"plotBands")},addPlotLine:function(a){return this.addPlotBandOrLine(a,"plotLines")},addPlotBandOrLine:function(k,m){var e=(new a.PlotLineOrBand(this,k)).render(),d=this.userOptions;e&&(m&&(d[m]=d[m]||[],d[m].push(k)),this.plotLinesAndBands.push(e));return e},removePlotBandOrLine:function(a){for(var m=
	this.plotLinesAndBands,e=this.options,d=this.userOptions,l=m.length;l--;)m[l].id===a&&m[l].destroy();w([e.plotLines||[],d.plotLines||[],e.plotBands||[],d.plotBands||[]],function(d){for(l=d.length;l--;)d[l].id===a&&k(d,d[l])})}}})(K);(function(a){var D=a.correctFloat,A=a.defined,G=a.destroyObjectProperties,H=a.isNumber,w=a.merge,k=a.pick,t=a.deg2rad;a.Tick=function(a,k,m,e){this.axis=a;this.pos=k;this.type=m||"";this.isNew=!0;m||e||this.addLabel()};a.Tick.prototype={addLabel:function(){var a=this.axis,
	p=a.options,m=a.chart,e=a.categories,d=a.names,l=this.pos,z=p.labels,b=a.tickPositions,u=l===b[0],c=l===b[b.length-1],d=e?k(e[l],d[l],l):l,e=this.label,b=b.info,C;a.isDatetimeAxis&&b&&(C=p.dateTimeLabelFormats[b.higherRanks[l]||b.unitName]);this.isFirst=u;this.isLast=c;p=a.labelFormatter.call({axis:a,chart:m,isFirst:u,isLast:c,dateTimeLabelFormat:C,value:a.isLog?D(a.lin2log(d)):d});A(e)?e&&e.attr({text:p}):(this.labelLength=(this.label=e=A(p)&&z.enabled?m.renderer.text(p,0,0,z.useHTML).css(w(z.style)).add(a.labelGroup):
	null)&&e.getBBox().width,this.rotation=0)},getLabelSize:function(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0},handleOverflow:function(a){var p=this.axis,m=a.x,e=p.chart.chartWidth,d=p.chart.spacing,l=k(p.labelLeft,Math.min(p.pos,d[3])),d=k(p.labelRight,Math.max(p.pos+p.len,e-d[1])),z=this.label,b=this.rotation,u={left:0,center:.5,right:1}[p.labelAlign],c=z.getBBox().width,C=p.getSlotWidth(),q=C,r=1,h,E={};if(b)0>b&&m-u*c<l?h=Math.round(m/Math.cos(b*t)-l):0<b&&m+u*
	c>d&&(h=Math.round((e-m)/Math.cos(b*t)));else if(e=m+(1-u)*c,m-u*c<l?q=a.x+q*(1-u)-l:e>d&&(q=d-a.x+q*u,r=-1),q=Math.min(C,q),q<C&&"center"===p.labelAlign&&(a.x+=r*(C-q-u*(C-Math.min(c,q)))),c>q||p.autoRotation&&(z.styles||{}).width)h=q;h&&(E.width=h,(p.options.labels.style||{}).textOverflow||(E.textOverflow="ellipsis"),z.css(E))},getPosition:function(a,k,m,e){var d=this.axis,l=d.chart,z=e&&l.oldChartHeight||l.chartHeight;return{x:a?d.translate(k+m,null,null,e)+d.transB:d.left+d.offset+(d.opposite?
	(e&&l.oldChartWidth||l.chartWidth)-d.right-d.left:0),y:a?z-d.bottom+d.offset-(d.opposite?d.height:0):z-d.translate(k+m,null,null,e)-d.transB}},getLabelPosition:function(a,k,m,e,d,l,z,b){var u=this.axis,c=u.transA,C=u.reversed,q=u.staggerLines,r=u.tickRotCorr||{x:0,y:0},h=d.y;A(h)||(h=0===u.side?m.rotation?-8:-m.getBBox().height:2===u.side?r.y+8:Math.cos(m.rotation*t)*(r.y-m.getBBox(!1,0).height/2));a=a+d.x+r.x-(l&&e?l*c*(C?-1:1):0);k=k+h-(l&&!e?l*c*(C?1:-1):0);q&&(m=z/(b||1)%q,u.opposite&&(m=q-m-
	1),k+=u.labelOffset/q*m);return{x:a,y:Math.round(k)}},getMarkPath:function(a,k,m,e,d,l){return l.crispLine(["M",a,k,"L",a+(d?0:-m),k+(d?m:0)],e)},renderGridLine:function(a,k,m){var e=this.axis,d=e.options,l=this.gridLine,z={},b=this.pos,u=this.type,c=e.tickmarkOffset,C=e.chart.renderer,q=u?u+"Grid":"grid",r=d[q+"LineWidth"],h=d[q+"LineColor"],d=d[q+"LineDashStyle"];l||(z.stroke=h,z["stroke-width"]=r,d&&(z.dashstyle=d),u||(z.zIndex=1),a&&(z.opacity=0),this.gridLine=l=C.path().attr(z).addClass("highcharts-"+
	(u?u+"-":"")+"grid-line").add(e.gridGroup));if(!a&&l&&(a=e.getPlotLinePath(b+c,l.strokeWidth()*m,a,!0)))l[this.isNew?"attr":"animate"]({d:a,opacity:k})},renderMark:function(a,p,m){var e=this.axis,d=e.options,l=e.chart.renderer,z=this.type,b=z?z+"Tick":"tick",u=e.tickSize(b),c=this.mark,C=!c,q=a.x;a=a.y;var r=k(d[b+"Width"],!z&&e.isXAxis?1:0),d=d[b+"Color"];u&&(e.opposite&&(u[0]=-u[0]),C&&(this.mark=c=l.path().addClass("highcharts-"+(z?z+"-":"")+"tick").add(e.axisGroup),c.attr({stroke:d,"stroke-width":r})),
	c[C?"attr":"animate"]({d:this.getMarkPath(q,a,u[0],c.strokeWidth()*m,e.horiz,l),opacity:p}))},renderLabel:function(a,p,m,e){var d=this.axis,l=d.horiz,z=d.options,b=this.label,u=z.labels,c=u.step,C=d.tickmarkOffset,q=!0,r=a.x;a=a.y;b&&H(r)&&(b.xy=a=this.getLabelPosition(r,a,b,l,u,C,e,c),this.isFirst&&!this.isLast&&!k(z.showFirstLabel,1)||this.isLast&&!this.isFirst&&!k(z.showLastLabel,1)?q=!1:!l||d.isRadial||u.step||u.rotation||p||0===m||this.handleOverflow(a),c&&e%c&&(q=!1),q&&H(a.y)?(a.opacity=m,
	b[this.isNew?"attr":"animate"](a)):b.attr("y",-9999),this.isNew=!1)},render:function(a,p,m){var e=this.axis,d=e.horiz,l=this.getPosition(d,this.pos,e.tickmarkOffset,p),z=l.x,b=l.y,e=d&&z===e.pos+e.len||!d&&b===e.pos?-1:1;m=k(m,1);this.isActive=!0;this.renderGridLine(p,m,e);this.renderMark(l,m,e);this.renderLabel(l,p,m,a)},destroy:function(){G(this,this.axis)}}})(K);(function(a){var D=a.addEvent,A=a.animObject,G=a.arrayMax,H=a.arrayMin,w=a.AxisPlotLineOrBandExtension,k=a.color,t=a.correctFloat,x=a.defaultOptions,
	p=a.defined,m=a.deg2rad,e=a.destroyObjectProperties,d=a.each,l=a.extend,z=a.fireEvent,b=a.format,u=a.getMagnitude,c=a.grep,C=a.inArray,q=a.isArray,r=a.isNumber,h=a.isString,E=a.merge,f=a.normalizeTickInterval,v=a.pick,n=a.PlotLineOrBand,y=a.removeEvent,L=a.splat,F=a.syncTimeout,I=a.Tick;a.Axis=function(){this.init.apply(this,arguments)};a.Axis.prototype={defaultOptions:{dateTimeLabelFormats:{millisecond:"%H:%M:%S.%L",second:"%H:%M:%S",minute:"%H:%M",hour:"%H:%M",day:"%e. %b",week:"%e. %b",month:"%b '%y",
	year:"%Y"},endOnTick:!1,labels:{enabled:!0,style:{color:"#666666",cursor:"default",fontSize:"11px"},x:0},minPadding:.01,maxPadding:.01,minorTickLength:2,minorTickPosition:"outside",startOfWeek:1,startOnTick:!1,tickLength:10,tickmarkPlacement:"between",tickPixelInterval:100,tickPosition:"outside",title:{align:"middle",style:{color:"#666666"}},type:"linear",minorGridLineColor:"#f2f2f2",minorGridLineWidth:1,minorTickColor:"#999999",lineColor:"#ccd6eb",lineWidth:1,gridLineColor:"#e6e6e6",tickColor:"#ccd6eb"},
	defaultYAxisOptions:{endOnTick:!0,tickPixelInterval:72,showLastLabel:!0,labels:{x:-8},maxPadding:.05,minPadding:.05,startOnTick:!0,title:{rotation:270,text:"Values"},stackLabels:{enabled:!1,formatter:function(){return a.numberFormat(this.total,-1)},style:{fontSize:"11px",fontWeight:"bold",color:"#000000",textOutline:"1px contrast"}},gridLineWidth:1,lineWidth:0},defaultLeftAxisOptions:{labels:{x:-15},title:{rotation:270}},defaultRightAxisOptions:{labels:{x:15},title:{rotation:90}},defaultBottomAxisOptions:{labels:{autoRotation:[-45],
	x:0},title:{rotation:0}},defaultTopAxisOptions:{labels:{autoRotation:[-45],x:0},title:{rotation:0}},init:function(a,b){var g=b.isX;this.chart=a;this.horiz=a.inverted?!g:g;this.isXAxis=g;this.coll=this.coll||(g?"xAxis":"yAxis");this.opposite=b.opposite;this.side=b.side||(this.horiz?this.opposite?0:2:this.opposite?1:3);this.setOptions(b);var c=this.options,f=c.type;this.labelFormatter=c.labels.formatter||this.defaultLabelFormatter;this.userOptions=b;this.minPixelPadding=0;this.reversed=c.reversed;this.visible=
	!1!==c.visible;this.zoomEnabled=!1!==c.zoomEnabled;this.hasNames="category"===f||!0===c.categories;this.categories=c.categories||this.hasNames;this.names=this.names||[];this.isLog="logarithmic"===f;this.isDatetimeAxis="datetime"===f;this.positiveValuesOnly=this.isLog&&!this.allowNegativeLog;this.isLinked=p(c.linkedTo);this.ticks={};this.labelEdge=[];this.minorTicks={};this.plotLinesAndBands=[];this.alternateBands={};this.len=0;this.minRange=this.userMinRange=c.minRange||c.maxZoom;this.range=c.range;
	this.offset=c.offset||0;this.stacks={};this.oldStacks={};this.stacksTouched=0;this.min=this.max=null;this.crosshair=v(c.crosshair,L(a.options.tooltip.crosshairs)[g?0:1],!1);var n;b=this.options.events;-1===C(this,a.axes)&&(g?a.axes.splice(a.xAxis.length,0,this):a.axes.push(this),a[this.coll].push(this));this.series=this.series||[];a.inverted&&g&&void 0===this.reversed&&(this.reversed=!0);this.removePlotLine=this.removePlotBand=this.removePlotBandOrLine;for(n in b)D(this,n,b[n]);this.lin2log=c.linearToLogConverter||
	this.lin2log;this.isLog&&(this.val2lin=this.log2lin,this.lin2val=this.lin2log)},setOptions:function(a){this.options=E(this.defaultOptions,"yAxis"===this.coll&&this.defaultYAxisOptions,[this.defaultTopAxisOptions,this.defaultRightAxisOptions,this.defaultBottomAxisOptions,this.defaultLeftAxisOptions][this.side],E(x[this.coll],a))},defaultLabelFormatter:function(){var g=this.axis,c=this.value,f=g.categories,n=this.dateTimeLabelFormat,h=x.lang,d=h.numericSymbols,h=h.numericSymbolMagnitude||1E3,y=d&&d.length,
	r,q=g.options.labels.format,g=g.isLog?Math.abs(c):g.tickInterval;if(q)r=b(q,this);else if(f)r=c;else if(n)r=a.dateFormat(n,c);else if(y&&1E3<=g)for(;y--&&void 0===r;)f=Math.pow(h,y+1),g>=f&&0===10*c%f&&null!==d[y]&&0!==c&&(r=a.numberFormat(c/f,-1)+d[y]);void 0===r&&(r=1E4<=Math.abs(c)?a.numberFormat(c,-1):a.numberFormat(c,-1,void 0,""));return r},getSeriesExtremes:function(){var a=this,b=a.chart;a.hasVisibleSeries=!1;a.dataMin=a.dataMax=a.threshold=null;a.softThreshold=!a.isXAxis;a.buildStacks&&a.buildStacks();
	d(a.series,function(g){if(g.visible||!b.options.chart.ignoreHiddenSeries){var f=g.options,n=f.threshold,h;a.hasVisibleSeries=!0;a.positiveValuesOnly&&0>=n&&(n=null);if(a.isXAxis)f=g.xData,f.length&&(g=H(f),r(g)||g instanceof Date||(f=c(f,function(a){return r(a)}),g=H(f)),a.dataMin=Math.min(v(a.dataMin,f[0]),g),a.dataMax=Math.max(v(a.dataMax,f[0]),G(f)));else if(g.getExtremes(),h=g.dataMax,g=g.dataMin,p(g)&&p(h)&&(a.dataMin=Math.min(v(a.dataMin,g),g),a.dataMax=Math.max(v(a.dataMax,h),h)),p(n)&&(a.threshold=
	n),!f.softThreshold||a.positiveValuesOnly)a.softThreshold=!1}})},translate:function(a,b,c,f,n,h){var g=this.linkedParent||this,d=1,y=0,J=f?g.oldTransA:g.transA;f=f?g.oldMin:g.min;var q=g.minPixelPadding;n=(g.isOrdinal||g.isBroken||g.isLog&&n)&&g.lin2val;J||(J=g.transA);c&&(d*=-1,y=g.len);g.reversed&&(d*=-1,y-=d*(g.sector||g.len));b?(a=(a*d+y-q)/J+f,n&&(a=g.lin2val(a))):(n&&(a=g.val2lin(a)),a=d*(a-f)*J+y+d*q+(r(h)?J*h:0));return a},toPixels:function(a,b){return this.translate(a,!1,!this.horiz,null,
	!0)+(b?0:this.pos)},toValue:function(a,b){return this.translate(a-(b?0:this.pos),!0,!this.horiz,null,!0)},getPlotLinePath:function(a,b,c,f,n){var g=this.chart,h=this.left,d=this.top,y,J,q=c&&g.oldChartHeight||g.chartHeight,F=c&&g.oldChartWidth||g.chartWidth,u;y=this.transB;var l=function(a,b,g){if(a<b||a>g)f?a=Math.min(Math.max(b,a),g):u=!0;return a};n=v(n,this.translate(a,null,null,c));a=c=Math.round(n+y);y=J=Math.round(q-n-y);r(n)?this.horiz?(y=d,J=q-this.bottom,a=c=l(a,h,h+this.width)):(a=h,c=
	F-this.right,y=J=l(y,d,d+this.height)):u=!0;return u&&!f?null:g.renderer.crispLine(["M",a,y,"L",c,J],b||1)},getLinearTickPositions:function(a,b,c){var g,f=t(Math.floor(b/a)*a);c=t(Math.ceil(c/a)*a);var n=[];if(this.single)return[b];for(b=f;b<=c;){n.push(b);b=t(b+a);if(b===g)break;g=b}return n},getMinorTickPositions:function(){var a=this,b=a.options,c=a.tickPositions,f=a.minorTickInterval,n=[],h=a.pointRangePadding||0,y=a.min-h,h=a.max+h,r=h-y;if(r&&r/f<a.len/3)if(a.isLog)d(this.paddedTicks,function(b,
	g,c){g&&n.push.apply(n,a.getLogTickPositions(f,c[g-1],c[g],!0))});else if(a.isDatetimeAxis&&"auto"===b.minorTickInterval)n=n.concat(a.getTimeTicks(a.normalizeTimeTickInterval(f),y,h,b.startOfWeek));else for(b=y+(c[0]-y)%f;b<=h&&b!==n[0];b+=f)n.push(b);0!==n.length&&a.trimTicks(n);return n},adjustForMinRange:function(){var a=this.options,b=this.min,c=this.max,f,n=this.dataMax-this.dataMin>=this.minRange,h,y,r,q,F,u;this.isXAxis&&void 0===this.minRange&&!this.isLog&&(p(a.min)||p(a.max)?this.minRange=
	null:(d(this.series,function(a){q=a.xData;for(y=F=a.xIncrement?1:q.length-1;0<y;y--)if(r=q[y]-q[y-1],void 0===h||r<h)h=r}),this.minRange=Math.min(5*h,this.dataMax-this.dataMin)));c-b<this.minRange&&(u=this.minRange,f=(u-c+b)/2,f=[b-f,v(a.min,b-f)],n&&(f[2]=this.isLog?this.log2lin(this.dataMin):this.dataMin),b=G(f),c=[b+u,v(a.max,b+u)],n&&(c[2]=this.isLog?this.log2lin(this.dataMax):this.dataMax),c=H(c),c-b<u&&(f[0]=c-u,f[1]=v(a.min,c-u),b=G(f)));this.min=b;this.max=c},getClosest:function(){var a;this.categories?
	a=1:d(this.series,function(b){var g=b.closestPointRange,c=b.visible||!b.chart.options.chart.ignoreHiddenSeries;!b.noSharedTooltip&&p(g)&&c&&(a=p(a)?Math.min(a,g):g)});return a},nameToX:function(a){var b=q(this.categories),g=b?this.categories:this.names,c=a.options.x,f;a.series.requireSorting=!1;p(c)||(c=!1===this.options.uniqueNames?a.series.autoIncrement():C(a.name,g));-1===c?b||(f=g.length):f=c;this.names[f]=a.name;return f},updateNames:function(){var a=this;0<this.names.length&&(this.names.length=
	0,this.minRange=void 0,d(this.series||[],function(b){b.xIncrement=null;if(!b.points||b.isDirtyData)b.processData(),b.generatePoints();d(b.points,function(g,c){var f;g.options&&(f=a.nameToX(g),f!==g.x&&(g.x=f,b.xData[c]=f))})}))},setAxisTranslation:function(a){var b=this,g=b.max-b.min,c=b.axisPointRange||0,f,n=0,y=0,r=b.linkedParent,q=!!b.categories,F=b.transA,u=b.isXAxis;if(u||q||c)f=b.getClosest(),r?(n=r.minPointOffset,y=r.pointRangePadding):d(b.series,function(a){var g=q?1:u?v(a.options.pointRange,
	f,0):b.axisPointRange||0;a=a.options.pointPlacement;c=Math.max(c,g);b.single||(n=Math.max(n,h(a)?0:g/2),y=Math.max(y,"on"===a?0:g))}),r=b.ordinalSlope&&f?b.ordinalSlope/f:1,b.minPointOffset=n*=r,b.pointRangePadding=y*=r,b.pointRange=Math.min(c,g),u&&(b.closestPointRange=f);a&&(b.oldTransA=F);b.translationSlope=b.transA=F=b.options.staticScale||b.len/(g+y||1);b.transB=b.horiz?b.left:b.bottom;b.minPixelPadding=F*n},minFromRange:function(){return this.max-this.range},setTickInterval:function(b){var g=
	this,c=g.chart,n=g.options,h=g.isLog,y=g.log2lin,q=g.isDatetimeAxis,F=g.isXAxis,l=g.isLinked,e=n.maxPadding,I=n.minPadding,C=n.tickInterval,E=n.tickPixelInterval,L=g.categories,m=g.threshold,k=g.softThreshold,x,w,A,D;q||L||l||this.getTickAmount();A=v(g.userMin,n.min);D=v(g.userMax,n.max);l?(g.linkedParent=c[g.coll][n.linkedTo],c=g.linkedParent.getExtremes(),g.min=v(c.min,c.dataMin),g.max=v(c.max,c.dataMax),n.type!==g.linkedParent.options.type&&a.error(11,1)):(!k&&p(m)&&(g.dataMin>=m?(x=m,I=0):g.dataMax<=
	m&&(w=m,e=0)),g.min=v(A,x,g.dataMin),g.max=v(D,w,g.dataMax));h&&(g.positiveValuesOnly&&!b&&0>=Math.min(g.min,v(g.dataMin,g.min))&&a.error(10,1),g.min=t(y(g.min),15),g.max=t(y(g.max),15));g.range&&p(g.max)&&(g.userMin=g.min=A=Math.max(g.min,g.minFromRange()),g.userMax=D=g.max,g.range=null);z(g,"foundExtremes");g.beforePadding&&g.beforePadding();g.adjustForMinRange();!(L||g.axisPointRange||g.usePercentage||l)&&p(g.min)&&p(g.max)&&(y=g.max-g.min)&&(!p(A)&&I&&(g.min-=y*I),!p(D)&&e&&(g.max+=y*e));r(n.floor)?
	g.min=Math.max(g.min,n.floor):r(n.softMin)&&(g.min=Math.min(g.min,n.softMin));r(n.ceiling)?g.max=Math.min(g.max,n.ceiling):r(n.softMax)&&(g.max=Math.max(g.max,n.softMax));k&&p(g.dataMin)&&(m=m||0,!p(A)&&g.min<m&&g.dataMin>=m?g.min=m:!p(D)&&g.max>m&&g.dataMax<=m&&(g.max=m));g.tickInterval=g.min===g.max||void 0===g.min||void 0===g.max?1:l&&!C&&E===g.linkedParent.options.tickPixelInterval?C=g.linkedParent.tickInterval:v(C,this.tickAmount?(g.max-g.min)/Math.max(this.tickAmount-1,1):void 0,L?1:(g.max-
	g.min)*E/Math.max(g.len,E));F&&!b&&d(g.series,function(a){a.processData(g.min!==g.oldMin||g.max!==g.oldMax)});g.setAxisTranslation(!0);g.beforeSetTickPositions&&g.beforeSetTickPositions();g.postProcessTickInterval&&(g.tickInterval=g.postProcessTickInterval(g.tickInterval));g.pointRange&&!C&&(g.tickInterval=Math.max(g.pointRange,g.tickInterval));b=v(n.minTickInterval,g.isDatetimeAxis&&g.closestPointRange);!C&&g.tickInterval<b&&(g.tickInterval=b);q||h||C||(g.tickInterval=f(g.tickInterval,null,u(g.tickInterval),
	v(n.allowDecimals,!(.5<g.tickInterval&&5>g.tickInterval&&1E3<g.max&&9999>g.max)),!!this.tickAmount));this.tickAmount||(g.tickInterval=g.unsquish());this.setTickPositions()},setTickPositions:function(){var a=this.options,b,c=a.tickPositions,f=a.tickPositioner,n=a.startOnTick,h=a.endOnTick;this.tickmarkOffset=this.categories&&"between"===a.tickmarkPlacement&&1===this.tickInterval?.5:0;this.minorTickInterval="auto"===a.minorTickInterval&&this.tickInterval?this.tickInterval/5:a.minorTickInterval;this.single=
	this.min===this.max&&p(this.min)&&!this.tickAmount&&!1!==a.allowDecimals;this.tickPositions=b=c&&c.slice();!b&&(b=this.isDatetimeAxis?this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval,a.units),this.min,this.max,a.startOfWeek,this.ordinalPositions,this.closestPointRange,!0):this.isLog?this.getLogTickPositions(this.tickInterval,this.min,this.max):this.getLinearTickPositions(this.tickInterval,this.min,this.max),b.length>this.len&&(b=[b[0],b.pop()]),this.tickPositions=b,f&&(f=f.apply(this,
	[this.min,this.max])))&&(this.tickPositions=b=f);this.paddedTicks=b.slice(0);this.trimTicks(b,n,h);this.isLinked||(this.single&&(this.min-=.5,this.max+=.5),c||f||this.adjustTickAmount())},trimTicks:function(a,b,c){var g=a[0],f=a[a.length-1],n=this.minPointOffset||0;if(!this.isLinked){if(b)this.min=g;else for(;this.min-n>a[0];)a.shift();if(c)this.max=f;else for(;this.max+n<a[a.length-1];)a.pop();0===a.length&&p(g)&&a.push((f+g)/2)}},alignToOthers:function(){var a={},b,c=this.options;!1===this.chart.options.chart.alignTicks||
	!1===c.alignTicks||this.isLog||d(this.chart[this.coll],function(g){var c=g.options,c=[g.horiz?c.left:c.top,c.width,c.height,c.pane].join();g.series.length&&(a[c]?b=!0:a[c]=1)});return b},getTickAmount:function(){var a=this.options,b=a.tickAmount,c=a.tickPixelInterval;!p(a.tickInterval)&&this.len<c&&!this.isRadial&&!this.isLog&&a.startOnTick&&a.endOnTick&&(b=2);!b&&this.alignToOthers()&&(b=Math.ceil(this.len/c)+1);4>b&&(this.finalTickAmt=b,b=5);this.tickAmount=b},adjustTickAmount:function(){var a=
	this.tickInterval,b=this.tickPositions,c=this.tickAmount,f=this.finalTickAmt,n=b&&b.length;if(n<c){for(;b.length<c;)b.push(t(b[b.length-1]+a));this.transA*=(n-1)/(c-1);this.max=b[b.length-1]}else n>c&&(this.tickInterval*=2,this.setTickPositions());if(p(f)){for(a=c=b.length;a--;)(3===f&&1===a%2||2>=f&&0<a&&a<c-1)&&b.splice(a,1);this.finalTickAmt=void 0}},setScale:function(){var a,b;this.oldMin=this.min;this.oldMax=this.max;this.oldAxisLength=this.len;this.setAxisSize();b=this.len!==this.oldAxisLength;
	d(this.series,function(b){if(b.isDirtyData||b.isDirty||b.xAxis.isDirty)a=!0});b||a||this.isLinked||this.forceRedraw||this.userMin!==this.oldUserMin||this.userMax!==this.oldUserMax||this.alignToOthers()?(this.resetStacks&&this.resetStacks(),this.forceRedraw=!1,this.getSeriesExtremes(),this.setTickInterval(),this.oldUserMin=this.userMin,this.oldUserMax=this.userMax,this.isDirty||(this.isDirty=b||this.min!==this.oldMin||this.max!==this.oldMax)):this.cleanStacks&&this.cleanStacks()},setExtremes:function(a,
	b,c,f,n){var g=this,h=g.chart;c=v(c,!0);d(g.series,function(a){delete a.kdTree});n=l(n,{min:a,max:b});z(g,"setExtremes",n,function(){g.userMin=a;g.userMax=b;g.eventArgs=n;c&&h.redraw(f)})},zoom:function(a,b){var g=this.dataMin,c=this.dataMax,f=this.options,n=Math.min(g,v(f.min,g)),f=Math.max(c,v(f.max,c));if(a!==this.min||b!==this.max)this.allowZoomOutside||(p(g)&&(a<n&&(a=n),a>f&&(a=f)),p(c)&&(b<n&&(b=n),b>f&&(b=f))),this.displayBtn=void 0!==a||void 0!==b,this.setExtremes(a,b,!1,void 0,{trigger:"zoom"});
	return!0},setAxisSize:function(){var a=this.chart,b=this.options,c=b.offsets||[0,0,0,0],f=this.horiz,n=v(b.width,a.plotWidth-c[3]+c[1]),h=v(b.height,a.plotHeight-c[0]+c[2]),d=v(b.top,a.plotTop+c[0]),b=v(b.left,a.plotLeft+c[3]),c=/%$/;c.test(h)&&(h=Math.round(parseFloat(h)/100*a.plotHeight));c.test(d)&&(d=Math.round(parseFloat(d)/100*a.plotHeight+a.plotTop));this.left=b;this.top=d;this.width=n;this.height=h;this.bottom=a.chartHeight-h-d;this.right=a.chartWidth-n-b;this.len=Math.max(f?n:h,0);this.pos=
	f?b:d},getExtremes:function(){var a=this.isLog,b=this.lin2log;return{min:a?t(b(this.min)):this.min,max:a?t(b(this.max)):this.max,dataMin:this.dataMin,dataMax:this.dataMax,userMin:this.userMin,userMax:this.userMax}},getThreshold:function(a){var b=this.isLog,g=this.lin2log,c=b?g(this.min):this.min,b=b?g(this.max):this.max;null===a?a=c:c>a?a=c:b<a&&(a=b);return this.translate(a,0,1,0,1)},autoLabelAlign:function(a){a=(v(a,0)-90*this.side+720)%360;return 15<a&&165>a?"right":195<a&&345>a?"left":"center"},
	tickSize:function(a){var b=this.options,g=b[a+"Length"],c=v(b[a+"Width"],"tick"===a&&this.isXAxis?1:0);if(c&&g)return"inside"===b[a+"Position"]&&(g=-g),[g,c]},labelMetrics:function(){return this.chart.renderer.fontMetrics(this.options.labels.style&&this.options.labels.style.fontSize,this.ticks[0]&&this.ticks[0].label)},unsquish:function(){var a=this.options.labels,b=this.horiz,c=this.tickInterval,f=c,n=this.len/(((this.categories?1:0)+this.max-this.min)/c),h,y=a.rotation,r=this.labelMetrics(),q,F=
	Number.MAX_VALUE,u,l=function(a){a/=n||1;a=1<a?Math.ceil(a):1;return a*c};b?(u=!a.staggerLines&&!a.step&&(p(y)?[y]:n<v(a.autoRotationLimit,80)&&a.autoRotation))&&d(u,function(a){var b;if(a===y||a&&-90<=a&&90>=a)q=l(Math.abs(r.h/Math.sin(m*a))),b=q+Math.abs(a/360),b<F&&(F=b,h=a,f=q)}):a.step||(f=l(r.h));this.autoRotation=u;this.labelRotation=v(h,y);return f},getSlotWidth:function(){var a=this.chart,b=this.horiz,c=this.options.labels,f=Math.max(this.tickPositions.length-(this.categories?0:1),1),n=a.margin[3];
	return b&&2>(c.step||0)&&!c.rotation&&(this.staggerLines||1)*this.len/f||!b&&(n&&n-a.spacing[3]||.33*a.chartWidth)},renderUnsquish:function(){var a=this.chart,b=a.renderer,c=this.tickPositions,f=this.ticks,n=this.options.labels,y=this.horiz,r=this.getSlotWidth(),q=Math.max(1,Math.round(r-2*(n.padding||5))),F={},u=this.labelMetrics(),l=n.style&&n.style.textOverflow,v,e=0,I,C;h(n.rotation)||(F.rotation=n.rotation||0);d(c,function(a){(a=f[a])&&a.labelLength>e&&(e=a.labelLength)});this.maxLabelLength=
	e;if(this.autoRotation)e>q&&e>u.h?F.rotation=this.labelRotation:this.labelRotation=0;else if(r&&(v={width:q+"px"},!l))for(v.textOverflow="clip",I=c.length;!y&&I--;)if(C=c[I],q=f[C].label)q.styles&&"ellipsis"===q.styles.textOverflow?q.css({textOverflow:"clip"}):f[C].labelLength>r&&q.css({width:r+"px"}),q.getBBox().height>this.len/c.length-(u.h-u.f)&&(q.specCss={textOverflow:"ellipsis"});F.rotation&&(v={width:(e>.5*a.chartHeight?.33*a.chartHeight:a.chartHeight)+"px"},l||(v.textOverflow="ellipsis"));
	if(this.labelAlign=n.align||this.autoLabelAlign(this.labelRotation))F.align=this.labelAlign;d(c,function(a){var b=(a=f[a])&&a.label;b&&(b.attr(F),v&&b.css(E(v,b.specCss)),delete b.specCss,a.rotation=F.rotation)});this.tickRotCorr=b.rotCorr(u.b,this.labelRotation||0,0!==this.side)},hasData:function(){return this.hasVisibleSeries||p(this.min)&&p(this.max)&&!!this.tickPositions},addTitle:function(a){var b=this.chart.renderer,g=this.horiz,c=this.opposite,f=this.options.title,n;this.axisTitle||((n=f.textAlign)||
	(n=(g?{low:"left",middle:"center",high:"right"}:{low:c?"right":"left",middle:"center",high:c?"left":"right"})[f.align]),this.axisTitle=b.text(f.text,0,0,f.useHTML).attr({zIndex:7,rotation:f.rotation||0,align:n}).addClass("highcharts-axis-title").css(f.style).add(this.axisGroup),this.axisTitle.isNew=!0);this.axisTitle[a?"show":"hide"](!0)},generateTick:function(a){var b=this.ticks;b[a]?b[a].addLabel():b[a]=new I(this,a)},getOffset:function(){var a=this,b=a.chart,c=b.renderer,f=a.options,n=a.tickPositions,
	h=a.ticks,y=a.horiz,r=a.side,q=b.inverted?[1,0,3,2][r]:r,F,u,l=0,e,I=0,C=f.title,z=f.labels,E=0,L=b.axisOffset,b=b.clipOffset,m=[-1,1,1,-1][r],k,t=f.className,x=a.axisParent,w=this.tickSize("tick");F=a.hasData();a.showAxis=u=F||v(f.showEmpty,!0);a.staggerLines=a.horiz&&z.staggerLines;a.axisGroup||(a.gridGroup=c.g("grid").attr({zIndex:f.gridZIndex||1}).addClass("highcharts-"+this.coll.toLowerCase()+"-grid "+(t||"")).add(x),a.axisGroup=c.g("axis").attr({zIndex:f.zIndex||2}).addClass("highcharts-"+this.coll.toLowerCase()+
	" "+(t||"")).add(x),a.labelGroup=c.g("axis-labels").attr({zIndex:z.zIndex||7}).addClass("highcharts-"+a.coll.toLowerCase()+"-labels "+(t||"")).add(x));if(F||a.isLinked)d(n,function(b,g){a.generateTick(b,g)}),a.renderUnsquish(),!1===z.reserveSpace||0!==r&&2!==r&&{1:"left",3:"right"}[r]!==a.labelAlign&&"center"!==a.labelAlign||d(n,function(a){E=Math.max(h[a].getLabelSize(),E)}),a.staggerLines&&(E*=a.staggerLines,a.labelOffset=E*(a.opposite?-1:1));else for(k in h)h[k].destroy(),delete h[k];C&&C.text&&
	!1!==C.enabled&&(a.addTitle(u),u&&(l=a.axisTitle.getBBox()[y?"height":"width"],e=C.offset,I=p(e)?0:v(C.margin,y?5:10)));a.renderLine();a.offset=m*v(f.offset,L[r]);a.tickRotCorr=a.tickRotCorr||{x:0,y:0};c=0===r?-a.labelMetrics().h:2===r?a.tickRotCorr.y:0;I=Math.abs(E)+I;E&&(I=I-c+m*(y?v(z.y,a.tickRotCorr.y+8*m):z.x));a.axisTitleMargin=v(e,I);L[r]=Math.max(L[r],a.axisTitleMargin+l+m*a.offset,I,F&&n.length&&w?w[0]+m*a.offset:0);f=f.offset?0:2*Math.floor(a.axisLine.strokeWidth()/2);b[q]=Math.max(b[q],
	f)},getLinePath:function(a){var b=this.chart,g=this.opposite,c=this.offset,f=this.horiz,n=this.left+(g?this.width:0)+c,c=b.chartHeight-this.bottom-(g?this.height:0)+c;g&&(a*=-1);return b.renderer.crispLine(["M",f?this.left:n,f?c:this.top,"L",f?b.chartWidth-this.right:n,f?c:b.chartHeight-this.bottom],a)},renderLine:function(){this.axisLine||(this.axisLine=this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup),this.axisLine.attr({stroke:this.options.lineColor,"stroke-width":this.options.lineWidth,
	zIndex:7}))},getTitlePosition:function(){var a=this.horiz,b=this.left,c=this.top,f=this.len,n=this.options.title,h=a?b:c,d=this.opposite,y=this.offset,r=n.x||0,q=n.y||0,F=this.chart.renderer.fontMetrics(n.style&&n.style.fontSize,this.axisTitle).f,f={low:h+(a?0:f),middle:h+f/2,high:h+(a?f:0)}[n.align],b=(a?c+this.height:b)+(a?1:-1)*(d?-1:1)*this.axisTitleMargin+(2===this.side?F:0);return{x:a?f+r:b+(d?this.width:0)+y+r,y:a?b+q-(d?this.height:0)+y:f+q}},renderMinorTick:function(a){var b=this.chart.hasRendered&&
	r(this.oldMin),g=this.minorTicks;g[a]||(g[a]=new I(this,a,"minor"));b&&g[a].isNew&&g[a].render(null,!0);g[a].render(null,!1,1)},renderTick:function(a,b){var g=this.isLinked,c=this.ticks,f=this.chart.hasRendered&&r(this.oldMin);if(!g||a>=this.min&&a<=this.max)c[a]||(c[a]=new I(this,a)),f&&c[a].isNew&&c[a].render(b,!0,.1),c[a].render(b)},render:function(){var a=this,b=a.chart,c=a.options,f=a.isLog,h=a.lin2log,y=a.isLinked,r=a.tickPositions,q=a.axisTitle,u=a.ticks,l=a.minorTicks,v=a.alternateBands,e=
	c.stackLabels,C=c.alternateGridColor,z=a.tickmarkOffset,E=a.axisLine,L=a.showAxis,m=A(b.renderer.globalAnimation),k,p;a.labelEdge.length=0;a.overlap=!1;d([u,l,v],function(a){for(var b in a)a[b].isActive=!1});if(a.hasData()||y)a.minorTickInterval&&!a.categories&&d(a.getMinorTickPositions(),function(b){a.renderMinorTick(b)}),r.length&&(d(r,function(b,g){a.renderTick(b,g)}),z&&(0===a.min||a.single)&&(u[-1]||(u[-1]=new I(a,-1,null,!0)),u[-1].render(-1))),C&&d(r,function(g,c){p=void 0!==r[c+1]?r[c+1]+
	z:a.max-z;0===c%2&&g<a.max&&p<=a.max+(b.polar?-z:z)&&(v[g]||(v[g]=new n(a)),k=g+z,v[g].options={from:f?h(k):k,to:f?h(p):p,color:C},v[g].render(),v[g].isActive=!0)}),a._addedPlotLB||(d((c.plotLines||[]).concat(c.plotBands||[]),function(b){a.addPlotBandOrLine(b)}),a._addedPlotLB=!0);d([u,l,v],function(a){var g,c,f=[],n=m.duration;for(g in a)a[g].isActive||(a[g].render(g,!1,0),a[g].isActive=!1,f.push(g));F(function(){for(c=f.length;c--;)a[f[c]]&&!a[f[c]].isActive&&(a[f[c]].destroy(),delete a[f[c]])},
	a!==v&&b.hasRendered&&n?n:0)});E&&(E[E.isPlaced?"animate":"attr"]({d:this.getLinePath(E.strokeWidth())}),E.isPlaced=!0,E[L?"show":"hide"](!0));q&&L&&(q[q.isNew?"attr":"animate"](a.getTitlePosition()),q.isNew=!1);e&&e.enabled&&a.renderStackTotals();a.isDirty=!1},redraw:function(){this.visible&&(this.render(),d(this.plotLinesAndBands,function(a){a.render()}));d(this.series,function(a){a.isDirty=!0})},keepProps:"extKey hcEvents names series userMax userMin".split(" "),destroy:function(a){var b=this,
	g=b.stacks,c,f=b.plotLinesAndBands,n;a||y(b);for(c in g)e(g[c]),g[c]=null;d([b.ticks,b.minorTicks,b.alternateBands],function(a){e(a)});if(f)for(a=f.length;a--;)f[a].destroy();d("stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross".split(" "),function(a){b[a]&&(b[a]=b[a].destroy())});for(n in b)b.hasOwnProperty(n)&&-1===C(n,b.keepProps)&&delete b[n]},drawCrosshair:function(a,b){var g,c=this.crosshair,f=v(c.snap,!0),n,h=this.cross;a||(a=this.cross&&this.cross.e);this.crosshair&&
	!1!==(p(b)||!f)?(f?p(b)&&(n=this.isXAxis?b.plotX:this.len-b.plotY):n=a&&(this.horiz?a.chartX-this.pos:this.len-a.chartY+this.pos),p(n)&&(g=this.getPlotLinePath(b&&(this.isXAxis?b.x:v(b.stackY,b.y)),null,null,null,n)||null),p(g)?(b=this.categories&&!this.isRadial,h||(this.cross=h=this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-"+(b?"category ":"thin ")+c.className).attr({zIndex:v(c.zIndex,2)}).add(),h.attr({stroke:c.color||(b?k("#ccd6eb").setOpacity(.25).get():"#cccccc"),
	"stroke-width":v(c.width,1)}),c.dashStyle&&h.attr({dashstyle:c.dashStyle})),h.show().attr({d:g}),b&&!c.width&&h.attr({"stroke-width":this.transA}),this.cross.e=a):this.hideCrosshair()):this.hideCrosshair()},hideCrosshair:function(){this.cross&&this.cross.hide()}};l(a.Axis.prototype,w)})(K);(function(a){var D=a.Axis,A=a.Date,G=a.dateFormat,H=a.defaultOptions,w=a.defined,k=a.each,t=a.extend,x=a.getMagnitude,p=a.getTZOffset,m=a.normalizeTickInterval,e=a.pick,d=a.timeUnits;D.prototype.getTimeTicks=function(a,
	z,b,u){var c=[],l={},q=H.global.useUTC,r,h=new A(z-Math.abs(p(z))),E=A.hcMakeTime,f=a.unitRange,v=a.count,n;if(w(z)){h[A.hcSetMilliseconds](f>=d.second?0:v*Math.floor(h.getMilliseconds()/v));if(f>=d.second)h[A.hcSetSeconds](f>=d.minute?0:v*Math.floor(h.getSeconds()/v));if(f>=d.minute)h[A.hcSetMinutes](f>=d.hour?0:v*Math.floor(h[A.hcGetMinutes]()/v));if(f>=d.hour)h[A.hcSetHours](f>=d.day?0:v*Math.floor(h[A.hcGetHours]()/v));if(f>=d.day)h[A.hcSetDate](f>=d.month?1:v*Math.floor(h[A.hcGetDate]()/v));
	f>=d.month&&(h[A.hcSetMonth](f>=d.year?0:v*Math.floor(h[A.hcGetMonth]()/v)),r=h[A.hcGetFullYear]());if(f>=d.year)h[A.hcSetFullYear](r-r%v);if(f===d.week)h[A.hcSetDate](h[A.hcGetDate]()-h[A.hcGetDay]()+e(u,1));r=h[A.hcGetFullYear]();u=h[A.hcGetMonth]();var y=h[A.hcGetDate](),L=h[A.hcGetHours]();if(A.hcTimezoneOffset||A.hcGetTimezoneOffset)n=(!q||!!A.hcGetTimezoneOffset)&&(b-z>4*d.month||p(z)!==p(b)),h=h.getTime(),h=new A(h+p(h));q=h.getTime();for(z=1;q<b;)c.push(q),q=f===d.year?E(r+z*v,0):f===d.month?
	E(r,u+z*v):!n||f!==d.day&&f!==d.week?n&&f===d.hour?E(r,u,y,L+z*v):q+f*v:E(r,u,y+z*v*(f===d.day?1:7)),z++;c.push(q);f<=d.hour&&1E4>c.length&&k(c,function(a){0===a%18E5&&"000000000"===G("%H%M%S%L",a)&&(l[a]="day")})}c.info=t(a,{higherRanks:l,totalRange:f*v});return c};D.prototype.normalizeTimeTickInterval=function(a,e){var b=e||[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1,2]],["week",[1,2]],["month",[1,2,
	3,4,6]],["year",null]];e=b[b.length-1];var u=d[e[0]],c=e[1],l;for(l=0;l<b.length&&!(e=b[l],u=d[e[0]],c=e[1],b[l+1]&&a<=(u*c[c.length-1]+d[b[l+1][0]])/2);l++);u===d.year&&a<5*u&&(c=[1,2,5]);a=m(a/u,c,"year"===e[0]?Math.max(x(a/u),1):1);return{unitRange:u,count:a,unitName:e[0]}}})(K);(function(a){var D=a.Axis,A=a.getMagnitude,G=a.map,H=a.normalizeTickInterval,w=a.pick;D.prototype.getLogTickPositions=function(a,t,x,p){var m=this.options,e=this.len,d=this.lin2log,l=this.log2lin,z=[];p||(this._minorAutoInterval=
	null);if(.5<=a)a=Math.round(a),z=this.getLinearTickPositions(a,t,x);else if(.08<=a)for(var e=Math.floor(t),b,u,c,C,q,m=.3<a?[1,2,4]:.15<a?[1,2,4,6,8]:[1,2,3,4,5,6,7,8,9];e<x+1&&!q;e++)for(u=m.length,b=0;b<u&&!q;b++)c=l(d(e)*m[b]),c>t&&(!p||C<=x)&&void 0!==C&&z.push(C),C>x&&(q=!0),C=c;else t=d(t),x=d(x),a=m[p?"minorTickInterval":"tickInterval"],a=w("auto"===a?null:a,this._minorAutoInterval,m.tickPixelInterval/(p?5:1)*(x-t)/((p?e/this.tickPositions.length:e)||1)),a=H(a,null,A(a)),z=G(this.getLinearTickPositions(a,
	t,x),l),p||(this._minorAutoInterval=a/5);p||(this.tickInterval=a);return z};D.prototype.log2lin=function(a){return Math.log(a)/Math.LN10};D.prototype.lin2log=function(a){return Math.pow(10,a)}})(K);(function(a){var D=a.dateFormat,A=a.each,G=a.extend,H=a.format,w=a.isNumber,k=a.map,t=a.merge,x=a.pick,p=a.splat,m=a.syncTimeout,e=a.timeUnits;a.Tooltip=function(){this.init.apply(this,arguments)};a.Tooltip.prototype={init:function(a,l){this.chart=a;this.options=l;this.crosshairs=[];this.now={x:0,y:0};
	this.isHidden=!0;this.split=l.split&&!a.inverted;this.shared=l.shared||this.split},cleanSplit:function(a){A(this.chart.series,function(d){var l=d&&d.tt;l&&(!l.isActive||a?d.tt=l.destroy():l.isActive=!1)})},getLabel:function(){var a=this.chart.renderer,l=this.options;this.label||(this.split?this.label=a.g("tooltip"):(this.label=a.label("",0,0,l.shape||"callout",null,null,l.useHTML,null,"tooltip").attr({padding:l.padding,r:l.borderRadius}),this.label.attr({fill:l.backgroundColor,"stroke-width":l.borderWidth}).css(l.style).shadow(l.shadow)),
	this.label.attr({zIndex:8}).add());return this.label},update:function(a){this.destroy();this.init(this.chart,t(!0,this.options,a))},destroy:function(){this.label&&(this.label=this.label.destroy());this.split&&this.tt&&(this.cleanSplit(this.chart,!0),this.tt=this.tt.destroy());clearTimeout(this.hideTimer);clearTimeout(this.tooltipTimeout)},move:function(a,l,e,b){var d=this,c=d.now,C=!1!==d.options.animation&&!d.isHidden&&(1<Math.abs(a-c.x)||1<Math.abs(l-c.y)),q=d.followPointer||1<d.len;G(c,{x:C?(2*
	c.x+a)/3:a,y:C?(c.y+l)/2:l,anchorX:q?void 0:C?(2*c.anchorX+e)/3:e,anchorY:q?void 0:C?(c.anchorY+b)/2:b});d.getLabel().attr(c);C&&(clearTimeout(this.tooltipTimeout),this.tooltipTimeout=setTimeout(function(){d&&d.move(a,l,e,b)},32))},hide:function(a){var d=this;clearTimeout(this.hideTimer);a=x(a,this.options.hideDelay,500);this.isHidden||(this.hideTimer=m(function(){d.getLabel()[a?"fadeOut":"hide"]();d.isHidden=!0},a))},getAnchor:function(a,l){var d,b=this.chart,u=b.inverted,c=b.plotTop,e=b.plotLeft,
	q=0,r=0,h,E;a=p(a);d=a[0].tooltipPos;this.followPointer&&l&&(void 0===l.chartX&&(l=b.pointer.normalize(l)),d=[l.chartX-b.plotLeft,l.chartY-c]);d||(A(a,function(a){h=a.series.yAxis;E=a.series.xAxis;q+=a.plotX+(!u&&E?E.left-e:0);r+=(a.plotLow?(a.plotLow+a.plotHigh)/2:a.plotY)+(!u&&h?h.top-c:0)}),q/=a.length,r/=a.length,d=[u?b.plotWidth-r:q,this.shared&&!u&&1<a.length&&l?l.chartY-c:u?b.plotHeight-q:r]);return k(d,Math.round)},getPosition:function(a,l,e){var b=this.chart,d=this.distance,c={},C=e.h||0,
	q,r=["y",b.chartHeight,l,e.plotY+b.plotTop,b.plotTop,b.plotTop+b.plotHeight],h=["x",b.chartWidth,a,e.plotX+b.plotLeft,b.plotLeft,b.plotLeft+b.plotWidth],E=!this.followPointer&&x(e.ttBelow,!b.inverted===!!e.negative),f=function(a,b,f,g,n,h){var y=f<g-d,r=g+d+f<b,q=g-d-f;g+=d;if(E&&r)c[a]=g;else if(!E&&y)c[a]=q;else if(y)c[a]=Math.min(h-f,0>q-C?q:q-C);else if(r)c[a]=Math.max(n,g+C+f>b?g:g+C);else return!1},v=function(a,b,f,g){var n;g<d||g>b-d?n=!1:c[a]=g<f/2?1:g>b-f/2?b-f-2:g-f/2;return n},n=function(a){var b=
	r;r=h;h=b;q=a},y=function(){!1!==f.apply(0,r)?!1!==v.apply(0,h)||q||(n(!0),y()):q?c.x=c.y=0:(n(!0),y())};(b.inverted||1<this.len)&&n();y();return c},defaultFormatter:function(a){var d=this.points||p(this),e;e=[a.tooltipFooterHeaderFormatter(d[0])];e=e.concat(a.bodyFormatter(d));e.push(a.tooltipFooterHeaderFormatter(d[0],!0));return e},refresh:function(a,e){var d,b=this.options,u,c=a,l,q={},r=[];d=b.formatter||this.defaultFormatter;var q=this.shared,h;clearTimeout(this.hideTimer);this.followPointer=
	p(c)[0].series.tooltipOptions.followPointer;l=this.getAnchor(c,e);e=l[0];u=l[1];!q||c.series&&c.series.noSharedTooltip?q=c.getLabelConfig():(A(c,function(a){a.setState("hover");r.push(a.getLabelConfig())}),q={x:c[0].category,y:c[0].y},q.points=r,c=c[0]);this.len=r.length;q=d.call(q,this);h=c.series;this.distance=x(h.tooltipOptions.distance,16);!1===q?this.hide():(d=this.getLabel(),this.isHidden&&d.attr({opacity:1}).show(),this.split?this.renderSplit(q,a):(d.attr({text:q&&q.join?q.join(""):q}),d.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-"+
	x(c.colorIndex,h.colorIndex)),d.attr({stroke:b.borderColor||c.color||h.color||"#666666"}),this.updatePosition({plotX:e,plotY:u,negative:c.negative,ttBelow:c.ttBelow,h:l[2]||0})),this.isHidden=!1)},renderSplit:function(d,e){var l=this,b=[],u=this.chart,c=u.renderer,C=!0,q=this.options,r,h=this.getLabel();A(d.slice(0,e.length+1),function(a,f){f=e[f-1]||{isHeader:!0,plotX:e[0].plotX};var d=f.series||l,n=d.tt,y=f.series||{},E="highcharts-color-"+x(f.colorIndex,y.colorIndex,"none");n||(d.tt=n=c.label(null,
	null,null,"callout").addClass("highcharts-tooltip-box "+E).attr({padding:q.padding,r:q.borderRadius,fill:q.backgroundColor,stroke:f.color||y.color||"#333333","stroke-width":q.borderWidth}).add(h));n.isActive=!0;n.attr({text:a});n.css(q.style);a=n.getBBox();y=a.width+n.strokeWidth();f.isHeader?(r=a.height,y=Math.max(0,Math.min(f.plotX+u.plotLeft-y/2,u.chartWidth-y))):y=f.plotX+u.plotLeft-x(q.distance,16)-y;0>y&&(C=!1);a=(f.series&&f.series.yAxis&&f.series.yAxis.pos)+(f.plotY||0);a-=u.plotTop;b.push({target:f.isHeader?
	u.plotHeight+r:a,rank:f.isHeader?1:0,size:d.tt.getBBox().height+1,point:f,x:y,tt:n})});this.cleanSplit();a.distribute(b,u.plotHeight+r);A(b,function(a){var b=a.point,c=b.series;a.tt.attr({visibility:void 0===a.pos?"hidden":"inherit",x:C||b.isHeader?a.x:b.plotX+u.plotLeft+x(q.distance,16),y:a.pos+u.plotTop,anchorX:b.isHeader?b.plotX+u.plotLeft:b.plotX+c.xAxis.pos,anchorY:b.isHeader?a.pos+u.plotTop-15:b.plotY+c.yAxis.pos})})},updatePosition:function(a){var d=this.chart,e=this.getLabel(),e=(this.options.positioner||
	this.getPosition).call(this,e.width,e.height,a);this.move(Math.round(e.x),Math.round(e.y||0),a.plotX+d.plotLeft,a.plotY+d.plotTop)},getDateFormat:function(a,l,m,b){var d=D("%m-%d %H:%M:%S.%L",l),c,C,q={millisecond:15,second:12,minute:9,hour:6,day:3},r="millisecond";for(C in e){if(a===e.week&&+D("%w",l)===m&&"00:00:00.000"===d.substr(6)){C="week";break}if(e[C]>a){C=r;break}if(q[C]&&d.substr(q[C])!=="01-01 00:00:00.000".substr(q[C]))break;"week"!==C&&(r=C)}C&&(c=b[C]);return c},getXDateFormat:function(a,
	e,m){e=e.dateTimeLabelFormats;var b=m&&m.closestPointRange;return(b?this.getDateFormat(b,a.x,m.options.startOfWeek,e):e.day)||e.year},tooltipFooterHeaderFormatter:function(a,e){var d=e?"footer":"header";e=a.series;var b=e.tooltipOptions,u=b.xDateFormat,c=e.xAxis,l=c&&"datetime"===c.options.type&&w(a.key),d=b[d+"Format"];l&&!u&&(u=this.getXDateFormat(a,b,c));l&&u&&(d=d.replace("{point.key}","{point.key:"+u+"}"));return H(d,{point:a,series:e})},bodyFormatter:function(a){return k(a,function(a){var d=
	a.series.tooltipOptions;return(d.pointFormatter||a.point.tooltipFormatter).call(a.point,d.pointFormat)})}}})(K);(function(a){var D=a.addEvent,A=a.attr,G=a.charts,H=a.color,w=a.css,k=a.defined,t=a.doc,x=a.each,p=a.extend,m=a.fireEvent,e=a.offset,d=a.pick,l=a.removeEvent,z=a.splat,b=a.Tooltip,u=a.win;a.Pointer=function(a,b){this.init(a,b)};a.Pointer.prototype={init:function(a,e){this.options=e;this.chart=a;this.runChartClick=e.chart.events&&!!e.chart.events.click;this.pinchDown=[];this.lastValidTouch=
	{};b&&e.tooltip.enabled&&(a.tooltip=new b(a,e.tooltip),this.followTouchMove=d(e.tooltip.followTouchMove,!0));this.setDOMEvents()},zoomOption:function(a){var b=this.chart,c=b.options.chart,r=c.zoomType||"",b=b.inverted;/touch/.test(a.type)&&(r=d(c.pinchType,r));this.zoomX=a=/x/.test(r);this.zoomY=r=/y/.test(r);this.zoomHor=a&&!b||r&&b;this.zoomVert=r&&!b||a&&b;this.hasZoom=a||r},normalize:function(a,b){var c,d;a=a||u.event;a.target||(a.target=a.srcElement);d=a.touches?a.touches.length?a.touches.item(0):
	a.changedTouches[0]:a;b||(this.chartPosition=b=e(this.chart.container));void 0===d.pageX?(c=Math.max(a.x,a.clientX-b.left),b=a.y):(c=d.pageX-b.left,b=d.pageY-b.top);return p(a,{chartX:Math.round(c),chartY:Math.round(b)})},getCoordinates:function(a){var b={xAxis:[],yAxis:[]};x(this.chart.axes,function(c){b[c.isXAxis?"xAxis":"yAxis"].push({axis:c,value:c.toValue(a[c.horiz?"chartX":"chartY"])})});return b},getKDPoints:function(a,b,q){var c=[],h,e,f;x(a,function(a){h=a.noSharedTooltip&&b;e=!b&&a.directTouch;
	a.visible&&!h&&!e&&d(a.options.enableMouseTracking,!0)&&(f=a.searchPoint(q,!h&&1===a.kdDimensions))&&f.series&&c.push(f)});c.sort(function(a,c){var f=a.distX-c.distX,n=a.dist-c.dist,h=(c.series.group&&c.series.group.zIndex)-(a.series.group&&a.series.group.zIndex);return 0!==f&&b?f:0!==n?n:0!==h?h:a.series.index>c.series.index?-1:1});if(b)for(a=c.length;a--;)(c[a].x!==c[0].x||c[a].series.noSharedTooltip)&&c.splice(a,1);return c},getPointFromEvent:function(a){a=a.target;for(var b;a&&!b;)b=a.point,a=
	a.parentNode;return b},getHoverData:function(a,b,q,r,h,e){var c=a;a=b;var u;if(r)h?(u=[],x(q,function(a){var b=a.noSharedTooltip&&h,f=!h&&a.directTouch;a.visible&&!b&&!f&&d(a.options.enableMouseTracking,!0)&&(a=a.searchKDTree({clientX:c.clientX,plotY:c.plotY},!b&&1===a.kdDimensions))&&a.series&&u.push(a)}),0===u.length&&(u=[c])):u=[c];else{if(a&&!a.options.stickyTracking)u=this.getKDPoints([a],h,e);else{if(!h)if(a)a.options.stickyTracking||(q=[a]);else for(r=0;r<q.length;r++)if(q[r].directTouch||
	!q[r].options.stickyTracking)q=[];u=this.getKDPoints(q,h,e)}a=(c=u[0])&&c.series}u.sort(function(a,b){return a.series.index-b.series.index});return{hoverPoint:c,hoverSeries:a,hoverPoints:u}},runPointActions:function(b,d){var c=this.chart,r=c.tooltip,h=r?r.shared:!1,e=d||c.hoverPoint,f=e&&e.series||c.hoverSeries;d=this.getHoverData(e,f,c.series,!!d||f&&f.directTouch,h,b);var u,n,e=d.hoverPoint;u=(f=d.hoverSeries)&&f.tooltipOptions.followPointer;n=(h=h&&e&&!e.series.noSharedTooltip)?d.hoverPoints:[e];
	if(e&&(e!==c.hoverPoint||r&&r.isHidden)){x(c.hoverPoints||[],function(b){-1===a.inArray(b,n)&&b.setState()});x(n||[],function(a){a.setState("hover")});if(c.hoverSeries!==f)f.onMouseOver();f&&!f.directTouch&&(c.hoverPoint&&c.hoverPoint.firePointEvent("mouseOut"),e.firePointEvent("mouseOver"));c.hoverPoints=n;c.hoverPoint=e;r&&r.refresh(h?n:e,b)}else u&&r&&!r.isHidden&&(e=r.getAnchor([{}],b),r.updatePosition({plotX:e[0],plotY:e[1]}));this.unDocMouseMove||(this.unDocMouseMove=D(t,"mousemove",function(b){var c=
	G[a.hoverChartIndex];if(c)c.pointer.onDocumentMouseMove(b)}));x(n,function(a){x(c.axes,function(c){(!a||a.series&&a.series[c.coll]===c)&&c.drawCrosshair(b,a)})})},reset:function(a,b){var c=this.chart,d=c.hoverSeries,h=c.hoverPoint,e=c.hoverPoints,f=c.tooltip,u=f&&f.shared?e:h;a&&u&&x(z(u),function(b){b.series.isCartesian&&void 0===b.plotX&&(a=!1)});if(a)f&&u&&(f.refresh(u),h&&(h.setState(h.state,!0),x(c.axes,function(a){a.crosshair&&a.drawCrosshair(null,h)})));else{if(h)h.onMouseOut();e&&x(e,function(a){a.setState()});
	if(d)d.onMouseOut();f&&f.hide(b);this.unDocMouseMove&&(this.unDocMouseMove=this.unDocMouseMove());x(c.axes,function(a){a.hideCrosshair()});this.hoverX=c.hoverPoints=c.hoverPoint=null}},scaleGroups:function(a,b){var c=this.chart,d;x(c.series,function(h){d=a||h.getPlotBox();h.xAxis&&h.xAxis.zoomEnabled&&h.group&&(h.group.attr(d),h.markerGroup&&(h.markerGroup.attr(d),h.markerGroup.clip(b?c.clipRect:null)),h.dataLabelsGroup&&h.dataLabelsGroup.attr(d))});c.clipRect.attr(b||c.clipBox)},dragStart:function(a){var b=
	this.chart;b.mouseIsDown=a.type;b.cancelClick=!1;b.mouseDownX=this.mouseDownX=a.chartX;b.mouseDownY=this.mouseDownY=a.chartY},drag:function(a){var b=this.chart,c=b.options.chart,d=a.chartX,h=a.chartY,e=this.zoomHor,f=this.zoomVert,u=b.plotLeft,n=b.plotTop,y=b.plotWidth,l=b.plotHeight,F,I=this.selectionMarker,g=this.mouseDownX,m=this.mouseDownY,z=c.panKey&&a[c.panKey+"Key"];I&&I.touch||(d<u?d=u:d>u+y&&(d=u+y),h<n?h=n:h>n+l&&(h=n+l),this.hasDragged=Math.sqrt(Math.pow(g-d,2)+Math.pow(m-h,2)),10<this.hasDragged&&
	(F=b.isInsidePlot(g-u,m-n),b.hasCartesianSeries&&(this.zoomX||this.zoomY)&&F&&!z&&!I&&(this.selectionMarker=I=b.renderer.rect(u,n,e?1:y,f?1:l,0).attr({fill:c.selectionMarkerFill||H("#335cad").setOpacity(.25).get(),"class":"highcharts-selection-marker",zIndex:7}).add()),I&&e&&(d-=g,I.attr({width:Math.abs(d),x:(0<d?0:d)+g})),I&&f&&(d=h-m,I.attr({height:Math.abs(d),y:(0<d?0:d)+m})),F&&!I&&c.panning&&b.pan(a,c.panning)))},drop:function(a){var b=this,c=this.chart,d=this.hasPinched;if(this.selectionMarker){var h=
	{originalEvent:a,xAxis:[],yAxis:[]},e=this.selectionMarker,f=e.attr?e.attr("x"):e.x,u=e.attr?e.attr("y"):e.y,n=e.attr?e.attr("width"):e.width,y=e.attr?e.attr("height"):e.height,l;if(this.hasDragged||d)x(c.axes,function(c){if(c.zoomEnabled&&k(c.min)&&(d||b[{xAxis:"zoomX",yAxis:"zoomY"}[c.coll]])){var e=c.horiz,g="touchend"===a.type?c.minPixelPadding:0,r=c.toValue((e?f:u)+g),e=c.toValue((e?f+n:u+y)-g);h[c.coll].push({axis:c,min:Math.min(r,e),max:Math.max(r,e)});l=!0}}),l&&m(c,"selection",h,function(a){c.zoom(p(a,
	d?{animation:!1}:null))});this.selectionMarker=this.selectionMarker.destroy();d&&this.scaleGroups()}c&&(w(c.container,{cursor:c._cursor}),c.cancelClick=10<this.hasDragged,c.mouseIsDown=this.hasDragged=this.hasPinched=!1,this.pinchDown=[])},onContainerMouseDown:function(a){a=this.normalize(a);this.zoomOption(a);a.preventDefault&&a.preventDefault();this.dragStart(a)},onDocumentMouseUp:function(b){G[a.hoverChartIndex]&&G[a.hoverChartIndex].pointer.drop(b)},onDocumentMouseMove:function(a){var b=this.chart,
	c=this.chartPosition;a=this.normalize(a,c);!c||this.inClass(a.target,"highcharts-tracker")||b.isInsidePlot(a.chartX-b.plotLeft,a.chartY-b.plotTop)||this.reset()},onContainerMouseLeave:function(b){var c=G[a.hoverChartIndex];c&&(b.relatedTarget||b.toElement)&&(c.pointer.reset(),c.pointer.chartPosition=null)},onContainerMouseMove:function(b){var c=this.chart;k(a.hoverChartIndex)&&G[a.hoverChartIndex]&&G[a.hoverChartIndex].mouseIsDown||(a.hoverChartIndex=c.index);b=this.normalize(b);b.returnValue=!1;
	"mousedown"===c.mouseIsDown&&this.drag(b);!this.inClass(b.target,"highcharts-tracker")&&!c.isInsidePlot(b.chartX-c.plotLeft,b.chartY-c.plotTop)||c.openMenu||this.runPointActions(b)},inClass:function(a,b){for(var c;a;){if(c=A(a,"class")){if(-1!==c.indexOf(b))return!0;if(-1!==c.indexOf("highcharts-container"))return!1}a=a.parentNode}},onTrackerMouseOut:function(a){var b=this.chart.hoverSeries;a=a.relatedTarget||a.toElement;if(!(!b||!a||b.options.stickyTracking||this.inClass(a,"highcharts-tooltip")||
	this.inClass(a,"highcharts-series-"+b.index)&&this.inClass(a,"highcharts-tracker")))b.onMouseOut()},onContainerClick:function(a){var b=this.chart,c=b.hoverPoint,d=b.plotLeft,h=b.plotTop;a=this.normalize(a);b.cancelClick||(c&&this.inClass(a.target,"highcharts-tracker")?(m(c.series,"click",p(a,{point:c})),b.hoverPoint&&c.firePointEvent("click",a)):(p(a,this.getCoordinates(a)),b.isInsidePlot(a.chartX-d,a.chartY-h)&&m(b,"click",a)))},setDOMEvents:function(){var b=this,d=b.chart.container;d.onmousedown=
	function(a){b.onContainerMouseDown(a)};d.onmousemove=function(a){b.onContainerMouseMove(a)};d.onclick=function(a){b.onContainerClick(a)};D(d,"mouseleave",b.onContainerMouseLeave);1===a.chartCount&&D(t,"mouseup",b.onDocumentMouseUp);a.hasTouch&&(d.ontouchstart=function(a){b.onContainerTouchStart(a)},d.ontouchmove=function(a){b.onContainerTouchMove(a)},1===a.chartCount&&D(t,"touchend",b.onDocumentTouchEnd))},destroy:function(){var b;l(this.chart.container,"mouseleave",this.onContainerMouseLeave);a.chartCount||
	(l(t,"mouseup",this.onDocumentMouseUp),l(t,"touchend",this.onDocumentTouchEnd));clearInterval(this.tooltipTimeout);for(b in this)this[b]=null}}})(K);(function(a){var D=a.charts,A=a.each,G=a.extend,H=a.map,w=a.noop,k=a.pick;G(a.Pointer.prototype,{pinchTranslate:function(a,k,p,m,e,d){this.zoomHor&&this.pinchTranslateDirection(!0,a,k,p,m,e,d);this.zoomVert&&this.pinchTranslateDirection(!1,a,k,p,m,e,d)},pinchTranslateDirection:function(a,k,p,m,e,d,l,z){var b=this.chart,u=a?"x":"y",c=a?"X":"Y",C="chart"+
	c,q=a?"width":"height",r=b["plot"+(a?"Left":"Top")],h,E,f=z||1,v=b.inverted,n=b.bounds[a?"h":"v"],y=1===k.length,L=k[0][C],F=p[0][C],I=!y&&k[1][C],g=!y&&p[1][C],t;p=function(){!y&&20<Math.abs(L-I)&&(f=z||Math.abs(F-g)/Math.abs(L-I));E=(r-F)/f+L;h=b["plot"+(a?"Width":"Height")]/f};p();k=E;k<n.min?(k=n.min,t=!0):k+h>n.max&&(k=n.max-h,t=!0);t?(F-=.8*(F-l[u][0]),y||(g-=.8*(g-l[u][1])),p()):l[u]=[F,g];v||(d[u]=E-r,d[q]=h);d=v?1/f:f;e[q]=h;e[u]=k;m[v?a?"scaleY":"scaleX":"scale"+c]=f;m["translate"+c]=d*
	r+(F-d*L)},pinch:function(a){var t=this,p=t.chart,m=t.pinchDown,e=a.touches,d=e.length,l=t.lastValidTouch,z=t.hasZoom,b=t.selectionMarker,u={},c=1===d&&(t.inClass(a.target,"highcharts-tracker")&&p.runTrackerClick||t.runChartClick),C={};1<d&&(t.initiated=!0);z&&t.initiated&&!c&&a.preventDefault();H(e,function(a){return t.normalize(a)});"touchstart"===a.type?(A(e,function(a,b){m[b]={chartX:a.chartX,chartY:a.chartY}}),l.x=[m[0].chartX,m[1]&&m[1].chartX],l.y=[m[0].chartY,m[1]&&m[1].chartY],A(p.axes,function(a){if(a.zoomEnabled){var b=
	p.bounds[a.horiz?"h":"v"],c=a.minPixelPadding,d=a.toPixels(k(a.options.min,a.dataMin)),f=a.toPixels(k(a.options.max,a.dataMax)),e=Math.max(d,f);b.min=Math.min(a.pos,Math.min(d,f)-c);b.max=Math.max(a.pos+a.len,e+c)}}),t.res=!0):t.followTouchMove&&1===d?this.runPointActions(t.normalize(a)):m.length&&(b||(t.selectionMarker=b=G({destroy:w,touch:!0},p.plotBox)),t.pinchTranslate(m,e,u,b,C,l),t.hasPinched=z,t.scaleGroups(u,C),t.res&&(t.res=!1,this.reset(!1,0)))},touch:function(t,w){var p=this.chart,m,e;
	if(p.index!==a.hoverChartIndex)this.onContainerMouseLeave({relatedTarget:!0});a.hoverChartIndex=p.index;1===t.touches.length?(t=this.normalize(t),(e=p.isInsidePlot(t.chartX-p.plotLeft,t.chartY-p.plotTop))&&!p.openMenu?(w&&this.runPointActions(t),"touchmove"===t.type&&(w=this.pinchDown,m=w[0]?4<=Math.sqrt(Math.pow(w[0].chartX-t.chartX,2)+Math.pow(w[0].chartY-t.chartY,2)):!1),k(m,!0)&&this.pinch(t)):w&&this.reset()):2===t.touches.length&&this.pinch(t)},onContainerTouchStart:function(a){this.zoomOption(a);
	this.touch(a,!0)},onContainerTouchMove:function(a){this.touch(a)},onDocumentTouchEnd:function(k){D[a.hoverChartIndex]&&D[a.hoverChartIndex].pointer.drop(k)}})})(K);(function(a){var D=a.addEvent,A=a.charts,G=a.css,H=a.doc,w=a.extend,k=a.noop,t=a.Pointer,x=a.removeEvent,p=a.win,m=a.wrap;if(p.PointerEvent||p.MSPointerEvent){var e={},d=!!p.PointerEvent,l=function(){var a,d=[];d.item=function(a){return this[a]};for(a in e)e.hasOwnProperty(a)&&d.push({pageX:e[a].pageX,pageY:e[a].pageY,target:e[a].target});
	return d},z=function(b,d,c,e){"touch"!==b.pointerType&&b.pointerType!==b.MSPOINTER_TYPE_TOUCH||!A[a.hoverChartIndex]||(e(b),e=A[a.hoverChartIndex].pointer,e[d]({type:c,target:b.currentTarget,preventDefault:k,touches:l()}))};w(t.prototype,{onContainerPointerDown:function(a){z(a,"onContainerTouchStart","touchstart",function(a){e[a.pointerId]={pageX:a.pageX,pageY:a.pageY,target:a.currentTarget}})},onContainerPointerMove:function(a){z(a,"onContainerTouchMove","touchmove",function(a){e[a.pointerId]={pageX:a.pageX,
	pageY:a.pageY};e[a.pointerId].target||(e[a.pointerId].target=a.currentTarget)})},onDocumentPointerUp:function(a){z(a,"onDocumentTouchEnd","touchend",function(a){delete e[a.pointerId]})},batchMSEvents:function(a){a(this.chart.container,d?"pointerdown":"MSPointerDown",this.onContainerPointerDown);a(this.chart.container,d?"pointermove":"MSPointerMove",this.onContainerPointerMove);a(H,d?"pointerup":"MSPointerUp",this.onDocumentPointerUp)}});m(t.prototype,"init",function(a,d,c){a.call(this,d,c);this.hasZoom&&
	G(d.container,{"-ms-touch-action":"none","touch-action":"none"})});m(t.prototype,"setDOMEvents",function(a){a.apply(this);(this.hasZoom||this.followTouchMove)&&this.batchMSEvents(D)});m(t.prototype,"destroy",function(a){this.batchMSEvents(x);a.call(this)})}})(K);(function(a){var D,A=a.addEvent,G=a.css,H=a.discardElement,w=a.defined,k=a.each,t=a.isFirefox,x=a.marginNames,p=a.merge,m=a.pick,e=a.setAnimation,d=a.stableSort,l=a.win,z=a.wrap;D=a.Legend=function(a,d){this.init(a,d)};D.prototype={init:function(a,
	d){this.chart=a;this.setOptions(d);d.enabled&&(this.render(),A(this.chart,"endResize",function(){this.legend.positionCheckboxes()}))},setOptions:function(a){var b=m(a.padding,8);this.options=a;this.itemStyle=a.itemStyle;this.itemHiddenStyle=p(this.itemStyle,a.itemHiddenStyle);this.itemMarginTop=a.itemMarginTop||0;this.initialItemX=this.padding=b;this.initialItemY=b-5;this.itemHeight=this.maxItemWidth=0;this.symbolWidth=m(a.symbolWidth,16);this.pages=[]},update:function(a,d){var b=this.chart;this.setOptions(p(!0,
	this.options,a));this.destroy();b.isDirtyLegend=b.isDirtyBox=!0;m(d,!0)&&b.redraw()},colorizeItem:function(a,d){a.legendGroup[d?"removeClass":"addClass"]("highcharts-legend-item-hidden");var b=this.options,e=a.legendItem,u=a.legendLine,r=a.legendSymbol,h=this.itemHiddenStyle.color,b=d?b.itemStyle.color:h,l=d?a.color||h:h,f=a.options&&a.options.marker,v={fill:l},n;e&&e.css({fill:b,color:b});u&&u.attr({stroke:l});if(r){if(f&&r.isMarker&&(v=a.pointAttribs(),!d))for(n in v)v[n]=h;r.attr(v)}},positionItem:function(a){var b=
	this.options,c=b.symbolPadding,b=!b.rtl,d=a._legendItemPos,e=d[0],d=d[1],r=a.checkbox;(a=a.legendGroup)&&a.element&&a.translate(b?e:this.legendWidth-e-2*c-4,d);r&&(r.x=e,r.y=d)},destroyItem:function(a){var b=a.checkbox;k(["legendItem","legendLine","legendSymbol","legendGroup"],function(b){a[b]&&(a[b]=a[b].destroy())});b&&H(a.checkbox)},destroy:function(){function a(a){this[a]&&(this[a]=this[a].destroy())}k(this.getAllItems(),function(b){k(["legendItem","legendGroup"],a,b)});k("clipRect up down pager nav box title group".split(" "),
	a,this);this.display=null},positionCheckboxes:function(a){var b=this.group&&this.group.alignAttr,c,d=this.clipHeight||this.legendHeight,e=this.titleHeight;b&&(c=b.translateY,k(this.allItems,function(r){var h=r.checkbox,l;h&&(l=c+e+h.y+(a||0)+3,G(h,{left:b.translateX+r.checkboxOffset+h.x-20+"px",top:l+"px",display:l>c-6&&l<c+d-6?"":"none"}))}))},renderTitle:function(){var a=this.padding,d=this.options.title,c=0;d.text&&(this.title||(this.title=this.chart.renderer.label(d.text,a-3,a-4,null,null,null,
	null,null,"legend-title").attr({zIndex:1}).css(d.style).add(this.group)),a=this.title.getBBox(),c=a.height,this.offsetWidth=a.width,this.contentGroup.attr({translateY:c}));this.titleHeight=c},setText:function(b){var d=this.options;b.legendItem.attr({text:d.labelFormat?a.format(d.labelFormat,b):d.labelFormatter.call(b)})},renderItem:function(a){var b=this.chart,c=b.renderer,d=this.options,e="horizontal"===d.layout,r=this.symbolWidth,h=d.symbolPadding,l=this.itemStyle,f=this.itemHiddenStyle,v=this.padding,
	n=e?m(d.itemDistance,20):0,y=!d.rtl,L=d.width,F=d.itemMarginBottom||0,I=this.itemMarginTop,g=this.initialItemX,k=a.legendItem,z=!a.series,t=!z&&a.series.drawLegendSymbol?a.series:a,w=t.options,w=this.createCheckboxForItem&&w&&w.showCheckbox,x=d.useHTML;k||(a.legendGroup=c.g("legend-item").addClass("highcharts-"+t.type+"-series highcharts-color-"+a.colorIndex+(a.options.className?" "+a.options.className:"")+(z?" highcharts-series-"+a.index:"")).attr({zIndex:1}).add(this.scrollGroup),a.legendItem=k=
	c.text("",y?r+h:-h,this.baseline||0,x).css(p(a.visible?l:f)).attr({align:y?"left":"right",zIndex:2}).add(a.legendGroup),this.baseline||(l=l.fontSize,this.fontMetrics=c.fontMetrics(l,k),this.baseline=this.fontMetrics.f+3+I,k.attr("y",this.baseline)),this.symbolHeight=d.symbolHeight||this.fontMetrics.f,t.drawLegendSymbol(this,a),this.setItemEvents&&this.setItemEvents(a,k,x),w&&this.createCheckboxForItem(a));this.colorizeItem(a,a.visible);this.setText(a);c=k.getBBox();r=a.checkboxOffset=d.itemWidth||
	a.legendItemWidth||r+h+c.width+n+(w?20:0);this.itemHeight=h=Math.round(a.legendItemHeight||c.height);e&&this.itemX-g+r>(L||b.chartWidth-2*v-g-d.x)&&(this.itemX=g,this.itemY+=I+this.lastLineHeight+F,this.lastLineHeight=0);this.maxItemWidth=Math.max(this.maxItemWidth,r);this.lastItemY=I+this.itemY+F;this.lastLineHeight=Math.max(h,this.lastLineHeight);a._legendItemPos=[this.itemX,this.itemY];e?this.itemX+=r:(this.itemY+=I+h+F,this.lastLineHeight=h);this.offsetWidth=L||Math.max((e?this.itemX-g-n:r)+v,
	this.offsetWidth)},getAllItems:function(){var a=[];k(this.chart.series,function(b){var c=b&&b.options;b&&m(c.showInLegend,w(c.linkedTo)?!1:void 0,!0)&&(a=a.concat(b.legendItems||("point"===c.legendType?b.data:b)))});return a},adjustMargins:function(a,d){var b=this.chart,e=this.options,l=e.align.charAt(0)+e.verticalAlign.charAt(0)+e.layout.charAt(0);e.floating||k([/(lth|ct|rth)/,/(rtv|rm|rbv)/,/(rbh|cb|lbh)/,/(lbv|lm|ltv)/],function(c,h){c.test(l)&&!w(a[h])&&(b[x[h]]=Math.max(b[x[h]],b.legend[(h+1)%
	2?"legendHeight":"legendWidth"]+[1,-1,-1,1][h]*e[h%2?"x":"y"]+m(e.margin,12)+d[h]))})},render:function(){var a=this,e=a.chart,c=e.renderer,l=a.group,q,r,h,m,f=a.box,v=a.options,n=a.padding;a.itemX=a.initialItemX;a.itemY=a.initialItemY;a.offsetWidth=0;a.lastItemY=0;l||(a.group=l=c.g("legend").attr({zIndex:7}).add(),a.contentGroup=c.g().attr({zIndex:1}).add(l),a.scrollGroup=c.g().add(a.contentGroup));a.renderTitle();q=a.getAllItems();d(q,function(a,b){return(a.options&&a.options.legendIndex||0)-(b.options&&
	b.options.legendIndex||0)});v.reversed&&q.reverse();a.allItems=q;a.display=r=!!q.length;a.lastLineHeight=0;k(q,function(b){a.renderItem(b)});h=(v.width||a.offsetWidth)+n;m=a.lastItemY+a.lastLineHeight+a.titleHeight;m=a.handleOverflow(m);m+=n;f||(a.box=f=c.rect().addClass("highcharts-legend-box").attr({r:v.borderRadius}).add(l),f.isNew=!0);f.attr({stroke:v.borderColor,"stroke-width":v.borderWidth||0,fill:v.backgroundColor||"none"}).shadow(v.shadow);0<h&&0<m&&(f[f.isNew?"attr":"animate"](f.crisp({x:0,
	y:0,width:h,height:m},f.strokeWidth())),f.isNew=!1);f[r?"show":"hide"]();a.legendWidth=h;a.legendHeight=m;k(q,function(b){a.positionItem(b)});r&&l.align(p(v,{width:h,height:m}),!0,"spacingBox");e.isResizing||this.positionCheckboxes()},handleOverflow:function(a){var b=this,c=this.chart,d=c.renderer,e=this.options,r=e.y,c=c.spacingBox.height+("top"===e.verticalAlign?-r:r)-this.padding,r=e.maxHeight,h,l=this.clipRect,f=e.navigation,v=m(f.animation,!0),n=f.arrowSize||12,y=this.nav,z=this.pages,F=this.padding,
	I,g=this.allItems,p=function(a){a?l.attr({height:a}):l&&(b.clipRect=l.destroy(),b.contentGroup.clip());b.contentGroup.div&&(b.contentGroup.div.style.clip=a?"rect("+F+"px,9999px,"+(F+a)+"px,0)":"auto")};"horizontal"!==e.layout||"middle"===e.verticalAlign||e.floating||(c/=2);r&&(c=Math.min(c,r));z.length=0;a>c&&!1!==f.enabled?(this.clipHeight=h=Math.max(c-20-this.titleHeight-F,0),this.currentPage=m(this.currentPage,1),this.fullHeight=a,k(g,function(a,b){var c=a._legendItemPos[1];a=Math.round(a.legendItem.getBBox().height);
	var f=z.length;if(!f||c-z[f-1]>h&&(I||c)!==z[f-1])z.push(I||c),f++;b===g.length-1&&c+a-z[f-1]>h&&z.push(c);c!==I&&(I=c)}),l||(l=b.clipRect=d.clipRect(0,F,9999,0),b.contentGroup.clip(l)),p(h),y||(this.nav=y=d.g().attr({zIndex:1}).add(this.group),this.up=d.symbol("triangle",0,0,n,n).on("click",function(){b.scroll(-1,v)}).add(y),this.pager=d.text("",15,10).addClass("highcharts-legend-navigation").css(f.style).add(y),this.down=d.symbol("triangle-down",0,0,n,n).on("click",function(){b.scroll(1,v)}).add(y)),
	b.scroll(0),a=c):y&&(p(),this.nav=y.destroy(),this.scrollGroup.attr({translateY:1}),this.clipHeight=0);return a},scroll:function(a,d){var b=this.pages,l=b.length;a=this.currentPage+a;var q=this.clipHeight,r=this.options.navigation,h=this.pager,u=this.padding;a>l&&(a=l);0<a&&(void 0!==d&&e(d,this.chart),this.nav.attr({translateX:u,translateY:q+this.padding+7+this.titleHeight,visibility:"visible"}),this.up.attr({"class":1===a?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"}),h.attr({text:a+
	"/"+l}),this.down.attr({x:18+this.pager.getBBox().width,"class":a===l?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"}),this.up.attr({fill:1===a?r.inactiveColor:r.activeColor}).css({cursor:1===a?"default":"pointer"}),this.down.attr({fill:a===l?r.inactiveColor:r.activeColor}).css({cursor:a===l?"default":"pointer"}),d=-b[a-1]+this.initialItemY,this.scrollGroup.animate({translateY:d}),this.currentPage=a,this.positionCheckboxes(d))}};a.LegendSymbolMixin={drawRectangle:function(a,d){var b=
	a.symbolHeight,e=a.options.squareSymbol;d.legendSymbol=this.chart.renderer.rect(e?(a.symbolWidth-b)/2:0,a.baseline-b+1,e?b:a.symbolWidth,b,m(a.options.symbolRadius,b/2)).addClass("highcharts-point").attr({zIndex:3}).add(d.legendGroup)},drawLineMarker:function(a){var b=this.options,c=b.marker,d=a.symbolWidth,e=a.symbolHeight,r=e/2,h=this.chart.renderer,l=this.legendGroup;a=a.baseline-Math.round(.3*a.fontMetrics.b);var f;f={"stroke-width":b.lineWidth||0};b.dashStyle&&(f.dashstyle=b.dashStyle);this.legendLine=
	h.path(["M",0,a,"L",d,a]).addClass("highcharts-graph").attr(f).add(l);c&&!1!==c.enabled&&(b=Math.min(m(c.radius,r),r),0===this.symbol.indexOf("url")&&(c=p(c,{width:e,height:e}),b=0),this.legendSymbol=c=h.symbol(this.symbol,d/2-b,a-b,2*b,2*b,c).addClass("highcharts-point").add(l),c.isMarker=!0)}};(/Trident\/7\.0/.test(l.navigator.userAgent)||t)&&z(D.prototype,"positionItem",function(a,d){var b=this,e=function(){d._legendItemPos&&a.call(b,d)};e();setTimeout(e)})})(K);(function(a){var D=a.addEvent,A=
	a.animate,G=a.animObject,H=a.attr,w=a.doc,k=a.Axis,t=a.createElement,x=a.defaultOptions,p=a.discardElement,m=a.charts,e=a.css,d=a.defined,l=a.each,z=a.extend,b=a.find,u=a.fireEvent,c=a.getStyle,C=a.grep,q=a.isNumber,r=a.isObject,h=a.isString,E=a.Legend,f=a.marginNames,v=a.merge,n=a.Pointer,y=a.pick,L=a.pInt,F=a.removeEvent,I=a.seriesTypes,g=a.splat,J=a.svg,Q=a.syncTimeout,P=a.win,M=a.Renderer,S=a.Chart=function(){this.getArgs.apply(this,arguments)};a.chart=function(a,b,g){return new S(a,b,g)};S.prototype=
	{callbacks:[],getArgs:function(){var a=[].slice.call(arguments);if(h(a[0])||a[0].nodeName)this.renderTo=a.shift();this.init(a[0],a[1])},init:function(b,g){var c,f=b.series;b.series=null;c=v(x,b);c.series=b.series=f;this.userOptions=b;b=c.chart;f=b.events;this.margin=[];this.spacing=[];this.bounds={h:{},v:{}};this.callback=g;this.isResizing=0;this.options=c;this.axes=[];this.series=[];this.hasCartesianSeries=b.showAxes;var d;this.index=m.length;m.push(this);a.chartCount++;if(f)for(d in f)D(this,d,
	f[d]);this.xAxis=[];this.yAxis=[];this.pointCount=this.colorCounter=this.symbolCounter=0;this.firstRender()},initSeries:function(b){var g=this.options.chart;(g=I[b.type||g.type||g.defaultSeriesType])||a.error(17,!0);g=new g;g.init(this,b);return g},orderSeries:function(a){var b=this.series;for(a=a||0;a<b.length;a++)b[a]&&(b[a].index=a,b[a].name=b[a].name||"Series "+(b[a].index+1))},isInsidePlot:function(a,b,g){var c=g?b:a;a=g?a:b;return 0<=c&&c<=this.plotWidth&&0<=a&&a<=this.plotHeight},redraw:function(b){var g=
	this.axes,c=this.series,f=this.pointer,d=this.legend,n=this.isDirtyLegend,h,e,y=this.hasCartesianSeries,r=this.isDirtyBox,F,v=this.renderer,q=v.isHidden(),I=[];this.setResponsive&&this.setResponsive(!1);a.setAnimation(b,this);q&&this.cloneRenderTo();this.layOutTitles();for(b=c.length;b--;)if(F=c[b],F.options.stacking&&(h=!0,F.isDirty)){e=!0;break}if(e)for(b=c.length;b--;)F=c[b],F.options.stacking&&(F.isDirty=!0);l(c,function(a){a.isDirty&&"point"===a.options.legendType&&(a.updateTotals&&a.updateTotals(),
	n=!0);a.isDirtyData&&u(a,"updatedData")});n&&d.options.enabled&&(d.render(),this.isDirtyLegend=!1);h&&this.getStacks();y&&l(g,function(a){a.updateNames();a.setScale()});this.getMargins();y&&(l(g,function(a){a.isDirty&&(r=!0)}),l(g,function(a){var b=a.min+","+a.max;a.extKey!==b&&(a.extKey=b,I.push(function(){u(a,"afterSetExtremes",z(a.eventArgs,a.getExtremes()));delete a.eventArgs}));(r||h)&&a.redraw()}));r&&this.drawChartBox();u(this,"predraw");l(c,function(a){(r||a.isDirty)&&a.visible&&a.redraw();
	a.isDirtyData=!1});f&&f.reset(!0);v.draw();u(this,"redraw");u(this,"render");q&&this.cloneRenderTo(!0);l(I,function(a){a.call()})},get:function(a){function g(b){return b.id===a||b.options&&b.options.id===a}var c,f=this.series,d;c=b(this.axes,g)||b(this.series,g);for(d=0;!c&&d<f.length;d++)c=b(f[d].points||[],g);return c},getAxes:function(){var a=this,b=this.options,c=b.xAxis=g(b.xAxis||{}),b=b.yAxis=g(b.yAxis||{});l(c,function(a,b){a.index=b;a.isX=!0});l(b,function(a,b){a.index=b});c=c.concat(b);
	l(c,function(b){new k(a,b)})},getSelectedPoints:function(){var a=[];l(this.series,function(b){a=a.concat(C(b.points||[],function(a){return a.selected}))});return a},getSelectedSeries:function(){return C(this.series,function(a){return a.selected})},setTitle:function(a,b,g){var c=this,f=c.options,d;d=f.title=v({style:{color:"#333333",fontSize:f.isStock?"16px":"18px"}},f.title,a);f=f.subtitle=v({style:{color:"#666666"}},f.subtitle,b);l([["title",a,d],["subtitle",b,f]],function(a,b){var g=a[0],f=c[g],
	d=a[1];a=a[2];f&&d&&(c[g]=f=f.destroy());a&&a.text&&!f&&(c[g]=c.renderer.text(a.text,0,0,a.useHTML).attr({align:a.align,"class":"highcharts-"+g,zIndex:a.zIndex||4}).add(),c[g].update=function(a){c.setTitle(!b&&a,b&&a)},c[g].css(a.style))});c.layOutTitles(g)},layOutTitles:function(a){var b=0,g,c=this.renderer,f=this.spacingBox;l(["title","subtitle"],function(a){var g=this[a],d=this.options[a],n;g&&(n=d.style.fontSize,n=c.fontMetrics(n,g).b,g.css({width:(d.width||f.width+d.widthAdjust)+"px"}).align(z({y:b+
	n+("title"===a?-3:2)},d),!1,"spacingBox"),d.floating||d.verticalAlign||(b=Math.ceil(b+g.getBBox().height)))},this);g=this.titleOffset!==b;this.titleOffset=b;!this.isDirtyBox&&g&&(this.isDirtyBox=g,this.hasRendered&&y(a,!0)&&this.isDirtyBox&&this.redraw())},getChartSize:function(){var b=this.options.chart,g=b.width,b=b.height,f=this.renderToClone||this.renderTo;d(g)||(this.containerWidth=c(f,"width"));d(b)||(this.containerHeight=c(f,"height"));this.chartWidth=Math.max(0,g||this.containerWidth||600);
	this.chartHeight=Math.max(0,a.relativeLength(b,this.chartWidth)||this.containerHeight||400)},cloneRenderTo:function(a){var b=this.renderToClone,g=this.container;if(a){if(b){for(;b.childNodes.length;)this.renderTo.appendChild(b.firstChild);p(b);delete this.renderToClone}}else g&&g.parentNode===this.renderTo&&this.renderTo.removeChild(g),this.renderToClone=b=this.renderTo.cloneNode(0),e(b,{position:"absolute",top:"-9999px",display:"block"}),b.style.setProperty&&b.style.setProperty("display","block",
	"important"),w.body.appendChild(b),g&&b.appendChild(g)},setClassName:function(a){this.container.className="highcharts-container "+(a||"")},getContainer:function(){var b,g=this.options,c=g.chart,f,d;b=this.renderTo;var n=a.uniqueKey(),e;b||(this.renderTo=b=c.renderTo);h(b)&&(this.renderTo=b=w.getElementById(b));b||a.error(13,!0);f=L(H(b,"data-highcharts-chart"));q(f)&&m[f]&&m[f].hasRendered&&m[f].destroy();H(b,"data-highcharts-chart",this.index);b.innerHTML="";c.skipClone||b.offsetWidth||this.cloneRenderTo();
	this.getChartSize();f=this.chartWidth;d=this.chartHeight;e=z({position:"relative",overflow:"hidden",width:f+"px",height:d+"px",textAlign:"left",lineHeight:"normal",zIndex:0,"-webkit-tap-highlight-color":"rgba(0,0,0,0)"},c.style);this.container=b=t("div",{id:n},e,this.renderToClone||b);this._cursor=b.style.cursor;this.renderer=new (a[c.renderer]||M)(b,f,d,null,c.forExport,g.exporting&&g.exporting.allowHTML);this.setClassName(c.className);this.renderer.setStyle(c.style);this.renderer.chartIndex=this.index},
	getMargins:function(a){var b=this.spacing,g=this.margin,c=this.titleOffset;this.resetMargins();c&&!d(g[0])&&(this.plotTop=Math.max(this.plotTop,c+this.options.title.margin+b[0]));this.legend.display&&this.legend.adjustMargins(g,b);this.extraMargin&&(this[this.extraMargin.type]=(this[this.extraMargin.type]||0)+this.extraMargin.value);this.extraTopMargin&&(this.plotTop+=this.extraTopMargin);a||this.getAxisMargins()},getAxisMargins:function(){var a=this,b=a.axisOffset=[0,0,0,0],g=a.margin;a.hasCartesianSeries&&
	l(a.axes,function(a){a.visible&&a.getOffset()});l(f,function(c,f){d(g[f])||(a[c]+=b[f])});a.setChartSize()},reflow:function(a){var b=this,g=b.options.chart,f=b.renderTo,n=d(g.width),h=g.width||c(f,"width"),g=g.height||c(f,"height"),f=a?a.target:P;if(!n&&!b.isPrinting&&h&&g&&(f===P||f===w)){if(h!==b.containerWidth||g!==b.containerHeight)clearTimeout(b.reflowTimeout),b.reflowTimeout=Q(function(){b.container&&b.setSize(void 0,void 0,!1)},a?100:0);b.containerWidth=h;b.containerHeight=g}},initReflow:function(){var a=
	this,b;b=D(P,"resize",function(b){a.reflow(b)});D(a,"destroy",b)},setSize:function(b,g,c){var f=this,d=f.renderer;f.isResizing+=1;a.setAnimation(c,f);f.oldChartHeight=f.chartHeight;f.oldChartWidth=f.chartWidth;void 0!==b&&(f.options.chart.width=b);void 0!==g&&(f.options.chart.height=g);f.getChartSize();b=d.globalAnimation;(b?A:e)(f.container,{width:f.chartWidth+"px",height:f.chartHeight+"px"},b);f.setChartSize(!0);d.setSize(f.chartWidth,f.chartHeight,c);l(f.axes,function(a){a.isDirty=!0;a.setScale()});
	f.isDirtyLegend=!0;f.isDirtyBox=!0;f.layOutTitles();f.getMargins();f.redraw(c);f.oldChartHeight=null;u(f,"resize");Q(function(){f&&u(f,"endResize",null,function(){--f.isResizing})},G(b).duration)},setChartSize:function(a){var b=this.inverted,g=this.renderer,c=this.chartWidth,f=this.chartHeight,d=this.options.chart,n=this.spacing,h=this.clipOffset,e,y,r,F;this.plotLeft=e=Math.round(this.plotLeft);this.plotTop=y=Math.round(this.plotTop);this.plotWidth=r=Math.max(0,Math.round(c-e-this.marginRight));
	this.plotHeight=F=Math.max(0,Math.round(f-y-this.marginBottom));this.plotSizeX=b?F:r;this.plotSizeY=b?r:F;this.plotBorderWidth=d.plotBorderWidth||0;this.spacingBox=g.spacingBox={x:n[3],y:n[0],width:c-n[3]-n[1],height:f-n[0]-n[2]};this.plotBox=g.plotBox={x:e,y:y,width:r,height:F};c=2*Math.floor(this.plotBorderWidth/2);b=Math.ceil(Math.max(c,h[3])/2);g=Math.ceil(Math.max(c,h[0])/2);this.clipBox={x:b,y:g,width:Math.floor(this.plotSizeX-Math.max(c,h[1])/2-b),height:Math.max(0,Math.floor(this.plotSizeY-
	Math.max(c,h[2])/2-g))};a||l(this.axes,function(a){a.setAxisSize();a.setAxisTranslation()})},resetMargins:function(){var a=this,b=a.options.chart;l(["margin","spacing"],function(g){var c=b[g],f=r(c)?c:[c,c,c,c];l(["Top","Right","Bottom","Left"],function(c,d){a[g][d]=y(b[g+c],f[d])})});l(f,function(b,g){a[b]=y(a.margin[g],a.spacing[g])});a.axisOffset=[0,0,0,0];a.clipOffset=[0,0,0,0]},drawChartBox:function(){var a=this.options.chart,b=this.renderer,g=this.chartWidth,c=this.chartHeight,f=this.chartBackground,
	d=this.plotBackground,n=this.plotBorder,h,e=this.plotBGImage,y=a.backgroundColor,r=a.plotBackgroundColor,l=a.plotBackgroundImage,F,v=this.plotLeft,q=this.plotTop,I=this.plotWidth,u=this.plotHeight,m=this.plotBox,k=this.clipRect,z=this.clipBox,L="animate";f||(this.chartBackground=f=b.rect().addClass("highcharts-background").add(),L="attr");h=a.borderWidth||0;F=h+(a.shadow?8:0);y={fill:y||"none"};if(h||f["stroke-width"])y.stroke=a.borderColor,y["stroke-width"]=h;f.attr(y).shadow(a.shadow);f[L]({x:F/
	2,y:F/2,width:g-F-h%2,height:c-F-h%2,r:a.borderRadius});L="animate";d||(L="attr",this.plotBackground=d=b.rect().addClass("highcharts-plot-background").add());d[L](m);d.attr({fill:r||"none"}).shadow(a.plotShadow);l&&(e?e.animate(m):this.plotBGImage=b.image(l,v,q,I,u).add());k?k.animate({width:z.width,height:z.height}):this.clipRect=b.clipRect(z);L="animate";n||(L="attr",this.plotBorder=n=b.rect().addClass("highcharts-plot-border").attr({zIndex:1}).add());n.attr({stroke:a.plotBorderColor,"stroke-width":a.plotBorderWidth||
	0,fill:"none"});n[L](n.crisp({x:v,y:q,width:I,height:u},-n.strokeWidth()));this.isDirtyBox=!1},propFromSeries:function(){var a=this,b=a.options.chart,g,c=a.options.series,f,d;l(["inverted","angular","polar"],function(n){g=I[b.type||b.defaultSeriesType];d=b[n]||g&&g.prototype[n];for(f=c&&c.length;!d&&f--;)(g=I[c[f].type])&&g.prototype[n]&&(d=!0);a[n]=d})},linkSeries:function(){var a=this,b=a.series;l(b,function(a){a.linkedSeries.length=0});l(b,function(b){var g=b.options.linkedTo;h(g)&&(g=":previous"===
	g?a.series[b.index-1]:a.get(g))&&g.linkedParent!==b&&(g.linkedSeries.push(b),b.linkedParent=g,b.visible=y(b.options.visible,g.options.visible,b.visible))})},renderSeries:function(){l(this.series,function(a){a.translate();a.render()})},renderLabels:function(){var a=this,b=a.options.labels;b.items&&l(b.items,function(g){var c=z(b.style,g.style),f=L(c.left)+a.plotLeft,d=L(c.top)+a.plotTop+12;delete c.left;delete c.top;a.renderer.text(g.html,f,d).attr({zIndex:2}).css(c).add()})},render:function(){var a=
	this.axes,b=this.renderer,g=this.options,c,f,d;this.setTitle();this.legend=new E(this,g.legend);this.getStacks&&this.getStacks();this.getMargins(!0);this.setChartSize();g=this.plotWidth;c=this.plotHeight-=21;l(a,function(a){a.setScale()});this.getAxisMargins();f=1.1<g/this.plotWidth;d=1.05<c/this.plotHeight;if(f||d)l(a,function(a){(a.horiz&&f||!a.horiz&&d)&&a.setTickInterval(!0)}),this.getMargins();this.drawChartBox();this.hasCartesianSeries&&l(a,function(a){a.visible&&a.render()});this.seriesGroup||
	(this.seriesGroup=b.g("series-group").attr({zIndex:3}).add());this.renderSeries();this.renderLabels();this.addCredits();this.setResponsive&&this.setResponsive();this.hasRendered=!0},addCredits:function(a){var b=this;a=v(!0,this.options.credits,a);a.enabled&&!this.credits&&(this.credits=this.renderer.text(a.text+(this.mapCredits||""),0,0).addClass("highcharts-credits").on("click",function(){a.href&&(P.location.href=a.href)}).attr({align:a.position.align,zIndex:8}).css(a.style).add().align(a.position),
	this.credits.update=function(a){b.credits=b.credits.destroy();b.addCredits(a)})},destroy:function(){var b=this,g=b.axes,c=b.series,f=b.container,d,n=f&&f.parentNode;u(b,"destroy");m[b.index]=void 0;a.chartCount--;b.renderTo.removeAttribute("data-highcharts-chart");F(b);for(d=g.length;d--;)g[d]=g[d].destroy();this.scroller&&this.scroller.destroy&&this.scroller.destroy();for(d=c.length;d--;)c[d]=c[d].destroy();l("title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" "),
	function(a){var g=b[a];g&&g.destroy&&(b[a]=g.destroy())});f&&(f.innerHTML="",F(f),n&&p(f));for(d in b)delete b[d]},isReadyToRender:function(){var a=this;return J||P!=P.top||"complete"===w.readyState?!0:(w.attachEvent("onreadystatechange",function(){w.detachEvent("onreadystatechange",a.firstRender);"complete"===w.readyState&&a.firstRender()}),!1)},firstRender:function(){var a=this,b=a.options;if(a.isReadyToRender()){a.getContainer();u(a,"init");a.resetMargins();a.setChartSize();a.propFromSeries();
	a.getAxes();l(b.series||[],function(b){a.initSeries(b)});a.linkSeries();u(a,"beforeRender");n&&(a.pointer=new n(a,b));a.render();if(!a.renderer.imgCount&&a.onload)a.onload();a.cloneRenderTo(!0)}},onload:function(){l([this.callback].concat(this.callbacks),function(a){a&&void 0!==this.index&&a.apply(this,[this])},this);u(this,"load");u(this,"render");d(this.index)&&!1!==this.options.chart.reflow&&this.initReflow();this.onload=null}}})(K);(function(a){var D,A=a.each,G=a.extend,H=a.erase,w=a.fireEvent,
	k=a.format,t=a.isArray,x=a.isNumber,p=a.pick,m=a.removeEvent;D=a.Point=function(){};D.prototype={init:function(a,d,l){this.series=a;this.color=a.color;this.applyOptions(d,l);a.options.colorByPoint?(d=a.options.colors||a.chart.options.colors,this.color=this.color||d[a.colorCounter],d=d.length,l=a.colorCounter,a.colorCounter++,a.colorCounter===d&&(a.colorCounter=0)):l=a.colorIndex;this.colorIndex=p(this.colorIndex,l);a.chart.pointCount++;return this},applyOptions:function(a,d){var e=this.series,m=e.options.pointValKey||
	e.pointValKey;a=D.prototype.optionsToObject.call(this,a);G(this,a);this.options=this.options?G(this.options,a):a;a.group&&delete this.group;m&&(this.y=this[m]);this.isNull=p(this.isValid&&!this.isValid(),null===this.x||!x(this.y,!0));this.selected&&(this.state="select");"name"in this&&void 0===d&&e.xAxis&&e.xAxis.hasNames&&(this.x=e.xAxis.nameToX(this));void 0===this.x&&e&&(this.x=void 0===d?e.autoIncrement(this):d);return this},optionsToObject:function(a){var d={},e=this.series,m=e.options.keys,
	b=m||e.pointArrayMap||["y"],u=b.length,c=0,k=0;if(x(a)||null===a)d[b[0]]=a;else if(t(a))for(!m&&a.length>u&&(e=typeof a[0],"string"===e?d.name=a[0]:"number"===e&&(d.x=a[0]),c++);k<u;)m&&void 0===a[c]||(d[b[k]]=a[c]),c++,k++;else"object"===typeof a&&(d=a,a.dataLabels&&(e._hasPointLabels=!0),a.marker&&(e._hasPointMarkers=!0));return d},getClassName:function(){return"highcharts-point"+(this.selected?" highcharts-point-select":"")+(this.negative?" highcharts-negative":"")+(this.isNull?" highcharts-null-point":
	"")+(void 0!==this.colorIndex?" highcharts-color-"+this.colorIndex:"")+(this.options.className?" "+this.options.className:"")+(this.zone&&this.zone.className?" "+this.zone.className.replace("highcharts-negative",""):"")},getZone:function(){var a=this.series,d=a.zones,a=a.zoneAxis||"y",l=0,m;for(m=d[l];this[a]>=m.value;)m=d[++l];m&&m.color&&!this.options.color&&(this.color=m.color);return m},destroy:function(){var a=this.series.chart,d=a.hoverPoints,l;a.pointCount--;d&&(this.setState(),H(d,this),d.length||
	(a.hoverPoints=null));if(this===a.hoverPoint)this.onMouseOut();if(this.graphic||this.dataLabel)m(this),this.destroyElements();this.legendItem&&a.legend.destroyItem(this);for(l in this)this[l]=null},destroyElements:function(){for(var a=["graphic","dataLabel","dataLabelUpper","connector","shadowGroup"],d,l=6;l--;)d=a[l],this[d]&&(this[d]=this[d].destroy())},getLabelConfig:function(){return{x:this.category,y:this.y,color:this.color,colorIndex:this.colorIndex,key:this.name||this.category,series:this.series,
	point:this,percentage:this.percentage,total:this.total||this.stackTotal}},tooltipFormatter:function(a){var d=this.series,e=d.tooltipOptions,m=p(e.valueDecimals,""),b=e.valuePrefix||"",u=e.valueSuffix||"";A(d.pointArrayMap||["y"],function(c){c="{point."+c;if(b||u)a=a.replace(c+"}",b+c+"}"+u);a=a.replace(c+"}",c+":,."+m+"f}")});return k(a,{point:this,series:this.series})},firePointEvent:function(a,d,l){var e=this,b=this.series.options;(b.point.events[a]||e.options&&e.options.events&&e.options.events[a])&&
	this.importEvents();"click"===a&&b.allowPointSelect&&(l=function(a){e.select&&e.select(null,a.ctrlKey||a.metaKey||a.shiftKey)});w(this,a,d,l)},visible:!0}})(K);(function(a){var D=a.addEvent,A=a.animObject,G=a.arrayMax,H=a.arrayMin,w=a.correctFloat,k=a.Date,t=a.defaultOptions,x=a.defaultPlotOptions,p=a.defined,m=a.each,e=a.erase,d=a.extend,l=a.fireEvent,z=a.grep,b=a.isArray,u=a.isNumber,c=a.isString,C=a.merge,q=a.pick,r=a.removeEvent,h=a.splat,E=a.SVGElement,f=a.syncTimeout,v=a.win;a.Series=a.seriesType("line",
	null,{lineWidth:2,allowPointSelect:!1,showCheckbox:!1,animation:{duration:1E3},events:{},marker:{lineWidth:0,lineColor:"#ffffff",radius:4,states:{hover:{animation:{duration:50},enabled:!0,radiusPlus:2,lineWidthPlus:1},select:{fillColor:"#cccccc",lineColor:"#000000",lineWidth:2}}},point:{events:{}},dataLabels:{align:"center",formatter:function(){return null===this.y?"":a.numberFormat(this.y,-1)},style:{fontSize:"11px",fontWeight:"bold",color:"contrast",textOutline:"1px contrast"},verticalAlign:"bottom",
	x:0,y:0,padding:5},cropThreshold:300,pointRange:0,softThreshold:!0,states:{hover:{animation:{duration:50},lineWidthPlus:1,marker:{},halo:{size:10,opacity:.25}},select:{marker:{}}},stickyTracking:!0,turboThreshold:1E3},{isCartesian:!0,pointClass:a.Point,sorted:!0,requireSorting:!0,directTouch:!1,axisTypes:["xAxis","yAxis"],colorCounter:0,parallelArrays:["x","y"],coll:"series",init:function(a,b){var c=this,f,n,g=a.series,h;c.chart=a;c.options=b=c.setOptions(b);c.linkedSeries=[];c.bindAxes();d(c,{name:b.name,
	state:"",visible:!1!==b.visible,selected:!0===b.selected});n=b.events;for(f in n)D(c,f,n[f]);if(n&&n.click||b.point&&b.point.events&&b.point.events.click||b.allowPointSelect)a.runTrackerClick=!0;c.getColor();c.getSymbol();m(c.parallelArrays,function(a){c[a+"Data"]=[]});c.setData(b.data,!1);c.isCartesian&&(a.hasCartesianSeries=!0);g.length&&(h=g[g.length-1]);c._i=q(h&&h._i,-1)+1;a.orderSeries(this.insert(g))},insert:function(a){var b=this.options.index,c;if(u(b)){for(c=a.length;c--;)if(b>=q(a[c].options.index,
	a[c]._i)){a.splice(c+1,0,this);break}-1===c&&a.unshift(this);c+=1}else a.push(this);return q(c,a.length-1)},bindAxes:function(){var b=this,c=b.options,f=b.chart,d;m(b.axisTypes||[],function(n){m(f[n],function(a){d=a.options;if(c[n]===d.index||void 0!==c[n]&&c[n]===d.id||void 0===c[n]&&0===d.index)b.insert(a.series),b[n]=a,a.isDirty=!0});b[n]||b.optionalAxis===n||a.error(18,!0)})},updateParallelArrays:function(a,b){var c=a.series,f=arguments,d=u(b)?function(g){var f="y"===g&&c.toYData?c.toYData(a):
	a[g];c[g+"Data"][b]=f}:function(a){Array.prototype[b].apply(c[a+"Data"],Array.prototype.slice.call(f,2))};m(c.parallelArrays,d)},autoIncrement:function(){var a=this.options,b=this.xIncrement,c,f=a.pointIntervalUnit,b=q(b,a.pointStart,0);this.pointInterval=c=q(this.pointInterval,a.pointInterval,1);f&&(a=new k(b),"day"===f?a=+a[k.hcSetDate](a[k.hcGetDate]()+c):"month"===f?a=+a[k.hcSetMonth](a[k.hcGetMonth]()+c):"year"===f&&(a=+a[k.hcSetFullYear](a[k.hcGetFullYear]()+c)),c=a-b);this.xIncrement=b+c;return b},
	setOptions:function(a){var b=this.chart,c=b.options.plotOptions,b=b.userOptions||{},f=b.plotOptions||{},d=c[this.type];this.userOptions=a;c=C(d,c.series,a);this.tooltipOptions=C(t.tooltip,t.plotOptions[this.type].tooltip,b.tooltip,f.series&&f.series.tooltip,f[this.type]&&f[this.type].tooltip,a.tooltip);null===d.marker&&delete c.marker;this.zoneAxis=c.zoneAxis;a=this.zones=(c.zones||[]).slice();!c.negativeColor&&!c.negativeFillColor||c.zones||a.push({value:c[this.zoneAxis+"Threshold"]||c.threshold||
	0,className:"highcharts-negative",color:c.negativeColor,fillColor:c.negativeFillColor});a.length&&p(a[a.length-1].value)&&a.push({color:this.color,fillColor:this.fillColor});return c},getCyclic:function(a,b,c){var f,d=this.chart,g=this.userOptions,n=a+"Index",h=a+"Counter",e=c?c.length:q(d.options.chart[a+"Count"],d[a+"Count"]);b||(f=q(g[n],g["_"+n]),p(f)||(d.series.length||(d[h]=0),g["_"+n]=f=d[h]%e,d[h]+=1),c&&(b=c[f]));void 0!==f&&(this[n]=f);this[a]=b},getColor:function(){this.options.colorByPoint?
	this.options.color=null:this.getCyclic("color",this.options.color||x[this.type].color,this.chart.options.colors)},getSymbol:function(){this.getCyclic("symbol",this.options.marker.symbol,this.chart.options.symbols)},drawLegendSymbol:a.LegendSymbolMixin.drawLineMarker,setData:function(f,d,h,e){var n=this,g=n.points,r=g&&g.length||0,y,l=n.options,F=n.chart,v=null,k=n.xAxis,z=l.turboThreshold,p=this.xData,E=this.yData,t=(y=n.pointArrayMap)&&y.length;f=f||[];y=f.length;d=q(d,!0);if(!1!==e&&y&&r===y&&!n.cropped&&
	!n.hasGroupedData&&n.visible)m(f,function(a,b){g[b].update&&a!==l.data[b]&&g[b].update(a,!1,null,!1)});else{n.xIncrement=null;n.colorCounter=0;m(this.parallelArrays,function(a){n[a+"Data"].length=0});if(z&&y>z){for(h=0;null===v&&h<y;)v=f[h],h++;if(u(v))for(h=0;h<y;h++)p[h]=this.autoIncrement(),E[h]=f[h];else if(b(v))if(t)for(h=0;h<y;h++)v=f[h],p[h]=v[0],E[h]=v.slice(1,t+1);else for(h=0;h<y;h++)v=f[h],p[h]=v[0],E[h]=v[1];else a.error(12)}else for(h=0;h<y;h++)void 0!==f[h]&&(v={series:n},n.pointClass.prototype.applyOptions.apply(v,
	[f[h]]),n.updateParallelArrays(v,h));c(E[0])&&a.error(14,!0);n.data=[];n.options.data=n.userOptions.data=f;for(h=r;h--;)g[h]&&g[h].destroy&&g[h].destroy();k&&(k.minRange=k.userMinRange);n.isDirty=F.isDirtyBox=!0;n.isDirtyData=!!g;h=!1}"point"===l.legendType&&(this.processData(),this.generatePoints());d&&F.redraw(h)},processData:function(b){var c=this.xData,f=this.yData,d=c.length,n;n=0;var g,h,e=this.xAxis,r,l=this.options;r=l.cropThreshold;var v=this.getExtremesFromAll||l.getExtremesFromAll,q=this.isCartesian,
	l=e&&e.val2lin,u=e&&e.isLog,m,k;if(q&&!this.isDirty&&!e.isDirty&&!this.yAxis.isDirty&&!b)return!1;e&&(b=e.getExtremes(),m=b.min,k=b.max);if(q&&this.sorted&&!v&&(!r||d>r||this.forceCrop))if(c[d-1]<m||c[0]>k)c=[],f=[];else if(c[0]<m||c[d-1]>k)n=this.cropData(this.xData,this.yData,m,k),c=n.xData,f=n.yData,n=n.start,g=!0;for(r=c.length||1;--r;)d=u?l(c[r])-l(c[r-1]):c[r]-c[r-1],0<d&&(void 0===h||d<h)?h=d:0>d&&this.requireSorting&&a.error(15);this.cropped=g;this.cropStart=n;this.processedXData=c;this.processedYData=
	f;this.closestPointRange=h},cropData:function(a,b,c,f){var d=a.length,g=0,n=d,h=q(this.cropShoulder,1),e;for(e=0;e<d;e++)if(a[e]>=c){g=Math.max(0,e-h);break}for(c=e;c<d;c++)if(a[c]>f){n=c+h;break}return{xData:a.slice(g,n),yData:b.slice(g,n),start:g,end:n}},generatePoints:function(){var a=this.options.data,b=this.data,c,f=this.processedXData,d=this.processedYData,g=this.pointClass,e=f.length,r=this.cropStart||0,l,v=this.hasGroupedData,q,u=[],m;b||v||(b=[],b.length=a.length,b=this.data=b);for(m=0;m<
	e;m++)l=r+m,v?(q=(new g).init(this,[f[m]].concat(h(d[m]))),q.dataGroup=this.groupMap[m]):(q=b[l])||void 0===a[l]||(b[l]=q=(new g).init(this,a[l],f[m])),q.index=l,u[m]=q;if(b&&(e!==(c=b.length)||v))for(m=0;m<c;m++)m!==r||v||(m+=e),b[m]&&(b[m].destroyElements(),b[m].plotX=void 0);this.data=b;this.points=u},getExtremes:function(a){var c=this.yAxis,f=this.processedXData,d,h=[],g=0;d=this.xAxis.getExtremes();var n=d.min,e=d.max,r,l,v,q;a=a||this.stackedYData||this.processedYData||[];d=a.length;for(q=0;q<
	d;q++)if(l=f[q],v=a[q],r=(u(v,!0)||b(v))&&(!c.positiveValuesOnly||v.length||0<v),l=this.getExtremesFromAll||this.options.getExtremesFromAll||this.cropped||(f[q+1]||l)>=n&&(f[q-1]||l)<=e,r&&l)if(r=v.length)for(;r--;)null!==v[r]&&(h[g++]=v[r]);else h[g++]=v;this.dataMin=H(h);this.dataMax=G(h)},translate:function(){this.processedXData||this.processData();this.generatePoints();var a=this.options,b=a.stacking,c=this.xAxis,f=c.categories,d=this.yAxis,g=this.points,h=g.length,e=!!this.modifyValue,r=a.pointPlacement,
	l="between"===r||u(r),v=a.threshold,m=a.startFromThreshold?v:0,k,z,E,t,C=Number.MAX_VALUE;"between"===r&&(r=.5);u(r)&&(r*=q(a.pointRange||c.pointRange));for(a=0;a<h;a++){var x=g[a],A=x.x,D=x.y;z=x.low;var G=b&&d.stacks[(this.negStacks&&D<(m?0:v)?"-":"")+this.stackKey],H;d.positiveValuesOnly&&null!==D&&0>=D&&(x.isNull=!0);x.plotX=k=w(Math.min(Math.max(-1E5,c.translate(A,0,0,0,1,r,"flags"===this.type)),1E5));b&&this.visible&&!x.isNull&&G&&G[A]&&(t=this.getStackIndicator(t,A,this.index),H=G[A],D=H.points[t.key],
	z=D[0],D=D[1],z===m&&t.key===G[A].base&&(z=q(v,d.min)),d.positiveValuesOnly&&0>=z&&(z=null),x.total=x.stackTotal=H.total,x.percentage=H.total&&x.y/H.total*100,x.stackY=D,H.setOffset(this.pointXOffset||0,this.barW||0));x.yBottom=p(z)?d.translate(z,0,1,0,1):null;e&&(D=this.modifyValue(D,x));x.plotY=z="number"===typeof D&&Infinity!==D?Math.min(Math.max(-1E5,d.translate(D,0,1,0,1)),1E5):void 0;x.isInside=void 0!==z&&0<=z&&z<=d.len&&0<=k&&k<=c.len;x.clientX=l?w(c.translate(A,0,0,0,1,r)):k;x.negative=x.y<
	(v||0);x.category=f&&void 0!==f[x.x]?f[x.x]:x.x;x.isNull||(void 0!==E&&(C=Math.min(C,Math.abs(k-E))),E=k);x.zone=this.zones.length&&x.getZone()}this.closestPointRangePx=C},getValidPoints:function(a,b){var c=this.chart;return z(a||this.points||[],function(a){return b&&!c.isInsidePlot(a.plotX,a.plotY,c.inverted)?!1:!a.isNull})},setClip:function(a){var b=this.chart,c=this.options,f=b.renderer,d=b.inverted,g=this.clipBox,h=g||b.clipBox,n=this.sharedClipKey||["_sharedClip",a&&a.duration,a&&a.easing,h.height,
	c.xAxis,c.yAxis].join(),e=b[n],r=b[n+"m"];e||(a&&(h.width=0,b[n+"m"]=r=f.clipRect(-99,d?-b.plotLeft:-b.plotTop,99,d?b.chartWidth:b.chartHeight)),b[n]=e=f.clipRect(h),e.count={length:0});a&&!e.count[this.index]&&(e.count[this.index]=!0,e.count.length+=1);!1!==c.clip&&(this.group.clip(a||g?e:b.clipRect),this.markerGroup.clip(r),this.sharedClipKey=n);a||(e.count[this.index]&&(delete e.count[this.index],--e.count.length),0===e.count.length&&n&&b[n]&&(g||(b[n]=b[n].destroy()),b[n+"m"]&&(this.markerGroup.clip(),
	b[n+"m"]=b[n+"m"].destroy())))},animate:function(a){var b=this.chart,c=A(this.options.animation),f;a?this.setClip(c):(f=this.sharedClipKey,(a=b[f])&&a.animate({width:b.plotSizeX},c),b[f+"m"]&&b[f+"m"].animate({width:b.plotSizeX+99},c),this.animate=null)},afterAnimate:function(){this.setClip();l(this,"afterAnimate")},drawPoints:function(){var a=this.points,b=this.chart,c,f,d,g,h=this.options.marker,e,r,l,v,m=this.markerGroup,k=q(h.enabled,this.xAxis.isRadial?!0:null,this.closestPointRangePx>=2*h.radius);
	if(!1!==h.enabled||this._hasPointMarkers)for(f=0;f<a.length;f++)d=a[f],c=d.plotY,g=d.graphic,e=d.marker||{},r=!!d.marker,l=k&&void 0===e.enabled||e.enabled,v=d.isInside,l&&u(c)&&null!==d.y?(c=q(e.symbol,this.symbol),d.hasImage=0===c.indexOf("url"),l=this.markerAttribs(d,d.selected&&"select"),g?g[v?"show":"hide"](!0).animate(l):v&&(0<l.width||d.hasImage)&&(d.graphic=g=b.renderer.symbol(c,l.x,l.y,l.width,l.height,r?e:h).add(m)),g&&g.attr(this.pointAttribs(d,d.selected&&"select")),g&&g.addClass(d.getClassName(),
	!0)):g&&(d.graphic=g.destroy())},markerAttribs:function(a,b){var c=this.options.marker,f=a.marker||{},d=q(f.radius,c.radius);b&&(c=c.states[b],b=f.states&&f.states[b],d=q(b&&b.radius,c&&c.radius,d+(c&&c.radiusPlus||0)));a.hasImage&&(d=0);a={x:Math.floor(a.plotX)-d,y:a.plotY-d};d&&(a.width=a.height=2*d);return a},pointAttribs:function(a,b){var c=this.options.marker,f=a&&a.options,d=f&&f.marker||{},g=this.color,h=f&&f.color,n=a&&a.color,f=q(d.lineWidth,c.lineWidth);a=a&&a.zone&&a.zone.color;g=h||a||
	n||g;a=d.fillColor||c.fillColor||g;g=d.lineColor||c.lineColor||g;b&&(c=c.states[b],b=d.states&&d.states[b]||{},f=q(b.lineWidth,c.lineWidth,f+q(b.lineWidthPlus,c.lineWidthPlus,0)),a=b.fillColor||c.fillColor||a,g=b.lineColor||c.lineColor||g);return{stroke:g,"stroke-width":f,fill:a}},destroy:function(){var a=this,b=a.chart,c=/AppleWebKit\/533/.test(v.navigator.userAgent),f,d=a.data||[],g,h,q;l(a,"destroy");r(a);m(a.axisTypes||[],function(b){(q=a[b])&&q.series&&(e(q.series,a),q.isDirty=q.forceRedraw=
	!0)});a.legendItem&&a.chart.legend.destroyItem(a);for(f=d.length;f--;)(g=d[f])&&g.destroy&&g.destroy();a.points=null;clearTimeout(a.animationTimeout);for(h in a)a[h]instanceof E&&!a[h].survive&&(f=c&&"group"===h?"hide":"destroy",a[h][f]());b.hoverSeries===a&&(b.hoverSeries=null);e(b.series,a);b.orderSeries();for(h in a)delete a[h]},getGraphPath:function(a,b,c){var f=this,d=f.options,g=d.step,h,n=[],e=[],r;a=a||f.points;(h=a.reversed)&&a.reverse();(g={right:1,center:2}[g]||g&&3)&&h&&(g=4-g);!d.connectNulls||
	b||c||(a=this.getValidPoints(a));m(a,function(h,l){var v=h.plotX,y=h.plotY,q=a[l-1];(h.leftCliff||q&&q.rightCliff)&&!c&&(r=!0);h.isNull&&!p(b)&&0<l?r=!d.connectNulls:h.isNull&&!b?r=!0:(0===l||r?l=["M",h.plotX,h.plotY]:f.getPointSpline?l=f.getPointSpline(a,h,l):g?(l=1===g?["L",q.plotX,y]:2===g?["L",(q.plotX+v)/2,q.plotY,"L",(q.plotX+v)/2,y]:["L",v,q.plotY],l.push("L",v,y)):l=["L",v,y],e.push(h.x),g&&e.push(h.x),n.push.apply(n,l),r=!1)});n.xMap=e;return f.graphPath=n},drawGraph:function(){var a=this,
	b=this.options,c=(this.gappedPath||this.getGraphPath).call(this),f=[["graph","highcharts-graph",b.lineColor||this.color,b.dashStyle]];m(this.zones,function(c,g){f.push(["zone-graph-"+g,"highcharts-graph highcharts-zone-graph-"+g+" "+(c.className||""),c.color||a.color,c.dashStyle||b.dashStyle])});m(f,function(f,g){var d=f[0],h=a[d];h?(h.endX=c.xMap,h.animate({d:c})):c.length&&(a[d]=a.chart.renderer.path(c).addClass(f[1]).attr({zIndex:1}).add(a.group),h={stroke:f[2],"stroke-width":b.lineWidth,fill:a.fillGraph&&
	a.color||"none"},f[3]?h.dashstyle=f[3]:"square"!==b.linecap&&(h["stroke-linecap"]=h["stroke-linejoin"]="round"),h=a[d].attr(h).shadow(2>g&&b.shadow));h&&(h.startX=c.xMap,h.isArea=c.isArea)})},applyZones:function(){var a=this,b=this.chart,c=b.renderer,f=this.zones,d,g,h=this.clips||[],e,r=this.graph,l=this.area,v=Math.max(b.chartWidth,b.chartHeight),u=this[(this.zoneAxis||"y")+"Axis"],k,z,E=b.inverted,p,t,C,x,w=!1;f.length&&(r||l)&&u&&void 0!==u.min&&(z=u.reversed,p=u.horiz,r&&r.hide(),l&&l.hide(),
	k=u.getExtremes(),m(f,function(f,n){d=z?p?b.plotWidth:0:p?0:u.toPixels(k.min);d=Math.min(Math.max(q(g,d),0),v);g=Math.min(Math.max(Math.round(u.toPixels(q(f.value,k.max),!0)),0),v);w&&(d=g=u.toPixels(k.max));t=Math.abs(d-g);C=Math.min(d,g);x=Math.max(d,g);u.isXAxis?(e={x:E?x:C,y:0,width:t,height:v},p||(e.x=b.plotHeight-e.x)):(e={x:0,y:E?x:C,width:v,height:t},p&&(e.y=b.plotWidth-e.y));E&&c.isVML&&(e=u.isXAxis?{x:0,y:z?C:x,height:e.width,width:b.chartWidth}:{x:e.y-b.plotLeft-b.spacingBox.x,y:0,width:e.height,
	height:b.chartHeight});h[n]?h[n].animate(e):(h[n]=c.clipRect(e),r&&a["zone-graph-"+n].clip(h[n]),l&&a["zone-area-"+n].clip(h[n]));w=f.value>k.max}),this.clips=h)},invertGroups:function(a){function b(){m(["group","markerGroup"],function(b){c[b]&&(f.renderer.isVML&&c[b].attr({width:c.yAxis.len,height:c.xAxis.len}),c[b].width=c.yAxis.len,c[b].height=c.xAxis.len,c[b].invert(a))})}var c=this,f=c.chart,d;c.xAxis&&(d=D(f,"resize",b),D(c,"destroy",d),b(a),c.invertGroups=b)},plotGroup:function(a,b,c,f,d){var g=
	this[a],h=!g;h&&(this[a]=g=this.chart.renderer.g(b).attr({zIndex:f||.1}).add(d),g.addClass("highcharts-series-"+this.index+" highcharts-"+this.type+"-series highcharts-color-"+this.colorIndex+" "+(this.options.className||"")));g.attr({visibility:c})[h?"attr":"animate"](this.getPlotBox());return g},getPlotBox:function(){var a=this.chart,b=this.xAxis,c=this.yAxis;a.inverted&&(b=c,c=this.xAxis);return{translateX:b?b.left:a.plotLeft,translateY:c?c.top:a.plotTop,scaleX:1,scaleY:1}},render:function(){var a=
	this,b=a.chart,c,d=a.options,h=!!a.animate&&b.renderer.isSVG&&A(d.animation).duration,g=a.visible?"inherit":"hidden",e=d.zIndex,r=a.hasRendered,l=b.seriesGroup,v=b.inverted;c=a.plotGroup("group","series",g,e,l);a.markerGroup=a.plotGroup("markerGroup","markers",g,e,l);h&&a.animate(!0);c.inverted=a.isCartesian?v:!1;a.drawGraph&&(a.drawGraph(),a.applyZones());a.drawDataLabels&&a.drawDataLabels();a.visible&&a.drawPoints();a.drawTracker&&!1!==a.options.enableMouseTracking&&a.drawTracker();a.invertGroups(v);
	!1===d.clip||a.sharedClipKey||r||c.clip(b.clipRect);h&&a.animate();r||(a.animationTimeout=f(function(){a.afterAnimate()},h));a.isDirty=!1;a.hasRendered=!0},redraw:function(){var a=this.chart,b=this.isDirty||this.isDirtyData,c=this.group,f=this.xAxis,d=this.yAxis;c&&(a.inverted&&c.attr({width:a.plotWidth,height:a.plotHeight}),c.animate({translateX:q(f&&f.left,a.plotLeft),translateY:q(d&&d.top,a.plotTop)}));this.translate();this.render();b&&delete this.kdTree},kdDimensions:1,kdAxisArray:["clientX",
	"plotY"],searchPoint:function(a,b){var c=this.xAxis,f=this.yAxis,d=this.chart.inverted;return this.searchKDTree({clientX:d?c.len-a.chartY+c.pos:a.chartX-c.pos,plotY:d?f.len-a.chartX+f.pos:a.chartY-f.pos},b)},buildKDTree:function(){function a(c,f,g){var d,h;if(h=c&&c.length)return d=b.kdAxisArray[f%g],c.sort(function(a,b){return a[d]-b[d]}),h=Math.floor(h/2),{point:c[h],left:a(c.slice(0,h),f+1,g),right:a(c.slice(h+1),f+1,g)}}this.buildingKdTree=!0;var b=this,c=b.kdDimensions;delete b.kdTree;f(function(){b.kdTree=
	a(b.getValidPoints(null,!b.directTouch),c,c);b.buildingKdTree=!1},b.options.kdNow?0:1)},searchKDTree:function(a,b){function c(a,b,e,n){var r=b.point,l=f.kdAxisArray[e%n],v,q,y=r;q=p(a[d])&&p(r[d])?Math.pow(a[d]-r[d],2):null;v=p(a[g])&&p(r[g])?Math.pow(a[g]-r[g],2):null;v=(q||0)+(v||0);r.dist=p(v)?Math.sqrt(v):Number.MAX_VALUE;r.distX=p(q)?Math.sqrt(q):Number.MAX_VALUE;l=a[l]-r[l];v=0>l?"left":"right";q=0>l?"right":"left";b[v]&&(v=c(a,b[v],e+1,n),y=v[h]<y[h]?v:r);b[q]&&Math.sqrt(l*l)<y[h]&&(a=c(a,
	b[q],e+1,n),y=a[h]<y[h]?a:y);return y}var f=this,d=this.kdAxisArray[0],g=this.kdAxisArray[1],h=b?"distX":"dist";this.kdTree||this.buildingKdTree||this.buildKDTree();if(this.kdTree)return c(a,this.kdTree,this.kdDimensions,this.kdDimensions)}})})(K);(function(a){function D(a,e,d,l,k){var b=a.chart.inverted;this.axis=a;this.isNegative=d;this.options=e;this.x=l;this.total=null;this.points={};this.stack=k;this.rightCliff=this.leftCliff=0;this.alignOptions={align:e.align||(b?d?"left":"right":"center"),
	verticalAlign:e.verticalAlign||(b?"middle":d?"bottom":"top"),y:p(e.y,b?4:d?14:-6),x:p(e.x,b?d?-6:6:0)};this.textAlign=e.textAlign||(b?d?"right":"left":"center")}var A=a.Axis,G=a.Chart,H=a.correctFloat,w=a.defined,k=a.destroyObjectProperties,t=a.each,x=a.format,p=a.pick;a=a.Series;D.prototype={destroy:function(){k(this,this.axis)},render:function(a){var e=this.options,d=e.format,d=d?x(d,this):e.formatter.call(this);this.label?this.label.attr({text:d,visibility:"hidden"}):this.label=this.axis.chart.renderer.text(d,
	null,null,e.useHTML).css(e.style).attr({align:this.textAlign,rotation:e.rotation,visibility:"hidden"}).add(a)},setOffset:function(a,e){var d=this.axis,l=d.chart,m=l.inverted,b=d.reversed,b=this.isNegative&&!b||!this.isNegative&&b,u=d.translate(d.usePercentage?100:this.total,0,0,0,1),d=d.translate(0),d=Math.abs(u-d);a=l.xAxis[0].translate(this.x)+a;var c=l.plotHeight,m={x:m?b?u:u-d:a,y:m?c-a-e:b?c-u-d:c-u,width:m?d:e,height:m?e:d};if(e=this.label)e.align(this.alignOptions,null,m),m=e.alignAttr,e[!1===
	this.options.crop||l.isInsidePlot(m.x,m.y)?"show":"hide"](!0)}};G.prototype.getStacks=function(){var a=this;t(a.yAxis,function(a){a.stacks&&a.hasVisibleSeries&&(a.oldStacks=a.stacks)});t(a.series,function(e){!e.options.stacking||!0!==e.visible&&!1!==a.options.chart.ignoreHiddenSeries||(e.stackKey=e.type+p(e.options.stack,""))})};A.prototype.buildStacks=function(){var a=this.series,e,d=p(this.options.reversedStacks,!0),l=a.length,k;if(!this.isXAxis){this.usePercentage=!1;for(k=l;k--;)a[d?k:l-k-1].setStackedPoints();
	for(k=l;k--;)e=a[d?k:l-k-1],e.setStackCliffs&&e.setStackCliffs();if(this.usePercentage)for(k=0;k<l;k++)a[k].setPercentStacks()}};A.prototype.renderStackTotals=function(){var a=this.chart,e=a.renderer,d=this.stacks,l,k,b=this.stackTotalGroup;b||(this.stackTotalGroup=b=e.g("stack-labels").attr({visibility:"visible",zIndex:6}).add());b.translate(a.plotLeft,a.plotTop);for(l in d)for(k in a=d[l],a)a[k].render(b)};A.prototype.resetStacks=function(){var a=this.stacks,e,d;if(!this.isXAxis)for(e in a)for(d in a[e])a[e][d].touched<
	this.stacksTouched?(a[e][d].destroy(),delete a[e][d]):(a[e][d].total=null,a[e][d].cum=null)};A.prototype.cleanStacks=function(){var a,e,d;if(!this.isXAxis)for(e in this.oldStacks&&(a=this.stacks=this.oldStacks),a)for(d in a[e])a[e][d].cum=a[e][d].total};a.prototype.setStackedPoints=function(){if(this.options.stacking&&(!0===this.visible||!1===this.chart.options.chart.ignoreHiddenSeries)){var a=this.processedXData,e=this.processedYData,d=[],l=e.length,k=this.options,b=k.threshold,u=k.startFromThreshold?
	b:0,c=k.stack,k=k.stacking,t=this.stackKey,q="-"+t,r=this.negStacks,h=this.yAxis,E=h.stacks,f=h.oldStacks,v,n,y,x,F,I,g;h.stacksTouched+=1;for(F=0;F<l;F++)I=a[F],g=e[F],v=this.getStackIndicator(v,I,this.index),x=v.key,y=(n=r&&g<(u?0:b))?q:t,E[y]||(E[y]={}),E[y][I]||(f[y]&&f[y][I]?(E[y][I]=f[y][I],E[y][I].total=null):E[y][I]=new D(h,h.options.stackLabels,n,I,c)),y=E[y][I],null!==g&&(y.points[x]=y.points[this.index]=[p(y.cum,u)],w(y.cum)||(y.base=x),y.touched=h.stacksTouched,0<v.index&&!1===this.singleStacks&&
	(y.points[x][0]=y.points[this.index+","+I+",0"][0])),"percent"===k?(n=n?t:q,r&&E[n]&&E[n][I]?(n=E[n][I],y.total=n.total=Math.max(n.total,y.total)+Math.abs(g)||0):y.total=H(y.total+(Math.abs(g)||0))):y.total=H(y.total+(g||0)),y.cum=p(y.cum,u)+(g||0),null!==g&&(y.points[x].push(y.cum),d[F]=y.cum);"percent"===k&&(h.usePercentage=!0);this.stackedYData=d;h.oldStacks={}}};a.prototype.setPercentStacks=function(){var a=this,e=a.stackKey,d=a.yAxis.stacks,l=a.processedXData,k;t([e,"-"+e],function(b){for(var e=
	l.length,c,m;e--;)if(c=l[e],k=a.getStackIndicator(k,c,a.index,b),c=(m=d[b]&&d[b][c])&&m.points[k.key])m=m.total?100/m.total:0,c[0]=H(c[0]*m),c[1]=H(c[1]*m),a.stackedYData[e]=c[1]})};a.prototype.getStackIndicator=function(a,e,d,l){!w(a)||a.x!==e||l&&a.key!==l?a={x:e,index:0,key:l}:a.index++;a.key=[d,e,a.index].join();return a}})(K);(function(a){var D=a.addEvent,A=a.animate,G=a.Axis,H=a.createElement,w=a.css,k=a.defined,t=a.each,x=a.erase,p=a.extend,m=a.fireEvent,e=a.inArray,d=a.isNumber,l=a.isObject,
	z=a.merge,b=a.pick,u=a.Point,c=a.Series,C=a.seriesTypes,q=a.setAnimation,r=a.splat;p(a.Chart.prototype,{addSeries:function(a,c,f){var d,h=this;a&&(c=b(c,!0),m(h,"addSeries",{options:a},function(){d=h.initSeries(a);h.isDirtyLegend=!0;h.linkSeries();c&&h.redraw(f)}));return d},addAxis:function(a,c,f,d){var h=c?"xAxis":"yAxis",e=this.options;a=z(a,{index:this[h].length,isX:c});new G(this,a);e[h]=r(e[h]||{});e[h].push(a);b(f,!0)&&this.redraw(d)},showLoading:function(a){var b=this,c=b.options,d=b.loadingDiv,
	h=c.loading,e=function(){d&&w(d,{left:b.plotLeft+"px",top:b.plotTop+"px",width:b.plotWidth+"px",height:b.plotHeight+"px"})};d||(b.loadingDiv=d=H("div",{className:"highcharts-loading highcharts-loading-hidden"},null,b.container),b.loadingSpan=H("span",{className:"highcharts-loading-inner"},null,d),D(b,"redraw",e));d.className="highcharts-loading";b.loadingSpan.innerHTML=a||c.lang.loading;w(d,p(h.style,{zIndex:10}));w(b.loadingSpan,h.labelStyle);b.loadingShown||(w(d,{opacity:0,display:""}),A(d,{opacity:h.style.opacity||
	.5},{duration:h.showDuration||0}));b.loadingShown=!0;e()},hideLoading:function(){var a=this.options,b=this.loadingDiv;b&&(b.className="highcharts-loading highcharts-loading-hidden",A(b,{opacity:0},{duration:a.loading.hideDuration||100,complete:function(){w(b,{display:"none"})}}));this.loadingShown=!1},propsRequireDirtyBox:"backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
	propsRequireUpdateSeries:"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions".split(" "),update:function(a,c){var f,h={credits:"addCredits",title:"setTitle",subtitle:"setSubtitle"},n=a.chart,l,q;if(n){z(!0,this.options.chart,n);"className"in n&&this.setClassName(n.className);if("inverted"in n||"polar"in n)this.propFromSeries(),l=!0;for(f in n)n.hasOwnProperty(f)&&(-1!==e("chart."+f,this.propsRequireUpdateSeries)&&(q=!0),-1!==e(f,this.propsRequireDirtyBox)&&(this.isDirtyBox=
	!0));"style"in n&&this.renderer.setStyle(n.style)}for(f in a){if(this[f]&&"function"===typeof this[f].update)this[f].update(a[f],!1);else if("function"===typeof this[h[f]])this[h[f]](a[f]);"chart"!==f&&-1!==e(f,this.propsRequireUpdateSeries)&&(q=!0)}a.colors&&(this.options.colors=a.colors);a.plotOptions&&z(!0,this.options.plotOptions,a.plotOptions);t(["xAxis","yAxis","series"],function(b){a[b]&&t(r(a[b]),function(a,c){(c=k(a.id)&&this.get(a.id)||this[b][c])&&c.coll===b&&c.update(a,!1)},this)},this);
	l&&t(this.axes,function(a){a.update({},!1)});q&&t(this.series,function(a){a.update({},!1)});a.loading&&z(!0,this.options.loading,a.loading);f=n&&n.width;n=n&&n.height;d(f)&&f!==this.chartWidth||d(n)&&n!==this.chartHeight?this.setSize(f,n):b(c,!0)&&this.redraw()},setSubtitle:function(a){this.setTitle(void 0,a)}});p(u.prototype,{update:function(a,c,f,d){function h(){e.applyOptions(a);null===e.y&&v&&(e.graphic=v.destroy());l(a,!0)&&(v&&v.element&&a&&a.marker&&a.marker.symbol&&(e.graphic=v.destroy()),
	a&&a.dataLabels&&e.dataLabel&&(e.dataLabel=e.dataLabel.destroy()));q=e.index;r.updateParallelArrays(e,q);u.data[q]=l(u.data[q],!0)||l(a,!0)?e.options:a;r.isDirty=r.isDirtyData=!0;!r.fixedBox&&r.hasCartesianSeries&&(g.isDirtyBox=!0);"point"===u.legendType&&(g.isDirtyLegend=!0);c&&g.redraw(f)}var e=this,r=e.series,v=e.graphic,q,g=r.chart,u=r.options;c=b(c,!0);!1===d?h():e.firePointEvent("update",{options:a},h)},remove:function(a,b){this.series.removePoint(e(this,this.series.data),a,b)}});p(c.prototype,
	{addPoint:function(a,c,f,d){var h=this.options,e=this.data,r=this.chart,l=this.xAxis,l=l&&l.hasNames&&l.names,v=h.data,g,q,u=this.xData,k,m;c=b(c,!0);g={series:this};this.pointClass.prototype.applyOptions.apply(g,[a]);m=g.x;k=u.length;if(this.requireSorting&&m<u[k-1])for(q=!0;k&&u[k-1]>m;)k--;this.updateParallelArrays(g,"splice",k,0,0);this.updateParallelArrays(g,k);l&&g.name&&(l[m]=g.name);v.splice(k,0,a);q&&(this.data.splice(k,0,null),this.processData());"point"===h.legendType&&this.generatePoints();
	f&&(e[0]&&e[0].remove?e[0].remove(!1):(e.shift(),this.updateParallelArrays(g,"shift"),v.shift()));this.isDirtyData=this.isDirty=!0;c&&r.redraw(d)},removePoint:function(a,c,f){var d=this,h=d.data,e=h[a],r=d.points,l=d.chart,u=function(){r&&r.length===h.length&&r.splice(a,1);h.splice(a,1);d.options.data.splice(a,1);d.updateParallelArrays(e||{series:d},"splice",a,1);e&&e.destroy();d.isDirty=!0;d.isDirtyData=!0;c&&l.redraw()};q(f,l);c=b(c,!0);e?e.firePointEvent("remove",null,u):u()},remove:function(a,
	c,f){function d(){h.destroy();e.isDirtyLegend=e.isDirtyBox=!0;e.linkSeries();b(a,!0)&&e.redraw(c)}var h=this,e=h.chart;!1!==f?m(h,"remove",null,d):d()},update:function(a,c){var f=this,d=this.chart,h=this.userOptions,e=this.oldType||this.type,r=a.type||h.type||d.options.chart.type,l=C[e].prototype,q=["group","markerGroup","dataLabelsGroup"],g;if(r&&r!==e||void 0!==a.zIndex)q.length=0;t(q,function(a){q[a]=f[a];delete f[a]});a=z(h,{animation:!1,index:this.index,pointStart:this.xData[0]},{data:this.options.data},
	a);this.remove(!1,null,!1);for(g in l)this[g]=void 0;p(this,C[r||e].prototype);t(q,function(a){f[a]=q[a]});this.init(d,a);this.oldType=e;d.linkSeries();b(c,!0)&&d.redraw(!1)}});p(G.prototype,{update:function(a,c){var f=this.chart;a=f.options[this.coll][this.options.index]=z(this.userOptions,a);this.destroy(!0);this.init(f,p(a,{events:void 0}));f.isDirtyBox=!0;b(c,!0)&&f.redraw()},remove:function(a){for(var c=this.chart,f=this.coll,d=this.series,h=d.length;h--;)d[h]&&d[h].remove(!1);x(c.axes,this);
	x(c[f],this);c.options[f].splice(this.options.index,1);t(c[f],function(a,b){a.options.index=b});this.destroy();c.isDirtyBox=!0;b(a,!0)&&c.redraw()},setTitle:function(a,b){this.update({title:a},b)},setCategories:function(a,b){this.update({categories:a},b)}})})(K);(function(a){var D=a.color,A=a.each,G=a.map,H=a.pick,w=a.Series,k=a.seriesType;k("area","line",{softThreshold:!1,threshold:0},{singleStacks:!1,getStackPoints:function(){var a=[],k=[],p=this.xAxis,m=this.yAxis,e=m.stacks[this.stackKey],d={},
	l=this.points,z=this.index,b=m.series,u=b.length,c,C=H(m.options.reversedStacks,!0)?1:-1,q,r;if(this.options.stacking){for(q=0;q<l.length;q++)d[l[q].x]=l[q];for(r in e)null!==e[r].total&&k.push(r);k.sort(function(a,b){return a-b});c=G(b,function(){return this.visible});A(k,function(b,r){var f=0,h,n;if(d[b]&&!d[b].isNull)a.push(d[b]),A([-1,1],function(a){var f=1===a?"rightNull":"leftNull",l=0,v=e[k[r+a]];if(v)for(q=z;0<=q&&q<u;)h=v.points[q],h||(q===z?d[b][f]=!0:c[q]&&(n=e[b].points[q])&&(l-=n[1]-
	n[0])),q+=C;d[b][1===a?"rightCliff":"leftCliff"]=l});else{for(q=z;0<=q&&q<u;){if(h=e[b].points[q]){f=h[1];break}q+=C}f=m.translate(f,0,1,0,1);a.push({isNull:!0,plotX:p.translate(b,0,0,0,1),x:b,plotY:f,yBottom:f})}})}return a},getGraphPath:function(a){var k=w.prototype.getGraphPath,p=this.options,m=p.stacking,e=this.yAxis,d,l,z=[],b=[],u=this.index,c,t=e.stacks[this.stackKey],q=p.threshold,r=e.getThreshold(p.threshold),h,p=p.connectNulls||"percent"===m,E=function(f,d,h){var n=a[f];f=m&&t[n.x].points[u];
	var l=n[h+"Null"]||0;h=n[h+"Cliff"]||0;var v,k,n=!0;h||l?(v=(l?f[0]:f[1])+h,k=f[0]+h,n=!!l):!m&&a[d]&&a[d].isNull&&(v=k=q);void 0!==v&&(b.push({plotX:c,plotY:null===v?r:e.getThreshold(v),isNull:n,isCliff:!0}),z.push({plotX:c,plotY:null===k?r:e.getThreshold(k),doCurve:!1}))};a=a||this.points;m&&(a=this.getStackPoints());for(d=0;d<a.length;d++)if(l=a[d].isNull,c=H(a[d].rectPlotX,a[d].plotX),h=H(a[d].yBottom,r),!l||p)p||E(d,d-1,"left"),l&&!m&&p||(b.push(a[d]),z.push({x:d,plotX:c,plotY:h})),p||E(d,d+
	1,"right");d=k.call(this,b,!0,!0);z.reversed=!0;l=k.call(this,z,!0,!0);l.length&&(l[0]="L");l=d.concat(l);k=k.call(this,b,!1,p);l.xMap=d.xMap;this.areaPath=l;return k},drawGraph:function(){this.areaPath=[];w.prototype.drawGraph.apply(this);var a=this,k=this.areaPath,p=this.options,m=[["area","highcharts-area",this.color,p.fillColor]];A(this.zones,function(e,d){m.push(["zone-area-"+d,"highcharts-area highcharts-zone-area-"+d+" "+e.className,e.color||a.color,e.fillColor||p.fillColor])});A(m,function(e){var d=
	e[0],l=a[d];l?(l.endX=k.xMap,l.animate({d:k})):(l=a[d]=a.chart.renderer.path(k).addClass(e[1]).attr({fill:H(e[3],D(e[2]).setOpacity(H(p.fillOpacity,.75)).get()),zIndex:0}).add(a.group),l.isArea=!0);l.startX=k.xMap;l.shiftUnit=p.step?2:1})},drawLegendSymbol:a.LegendSymbolMixin.drawRectangle})})(K);(function(a){var D=a.pick;a=a.seriesType;a("spline","line",{},{getPointSpline:function(a,G,H){var w=G.plotX,k=G.plotY,t=a[H-1];H=a[H+1];var x,p,m,e;if(t&&!t.isNull&&!1!==t.doCurve&&!G.isCliff&&H&&!H.isNull&&
	!1!==H.doCurve&&!G.isCliff){a=t.plotY;m=H.plotX;H=H.plotY;var d=0;x=(1.5*w+t.plotX)/2.5;p=(1.5*k+a)/2.5;m=(1.5*w+m)/2.5;e=(1.5*k+H)/2.5;m!==x&&(d=(e-p)*(m-w)/(m-x)+k-e);p+=d;e+=d;p>a&&p>k?(p=Math.max(a,k),e=2*k-p):p<a&&p<k&&(p=Math.min(a,k),e=2*k-p);e>H&&e>k?(e=Math.max(H,k),p=2*k-e):e<H&&e<k&&(e=Math.min(H,k),p=2*k-e);G.rightContX=m;G.rightContY=e}G=["C",D(t.rightContX,t.plotX),D(t.rightContY,t.plotY),D(x,w),D(p,k),w,k];t.rightContX=t.rightContY=null;return G}})})(K);(function(a){var D=a.seriesTypes.area.prototype,
	A=a.seriesType;A("areaspline","spline",a.defaultPlotOptions.area,{getStackPoints:D.getStackPoints,getGraphPath:D.getGraphPath,setStackCliffs:D.setStackCliffs,drawGraph:D.drawGraph,drawLegendSymbol:a.LegendSymbolMixin.drawRectangle})})(K);(function(a){var D=a.animObject,A=a.color,G=a.each,H=a.extend,w=a.isNumber,k=a.merge,t=a.pick,x=a.Series,p=a.seriesType,m=a.svg;p("column","line",{borderRadius:0,groupPadding:.2,marker:null,pointPadding:.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{halo:!1,
	brightness:.1,shadow:!1},select:{color:"#cccccc",borderColor:"#000000",shadow:!1}},dataLabels:{align:null,verticalAlign:null,y:null},softThreshold:!1,startFromThreshold:!0,stickyTracking:!1,tooltip:{distance:6},threshold:0,borderColor:"#ffffff"},{cropShoulder:0,directTouch:!0,trackerGroups:["group","dataLabelsGroup"],negStacks:!0,init:function(){x.prototype.init.apply(this,arguments);var a=this,d=a.chart;d.hasRendered&&G(d.series,function(d){d.type===a.type&&(d.isDirty=!0)})},getColumnMetrics:function(){var a=
	this,d=a.options,l=a.xAxis,k=a.yAxis,b=l.reversed,u,c={},m=0;!1===d.grouping?m=1:G(a.chart.series,function(b){var f=b.options,d=b.yAxis,h;b.type===a.type&&b.visible&&k.len===d.len&&k.pos===d.pos&&(f.stacking?(u=b.stackKey,void 0===c[u]&&(c[u]=m++),h=c[u]):!1!==f.grouping&&(h=m++),b.columnIndex=h)});var q=Math.min(Math.abs(l.transA)*(l.ordinalSlope||d.pointRange||l.closestPointRange||l.tickInterval||1),l.len),r=q*d.groupPadding,h=(q-2*r)/(m||1),d=Math.min(d.maxPointWidth||l.len,t(d.pointWidth,h*(1-
	2*d.pointPadding)));a.columnMetrics={width:d,offset:(h-d)/2+(r+((a.columnIndex||0)+(b?1:0))*h-q/2)*(b?-1:1)};return a.columnMetrics},crispCol:function(a,d,l,k){var b=this.chart,e=this.borderWidth,c=-(e%2?.5:0),e=e%2?.5:1;b.inverted&&b.renderer.isVML&&(e+=1);l=Math.round(a+l)+c;a=Math.round(a)+c;k=Math.round(d+k)+e;c=.5>=Math.abs(d)&&.5<k;d=Math.round(d)+e;k-=d;c&&k&&(--d,k+=1);return{x:a,y:d,width:l-a,height:k}},translate:function(){var a=this,d=a.chart,l=a.options,k=a.dense=2>a.closestPointRange*
	a.xAxis.transA,k=a.borderWidth=t(l.borderWidth,k?0:1),b=a.yAxis,u=a.translatedThreshold=b.getThreshold(l.threshold),c=t(l.minPointLength,5),m=a.getColumnMetrics(),q=m.width,r=a.barW=Math.max(q,1+2*k),h=a.pointXOffset=m.offset;d.inverted&&(u-=.5);l.pointPadding&&(r=Math.ceil(r));x.prototype.translate.apply(a);G(a.points,function(e){var f=t(e.yBottom,u),l=999+Math.abs(f),l=Math.min(Math.max(-l,e.plotY),b.len+l),n=e.plotX+h,k=r,m=Math.min(l,f),F,p=Math.max(l,f)-m;Math.abs(p)<c&&c&&(p=c,F=!b.reversed&&
	!e.negative||b.reversed&&e.negative,m=Math.abs(m-u)>c?f-c:u-(F?c:0));e.barX=n;e.pointWidth=q;e.tooltipPos=d.inverted?[b.len+b.pos-d.plotLeft-l,a.xAxis.len-n-k/2,p]:[n+k/2,l+b.pos-d.plotTop,p];e.shapeType="rect";e.shapeArgs=a.crispCol.apply(a,e.isNull?[e.plotX,b.len/2,0,0]:[n,m,k,p])})},getSymbol:a.noop,drawLegendSymbol:a.LegendSymbolMixin.drawRectangle,drawGraph:function(){this.group[this.dense?"addClass":"removeClass"]("highcharts-dense-data")},pointAttribs:function(a,d){var e=this.options,m,b=this.pointAttrToOptions||
	{};m=b.stroke||"borderColor";var u=b["stroke-width"]||"borderWidth",c=a&&a.color||this.color,p=a[m]||e[m]||this.color||c,q=a[u]||e[u]||this[u]||0,b=e.dashStyle;a&&this.zones.length&&(c=(c=a.getZone())&&c.color||a.options.color||this.color);d&&(a=k(e.states[d],a.options.states&&a.options.states[d]||{}),d=a.brightness,c=a.color||void 0!==d&&A(c).brighten(a.brightness).get()||c,p=a[m]||p,q=a[u]||q,b=a.dashStyle||b);m={fill:c,stroke:p,"stroke-width":q};e.borderRadius&&(m.r=e.borderRadius);b&&(m.dashstyle=
	b);return m},drawPoints:function(){var a=this,d=this.chart,l=a.options,m=d.renderer,b=l.animationLimit||250,u;G(a.points,function(c){var e=c.graphic;if(w(c.plotY)&&null!==c.y){u=c.shapeArgs;if(e)e[d.pointCount<b?"animate":"attr"](k(u));else c.graphic=e=m[c.shapeType](u).add(c.group||a.group);e.attr(a.pointAttribs(c,c.selected&&"select")).shadow(l.shadow,null,l.stacking&&!l.borderRadius);e.addClass(c.getClassName(),!0)}else e&&(c.graphic=e.destroy())})},animate:function(a){var d=this,e=this.yAxis,
	k=d.options,b=this.chart.inverted,u={};m&&(a?(u.scaleY=.001,a=Math.min(e.pos+e.len,Math.max(e.pos,e.toPixels(k.threshold))),b?u.translateX=a-e.len:u.translateY=a,d.group.attr(u)):(u[b?"translateX":"translateY"]=e.pos,d.group.animate(u,H(D(d.options.animation),{step:function(a,b){d.group.attr({scaleY:Math.max(.001,b.pos)})}})),d.animate=null))},remove:function(){var a=this,d=a.chart;d.hasRendered&&G(d.series,function(d){d.type===a.type&&(d.isDirty=!0)});x.prototype.remove.apply(a,arguments)}})})(K);
	(function(a){a=a.seriesType;a("bar","column",null,{inverted:!0})})(K);(function(a){var D=a.Series;a=a.seriesType;a("scatter","line",{lineWidth:0,marker:{enabled:!0},tooltip:{headerFormat:'\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e \x3cspan style\x3d"font-size: 0.85em"\x3e {series.name}\x3c/span\x3e\x3cbr/\x3e',pointFormat:"x: \x3cb\x3e{point.x}\x3c/b\x3e\x3cbr/\x3ey: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e"}},{sorted:!1,requireSorting:!1,noSharedTooltip:!0,trackerGroups:["group",
	"markerGroup","dataLabelsGroup"],takeOrdinalPosition:!1,kdDimensions:2,drawGraph:function(){this.options.lineWidth&&D.prototype.drawGraph.call(this)}})})(K);(function(a){var D=a.pick,A=a.relativeLength;a.CenteredSeriesMixin={getCenter:function(){var a=this.options,H=this.chart,w=2*(a.slicedOffset||0),k=H.plotWidth-2*w,H=H.plotHeight-2*w,t=a.center,t=[D(t[0],"50%"),D(t[1],"50%"),a.size||"100%",a.innerSize||0],x=Math.min(k,H),p,m;for(p=0;4>p;++p)m=t[p],a=2>p||2===p&&/%$/.test(m),t[p]=A(m,[k,H,x,t[2]][p])+
	(a?w:0);t[3]>t[2]&&(t[3]=t[2]);return t}}})(K);(function(a){var D=a.addEvent,A=a.defined,G=a.each,H=a.extend,w=a.inArray,k=a.noop,t=a.pick,x=a.Point,p=a.Series,m=a.seriesType,e=a.setAnimation;m("pie","line",{center:[null,null],clip:!1,colorByPoint:!0,dataLabels:{distance:30,enabled:!0,formatter:function(){return null===this.y?void 0:this.point.name},x:0},ignoreHiddenPoint:!0,legendType:"point",marker:null,size:null,showInLegend:!1,slicedOffset:10,stickyTracking:!1,tooltip:{followPointer:!0},borderColor:"#ffffff",
	borderWidth:1,states:{hover:{brightness:.1,shadow:!1}}},{isCartesian:!1,requireSorting:!1,directTouch:!0,noSharedTooltip:!0,trackerGroups:["group","dataLabelsGroup"],axisTypes:[],pointAttribs:a.seriesTypes.column.prototype.pointAttribs,animate:function(a){var d=this,e=d.points,b=d.startAngleRad;a||(G(e,function(a){var c=a.graphic,e=a.shapeArgs;c&&(c.attr({r:a.startR||d.center[3]/2,start:b,end:b}),c.animate({r:e.r,start:e.start,end:e.end},d.options.animation))}),d.animate=null)},updateTotals:function(){var a,
	e=0,k=this.points,b=k.length,u,c=this.options.ignoreHiddenPoint;for(a=0;a<b;a++)u=k[a],0>u.y&&(u.y=null),e+=c&&!u.visible?0:u.y;this.total=e;for(a=0;a<b;a++)u=k[a],u.percentage=0<e&&(u.visible||!c)?u.y/e*100:0,u.total=e},generatePoints:function(){p.prototype.generatePoints.call(this);this.updateTotals()},translate:function(a){this.generatePoints();var d=0,e=this.options,b=e.slicedOffset,k=b+(e.borderWidth||0),c,m,q,r=e.startAngle||0,h=this.startAngleRad=Math.PI/180*(r-90),r=(this.endAngleRad=Math.PI/
	180*(t(e.endAngle,r+360)-90))-h,p=this.points,f=e.dataLabels.distance,e=e.ignoreHiddenPoint,v,n=p.length,y;a||(this.center=a=this.getCenter());this.getX=function(b,c){q=Math.asin(Math.min((b-a[1])/(a[2]/2+f),1));return a[0]+(c?-1:1)*Math.cos(q)*(a[2]/2+f)};for(v=0;v<n;v++){y=p[v];c=h+d*r;if(!e||y.visible)d+=y.percentage/100;m=h+d*r;y.shapeType="arc";y.shapeArgs={x:a[0],y:a[1],r:a[2]/2,innerR:a[3]/2,start:Math.round(1E3*c)/1E3,end:Math.round(1E3*m)/1E3};q=(m+c)/2;q>1.5*Math.PI?q-=2*Math.PI:q<-Math.PI/
	2&&(q+=2*Math.PI);y.slicedTranslation={translateX:Math.round(Math.cos(q)*b),translateY:Math.round(Math.sin(q)*b)};c=Math.cos(q)*a[2]/2;m=Math.sin(q)*a[2]/2;y.tooltipPos=[a[0]+.7*c,a[1]+.7*m];y.half=q<-Math.PI/2||q>Math.PI/2?1:0;y.angle=q;k=Math.min(k,f/5);y.labelPos=[a[0]+c+Math.cos(q)*f,a[1]+m+Math.sin(q)*f,a[0]+c+Math.cos(q)*k,a[1]+m+Math.sin(q)*k,a[0]+c,a[1]+m,0>f?"center":y.half?"right":"left",q]}},drawGraph:null,drawPoints:function(){var a=this,e=a.chart.renderer,k,b,m,c,p=a.options.shadow;p&&
	!a.shadowGroup&&(a.shadowGroup=e.g("shadow").add(a.group));G(a.points,function(d){if(null!==d.y){b=d.graphic;c=d.shapeArgs;k=d.getTranslate();var r=d.shadowGroup;p&&!r&&(r=d.shadowGroup=e.g("shadow").add(a.shadowGroup));r&&r.attr(k);m=a.pointAttribs(d,d.selected&&"select");b?b.setRadialReference(a.center).attr(m).animate(H(c,k)):(d.graphic=b=e[d.shapeType](c).setRadialReference(a.center).attr(k).add(a.group),d.visible||b.attr({visibility:"hidden"}),b.attr(m).attr({"stroke-linejoin":"round"}).shadow(p,
	r));b.addClass(d.getClassName())}})},searchPoint:k,sortByAngle:function(a,e){a.sort(function(a,b){return void 0!==a.angle&&(b.angle-a.angle)*e})},drawLegendSymbol:a.LegendSymbolMixin.drawRectangle,getCenter:a.CenteredSeriesMixin.getCenter,getSymbol:k},{init:function(){x.prototype.init.apply(this,arguments);var a=this,e;a.name=t(a.name,"Slice");e=function(d){a.slice("select"===d.type)};D(a,"select",e);D(a,"unselect",e);return a},setVisible:function(a,e){var d=this,b=d.series,l=b.chart,c=b.options.ignoreHiddenPoint;
	e=t(e,c);a!==d.visible&&(d.visible=d.options.visible=a=void 0===a?!d.visible:a,b.options.data[w(d,b.data)]=d.options,G(["graphic","dataLabel","connector","shadowGroup"],function(b){if(d[b])d[b][a?"show":"hide"](!0)}),d.legendItem&&l.legend.colorizeItem(d,a),a||"hover"!==d.state||d.setState(""),c&&(b.isDirty=!0),e&&l.redraw())},slice:function(a,l,k){var b=this.series;e(k,b.chart);t(l,!0);this.sliced=this.options.sliced=A(a)?a:!this.sliced;b.options.data[w(this,b.data)]=this.options;this.graphic.animate(this.getTranslate());
	this.shadowGroup&&this.shadowGroup.animate(this.getTranslate())},getTranslate:function(){return this.sliced?this.slicedTranslation:{translateX:0,translateY:0}},haloPath:function(a){var d=this.shapeArgs;return this.sliced||!this.visible?[]:this.series.chart.renderer.symbols.arc(d.x,d.y,d.r+a,d.r+a,{innerR:this.shapeArgs.r,start:d.start,end:d.end})}})})(K);(function(a){var D=a.addEvent,A=a.arrayMax,G=a.defined,H=a.each,w=a.extend,k=a.format,t=a.map,x=a.merge,p=a.noop,m=a.pick,e=a.relativeLength,d=a.Series,
	l=a.seriesTypes,z=a.stableSort;a.distribute=function(a,d){function b(a,b){return a.target-b.target}var e,l=!0,r=a,h=[],k;k=0;for(e=a.length;e--;)k+=a[e].size;if(k>d){z(a,function(a,b){return(b.rank||0)-(a.rank||0)});for(k=e=0;k<=d;)k+=a[e].size,e++;h=a.splice(e-1,a.length)}z(a,b);for(a=t(a,function(a){return{size:a.size,targets:[a.target]}});l;){for(e=a.length;e--;)l=a[e],k=(Math.min.apply(0,l.targets)+Math.max.apply(0,l.targets))/2,l.pos=Math.min(Math.max(0,k-l.size/2),d-l.size);e=a.length;for(l=
	!1;e--;)0<e&&a[e-1].pos+a[e-1].size>a[e].pos&&(a[e-1].size+=a[e].size,a[e-1].targets=a[e-1].targets.concat(a[e].targets),a[e-1].pos+a[e-1].size>d&&(a[e-1].pos=d-a[e-1].size),a.splice(e,1),l=!0)}e=0;H(a,function(a){var b=0;H(a.targets,function(){r[e].pos=a.pos+b;b+=r[e].size;e++})});r.push.apply(r,h);z(r,b)};d.prototype.drawDataLabels=function(){var a=this,d=a.options,c=d.dataLabels,e=a.points,l,r,h=a.hasRendered||0,p,f,v=m(c.defer,!0),n=a.chart.renderer;if(c.enabled||a._hasPointLabels)a.dlProcessOptions&&
	a.dlProcessOptions(c),f=a.plotGroup("dataLabelsGroup","data-labels",v&&!h?"hidden":"visible",c.zIndex||6),v&&(f.attr({opacity:+h}),h||D(a,"afterAnimate",function(){a.visible&&f.show(!0);f[d.animation?"animate":"attr"]({opacity:1},{duration:200})})),r=c,H(e,function(b){var h,e=b.dataLabel,q,g,v,u=b.connector,y=!e,t;l=b.dlOptions||b.options&&b.options.dataLabels;if(h=m(l&&l.enabled,r.enabled)&&null!==b.y)for(g in c=x(r,l),q=b.getLabelConfig(),p=c.format?k(c.format,q):c.formatter.call(q,c),t=c.style,
	v=c.rotation,t.color=m(c.color,t.color,a.color,"#000000"),"contrast"===t.color&&(t.color=c.inside||0>c.distance||d.stacking?n.getContrast(b.color||a.color):"#000000"),d.cursor&&(t.cursor=d.cursor),q={fill:c.backgroundColor,stroke:c.borderColor,"stroke-width":c.borderWidth,r:c.borderRadius||0,rotation:v,padding:c.padding,zIndex:1},q)void 0===q[g]&&delete q[g];!e||h&&G(p)?h&&G(p)&&(e?q.text=p:(e=b.dataLabel=n[v?"text":"label"](p,0,-9999,c.shape,null,null,c.useHTML,null,"data-label"),e.addClass("highcharts-data-label-color-"+
	b.colorIndex+" "+(c.className||"")+(c.useHTML?"highcharts-tracker":""))),e.attr(q),e.css(t).shadow(c.shadow),e.added||e.add(f),a.alignDataLabel(b,e,c,null,y)):(b.dataLabel=e.destroy(),u&&(b.connector=u.destroy()))})};d.prototype.alignDataLabel=function(a,d,c,e,l){var b=this.chart,h=b.inverted,k=m(a.plotX,-9999),f=m(a.plotY,-9999),q=d.getBBox(),n,u=c.rotation,p=c.align,F=this.visible&&(a.series.forceDL||b.isInsidePlot(k,Math.round(f),h)||e&&b.isInsidePlot(k,h?e.x+1:e.y+e.height-1,h)),t="justify"===
	m(c.overflow,"justify");F&&(n=c.style.fontSize,n=b.renderer.fontMetrics(n,d).b,e=w({x:h?b.plotWidth-f:k,y:Math.round(h?b.plotHeight-k:f),width:0,height:0},e),w(c,{width:q.width,height:q.height}),u?(t=!1,h=b.renderer.rotCorr(n,u),h={x:e.x+c.x+e.width/2+h.x,y:e.y+c.y+{top:0,middle:.5,bottom:1}[c.verticalAlign]*e.height},d[l?"attr":"animate"](h).attr({align:p}),k=(u+720)%360,k=180<k&&360>k,"left"===p?h.y-=k?q.height:0:"center"===p?(h.x-=q.width/2,h.y-=q.height/2):"right"===p&&(h.x-=q.width,h.y-=k?0:
	q.height)):(d.align(c,null,e),h=d.alignAttr),t?this.justifyDataLabel(d,c,h,q,e,l):m(c.crop,!0)&&(F=b.isInsidePlot(h.x,h.y)&&b.isInsidePlot(h.x+q.width,h.y+q.height)),c.shape&&!u&&d.attr({anchorX:a.plotX,anchorY:a.plotY}));F||(d.attr({y:-9999}),d.placed=!1)};d.prototype.justifyDataLabel=function(a,d,c,e,l,r){var b=this.chart,k=d.align,f=d.verticalAlign,q,n,m=a.box?0:a.padding||0;q=c.x+m;0>q&&("right"===k?d.align="left":d.x=-q,n=!0);q=c.x+e.width-m;q>b.plotWidth&&("left"===k?d.align="right":d.x=b.plotWidth-
	q,n=!0);q=c.y+m;0>q&&("bottom"===f?d.verticalAlign="top":d.y=-q,n=!0);q=c.y+e.height-m;q>b.plotHeight&&("top"===f?d.verticalAlign="bottom":d.y=b.plotHeight-q,n=!0);n&&(a.placed=!r,a.align(d,null,l))};l.pie&&(l.pie.prototype.drawDataLabels=function(){var b=this,e=b.data,c,l=b.chart,q=b.options.dataLabels,r=m(q.connectorPadding,10),h=m(q.connectorWidth,1),k=l.plotWidth,f=l.plotHeight,v,n=q.distance,y=b.center,p=y[2]/2,F=y[1],z=0<n,g,w,x,D,M=[[],[]],G,B,N,R,O=[0,0,0,0];b.visible&&(q.enabled||b._hasPointLabels)&&
	(H(e,function(a){a.dataLabel&&a.visible&&a.dataLabel.shortened&&(a.dataLabel.attr({width:"auto"}).css({width:"auto",textOverflow:"clip"}),a.dataLabel.shortened=!1)}),d.prototype.drawDataLabels.apply(b),H(e,function(a){a.dataLabel&&a.visible&&(M[a.half].push(a),a.dataLabel._pos=null)}),H(M,function(d,h){var e,v,m=d.length,u,z,I;if(m)for(b.sortByAngle(d,h-.5),0<n&&(e=Math.max(0,F-p-n),v=Math.min(F+p+n,l.plotHeight),u=t(d,function(a){if(a.dataLabel)return I=a.dataLabel.getBBox().height||21,{target:a.labelPos[1]-
	e+I/2,size:I,rank:a.y}}),a.distribute(u,v+I-e)),R=0;R<m;R++)c=d[R],x=c.labelPos,g=c.dataLabel,N=!1===c.visible?"hidden":"inherit",z=x[1],u?void 0===u[R].pos?N="hidden":(D=u[R].size,B=e+u[R].pos):B=z,G=q.justify?y[0]+(h?-1:1)*(p+n):b.getX(B<e+2||B>v-2?z:B,h),g._attr={visibility:N,align:x[6]},g._pos={x:G+q.x+({left:r,right:-r}[x[6]]||0),y:B+q.y-10},x.x=G,x.y=B,null===b.options.size&&(w=g.getBBox().width,z=null,G-w<r?(z=Math.round(w-G+r),O[3]=Math.max(z,O[3])):G+w>k-r&&(z=Math.round(G+w-k+r),O[1]=Math.max(z,
	O[1])),0>B-D/2?O[0]=Math.max(Math.round(-B+D/2),O[0]):B+D/2>f&&(O[2]=Math.max(Math.round(B+D/2-f),O[2])),g.sideOverflow=z)}),0===A(O)||this.verifyDataLabelOverflow(O))&&(this.placeDataLabels(),z&&h&&H(this.points,function(a){var c;v=a.connector;if((g=a.dataLabel)&&g._pos&&a.visible){N=g._attr.visibility;if(c=!v)a.connector=v=l.renderer.path().addClass("highcharts-data-label-connector highcharts-color-"+a.colorIndex).add(b.dataLabelsGroup),v.attr({"stroke-width":h,stroke:q.connectorColor||a.color||
	"#666666"});v[c?"attr":"animate"]({d:b.connectorPath(a.labelPos)});v.attr("visibility",N)}else v&&(a.connector=v.destroy())}))},l.pie.prototype.connectorPath=function(a){var b=a.x,c=a.y;return m(this.options.dataLabels.softConnector,!0)?["M",b+("left"===a[6]?5:-5),c,"C",b,c,2*a[2]-a[4],2*a[3]-a[5],a[2],a[3],"L",a[4],a[5]]:["M",b+("left"===a[6]?5:-5),c,"L",a[2],a[3],"L",a[4],a[5]]},l.pie.prototype.placeDataLabels=function(){H(this.points,function(a){var b=a.dataLabel;b&&a.visible&&((a=b._pos)?(b.sideOverflow&&
	(b._attr.width=b.getBBox().width-b.sideOverflow,b.css({width:b._attr.width+"px",textOverflow:"ellipsis"}),b.shortened=!0),b.attr(b._attr),b[b.moved?"animate":"attr"](a),b.moved=!0):b&&b.attr({y:-9999}))},this)},l.pie.prototype.alignDataLabel=p,l.pie.prototype.verifyDataLabelOverflow=function(a){var b=this.center,c=this.options,d=c.center,l=c.minSize||80,r,h;null!==d[0]?r=Math.max(b[2]-Math.max(a[1],a[3]),l):(r=Math.max(b[2]-a[1]-a[3],l),b[0]+=(a[3]-a[1])/2);null!==d[1]?r=Math.max(Math.min(r,b[2]-
	Math.max(a[0],a[2])),l):(r=Math.max(Math.min(r,b[2]-a[0]-a[2]),l),b[1]+=(a[0]-a[2])/2);r<b[2]?(b[2]=r,b[3]=Math.min(e(c.innerSize||0,r),r),this.translate(b),this.drawDataLabels&&this.drawDataLabels()):h=!0;return h});l.column&&(l.column.prototype.alignDataLabel=function(a,e,c,l,k){var b=this.chart.inverted,h=a.series,q=a.dlBox||a.shapeArgs,f=m(a.below,a.plotY>m(this.translatedThreshold,h.yAxis.len)),v=m(c.inside,!!this.options.stacking);q&&(l=x(q),0>l.y&&(l.height+=l.y,l.y=0),q=l.y+l.height-h.yAxis.len,
	0<q&&(l.height-=q),b&&(l={x:h.yAxis.len-l.y-l.height,y:h.xAxis.len-l.x-l.width,width:l.height,height:l.width}),v||(b?(l.x+=f?0:l.width,l.width=0):(l.y+=f?l.height:0,l.height=0)));c.align=m(c.align,!b||v?"center":f?"right":"left");c.verticalAlign=m(c.verticalAlign,b||v?"middle":f?"top":"bottom");d.prototype.alignDataLabel.call(this,a,e,c,l,k)})})(K);(function(a){var D=a.Chart,A=a.each,G=a.pick,H=a.addEvent;D.prototype.callbacks.push(function(a){function k(){var k=[];A(a.series||[],function(a){var p=
	a.options.dataLabels,m=a.dataLabelCollections||["dataLabel"];(p.enabled||a._hasPointLabels)&&!p.allowOverlap&&a.visible&&A(m,function(e){A(a.points,function(a){a[e]&&(a[e].labelrank=G(a.labelrank,a.shapeArgs&&a.shapeArgs.height),k.push(a[e]))})})});a.hideOverlappingLabels(k)}k();H(a,"redraw",k)});D.prototype.hideOverlappingLabels=function(a){var k=a.length,t,x,p,m,e,d,l,z,b,u=function(a,b,d,e,h,l,f,k){return!(h>a+d||h+f<a||l>b+e||l+k<b)};for(x=0;x<k;x++)if(t=a[x])t.oldOpacity=t.opacity,t.newOpacity=
	1;a.sort(function(a,b){return(b.labelrank||0)-(a.labelrank||0)});for(x=0;x<k;x++)for(p=a[x],t=x+1;t<k;++t)if(m=a[t],p&&m&&p.placed&&m.placed&&0!==p.newOpacity&&0!==m.newOpacity&&(e=p.alignAttr,d=m.alignAttr,l=p.parentGroup,z=m.parentGroup,b=2*(p.box?0:p.padding),e=u(e.x+l.translateX,e.y+l.translateY,p.width-b,p.height-b,d.x+z.translateX,d.y+z.translateY,m.width-b,m.height-b)))(p.labelrank<m.labelrank?p:m).newOpacity=0;A(a,function(a){var b,c;a&&(c=a.newOpacity,a.oldOpacity!==c&&a.placed&&(c?a.show(!0):
	b=function(){a.hide()},a.alignAttr.opacity=c,a[a.isOld?"animate":"attr"](a.alignAttr,null,b)),a.isOld=!0)})}})(K);(function(a){var D=a.addEvent,A=a.Chart,G=a.createElement,H=a.css,w=a.defaultOptions,k=a.defaultPlotOptions,t=a.each,x=a.extend,p=a.fireEvent,m=a.hasTouch,e=a.inArray,d=a.isObject,l=a.Legend,z=a.merge,b=a.pick,u=a.Point,c=a.Series,C=a.seriesTypes,q=a.svg;a=a.TrackerMixin={drawTrackerPoint:function(){var a=this,b=a.chart.pointer,c=function(a){var c=b.getPointFromEvent(a);if(void 0!==c)c.onMouseOver(a)};
	t(a.points,function(a){a.graphic&&(a.graphic.element.point=a);a.dataLabel&&(a.dataLabel.div?a.dataLabel.div.point=a:a.dataLabel.element.point=a)});a._hasTracking||(t(a.trackerGroups,function(d){if(a[d]){a[d].addClass("highcharts-tracker").on("mouseover",c).on("mouseout",function(a){b.onTrackerMouseOut(a)});if(m)a[d].on("touchstart",c);a.options.cursor&&a[d].css(H).css({cursor:a.options.cursor})}}),a._hasTracking=!0)},drawTrackerGraph:function(){var a=this,b=a.options,c=b.trackByArea,d=[].concat(c?
	a.areaPath:a.graphPath),e=d.length,n=a.chart,l=n.pointer,k=n.renderer,u=n.options.tooltip.snap,p=a.tracker,g,z=function(){if(n.hoverSeries!==a)a.onMouseOver()},x="rgba(192,192,192,"+(q?.0001:.002)+")";if(e&&!c)for(g=e+1;g--;)"M"===d[g]&&d.splice(g+1,0,d[g+1]-u,d[g+2],"L"),(g&&"M"===d[g]||g===e)&&d.splice(g,0,"L",d[g-2]+u,d[g-1]);p?p.attr({d:d}):a.graph&&(a.tracker=k.path(d).attr({"stroke-linejoin":"round",visibility:a.visible?"visible":"hidden",stroke:x,fill:c?x:"none","stroke-width":a.graph.strokeWidth()+
	(c?0:2*u),zIndex:2}).add(a.group),t([a.tracker,a.markerGroup],function(a){a.addClass("highcharts-tracker").on("mouseover",z).on("mouseout",function(a){l.onTrackerMouseOut(a)});b.cursor&&a.css({cursor:b.cursor});if(m)a.on("touchstart",z)}))}};C.column&&(C.column.prototype.drawTracker=a.drawTrackerPoint);C.pie&&(C.pie.prototype.drawTracker=a.drawTrackerPoint);C.scatter&&(C.scatter.prototype.drawTracker=a.drawTrackerPoint);x(l.prototype,{setItemEvents:function(a,b,c){var d=this,h=d.chart.renderer.boxWrapper,
	e="highcharts-legend-"+(a.series?"point":"series")+"-active";(c?b:a.legendGroup).on("mouseover",function(){a.setState("hover");h.addClass(e);b.css(d.options.itemHoverStyle)}).on("mouseout",function(){b.css(a.visible?d.itemStyle:d.itemHiddenStyle);h.removeClass(e);a.setState()}).on("click",function(b){var c=function(){a.setVisible&&a.setVisible()};b={browserEvent:b};a.firePointEvent?a.firePointEvent("legendItemClick",b,c):p(a,"legendItemClick",b,c)})},createCheckboxForItem:function(a){a.checkbox=G("input",
	{type:"checkbox",checked:a.selected,defaultChecked:a.selected},this.options.itemCheckboxStyle,this.chart.container);D(a.checkbox,"click",function(b){p(a.series||a,"checkboxClick",{checked:b.target.checked,item:a},function(){a.select()})})}});w.legend.itemStyle.cursor="pointer";x(A.prototype,{showResetZoom:function(){var a=this,b=w.lang,c=a.options.chart.resetZoomButton,d=c.theme,e=d.states,n="chart"===c.relativeTo?null:"plotBox";this.resetZoomButton=a.renderer.button(b.resetZoom,null,null,function(){a.zoomOut()},
	d,e&&e.hover).attr({align:c.position.align,title:b.resetZoomTitle}).addClass("highcharts-reset-zoom").add().align(c.position,!1,n)},zoomOut:function(){var a=this;p(a,"selection",{resetSelection:!0},function(){a.zoom()})},zoom:function(a){var c,e=this.pointer,f=!1,l;!a||a.resetSelection?t(this.axes,function(a){c=a.zoom()}):t(a.xAxis.concat(a.yAxis),function(a){var b=a.axis;e[b.isXAxis?"zoomX":"zoomY"]&&(c=b.zoom(a.min,a.max),b.displayBtn&&(f=!0))});l=this.resetZoomButton;f&&!l?this.showResetZoom():
	!f&&d(l)&&(this.resetZoomButton=l.destroy());c&&this.redraw(b(this.options.chart.animation,a&&a.animation,100>this.pointCount))},pan:function(a,b){var c=this,d=c.hoverPoints,h;d&&t(d,function(a){a.setState()});t("xy"===b?[1,0]:[1],function(b){b=c[b?"xAxis":"yAxis"][0];var d=b.horiz,f=a[d?"chartX":"chartY"],d=d?"mouseDownX":"mouseDownY",e=c[d],l=(b.pointRange||0)/2,g=b.getExtremes(),n=b.toValue(e-f,!0)+l,l=b.toValue(e+b.len-f,!0)-l,r=l<n,e=r?l:n,n=r?n:l,r=b.toValue(b.toPixels(g.min)-b.minPixelPadding),
	l=b.toValue(b.toPixels(g.max)+b.minPixelPadding),r=Math.min(g.dataMin,r)-e,g=n-Math.max(g.dataMax,l);b.series.length&&0>r&&0>g&&(b.setExtremes(e,n,!1,!1,{trigger:"pan"}),h=!0);c[d]=f});h&&c.redraw(!1);H(c.container,{cursor:"move"})}});x(u.prototype,{select:function(a,c){var d=this,f=d.series,h=f.chart;a=b(a,!d.selected);d.firePointEvent(a?"select":"unselect",{accumulate:c},function(){d.selected=d.options.selected=a;f.options.data[e(d,f.data)]=d.options;d.setState(a&&"select");c||t(h.getSelectedPoints(),
	function(a){a.selected&&a!==d&&(a.selected=a.options.selected=!1,f.options.data[e(a,f.data)]=a.options,a.setState(""),a.firePointEvent("unselect"))})})},onMouseOver:function(a){var b=this.series.chart.pointer;this.firePointEvent("mouseOver");b.runPointActions(a,this)},onMouseOut:function(){var a=this.series.chart;this.firePointEvent("mouseOut");t(a.hoverPoints||[],function(a){a.setState()});a.hoverPoints=a.hoverPoint=null},importEvents:function(){if(!this.hasImportedEvents){var a=z(this.series.options.point,
	this.options).events,b;this.events=a;for(b in a)D(this,b,a[b]);this.hasImportedEvents=!0}},setState:function(a,c){var d=Math.floor(this.plotX),f=this.plotY,e=this.series,h=e.options.states[a]||{},l=k[e.type].marker&&e.options.marker,r=l&&!1===l.enabled,q=l&&l.states&&l.states[a]||{},m=!1===q.enabled,g=e.stateMarkerGraphic,u=this.marker||{},p=e.chart,t=e.halo,z,w=l&&e.markerAttribs;a=a||"";if(!(a===this.state&&!c||this.selected&&"select"!==a||!1===h.enabled||a&&(m||r&&!1===q.enabled)||a&&u.states&&
	u.states[a]&&!1===u.states[a].enabled)){w&&(z=e.markerAttribs(this,a));if(this.graphic)this.state&&this.graphic.removeClass("highcharts-point-"+this.state),a&&this.graphic.addClass("highcharts-point-"+a),this.graphic.attr(e.pointAttribs(this,a)),z&&this.graphic.animate(z,b(p.options.chart.animation,q.animation,l.animation)),g&&g.hide();else{if(a&&q){l=u.symbol||e.symbol;g&&g.currentSymbol!==l&&(g=g.destroy());if(g)g[c?"animate":"attr"]({x:z.x,y:z.y});else l&&(e.stateMarkerGraphic=g=p.renderer.symbol(l,
	z.x,z.y,z.width,z.height).add(e.markerGroup),g.currentSymbol=l);g&&g.attr(e.pointAttribs(this,a))}g&&(g[a&&p.isInsidePlot(d,f,p.inverted)?"show":"hide"](),g.element.point=this)}(d=h.halo)&&d.size?(t||(e.halo=t=p.renderer.path().add(w?e.markerGroup:e.group)),t[c?"animate":"attr"]({d:this.haloPath(d.size)}),t.attr({"class":"highcharts-halo highcharts-color-"+b(this.colorIndex,e.colorIndex)}),t.point=this,t.attr(x({fill:this.color||e.color,"fill-opacity":d.opacity,zIndex:-1},d.attributes))):t&&t.point&&
	t.point.haloPath&&t.animate({d:t.point.haloPath(0)});this.state=a}},haloPath:function(a){return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX)-a,this.plotY-a,2*a,2*a)}});x(c.prototype,{onMouseOver:function(){var a=this.chart,b=a.hoverSeries;if(b&&b!==this)b.onMouseOut();this.options.events.mouseOver&&p(this,"mouseOver");this.setState("hover");a.hoverSeries=this},onMouseOut:function(){var a=this.options,b=this.chart,c=b.tooltip,d=b.hoverPoint;b.hoverSeries=null;if(d)d.onMouseOut();
	this&&a.events.mouseOut&&p(this,"mouseOut");!c||a.stickyTracking||c.shared&&!this.noSharedTooltip||c.hide();this.setState()},setState:function(a){var c=this,d=c.options,f=c.graph,e=d.states,l=d.lineWidth,d=0;a=a||"";if(c.state!==a&&(t([c.group,c.markerGroup,c.dataLabelsGroup],function(b){b&&(c.state&&b.removeClass("highcharts-series-"+c.state),a&&b.addClass("highcharts-series-"+a))}),c.state=a,!e[a]||!1!==e[a].enabled)&&(a&&(l=e[a].lineWidth||l+(e[a].lineWidthPlus||0)),f&&!f.dashstyle))for(l={"stroke-width":l},
	f.animate(l,b(c.chart.options.chart.animation,e[a]&&e[a].animation));c["zone-graph-"+d];)c["zone-graph-"+d].attr(l),d+=1},setVisible:function(a,b){var c=this,d=c.chart,e=c.legendItem,h,l=d.options.chart.ignoreHiddenSeries,k=c.visible;h=(c.visible=a=c.options.visible=c.userOptions.visible=void 0===a?!k:a)?"show":"hide";t(["group","dataLabelsGroup","markerGroup","tracker","tt"],function(a){if(c[a])c[a][h]()});if(d.hoverSeries===c||(d.hoverPoint&&d.hoverPoint.series)===c)c.onMouseOut();e&&d.legend.colorizeItem(c,
	a);c.isDirty=!0;c.options.stacking&&t(d.series,function(a){a.options.stacking&&a.visible&&(a.isDirty=!0)});t(c.linkedSeries,function(b){b.setVisible(a,!1)});l&&(d.isDirtyBox=!0);!1!==b&&d.redraw();p(c,h)},show:function(){this.setVisible(!0)},hide:function(){this.setVisible(!1)},select:function(a){this.selected=a=void 0===a?!this.selected:a;this.checkbox&&(this.checkbox.checked=a);p(this,a?"select":"unselect")},drawTracker:a.drawTrackerGraph})})(K);(function(a){var D=a.Chart,A=a.each,G=a.inArray,H=
	a.isArray,w=a.isObject,k=a.pick,t=a.splat;D.prototype.setResponsive=function(k){var p=this.options.responsive,m=[],e=this.currentResponsive;p&&p.rules&&A(p.rules,function(d){void 0===d._id&&(d._id=a.uniqueKey());this.matchResponsiveRule(d,m,k)},this);var d=a.merge.apply(0,a.map(m,function(d){return a.find(p.rules,function(a){return a._id===d}).chartOptions})),m=m.toString()||void 0;m!==(e&&e.ruleIds)&&(e&&this.update(e.undoOptions,k),m?(this.currentResponsive={ruleIds:m,mergedOptions:d,undoOptions:this.currentOptions(d)},
	this.update(d,k)):this.currentResponsive=void 0)};D.prototype.matchResponsiveRule=function(a,p){var m=a.condition;(m.callback||function(){return this.chartWidth<=k(m.maxWidth,Number.MAX_VALUE)&&this.chartHeight<=k(m.maxHeight,Number.MAX_VALUE)&&this.chartWidth>=k(m.minWidth,0)&&this.chartHeight>=k(m.minHeight,0)}).call(this)&&p.push(a._id)};D.prototype.currentOptions=function(a){function k(a,d,l,m){var b,e;for(b in a)if(!m&&-1<G(b,["series","xAxis","yAxis"]))for(a[b]=t(a[b]),l[b]=[],e=0;e<a[b].length;e++)d[b][e]&&
	(l[b][e]={},k(a[b][e],d[b][e],l[b][e],m+1));else w(a[b])?(l[b]=H(a[b])?[]:{},k(a[b],d[b]||{},l[b],m+1)):l[b]=d[b]||null}var m={};k(a,this.options,m,0);return m}})(K);(function(a){var D=a.addEvent,A=a.Axis,G=a.Chart,H=a.css,w=a.dateFormat,k=a.defined,t=a.each,x=a.extend,p=a.noop,m=a.Series,e=a.timeUnits;a=a.wrap;a(m.prototype,"init",function(a){var d;a.apply(this,Array.prototype.slice.call(arguments,1));(d=this.xAxis)&&d.options.ordinal&&D(this,"updatedData",function(){delete d.ordinalIndex})});a(A.prototype,
	"getTimeTicks",function(a,l,m,b,u,c,p,q){var d=0,h,t,f={},v,n,y,z=[],F=-Number.MAX_VALUE,x=this.options.tickPixelInterval;if(!this.options.ordinal&&!this.options.breaks||!c||3>c.length||void 0===m)return a.call(this,l,m,b,u);n=c.length;for(h=0;h<n;h++){y=h&&c[h-1]>b;c[h]<m&&(d=h);if(h===n-1||c[h+1]-c[h]>5*p||y){if(c[h]>F){for(t=a.call(this,l,c[d],c[h],u);t.length&&t[0]<=F;)t.shift();t.length&&(F=t[t.length-1]);z=z.concat(t)}d=h+1}if(y)break}a=t.info;if(q&&a.unitRange<=e.hour){h=z.length-1;for(d=1;d<
	h;d++)w("%d",z[d])!==w("%d",z[d-1])&&(f[z[d]]="day",v=!0);v&&(f[z[0]]="day");a.higherRanks=f}z.info=a;if(q&&k(x)){q=a=z.length;h=[];var g;for(v=[];q--;)d=this.translate(z[q]),g&&(v[q]=g-d),h[q]=g=d;v.sort();v=v[Math.floor(v.length/2)];v<.6*x&&(v=null);q=z[a-1]>b?a-1:a;for(g=void 0;q--;)d=h[q],b=Math.abs(g-d),g&&b<.8*x&&(null===v||b<.8*v)?(f[z[q]]&&!f[z[q+1]]?(b=q+1,g=d):b=q,z.splice(b,1)):g=d}return z});x(A.prototype,{beforeSetTickPositions:function(){var a,e=[],k=!1,b,m=this.getExtremes(),c=m.min,
	p=m.max,q,r=this.isXAxis&&!!this.options.breaks,m=this.options.ordinal,h=this.chart.options.chart.ignoreHiddenSeries;if(m||r){t(this.series,function(b,c){if(!(h&&!1===b.visible||!1===b.takeOrdinalPosition&&!r)&&(e=e.concat(b.processedXData),a=e.length,e.sort(function(a,b){return a-b}),a))for(c=a-1;c--;)e[c]===e[c+1]&&e.splice(c,1)});a=e.length;if(2<a){b=e[1]-e[0];for(q=a-1;q--&&!k;)e[q+1]-e[q]!==b&&(k=!0);!this.options.keepOrdinalPadding&&(e[0]-c>b||p-e[e.length-1]>b)&&(k=!0)}k?(this.ordinalPositions=
	e,b=this.ordinal2lin(Math.max(c,e[0]),!0),q=Math.max(this.ordinal2lin(Math.min(p,e[e.length-1]),!0),1),this.ordinalSlope=p=(p-c)/(q-b),this.ordinalOffset=c-b*p):this.ordinalPositions=this.ordinalSlope=this.ordinalOffset=void 0}this.isOrdinal=m&&k;this.groupIntervalFactor=null},val2lin:function(a,e){var d=this.ordinalPositions;if(d){var b=d.length,l,c;for(l=b;l--;)if(d[l]===a){c=l;break}for(l=b-1;l--;)if(a>d[l]||0===l){a=(a-d[l])/(d[l+1]-d[l]);c=l+a;break}e=e?c:this.ordinalSlope*(c||0)+this.ordinalOffset}else e=
	a;return e},lin2val:function(a,e){var d=this.ordinalPositions;if(d){var b=this.ordinalSlope,l=this.ordinalOffset,c=d.length-1,k;if(e)0>a?a=d[0]:a>c?a=d[c]:(c=Math.floor(a),k=a-c);else for(;c--;)if(e=b*c+l,a>=e){b=b*(c+1)+l;k=(a-e)/(b-e);break}return void 0!==k&&void 0!==d[c]?d[c]+(k?k*(d[c+1]-d[c]):0):a}return a},getExtendedPositions:function(){var a=this.chart,e=this.series[0].currentDataGrouping,k=this.ordinalIndex,b=e?e.count+e.unitName:"raw",m=this.getExtremes(),c,w;k||(k=this.ordinalIndex={});
	k[b]||(c={series:[],chart:a,getExtremes:function(){return{min:m.dataMin,max:m.dataMax}},options:{ordinal:!0},val2lin:A.prototype.val2lin,ordinal2lin:A.prototype.ordinal2lin},t(this.series,function(b){w={xAxis:c,xData:b.xData,chart:a,destroyGroupedData:p};w.options={dataGrouping:e?{enabled:!0,forced:!0,approximation:"open",units:[[e.unitName,[e.count]]]}:{enabled:!1}};b.processData.apply(w);c.series.push(w)}),this.beforeSetTickPositions.apply(c),k[b]=c.ordinalPositions);return k[b]},getGroupIntervalFactor:function(a,
	e,k){var b;k=k.processedXData;var d=k.length,c=[];b=this.groupIntervalFactor;if(!b){for(b=0;b<d-1;b++)c[b]=k[b+1]-k[b];c.sort(function(a,b){return a-b});c=c[Math.floor(d/2)];a=Math.max(a,k[0]);e=Math.min(e,k[d-1]);this.groupIntervalFactor=b=d*c/(e-a)}return b},postProcessTickInterval:function(a){var d=this.ordinalSlope;return d?this.options.breaks?this.closestPointRange:a/(d/this.closestPointRange):a}});A.prototype.ordinal2lin=A.prototype.val2lin;a(G.prototype,"pan",function(a,e){var d=this.xAxis[0],
	b=e.chartX,l=!1;if(d.options.ordinal&&d.series.length){var c=this.mouseDownX,k=d.getExtremes(),q=k.dataMax,r=k.min,h=k.max,m=this.hoverPoints,f=d.closestPointRange,c=(c-b)/(d.translationSlope*(d.ordinalSlope||f)),v={ordinalPositions:d.getExtendedPositions()},f=d.lin2val,n=d.val2lin,p;v.ordinalPositions?1<Math.abs(c)&&(m&&t(m,function(a){a.setState()}),0>c?(m=v,p=d.ordinalPositions?d:v):(m=d.ordinalPositions?d:v,p=v),v=p.ordinalPositions,q>v[v.length-1]&&v.push(q),this.fixedRange=h-r,c=d.toFixedRange(null,
	null,f.apply(m,[n.apply(m,[r,!0])+c,!0]),f.apply(p,[n.apply(p,[h,!0])+c,!0])),c.min>=Math.min(k.dataMin,r)&&c.max<=Math.max(q,h)&&d.setExtremes(c.min,c.max,!0,!1,{trigger:"pan"}),this.mouseDownX=b,H(this.container,{cursor:"move"})):l=!0}else l=!0;l&&a.apply(this,Array.prototype.slice.call(arguments,1))});m.prototype.gappedPath=function(){var a=this.options.gapSize,e=this.points.slice(),k=e.length-1;if(a&&0<k)for(;k--;)e[k+1].x-e[k].x>this.closestPointRange*a&&e.splice(k+1,0,{isNull:!0});return this.getGraphPath(e)}})(K);
	(function(a){function D(){return Array.prototype.slice.call(arguments,1)}function A(a){a.apply(this);this.drawBreaks(this.xAxis,["x"]);this.drawBreaks(this.yAxis,G(this.pointArrayMap,["y"]))}var G=a.pick,H=a.wrap,w=a.each,k=a.extend,t=a.isArray,x=a.fireEvent,p=a.Axis,m=a.Series;k(p.prototype,{isInBreak:function(a,d){var e=a.repeat||Infinity,k=a.from,b=a.to-a.from;d=d>=k?(d-k)%e:e-(k-d)%e;return a.inclusive?d<=b:d<b&&0!==d},isInAnyBreak:function(a,d){var e=this.options.breaks,k=e&&e.length,b,m,c;if(k){for(;k--;)this.isInBreak(e[k],
	a)&&(b=!0,m||(m=G(e[k].showPoints,this.isXAxis?!1:!0)));c=b&&d?b&&!m:b}return c}});H(p.prototype,"setTickPositions",function(a){a.apply(this,Array.prototype.slice.call(arguments,1));if(this.options.breaks){var d=this.tickPositions,e=this.tickPositions.info,k=[],b;for(b=0;b<d.length;b++)this.isInAnyBreak(d[b])||k.push(d[b]);this.tickPositions=k;this.tickPositions.info=e}});H(p.prototype,"init",function(a,d,l){var e=this;l.breaks&&l.breaks.length&&(l.ordinal=!1);a.call(this,d,l);a=this.options.breaks;
	e.isBroken=t(a)&&!!a.length;e.isBroken&&(e.val2lin=function(a){var b=a,c,d;for(d=0;d<e.breakArray.length;d++)if(c=e.breakArray[d],c.to<=a)b-=c.len;else if(c.from>=a)break;else if(e.isInBreak(c,a)){b-=a-c.from;break}return b},e.lin2val=function(a){var b,c;for(c=0;c<e.breakArray.length&&!(b=e.breakArray[c],b.from>=a);c++)b.to<a?a+=b.len:e.isInBreak(b,a)&&(a+=b.len);return a},e.setExtremes=function(a,d,c,e,l){for(;this.isInAnyBreak(a);)a-=this.closestPointRange;for(;this.isInAnyBreak(d);)d-=this.closestPointRange;
	p.prototype.setExtremes.call(this,a,d,c,e,l)},e.setAxisTranslation=function(a){p.prototype.setAxisTranslation.call(this,a);var b=e.options.breaks;a=[];var c=[],d=0,l,k,h=e.userMin||e.min,m=e.userMax||e.max,f=G(e.pointRangePadding,0),v,n;for(n in b)k=b[n],l=k.repeat||Infinity,e.isInBreak(k,h)&&(h+=k.to%l-h%l),e.isInBreak(k,m)&&(m-=m%l-k.from%l);for(n in b){k=b[n];v=k.from;for(l=k.repeat||Infinity;v-l>h;)v-=l;for(;v<h;)v+=l;for(;v<m;v+=l)a.push({value:v,move:"in"}),a.push({value:v+(k.to-k.from),move:"out",
	size:k.breakSize})}a.sort(function(a,b){return a.value===b.value?("in"===a.move?0:1)-("in"===b.move?0:1):a.value-b.value});b=0;v=h;for(n in a)k=a[n],b+="in"===k.move?1:-1,1===b&&"in"===k.move&&(v=k.value),0===b&&(c.push({from:v,to:k.value,len:k.value-v-(k.size||0)}),d+=k.value-v-(k.size||0));e.breakArray=c;e.unitLength=m-h-d+f;x(e,"afterBreaks");e.transA=e.options.staticScale?e.options.staticScale:(m-e.min+f)/e.unitLength*e.transA;f&&(e.minPixelPadding=e.transA*e.minPointOffset);e.min=h;e.max=m})});
	H(m.prototype,"generatePoints",function(a){a.apply(this,D(arguments));var d=this.xAxis,e=this.yAxis,k=this.points,b,m=k.length,c=this.options.connectNulls,p;if(d&&e&&(d.options.breaks||e.options.breaks))for(;m--;)b=k[m],p=null===b.y&&!1===c,p||!d.isInAnyBreak(b.x,!0)&&!e.isInAnyBreak(b.y,!0)||(k.splice(m,1),this.data[m]&&this.data[m].destroyElements())});a.Series.prototype.drawBreaks=function(a,d){var e=this,k=e.points,b,m,c,p;a&&w(d,function(d){b=a.breakArray||[];m=a.isXAxis?a.min:G(e.options.threshold,
	a.min);w(k,function(e){p=G(e["stack"+d.toUpperCase()],e[d]);w(b,function(b){c=!1;if(m<b.from&&p>b.to||m>b.from&&p<b.from)c="pointBreak";else if(m<b.from&&p>b.from&&p<b.to||m>b.from&&p>b.to&&p<b.from)c="pointInBreak";c&&x(a,c,{point:e,brk:b})})})})};H(a.seriesTypes.column.prototype,"drawPoints",A);H(a.Series.prototype,"drawPoints",A)})(K);(function(a){var D=a.arrayMax,A=a.arrayMin,G=a.Axis,H=a.defaultPlotOptions,w=a.defined,k=a.each,t=a.extend,x=a.format,p=a.isNumber,m=a.merge,e=a.pick,d=a.Point,l=
	a.Tooltip,z=a.wrap,b=a.Series.prototype,u=b.processData,c=b.generatePoints,C=b.destroy,q={approximation:"average",groupPixelWidth:2,dateTimeLabelFormats:{millisecond:["%A, %b %e, %H:%M:%S.%L","%A, %b %e, %H:%M:%S.%L","-%H:%M:%S.%L"],second:["%A, %b %e, %H:%M:%S","%A, %b %e, %H:%M:%S","-%H:%M:%S"],minute:["%A, %b %e, %H:%M","%A, %b %e, %H:%M","-%H:%M"],hour:["%A, %b %e, %H:%M","%A, %b %e, %H:%M","-%H:%M"],day:["%A, %b %e, %Y","%A, %b %e","-%A, %b %e, %Y"],week:["Week from %A, %b %e, %Y","%A, %b %e",
	"-%A, %b %e, %Y"],month:["%B %Y","%B","-%B %Y"],year:["%Y","%Y","-%Y"]}},r={line:{},spline:{},area:{},areaspline:{},column:{approximation:"sum",groupPixelWidth:10},arearange:{approximation:"range"},areasplinerange:{approximation:"range"},columnrange:{approximation:"range",groupPixelWidth:10},candlestick:{approximation:"ohlc",groupPixelWidth:10},ohlc:{approximation:"ohlc",groupPixelWidth:5}},h=a.defaultDataGroupingUnits=[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",
	[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1]],["week",[1]],["month",[1,3,6]],["year",null]],E={sum:function(a){var b=a.length,c;if(!b&&a.hasNulls)c=null;else if(b)for(c=0;b--;)c+=a[b];return c},average:function(a){var b=a.length;a=E.sum(a);p(a)&&b&&(a/=b);return a},open:function(a){return a.length?a[0]:a.hasNulls?null:void 0},high:function(a){return a.length?D(a):a.hasNulls?null:void 0},low:function(a){return a.length?A(a):a.hasNulls?null:void 0},close:function(a){return a.length?a[a.length-
	1]:a.hasNulls?null:void 0},ohlc:function(a,b,c,d){a=E.open(a);b=E.high(b);c=E.low(c);d=E.close(d);if(p(a)||p(b)||p(c)||p(d))return[a,b,c,d]},range:function(a,b){a=E.low(a);b=E.high(b);if(p(a)||p(b))return[a,b]}};b.groupData=function(a,b,c,d){var f=this.data,e=this.options.data,h=[],g=[],k=[],l=a.length,n,m,q=!!b,r=[[],[],[],[]];d="function"===typeof d?d:E[d];var v=this.pointArrayMap,y=v&&v.length,t,u=0;for(t=m=0;t<=l&&!(a[t]>=c[0]);t++);for(t;t<=l;t++){for(;(void 0!==c[u+1]&&a[t]>=c[u+1]||t===l)&&
	(n=c[u],this.dataGroupInfo={start:m,length:r[0].length},m=d.apply(this,r),void 0!==m&&(h.push(n),g.push(m),k.push(this.dataGroupInfo)),m=t,r[0]=[],r[1]=[],r[2]=[],r[3]=[],u+=1,t!==l););if(t===l)break;if(v){n=this.cropStart+t;n=f&&f[n]||this.pointClass.prototype.applyOptions.apply({series:this},[e[n]]);var w,x;for(w=0;w<y;w++)x=n[v[w]],p(x)?r[w].push(x):null===x&&(r[w].hasNulls=!0)}else n=q?b[t]:null,p(n)?r[0].push(n):null===n&&(r[0].hasNulls=!0)}return[h,g,k]};b.processData=function(){var a=this.chart,
	c=this.options.dataGrouping,d=!1!==this.allowDG&&c&&e(c.enabled,a.options.isStock),k=this.visible||!a.options.chart.ignoreHiddenSeries,l;this.forceCrop=d;this.groupPixelWidth=null;this.hasProcessed=!0;if(!1!==u.apply(this,arguments)&&d){this.destroyGroupedData();var m=this.processedXData,q=this.processedYData,g=a.plotSizeX,a=this.xAxis,r=a.options.ordinal,p=this.groupPixelWidth=a.getGroupPixelWidth&&a.getGroupPixelWidth();if(p){this.isDirty=l=!0;var t=a.getExtremes(),d=t.min,t=t.max,r=r&&a.getGroupIntervalFactor(d,
	t,this)||1,g=p*(t-d)/g*r,p=a.getTimeTicks(a.normalizeTimeTickInterval(g,c.units||h),Math.min(d,m[0]),Math.max(t,m[m.length-1]),a.options.startOfWeek,m,this.closestPointRange),m=b.groupData.apply(this,[m,q,p,c.approximation]),q=m[0],r=m[1];if(c.smoothed){c=q.length-1;for(q[c]=Math.min(q[c],t);c--&&0<c;)q[c]+=g/2;q[0]=Math.max(q[0],d)}this.currentDataGrouping=p.info;this.closestPointRange=p.info.totalRange;this.groupMap=m[2];w(q[0])&&q[0]<a.dataMin&&k&&(a.min===a.dataMin&&(a.min=q[0]),a.dataMin=q[0]);
	this.processedXData=q;this.processedYData=r}else this.currentDataGrouping=this.groupMap=null;this.hasGroupedData=l}};b.destroyGroupedData=function(){var a=this.groupedData;k(a||[],function(b,c){b&&(a[c]=b.destroy?b.destroy():null)});this.groupedData=null};b.generatePoints=function(){c.apply(this);this.destroyGroupedData();this.groupedData=this.hasGroupedData?this.points:null};z(d.prototype,"update",function(b){this.dataGroup?a.error(24):b.apply(this,[].slice.call(arguments,1))});z(l.prototype,"tooltipFooterHeaderFormatter",
	function(b,c,d){var f=c.series,e=f.tooltipOptions,h=f.options.dataGrouping,k=e.xDateFormat,g,l=f.xAxis,n=a.dateFormat;return l&&"datetime"===l.options.type&&h&&p(c.key)?(b=f.currentDataGrouping,h=h.dateTimeLabelFormats,b?(l=h[b.unitName],1===b.count?k=l[0]:(k=l[1],g=l[2])):!k&&h&&(k=this.getXDateFormat(c,e,l)),k=n(k,c.key),g&&(k+=n(g,c.key+b.totalRange-1)),x(e[(d?"footer":"header")+"Format"],{point:t(c.point,{key:k}),series:f})):b.call(this,c,d)});b.destroy=function(){for(var a=this.groupedData||
	[],b=a.length;b--;)a[b]&&a[b].destroy();C.apply(this)};z(b,"setOptions",function(a,b){a=a.call(this,b);var c=this.type,d=this.chart.options.plotOptions,e=H[c].dataGrouping;r[c]&&(e||(e=m(q,r[c])),a.dataGrouping=m(e,d.series&&d.series.dataGrouping,d[c].dataGrouping,b.dataGrouping));this.chart.options.isStock&&(this.requireSorting=!0);return a});z(G.prototype,"setScale",function(a){a.call(this);k(this.series,function(a){a.hasProcessed=!1})});G.prototype.getGroupPixelWidth=function(){var a=this.series,
	b=a.length,c,d=0,e=!1,h;for(c=b;c--;)(h=a[c].options.dataGrouping)&&(d=Math.max(d,h.groupPixelWidth));for(c=b;c--;)(h=a[c].options.dataGrouping)&&a[c].hasProcessed&&(b=(a[c].processedXData||a[c].data).length,a[c].groupPixelWidth||b>this.chart.plotSizeX/d||b&&h.forced)&&(e=!0);return e?d:0};G.prototype.setDataGrouping=function(a,b){var c;b=e(b,!0);a||(a={forced:!1,units:null});if(this instanceof G)for(c=this.series.length;c--;)this.series[c].update({dataGrouping:a},!1);else k(this.chart.options.series,
	function(b){b.dataGrouping=a},!1);b&&this.chart.redraw()}})(K);(function(a){var D=a.each,A=a.Point,G=a.seriesType,H=a.seriesTypes;G("ohlc","column",{lineWidth:1,tooltip:{pointFormat:'\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e \x3cb\x3e {series.name}\x3c/b\x3e\x3cbr/\x3eOpen: {point.open}\x3cbr/\x3eHigh: {point.high}\x3cbr/\x3eLow: {point.low}\x3cbr/\x3eClose: {point.close}\x3cbr/\x3e'},threshold:null,states:{hover:{lineWidth:3}}},{pointArrayMap:["open","high","low","close"],toYData:function(a){return[a.open,
	a.high,a.low,a.close]},pointValKey:"high",pointAttrToOptions:{stroke:"color","stroke-width":"lineWidth"},pointAttribs:function(a,k){k=H.column.prototype.pointAttribs.call(this,a,k);var t=this.options;delete k.fill;!a.options.color&&t.upColor&&a.open<a.close&&(k.stroke=t.upColor);return k},translate:function(){var a=this,k=a.yAxis,t=!!a.modifyValue,x=["plotOpen","yBottom","plotClose"];H.column.prototype.translate.apply(a);D(a.points,function(p){D([p.open,p.low,p.close],function(m,e){null!==m&&(t&&
	(m=a.modifyValue(m)),p[x[e]]=k.toPixels(m,!0))})})},drawPoints:function(){var a=this,k=a.chart;D(a.points,function(t){var x,p,m,e,d=t.graphic,l,w=!d;void 0!==t.plotY&&(d||(t.graphic=d=k.renderer.path().add(a.group)),d.attr(a.pointAttribs(t,t.selected&&"select")),p=d.strokeWidth()%2/2,l=Math.round(t.plotX)-p,m=Math.round(t.shapeArgs.width/2),e=["M",l,Math.round(t.yBottom),"L",l,Math.round(t.plotY)],null!==t.open&&(x=Math.round(t.plotOpen)+p,e.push("M",l,x,"L",l-m,x)),null!==t.close&&(x=Math.round(t.plotClose)+
	p,e.push("M",l,x,"L",l+m,x)),d[w?"attr":"animate"]({d:e}).addClass(t.getClassName(),!0))})},animate:null},{getClassName:function(){return A.prototype.getClassName.call(this)+(this.open<this.close?" highcharts-point-up":" highcharts-point-down")}})})(K);(function(a){var D=a.defaultPlotOptions,A=a.each,G=a.merge,H=a.seriesType,w=a.seriesTypes;H("candlestick","ohlc",G(D.column,{states:{hover:{lineWidth:2}},tooltip:D.ohlc.tooltip,threshold:null,lineColor:"#000000",lineWidth:1,upColor:"#ffffff"}),{pointAttribs:function(a,
	t){var k=w.column.prototype.pointAttribs.call(this,a,t),p=this.options,m=a.open<a.close,e=p.lineColor||this.color;k["stroke-width"]=p.lineWidth;k.fill=a.options.color||(m?p.upColor||this.color:this.color);k.stroke=a.lineColor||(m?p.upLineColor||e:e);t&&(a=p.states[t],k.fill=a.color||k.fill,k.stroke=a.lineColor||k.stroke,k["stroke-width"]=a.lineWidth||k["stroke-width"]);return k},drawPoints:function(){var a=this,t=a.chart;A(a.points,function(k){var p=k.graphic,m,e,d,l,w,b,u,c=!p;void 0!==k.plotY&&
	(p||(k.graphic=p=t.renderer.path().add(a.group)),p.attr(a.pointAttribs(k,k.selected&&"select")).shadow(a.options.shadow),w=p.strokeWidth()%2/2,b=Math.round(k.plotX)-w,m=k.plotOpen,e=k.plotClose,d=Math.min(m,e),m=Math.max(m,e),u=Math.round(k.shapeArgs.width/2),e=Math.round(d)!==Math.round(k.plotY),l=m!==k.yBottom,d=Math.round(d)+w,m=Math.round(m)+w,w=[],w.push("M",b-u,m,"L",b-u,d,"L",b+u,d,"L",b+u,m,"Z","M",b,d,"L",b,e?Math.round(k.plotY):d,"M",b,m,"L",b,l?Math.round(k.yBottom):m),p[c?"attr":"animate"]({d:w}).addClass(k.getClassName(),
	!0))})}})})(K);(function(a){var D=a.addEvent,A=a.each,G=a.merge,H=a.noop,w=a.Renderer,k=a.seriesType,t=a.seriesTypes,x=a.TrackerMixin,p=a.VMLRenderer,m=a.SVGRenderer.prototype.symbols;k("flags","column",{pointRange:0,shape:"flag",stackDistance:12,textAlign:"center",tooltip:{pointFormat:"{point.text}\x3cbr/\x3e"},threshold:null,y:-30,fillColor:"#ffffff",lineWidth:1,states:{hover:{lineColor:"#000000",fillColor:"#ccd6eb"}},style:{fontSize:"11px",fontWeight:"bold"}},{sorted:!1,noSharedTooltip:!0,allowDG:!1,
	takeOrdinalPosition:!1,trackerGroups:["markerGroup"],forceCrop:!0,init:a.Series.prototype.init,pointAttribs:function(a,d){var e=this.options,k=a&&a.color||this.color,b=e.lineColor,m=a&&a.lineWidth;a=a&&a.fillColor||e.fillColor;d&&(a=e.states[d].fillColor,b=e.states[d].lineColor,m=e.states[d].lineWidth);return{fill:a||k,stroke:b||k,"stroke-width":m||e.lineWidth||0}},translate:function(){t.column.prototype.translate.apply(this);var a=this.options,d=this.chart,k=this.points,m=k.length-1,b,p,c=a.onSeries;
	b=c&&d.get(c);var a=a.onKey||"y",c=b&&b.options.step,w=b&&b.points,q=w&&w.length,r=this.xAxis,h=r.getExtremes(),x=0,f,v,n;if(b&&b.visible&&q)for(x=(b.pointXOffset||0)+(b.barW||0)/2,b=b.currentDataGrouping,v=w[q-1].x+(b?b.totalRange:0),k.sort(function(a,b){return a.x-b.x}),a="plot"+a[0].toUpperCase()+a.substr(1);q--&&k[m]&&!(b=k[m],f=w[q],f.x<=b.x&&void 0!==f[a]&&(b.x<=v&&(b.plotY=f[a],f.x<b.x&&!c&&(n=w[q+1])&&void 0!==n[a]&&(b.plotY+=(b.x-f.x)/(n.x-f.x)*(n[a]-f[a]))),m--,q++,0>m)););A(k,function(a,
	b){var c;void 0===a.plotY&&(a.x>=h.min&&a.x<=h.max?a.plotY=d.chartHeight-r.bottom-(r.opposite?r.height:0)+r.offset-d.plotTop:a.shapeArgs={});a.plotX+=x;(p=k[b-1])&&p.plotX===a.plotX&&(void 0===p.stackIndex&&(p.stackIndex=0),c=p.stackIndex+1);a.stackIndex=c})},drawPoints:function(){var a=this.points,d=this.chart,k=d.renderer,m,b,p=this.options,c=p.y,t,q,r,h,w,f,v,n=this.yAxis;for(q=a.length;q--;)r=a[q],v=r.plotX>this.xAxis.len,m=r.plotX,h=r.stackIndex,t=r.options.shape||p.shape,b=r.plotY,void 0!==
	b&&(b=r.plotY+c-(void 0!==h&&h*p.stackDistance)),w=h?void 0:r.plotX,f=h?void 0:r.plotY,h=r.graphic,void 0!==b&&0<=m&&!v?(h||(h=r.graphic=k.label("",null,null,t,null,null,p.useHTML).attr(this.pointAttribs(r)).css(G(p.style,r.style)).attr({align:"flag"===t?"left":"center",width:p.width,height:p.height,"text-align":p.textAlign}).addClass("highcharts-point").add(this.markerGroup),h.shadow(p.shadow)),0<m&&(m-=h.strokeWidth()%2),h.attr({text:r.options.title||p.title||"A",x:m,y:b,anchorX:w,anchorY:f}),r.tooltipPos=
	d.inverted?[n.len+n.pos-d.plotLeft-b,this.xAxis.len-m]:[m,b+n.pos-d.plotTop]):h&&(r.graphic=h.destroy())},drawTracker:function(){var a=this.points;x.drawTrackerPoint.apply(this);A(a,function(d){var e=d.graphic;e&&D(e.element,"mouseover",function(){0<d.stackIndex&&!d.raised&&(d._y=e.y,e.attr({y:d._y-8}),d.raised=!0);A(a,function(a){a!==d&&a.raised&&a.graphic&&(a.graphic.attr({y:a._y}),a.raised=!1)})})})},animate:H,buildKDTree:H,setClip:H});m.flag=function(a,d,k,m,b){return["M",b&&b.anchorX||a,b&&b.anchorY||
	d,"L",a,d+m,a,d,a+k,d,a+k,d+m,a,d+m,"Z"]};A(["circle","square"],function(a){m[a+"pin"]=function(d,e,k,b,p){var c=p&&p.anchorX;p=p&&p.anchorY;"circle"===a&&b>k&&(d-=Math.round((b-k)/2),k=b);d=m[a](d,e,k,b);c&&p&&d.push("M",c,e>p?e:e+b,"L",c,p);return d}});w===p&&A(["flag","circlepin","squarepin"],function(a){p.prototype.symbols[a]=m[a]})})(K);(function(a){function D(a,b,c){this.init(a,b,c)}var A=a.addEvent,G=a.Axis,H=a.correctFloat,w=a.defaultOptions,k=a.defined,t=a.destroyObjectProperties,x=a.doc,
	p=a.each,m=a.fireEvent,e=a.hasTouch,d=a.isTouchDevice,l=a.merge,z=a.pick,b=a.removeEvent,u=a.wrap,c,C={height:d?20:14,barBorderRadius:0,buttonBorderRadius:0,liveRedraw:a.svg&&!d,margin:10,minWidth:6,step:.2,zIndex:3,barBackgroundColor:"#cccccc",barBorderWidth:1,barBorderColor:"#cccccc",buttonArrowColor:"#333333",buttonBackgroundColor:"#e6e6e6",buttonBorderColor:"#cccccc",buttonBorderWidth:1,rifleColor:"#333333",trackBackgroundColor:"#f2f2f2",trackBorderColor:"#f2f2f2",trackBorderWidth:1};w.scrollbar=
	l(!0,C,w.scrollbar);a.swapXY=c=function(a,b){var c=a.length,d;if(b)for(b=0;b<c;b+=3)d=a[b+1],a[b+1]=a[b+2],a[b+2]=d;return a};D.prototype={init:function(a,b,c){this.scrollbarButtons=[];this.renderer=a;this.userOptions=b;this.options=l(C,b);this.chart=c;this.size=z(this.options.size,this.options.height);b.enabled&&(this.render(),this.initEvents(),this.addEvents())},render:function(){var a=this.renderer,b=this.options,d=this.size,e;this.group=e=a.g("scrollbar").attr({zIndex:b.zIndex,translateY:-99999}).add();
	this.track=a.rect().addClass("highcharts-scrollbar-track").attr({x:0,r:b.trackBorderRadius||0,height:d,width:d}).add(e);this.track.attr({fill:b.trackBackgroundColor,stroke:b.trackBorderColor,"stroke-width":b.trackBorderWidth});this.trackBorderWidth=this.track.strokeWidth();this.track.attr({y:-this.trackBorderWidth%2/2});this.scrollbarGroup=a.g().add(e);this.scrollbar=a.rect().addClass("highcharts-scrollbar-thumb").attr({height:d,width:d,r:b.barBorderRadius||0}).add(this.scrollbarGroup);this.scrollbarRifles=
	a.path(c(["M",-3,d/4,"L",-3,2*d/3,"M",0,d/4,"L",0,2*d/3,"M",3,d/4,"L",3,2*d/3],b.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup);this.scrollbar.attr({fill:b.barBackgroundColor,stroke:b.barBorderColor,"stroke-width":b.barBorderWidth});this.scrollbarRifles.attr({stroke:b.rifleColor,"stroke-width":1});this.scrollbarStrokeWidth=this.scrollbar.strokeWidth();this.scrollbarGroup.translate(-this.scrollbarStrokeWidth%2/2,-this.scrollbarStrokeWidth%2/2);this.drawScrollbarButton(0);
	this.drawScrollbarButton(1)},position:function(a,b,c,d){var e=this.options.vertical,h=0,k=this.rendered?"animate":"attr";this.x=a;this.y=b+this.trackBorderWidth;this.width=c;this.xOffset=this.height=d;this.yOffset=h;e?(this.width=this.yOffset=c=h=this.size,this.xOffset=b=0,this.barWidth=d-2*c,this.x=a+=this.options.margin):(this.height=this.xOffset=d=b=this.size,this.barWidth=c-2*d,this.y+=this.options.margin);this.group[k]({translateX:a,translateY:this.y});this.track[k]({width:c,height:d});this.scrollbarButtons[1][k]({translateX:e?
	0:c-b,translateY:e?d-h:0})},drawScrollbarButton:function(a){var b=this.renderer,d=this.scrollbarButtons,e=this.options,f=this.size,k;k=b.g().add(this.group);d.push(k);k=b.rect().addClass("highcharts-scrollbar-button").add(k);k.attr({stroke:e.buttonBorderColor,"stroke-width":e.buttonBorderWidth,fill:e.buttonBackgroundColor});k.attr(k.crisp({x:-.5,y:-.5,width:f+1,height:f+1,r:e.buttonBorderRadius},k.strokeWidth()));k=b.path(c(["M",f/2+(a?-1:1),f/2-3,"L",f/2+(a?-1:1),f/2+3,"L",f/2+(a?2:-2),f/2],e.vertical)).addClass("highcharts-scrollbar-arrow").add(d[a]);
	k.attr({fill:e.buttonArrowColor})},setRange:function(a,b){var c=this.options,d=c.vertical,e=c.minWidth,l=this.barWidth,n,m,q=this.rendered&&!this.hasDragged?"animate":"attr";k(l)&&(a=Math.max(a,0),n=l*a,this.calculatedWidth=m=H(l*Math.min(b,1)-n),m<e&&(n=(l-e+m)*a,m=e),e=Math.floor(n+this.xOffset+this.yOffset),l=m/2-.5,this.from=a,this.to=b,d?(this.scrollbarGroup[q]({translateY:e}),this.scrollbar[q]({height:m}),this.scrollbarRifles[q]({translateY:l}),this.scrollbarTop=e,this.scrollbarLeft=0):(this.scrollbarGroup[q]({translateX:e}),
	this.scrollbar[q]({width:m}),this.scrollbarRifles[q]({translateX:l}),this.scrollbarLeft=e,this.scrollbarTop=0),12>=m?this.scrollbarRifles.hide():this.scrollbarRifles.show(!0),!1===c.showFull&&(0>=a&&1<=b?this.group.hide():this.group.show()),this.rendered=!0)},initEvents:function(){var a=this;a.mouseMoveHandler=function(b){var c=a.chart.pointer.normalize(b),d=a.options.vertical?"chartY":"chartX",e=a.initPositions;!a.grabbedCenter||b.touches&&0===b.touches[0][d]||(c=a.cursorToScrollbarPosition(c)[d],
	d=a[d],d=c-d,a.hasDragged=!0,a.updatePosition(e[0]+d,e[1]+d),a.hasDragged&&m(a,"changed",{from:a.from,to:a.to,trigger:"scrollbar",DOMType:b.type,DOMEvent:b}))};a.mouseUpHandler=function(b){a.hasDragged&&m(a,"changed",{from:a.from,to:a.to,trigger:"scrollbar",DOMType:b.type,DOMEvent:b});a.grabbedCenter=a.hasDragged=a.chartX=a.chartY=null};a.mouseDownHandler=function(b){b=a.chart.pointer.normalize(b);b=a.cursorToScrollbarPosition(b);a.chartX=b.chartX;a.chartY=b.chartY;a.initPositions=[a.from,a.to];a.grabbedCenter=
	!0};a.buttonToMinClick=function(b){var c=H(a.to-a.from)*a.options.step;a.updatePosition(H(a.from-c),H(a.to-c));m(a,"changed",{from:a.from,to:a.to,trigger:"scrollbar",DOMEvent:b})};a.buttonToMaxClick=function(b){var c=(a.to-a.from)*a.options.step;a.updatePosition(a.from+c,a.to+c);m(a,"changed",{from:a.from,to:a.to,trigger:"scrollbar",DOMEvent:b})};a.trackClick=function(b){var c=a.chart.pointer.normalize(b),d=a.to-a.from,e=a.y+a.scrollbarTop,k=a.x+a.scrollbarLeft;a.options.vertical&&c.chartY>e||!a.options.vertical&&
	c.chartX>k?a.updatePosition(a.from+d,a.to+d):a.updatePosition(a.from-d,a.to-d);m(a,"changed",{from:a.from,to:a.to,trigger:"scrollbar",DOMEvent:b})}},cursorToScrollbarPosition:function(a){var b=this.options,b=b.minWidth>this.calculatedWidth?b.minWidth:0;return{chartX:(a.chartX-this.x-this.xOffset)/(this.barWidth-b),chartY:(a.chartY-this.y-this.yOffset)/(this.barWidth-b)}},updatePosition:function(a,b){1<b&&(a=H(1-H(b-a)),b=1);0>a&&(b=H(b-a),a=0);this.from=a;this.to=b},update:function(a){this.destroy();
	this.init(this.chart.renderer,l(!0,this.options,a),this.chart)},addEvents:function(){var a=this.options.inverted?[1,0]:[0,1],b=this.scrollbarButtons,c=this.scrollbarGroup.element,d=this.mouseDownHandler,f=this.mouseMoveHandler,k=this.mouseUpHandler,a=[[b[a[0]].element,"click",this.buttonToMinClick],[b[a[1]].element,"click",this.buttonToMaxClick],[this.track.element,"click",this.trackClick],[c,"mousedown",d],[x,"mousemove",f],[x,"mouseup",k]];e&&a.push([c,"touchstart",d],[x,"touchmove",f],[x,"touchend",
	k]);p(a,function(a){A.apply(null,a)});this._events=a},removeEvents:function(){p(this._events,function(a){b.apply(null,a)});this._events=void 0},destroy:function(){var a=this.chart.scroller;this.removeEvents();p(["track","scrollbarRifles","scrollbar","scrollbarGroup","group"],function(a){this[a]&&this[a].destroy&&(this[a]=this[a].destroy())},this);a&&this===a.scrollbar&&(a.scrollbar=null,t(a.scrollbarButtons))}};u(G.prototype,"init",function(a){var b=this;a.apply(b,[].slice.call(arguments,1));b.options.scrollbar&&
	b.options.scrollbar.enabled&&(b.options.scrollbar.vertical=!b.horiz,b.options.startOnTick=b.options.endOnTick=!1,b.scrollbar=new D(b.chart.renderer,b.options.scrollbar,b.chart),A(b.scrollbar,"changed",function(a){var c=Math.min(z(b.options.min,b.min),b.min,b.dataMin),d=Math.max(z(b.options.max,b.max),b.max,b.dataMax)-c,e;b.horiz&&!b.reversed||!b.horiz&&b.reversed?(e=c+d*this.to,c+=d*this.from):(e=c+d*(1-this.from),c+=d*(1-this.to));b.setExtremes(c,e,!0,!1,a)}))});u(G.prototype,"render",function(a){var b=
	Math.min(z(this.options.min,this.min),this.min,this.dataMin),c=Math.max(z(this.options.max,this.max),this.max,this.dataMax),d=this.scrollbar,e;a.apply(this,[].slice.call(arguments,1));d&&(this.horiz?d.position(this.left,this.top+this.height+this.offset+2+(this.opposite?0:this.axisTitleMargin),this.width,this.height):d.position(this.left+this.width+2+this.offset+(this.opposite?this.axisTitleMargin:0),this.top,this.width,this.height),isNaN(b)||isNaN(c)||!k(this.min)||!k(this.max)?d.setRange(0,0):(e=
	(this.min-b)/(c-b),b=(this.max-b)/(c-b),this.horiz&&!this.reversed||!this.horiz&&this.reversed?d.setRange(e,b):d.setRange(1-b,1-e)))});u(G.prototype,"getOffset",function(a){var b=this.horiz?2:1,c=this.scrollbar;a.apply(this,[].slice.call(arguments,1));c&&(this.chart.axisOffset[b]+=c.size+c.options.margin)});u(G.prototype,"destroy",function(a){this.scrollbar&&(this.scrollbar=this.scrollbar.destroy());a.apply(this,[].slice.call(arguments,1))});a.Scrollbar=D})(K);(function(a){function D(a){this.init(a)}
	var A=a.addEvent,G=a.Axis,H=a.Chart,w=a.color,k=a.defaultOptions,t=a.defined,x=a.destroyObjectProperties,p=a.doc,m=a.each,e=a.erase,d=a.error,l=a.extend,z=a.grep,b=a.hasTouch,u=a.isNumber,c=a.isObject,C=a.merge,q=a.pick,r=a.removeEvent,h=a.Scrollbar,E=a.Series,f=a.seriesTypes,v=a.wrap,n=a.swapXY,y=[].concat(a.defaultDataGroupingUnits),L=function(a){var b=z(arguments,u);if(b.length)return Math[a].apply(0,b)};y[4]=["day",[1,2,3,4]];y[5]=["week",[1,2,3]];f=void 0===f.areaspline?"line":"areaspline";l(k,
	{navigator:{height:40,margin:25,maskInside:!0,handles:{backgroundColor:"#f2f2f2",borderColor:"#999999"},maskFill:w("#6685c2").setOpacity(.3).get(),outlineColor:"#cccccc",outlineWidth:1,series:{type:f,color:"#335cad",fillOpacity:.05,lineWidth:1,compare:null,dataGrouping:{approximation:"average",enabled:!0,groupPixelWidth:2,smoothed:!0,units:y},dataLabels:{enabled:!1,zIndex:2},id:"highcharts-navigator-series",className:"highcharts-navigator-series",lineColor:null,marker:{enabled:!1},pointRange:0,shadow:!1,
	threshold:null},xAxis:{className:"highcharts-navigator-xaxis",tickLength:0,lineWidth:0,gridLineColor:"#e6e6e6",gridLineWidth:1,tickPixelInterval:200,labels:{align:"left",style:{color:"#999999"},x:3,y:-4},crosshair:!1},yAxis:{className:"highcharts-navigator-yaxis",gridLineWidth:0,startOnTick:!1,endOnTick:!1,minPadding:.1,maxPadding:.1,labels:{enabled:!1},crosshair:!1,title:{text:null},tickLength:0,tickWidth:0}}});D.prototype={drawHandle:function(a,b,c,d){this.handles[b][d](c?{translateX:Math.round(this.left+
	this.height/2-8),translateY:Math.round(this.top+parseInt(a,10)+.5)}:{translateX:Math.round(this.left+parseInt(a,10)),translateY:Math.round(this.top+this.height/2-8)})},getHandlePath:function(a){return n(["M",-4.5,.5,"L",3.5,.5,"L",3.5,15.5,"L",-4.5,15.5,"L",-4.5,.5,"M",-1.5,4,"L",-1.5,12,"M",.5,4,"L",.5,12],a)},drawOutline:function(a,b,c,d){var g=this.navigatorOptions.maskInside,e=this.outline.strokeWidth(),f=e/2,e=e%2/2,h=this.outlineHeight,k=this.scrollbarHeight,l=this.size,n=this.left-k,m=this.top;
	c?(n-=f,c=m+b+e,b=m+a+e,a=["M",n+h,m-k-e,"L",n+h,c,"L",n,c,"L",n,b,"L",n+h,b,"L",n+h,m+l+k].concat(g?["M",n+h,c-f,"L",n+h,b+f]:[])):(a+=n+k-e,b+=n+k-e,m+=f,a=["M",n,m,"L",a,m,"L",a,m+h,"L",b,m+h,"L",b,m,"L",n+l+2*k,m].concat(g?["M",a-f,m,"L",b+f,m]:[]));this.outline[d]({d:a})},drawMasks:function(a,b,c,d){var g=this.left,e=this.top,f=this.height,h,k,l,n;c?(l=[g,g,g],n=[e,e+a,e+b],k=[f,f,f],h=[a,b-a,this.size-b]):(l=[g,g+a,g+b],n=[e,e,e],k=[a,b-a,this.size-b],h=[f,f,f]);m(this.shades,function(a,b){a[d]({x:l[b],
	y:n[b],width:k[b],height:h[b]})})},renderElements:function(){var a=this,b=a.navigatorOptions,c=b.maskInside,d=a.chart,e=d.inverted,f=d.renderer,h;a.navigatorGroup=h=f.g("navigator").attr({zIndex:8,visibility:"hidden"}).add();var k={cursor:e?"ns-resize":"ew-resize"};m([!c,c,!c],function(c,d){a.shades[d]=f.rect().addClass("highcharts-navigator-mask"+(1===d?"-inside":"-outside")).attr({fill:c?b.maskFill:"transparent"}).css(1===d&&k).add(h)});a.outline=f.path().addClass("highcharts-navigator-outline").attr({"stroke-width":b.outlineWidth,
	stroke:b.outlineColor}).add(h);m([0,1],function(c){a.handles[c]=f.path(a.getHandlePath(e)).attr({zIndex:7-c}).addClass("highcharts-navigator-handle highcharts-navigator-handle-"+["left","right"][c]).add(h);var d=b.handles;a.handles[c].attr({fill:d.backgroundColor,stroke:d.borderColor,"stroke-width":1}).css(k)})},update:function(a){this.destroy();C(!0,this.chart.options.navigator,this.options,a);this.init(this.chart)},render:function(a,b,c,d){var g=this.chart,e,f,h=this.scrollbarHeight,k,l=this.xAxis;
	e=this.navigatorEnabled;var n,m=this.rendered;f=g.inverted;var p=g.xAxis[0].minRange;if(!this.hasDragged||t(c)){if(!u(a)||!u(b))if(m)c=0,d=l.width;else return;this.left=q(l.left,g.plotLeft+h+(f?g.plotWidth:0));this.size=n=k=q(l.len,(f?g.plotHeight:g.plotWidth)-2*h);g=f?h:k+2*h;c=q(c,l.toPixels(a,!0));d=q(d,l.toPixels(b,!0));u(c)&&Infinity!==Math.abs(c)||(c=0,d=g);a=l.toValue(c,!0);b=l.toValue(d,!0);if(Math.abs(b-a)<p)if(this.grabbedLeft)c=l.toPixels(b-p,!0);else if(this.grabbedRight)d=l.toPixels(a+
	p,!0);else return;this.zoomedMax=Math.min(Math.max(c,d,0),n);this.zoomedMin=Math.min(Math.max(this.fixedWidth?this.zoomedMax-this.fixedWidth:Math.min(c,d),0),n);this.range=this.zoomedMax-this.zoomedMin;n=Math.round(this.zoomedMax);c=Math.round(this.zoomedMin);e&&(this.navigatorGroup.attr({visibility:"visible"}),m=m&&!this.hasDragged?"animate":"attr",this.drawMasks(c,n,f,m),this.drawOutline(c,n,f,m),this.drawHandle(c,0,f,m),this.drawHandle(n,1,f,m));this.scrollbar&&(f?(f=this.top-h,e=this.left-h+(e?
	0:this.height),h=k+2*h):(f=this.top+(e?this.height:-h),e=this.left-h),this.scrollbar.position(e,f,g,h),this.scrollbar.setRange(c/k,n/k));this.rendered=!0}},addMouseEvents:function(){var a=this,c=a.chart,d=c.container,e=[],f,h,k=b?["touchstart","touchmove","touchend"]:["mousedown","mousemove","mouseup"];a.mouseMoveHandler=f=function(b){a.onMouseMove(b)};a.mouseUpHandler=h=function(b){a.onMouseUp(b)};e=a.getPartsEvents(k[0]);e.push(A(d,k[1],f),A(p,k[2],h));a.eventsToUnbind=e;a.series&&a.series[0]&&
	e.push(A(a.series[0].xAxis,"foundExtremes",function(){c.navigator.modifyNavigatorAxisExtremes()}))},getPartsEvents:function(a){var b=this,c=[];m(["shades","handles"],function(d){m(b[d],function(e,g){c.push(A(e.element,a,function(a){b[d+"Mousedown"](a,g)}))})});return c},shadesMousedown:function(a,b){a=this.chart.pointer.normalize(a);var c=this.chart,d=this.xAxis,e=this.zoomedMin,f=this.left,h=this.size,k=this.range,l=a.chartX,n;c.inverted&&(l=a.chartY,f=this.top);1===b?(this.grabbedCenter=l,this.fixedWidth=
	k,this.dragOffset=l-e):(a=l-f-k/2,0===b?a=Math.max(0,a):2===b&&a+k>=h&&(a=h-k,n=this.getUnionExtremes().dataMax),a!==e&&(this.fixedWidth=k,b=d.toFixedRange(a,a+k,null,n),c.xAxis[0].setExtremes(Math.min(b.min,b.max),Math.max(b.min,b.max),!0,null,{trigger:"navigator"})))},handlesMousedown:function(a,b){this.chart.pointer.normalize(a);a=this.chart;var c=a.xAxis[0],d=a.inverted&&!c.reversed||!a.inverted&&c.reversed;0===b?(this.grabbedLeft=!0,this.otherHandlePos=this.zoomedMax,this.fixedExtreme=d?c.min:
	c.max):(this.grabbedRight=!0,this.otherHandlePos=this.zoomedMin,this.fixedExtreme=d?c.max:c.min);a.fixedRange=null},onMouseMove:function(a){var b=this,c=b.chart,d=b.left,e=b.navigatorSize,f=b.range,h=b.dragOffset,k=c.inverted;a.touches&&0===a.touches[0].pageX||(a=c.pointer.normalize(a),c=a.chartX,k&&(d=b.top,c=a.chartY),b.grabbedLeft?(b.hasDragged=!0,b.render(0,0,c-d,b.otherHandlePos)):b.grabbedRight?(b.hasDragged=!0,b.render(0,0,b.otherHandlePos,c-d)):b.grabbedCenter&&(b.hasDragged=!0,c<h?c=h:c>
	e+h-f&&(c=e+h-f),b.render(0,0,c-h,c-h+f)),b.hasDragged&&b.scrollbar&&b.scrollbar.options.liveRedraw&&(a.DOMType=a.type,setTimeout(function(){b.onMouseUp(a)},0)))},onMouseUp:function(a){var b=this.chart,c=this.xAxis,d=this.scrollbar,e,f,h=a.DOMEvent||a;(!this.hasDragged||d&&d.hasDragged)&&"scrollbar"!==a.trigger||(this.zoomedMin===this.otherHandlePos?e=this.fixedExtreme:this.zoomedMax===this.otherHandlePos&&(f=this.fixedExtreme),this.zoomedMax===this.size&&(f=this.getUnionExtremes().dataMax),c=c.toFixedRange(this.zoomedMin,
	this.zoomedMax,e,f),t(c.min)&&b.xAxis[0].setExtremes(Math.min(c.min,c.max),Math.max(c.min,c.max),!0,this.hasDragged?!1:null,{trigger:"navigator",triggerOp:"navigator-drag",DOMEvent:h}));"mousemove"!==a.DOMType&&(this.grabbedLeft=this.grabbedRight=this.grabbedCenter=this.fixedWidth=this.fixedExtreme=this.otherHandlePos=this.hasDragged=this.dragOffset=null)},removeEvents:function(){this.eventsToUnbind&&(m(this.eventsToUnbind,function(a){a()}),this.eventsToUnbind=void 0);this.removeBaseSeriesEvents()},
	removeBaseSeriesEvents:function(){var a=this.baseSeries||[];this.navigatorEnabled&&a[0]&&!1!==this.navigatorOptions.adaptToUpdatedData&&(m(a,function(a){r(a,"updatedData",this.updatedDataHandler)},this),a[0].xAxis&&r(a[0].xAxis,"foundExtremes",this.modifyBaseAxisExtremes))},init:function(a){var b=a.options,c=b.navigator,d=c.enabled,e=b.scrollbar,f=e.enabled,b=d?c.height:0,k=f?e.height:0;this.handles=[];this.shades=[];this.chart=a;this.setBaseSeries();this.height=b;this.scrollbarHeight=k;this.scrollbarEnabled=
	f;this.navigatorEnabled=d;this.navigatorOptions=c;this.scrollbarOptions=e;this.outlineHeight=b+k;this.opposite=q(c.opposite,!d&&a.inverted);var l=this,e=l.baseSeries,f=a.xAxis.length,n=a.yAxis.length,m=e&&e[0]&&e[0].xAxis||a.xAxis[0];a.extraMargin={type:l.opposite?"plotTop":"marginBottom",value:(d||!a.inverted?l.outlineHeight:0)+c.margin};a.inverted&&(a.extraMargin.type=l.opposite?"marginRight":"plotLeft");a.isDirtyBox=!0;l.navigatorEnabled?(l.xAxis=new G(a,C({breaks:m.options.breaks,ordinal:m.options.ordinal},
	c.xAxis,{id:"navigator-x-axis",yAxis:"navigator-y-axis",isX:!0,type:"datetime",index:f,offset:0,keepOrdinalPadding:!0,startOnTick:!1,endOnTick:!1,minPadding:0,maxPadding:0,zoomEnabled:!1},a.inverted?{offsets:[k,0,-k,0],width:b}:{offsets:[0,-k,0,k],height:b})),l.yAxis=new G(a,C(c.yAxis,{id:"navigator-y-axis",alignTicks:!1,offset:0,index:n,zoomEnabled:!1},a.inverted?{width:b}:{height:b})),e||c.series.data?l.addBaseSeries():0===a.series.length&&v(a,"redraw",function(b,c){0<a.series.length&&!l.series&&
	(l.setBaseSeries(),a.redraw=b);b.call(a,c)}),l.renderElements(),l.addMouseEvents()):l.xAxis={translate:function(b,c){var d=a.xAxis[0],e=d.getExtremes(),g=d.len-2*k,f=L("min",d.options.min,e.dataMin),d=L("max",d.options.max,e.dataMax)-f;return c?b*d/g+f:g*(b-f)/d},toPixels:function(a){return this.translate(a)},toValue:function(a){return this.translate(a,!0)},toFixedRange:G.prototype.toFixedRange,fake:!0};a.options.scrollbar.enabled&&(a.scrollbar=l.scrollbar=new h(a.renderer,C(a.options.scrollbar,{margin:l.navigatorEnabled?
	0:10,vertical:a.inverted}),a),A(l.scrollbar,"changed",function(b){var c=l.size,d=c*this.to,c=c*this.from;l.hasDragged=l.scrollbar.hasDragged;l.render(0,0,c,d);(a.options.scrollbar.liveRedraw||"mousemove"!==b.DOMType)&&setTimeout(function(){l.onMouseUp(b)})}));l.addBaseSeriesEvents();l.addChartEvents()},getUnionExtremes:function(a){var b=this.chart.xAxis[0],c=this.xAxis,d=c.options,e=b.options,f;a&&null===b.dataMin||(f={dataMin:q(d&&d.min,L("min",e.min,b.dataMin,c.dataMin,c.min)),dataMax:q(d&&d.max,
	L("max",e.max,b.dataMax,c.dataMax,c.max))});return f},setBaseSeries:function(a){var b=this.chart,c;a=a||b.options&&b.options.navigator.baseSeries||0;this.series&&(this.removeBaseSeriesEvents(),m(this.series,function(a){a.destroy()}));c=this.baseSeries=[];m(b.series||[],function(b,d){(b.options.showInNavigator||(d===a||b.options.id===a)&&!1!==b.options.showInNavigator)&&c.push(b)});this.xAxis&&!this.xAxis.fake&&this.addBaseSeries()},addBaseSeries:function(){var a=this,b=a.chart,c=a.series=[],d=a.baseSeries,
	e,f,h=a.navigatorOptions.series,k,l={enableMouseTracking:!1,index:null,group:"nav",padXAxis:!1,xAxis:"navigator-x-axis",yAxis:"navigator-y-axis",showInLegend:!1,stacking:!1,isInternal:!0,visible:!0};d?m(d,function(d,g){l.name="Navigator "+(g+1);e=d.options||{};k=e.navigatorOptions||{};f=C(e,l,h,k);g=k.data||h.data;a.hasNavigatorData=a.hasNavigatorData||!!g;f.data=g||e.data&&e.data.slice(0);d.navigatorSeries=b.initSeries(f);c.push(d.navigatorSeries)}):(f=C(h,l),f.data=h.data,a.hasNavigatorData=!!f.data,
	c.push(b.initSeries(f)));this.addBaseSeriesEvents()},addBaseSeriesEvents:function(){var a=this,b=a.baseSeries||[];b[0]&&b[0].xAxis&&A(b[0].xAxis,"foundExtremes",this.modifyBaseAxisExtremes);!1!==this.navigatorOptions.adaptToUpdatedData&&m(b,function(b){b.xAxis&&A(b,"updatedData",this.updatedDataHandler);A(b,"remove",function(){this.navigatorSeries&&(e(a.series,this.navigatorSeries),this.navigatorSeries.remove(!1),delete this.navigatorSeries)})},this)},modifyNavigatorAxisExtremes:function(){var a=
	this.xAxis,b;a.getExtremes&&(!(b=this.getUnionExtremes(!0))||b.dataMin===a.min&&b.dataMax===a.max||(a.min=b.dataMin,a.max=b.dataMax))},modifyBaseAxisExtremes:function(){var a=this.chart.navigator,b=this.getExtremes(),c=b.dataMin,d=b.dataMax,b=b.max-b.min,e=a.stickToMin,f=a.stickToMax,h,k,l=a.series&&a.series[0],n=!!this.setExtremes;this.eventArgs&&"rangeSelectorButton"===this.eventArgs.trigger||(e&&(k=c,h=k+b),f&&(h=d,e||(k=Math.max(h-b,l&&l.xData?l.xData[0]:-Number.MAX_VALUE))),n&&(e||f)&&u(k)&&
	(this.min=this.userMin=k,this.max=this.userMax=h));a.stickToMin=a.stickToMax=null},updatedDataHandler:function(){var a=this.chart.navigator,b=this.navigatorSeries;a.stickToMin=u(this.xAxis.min)&&this.xAxis.min<=this.xData[0];a.stickToMax=Math.round(a.zoomedMax)>=Math.round(a.size);b&&!a.hasNavigatorData&&(b.options.pointStart=this.xData[0],b.setData(this.options.data,!1,null,!1))},addChartEvents:function(){A(this.chart,"redraw",function(){var a=this.navigator,b=a&&(a.baseSeries&&a.baseSeries[0]&&
	a.baseSeries[0].xAxis||a.scrollbar&&this.xAxis[0]);b&&a.render(b.min,b.max)})},destroy:function(){this.removeEvents();this.xAxis&&(e(this.chart.xAxis,this.xAxis),e(this.chart.axes,this.xAxis));this.yAxis&&(e(this.chart.yAxis,this.yAxis),e(this.chart.axes,this.yAxis));m(this.series||[],function(a){a.destroy&&a.destroy()});m("series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered".split(" "),function(a){this[a]&&this[a].destroy&&this[a].destroy();
	this[a]=null},this);m([this.handles],function(a){x(a)},this)}};a.Navigator=D;v(G.prototype,"zoom",function(a,b,c){var d=this.chart,e=d.options,f=e.chart.zoomType,g=e.navigator,e=e.rangeSelector,h;this.isXAxis&&(g&&g.enabled||e&&e.enabled)&&("x"===f?d.resetZoomButton="blocked":"y"===f?h=!1:"xy"===f&&(d=this.previousZoom,t(b)?this.previousZoom=[this.min,this.max]:d&&(b=d[0],c=d[1],delete this.previousZoom)));return void 0!==h?h:a.call(this,b,c)});v(H.prototype,"init",function(a,b,c){A(this,"beforeRender",
	function(){var a=this.options;if(a.navigator.enabled||a.scrollbar.enabled)this.scroller=this.navigator=new D(this)});a.call(this,b,c)});v(H.prototype,"setChartSize",function(a){var b=this.legend,c=this.navigator,d,e,f,h;a.apply(this,[].slice.call(arguments,1));c&&(e=b.options,f=c.xAxis,h=c.yAxis,d=c.scrollbarHeight,this.inverted?(c.left=c.opposite?this.chartWidth-d-c.height:this.spacing[3]+d,c.top=this.plotTop+d):(c.left=this.plotLeft+d,c.top=c.navigatorOptions.top||this.chartHeight-c.height-d-this.spacing[2]-
	("bottom"===e.verticalAlign&&e.enabled&&!e.floating?b.legendHeight+q(e.margin,10):0)),f&&h&&(this.inverted?f.options.left=h.options.left=c.left:f.options.top=h.options.top=c.top,f.setAxisSize(),h.setAxisSize()))});v(E.prototype,"addPoint",function(a,b,e,f,h){var g=this.options.turboThreshold;g&&this.xData.length>g&&c(b,!0)&&this.chart.navigator&&d(20,!0);a.call(this,b,e,f,h)});v(H.prototype,"addSeries",function(a,b,c,d){a=a.call(this,b,!1,d);this.navigator&&this.navigator.setBaseSeries();q(c,!0)&&
	this.redraw();return a});v(E.prototype,"update",function(a,b,c){a.call(this,b,!1);this.chart.navigator&&this.chart.navigator.setBaseSeries();q(c,!0)&&this.chart.redraw()});H.prototype.callbacks.push(function(a){var b=a.navigator;b&&(a=a.xAxis[0].getExtremes(),b.render(a.min,a.max))})})(K);(function(a){function D(a){this.init(a)}var A=a.addEvent,G=a.Axis,H=a.Chart,w=a.css,k=a.createElement,t=a.dateFormat,x=a.defaultOptions,p=x.global.useUTC,m=a.defined,e=a.destroyObjectProperties,d=a.discardElement,
	l=a.each,z=a.extend,b=a.fireEvent,u=a.Date,c=a.isNumber,C=a.merge,q=a.pick,r=a.pInt,h=a.splat,E=a.wrap;z(x,{rangeSelector:{buttonTheme:{"stroke-width":0,width:28,height:18,padding:2,zIndex:7},height:35,inputPosition:{align:"right"},labelStyle:{color:"#666666"}}});x.lang=C(x.lang,{rangeSelectorZoom:"Zoom",rangeSelectorFrom:"From",rangeSelectorTo:"To"});D.prototype={clickButton:function(a,b){var d=this,e=d.chart,f=d.buttonOptions[a],k=e.xAxis[0],m=e.scroller&&e.scroller.getUnionExtremes()||k||{},g=
	m.dataMin,r=m.dataMax,t,v=k&&Math.round(Math.min(k.max,q(r,k.max))),u=f.type,w,m=f._range,x,z,C,D=f.dataGrouping;if(null!==g&&null!==r){e.fixedRange=m;D&&(this.forcedDataGrouping=!0,G.prototype.setDataGrouping.call(k||{chart:this.chart},D,!1));if("month"===u||"year"===u)k?(u={range:f,max:v,dataMin:g,dataMax:r},t=k.minFromRange.call(u),c(u.newMax)&&(v=u.newMax)):m=f;else if(m)t=Math.max(v-m,g),v=Math.min(t+m,r);else if("ytd"===u)if(k)void 0===r&&(g=Number.MAX_VALUE,r=Number.MIN_VALUE,l(e.series,function(a){a=
	a.xData;g=Math.min(a[0],g);r=Math.max(a[a.length-1],r)}),b=!1),v=d.getYTDExtremes(r,g,p),t=x=v.min,v=v.max;else{A(e,"beforeRender",function(){d.clickButton(a)});return}else"all"===u&&k&&(t=g,v=r);d.setSelected(a);k?k.setExtremes(t,v,q(b,1),null,{trigger:"rangeSelectorButton",rangeSelectorButton:f}):(w=h(e.options.xAxis)[0],C=w.range,w.range=m,z=w.min,w.min=x,A(e,"load",function(){w.range=C;w.min=z}))}},setSelected:function(a){this.selected=this.options.selected=a},defaultButtons:[{type:"month",count:1,
	text:"1m"},{type:"month",count:3,text:"3m"},{type:"month",count:6,text:"6m"},{type:"ytd",text:"YTD"},{type:"year",count:1,text:"1y"},{type:"all",text:"All"}],init:function(a){var c=this,d=a.options.rangeSelector,e=d.buttons||[].concat(c.defaultButtons),f=d.selected,h=function(){var a=c.minInput,d=c.maxInput;a&&a.blur&&b(a,"blur");d&&d.blur&&b(d,"blur")};c.chart=a;c.options=d;c.buttons=[];a.extraTopMargin=d.height;c.buttonOptions=e;this.unMouseDown=A(a.container,"mousedown",h);this.unResize=A(a,"resize",
	h);l(e,c.computeButtonRange);void 0!==f&&e[f]&&this.clickButton(f,!1);A(a,"load",function(){A(a.xAxis[0],"setExtremes",function(b){this.max-this.min!==a.fixedRange&&"rangeSelectorButton"!==b.trigger&&"updatedData"!==b.trigger&&c.forcedDataGrouping&&this.setDataGrouping(!1,!1)})})},updateButtonStates:function(){var a=this.chart,b=a.xAxis[0],d=Math.round(b.max-b.min),e=!b.hasVisibleSeries,a=a.scroller&&a.scroller.getUnionExtremes()||b,h=a.dataMin,k=a.dataMax,a=this.getYTDExtremes(k,h,p),m=a.min,g=a.max,
	q=this.selected,r=c(q),t=this.options.allButtonsEnabled,u=this.buttons;l(this.buttonOptions,function(a,c){var f=a._range,l=a.type,n=a.count||1;a=u[c];var p=0;c=c===q;var v=f>k-h,y=f<b.minRange,w=!1,x=!1,f=f===d;("month"===l||"year"===l)&&d>=864E5*{month:28,year:365}[l]*n&&d<=864E5*{month:31,year:366}[l]*n?f=!0:"ytd"===l?(f=g-m===d,w=!c):"all"===l&&(f=b.max-b.min>=k-h,x=!c&&r&&f);l=!t&&(v||y||x||e);f=c&&f||f&&!r&&!w;l?p=3:f&&(r=!0,p=2);a.state!==p&&a.setState(p)})},computeButtonRange:function(a){var b=
	a.type,c=a.count||1,d={millisecond:1,second:1E3,minute:6E4,hour:36E5,day:864E5,week:6048E5};if(d[b])a._range=d[b]*c;else if("month"===b||"year"===b)a._range=864E5*{month:30,year:365}[b]*c},setInputValue:function(a,b){var c=this.chart.options.rangeSelector,d=this[a+"Input"];m(b)&&(d.previousValue=d.HCTime,d.HCTime=b);d.value=t(c.inputEditDateFormat||"%Y-%m-%d",d.HCTime);this[a+"DateBox"].attr({text:t(c.inputDateFormat||"%b %e, %Y",d.HCTime)})},showInput:function(a){var b=this.inputGroup,c=this[a+"DateBox"];
	w(this[a+"Input"],{left:b.translateX+c.x+"px",top:b.translateY+"px",width:c.width-2+"px",height:c.height-2+"px",border:"2px solid silver"})},hideInput:function(a){w(this[a+"Input"],{border:0,width:"1px",height:"1px"});this.setInputValue(a)},drawInput:function(a){function b(){var a=q.value,b=(l.inputDateParser||Date.parse)(a),f=e.xAxis[0],g=e.scroller&&e.scroller.xAxis?e.scroller.xAxis:f,h=g.dataMin,g=g.dataMax;b!==q.previousValue&&(q.previousValue=b,c(b)||(b=a.split("-"),b=Date.UTC(r(b[0]),r(b[1])-
	1,r(b[2]))),c(b)&&(p||(b+=6E4*(new Date).getTimezoneOffset()),m?b>d.maxInput.HCTime?b=void 0:b<h&&(b=h):b<d.minInput.HCTime?b=void 0:b>g&&(b=g),void 0!==b&&f.setExtremes(m?b:f.min,m?f.max:b,void 0,void 0,{trigger:"rangeSelectorInput"})))}var d=this,e=d.chart,f=e.renderer.style||{},h=e.renderer,l=e.options.rangeSelector,g=d.div,m="min"===a,q,t,u=this.inputGroup;this[a+"Label"]=t=h.label(x.lang[m?"rangeSelectorFrom":"rangeSelectorTo"],this.inputGroup.offset).addClass("highcharts-range-label").attr({padding:2}).add(u);
	u.offset+=t.width+5;this[a+"DateBox"]=h=h.label("",u.offset).addClass("highcharts-range-input").attr({padding:2,width:l.inputBoxWidth||90,height:l.inputBoxHeight||17,stroke:l.inputBoxBorderColor||"#cccccc","stroke-width":1,"text-align":"center"}).on("click",function(){d.showInput(a);d[a+"Input"].focus()}).add(u);u.offset+=h.width+(m?10:0);this[a+"Input"]=q=k("input",{name:a,className:"highcharts-range-selector",type:"text"},{top:e.plotTop+"px"},g);t.css(C(f,l.labelStyle));h.css(C({color:"#333333"},
	f,l.inputStyle));w(q,z({position:"absolute",border:0,width:"1px",height:"1px",padding:0,textAlign:"center",fontSize:f.fontSize,fontFamily:f.fontFamily,left:"-9em"},l.inputStyle));q.onfocus=function(){d.showInput(a)};q.onblur=function(){d.hideInput(a)};q.onchange=b;q.onkeypress=function(a){13===a.keyCode&&b()}},getPosition:function(){var a=this.chart,b=a.options.rangeSelector,a=q((b.buttonPosition||{}).y,a.plotTop-a.axisOffset[0]-b.height);return{buttonTop:a,inputTop:a-10}},getYTDExtremes:function(a,
	b,c){var d=new u(a),e=d[u.hcGetFullYear]();c=c?u.UTC(e,0,1):+new u(e,0,1);b=Math.max(b||0,c);d=d.getTime();return{max:Math.min(a||d,d),min:b}},render:function(a,b){var c=this,d=c.chart,e=d.renderer,f=d.container,h=d.options,g=h.exporting&&!1!==h.exporting.enabled&&h.navigation&&h.navigation.buttonOptions,p=h.rangeSelector,r=c.buttons,h=x.lang,t=c.div,t=c.inputGroup,u=p.buttonTheme,v=p.buttonPosition||{},w=p.inputEnabled,A=u&&u.states,C=d.plotLeft,D,E=this.getPosition(),G=c.group,H=c.rendered;!1!==
	p.enabled&&(H||(c.group=G=e.g("range-selector-buttons").add(),c.zoomText=e.text(h.rangeSelectorZoom,q(v.x,C),15).css(p.labelStyle).add(G),D=q(v.x,C)+c.zoomText.getBBox().width+5,l(c.buttonOptions,function(a,b){r[b]=e.button(a.text,D,0,function(){c.clickButton(b);c.isActive=!0},u,A&&A.hover,A&&A.select,A&&A.disabled).attr({"text-align":"center"}).add(G);D+=r[b].width+q(p.buttonSpacing,5)}),!1!==w&&(c.div=t=k("div",null,{position:"relative",height:0,zIndex:1}),f.parentNode.insertBefore(t,f),c.inputGroup=
	t=e.g("input-group").add(),t.offset=0,c.drawInput("min"),c.drawInput("max"))),c.updateButtonStates(),G[H?"animate":"attr"]({translateY:E.buttonTop}),!1!==w&&(t.align(z({y:E.inputTop,width:t.offset,x:g&&E.inputTop<(g.y||0)+g.height-d.spacing[0]?-40:0},p.inputPosition),!0,d.spacingBox),m(w)||(d=G.getBBox(),t[t.alignAttr.translateX<d.x+d.width+10?"hide":"show"]()),c.setInputValue("min",a),c.setInputValue("max",b)),c.rendered=!0)},update:function(a){var b=this.chart;C(!0,b.options.rangeSelector,a);this.destroy();
	this.init(b)},destroy:function(){var a=this.minInput,b=this.maxInput,c;this.unMouseDown();this.unResize();e(this.buttons);a&&(a.onfocus=a.onblur=a.onchange=null);b&&(b.onfocus=b.onblur=b.onchange=null);for(c in this)this[c]&&"chart"!==c&&(this[c].destroy?this[c].destroy():this[c].nodeType&&d(this[c])),this[c]!==D.prototype[c]&&(this[c]=null)}};G.prototype.toFixedRange=function(a,b,d,e){var f=this.chart&&this.chart.fixedRange;a=q(d,this.translate(a,!0,!this.horiz));b=q(e,this.translate(b,!0,!this.horiz));
	d=f&&(b-a)/f;.7<d&&1.3>d&&(e?a=b-f:b=a+f);c(a)||(a=b=void 0);return{min:a,max:b}};G.prototype.minFromRange=function(){var a=this.range,b={month:"Month",year:"FullYear"}[a.type],d,e=this.max,h,k,l=function(a,c){var d=new Date(a);d["set"+b](d["get"+b]()+c);return d.getTime()-a};c(a)?(d=e-a,k=a):(d=e+l(e,-a.count),this.chart&&(this.chart.fixedRange=e-d));h=q(this.dataMin,Number.MIN_VALUE);c(d)||(d=h);d<=h&&(d=h,void 0===k&&(k=l(d,a.count)),this.newMax=Math.min(d+k,this.dataMax));c(e)||(d=void 0);return d};
	E(H.prototype,"init",function(a,b,c){A(this,"init",function(){this.options.rangeSelector.enabled&&(this.rangeSelector=new D(this))});a.call(this,b,c)});H.prototype.callbacks.push(function(a){function b(){d=a.xAxis[0].getExtremes();c(d.min)&&e.render(d.min,d.max)}var d,e=a.rangeSelector,f,h;e&&(h=A(a.xAxis[0],"afterSetExtremes",function(a){e.render(a.min,a.max)}),f=A(a,"redraw",b),b());A(a,"destroy",function(){e&&(f(),h())})});a.RangeSelector=D})(K);(function(a){var D=a.arrayMax,A=a.arrayMin,G=a.Axis,
	H=a.Chart,w=a.defined,k=a.each,t=a.extend,x=a.format,p=a.inArray,m=a.isNumber,e=a.isString,d=a.map,l=a.merge,z=a.pick,b=a.Point,u=a.Renderer,c=a.Series,C=a.splat,q=a.SVGRenderer,r=a.VMLRenderer,h=a.wrap,E=c.prototype,f=E.init,v=E.processData,n=b.prototype.tooltipFormatter;a.StockChart=a.stockChart=function(b,c,f){var h=e(b)||b.nodeName,g=arguments[h?1:0],k=g.series,m=a.getOptions(),n,p=z(g.navigator&&g.navigator.enabled,m.navigator.enabled,!0),q=p?{startOnTick:!1,endOnTick:!1}:null,r={marker:{enabled:!1,
	radius:2}},t={shadow:!1,borderWidth:0};g.xAxis=d(C(g.xAxis||{}),function(a){return l({minPadding:0,maxPadding:0,ordinal:!0,title:{text:null},labels:{overflow:"justify"},showLastLabel:!0},m.xAxis,a,{type:"datetime",categories:null},q)});g.yAxis=d(C(g.yAxis||{}),function(a){n=z(a.opposite,!0);return l({labels:{y:-2},opposite:n,showLastLabel:!1,title:{text:null}},m.yAxis,a)});g.series=null;g=l({chart:{panning:!0,pinchType:"x"},navigator:{enabled:p},scrollbar:{enabled:z(m.scrollbar.enabled,!0)},rangeSelector:{enabled:z(m.rangeSelector.enabled,
	!0)},title:{text:null},tooltip:{shared:!0,crosshairs:!0},legend:{enabled:!1},plotOptions:{line:r,spline:r,area:r,areaspline:r,arearange:r,areasplinerange:r,column:t,columnrange:t,candlestick:t,ohlc:t}},g,{isStock:!0});g.series=k;return h?new H(b,g,f):new H(g,c)};h(G.prototype,"autoLabelAlign",function(a){var b=this.chart,c=this.options,b=b._labelPanes=b._labelPanes||{},d=this.options.labels;return this.chart.options.isStock&&"yAxis"===this.coll&&(c=c.top+","+c.height,!b[c]&&d.enabled)?(15===d.x&&
	(d.x=0),void 0===d.align&&(d.align="right"),b[c]=this,"right"):a.call(this,[].slice.call(arguments,1))});h(G.prototype,"destroy",function(a){var b=this.chart,c=this.options&&this.options.top+","+this.options.height;c&&b._labelPanes&&b._labelPanes[c]===this&&delete b._labelPanes[c];return a.call(this,Array.prototype.slice.call(arguments,1))});h(G.prototype,"getPlotLinePath",function(a,b,c,f,g,h){var l=this,n=this.isLinked&&!this.series?this.linkedParent.series:this.series,q=l.chart,r=q.renderer,t=
	l.left,u=l.top,v,x,y,A,F=[],D=[],C,E;if("colorAxis"===l.coll)return a.apply(this,[].slice.call(arguments,1));D=function(a){var b="xAxis"===a?"yAxis":"xAxis";a=l.options[b];return m(a)?[q[b][a]]:e(a)?[q.get(a)]:d(n,function(a){return a[b]})}(l.coll);k(l.isXAxis?q.yAxis:q.xAxis,function(a){if(w(a.options.id)?-1===a.options.id.indexOf("navigator"):1){var b=a.isXAxis?"yAxis":"xAxis",b=w(a.options[b])?q[b][a.options[b]]:q[b][0];l===b&&D.push(a)}});C=D.length?[]:[l.isXAxis?q.yAxis[0]:q.xAxis[0]];k(D,function(a){-1===
	p(a,C)&&C.push(a)});E=z(h,l.translate(b,null,null,f));m(E)&&(l.horiz?k(C,function(a){var b;x=a.pos;A=x+a.len;v=y=Math.round(E+l.transB);if(v<t||v>t+l.width)g?v=y=Math.min(Math.max(t,v),t+l.width):b=!0;b||F.push("M",v,x,"L",y,A)}):k(C,function(a){var b;v=a.pos;y=v+a.len;x=A=Math.round(u+l.height-E);if(x<u||x>u+l.height)g?x=A=Math.min(Math.max(u,x),l.top+l.height):b=!0;b||F.push("M",v,x,"L",y,A)}));return 0<F.length?r.crispPolyLine(F,c||1):null});G.prototype.getPlotBandPath=function(a,b){b=this.getPlotLinePath(b,
	null,null,!0);a=this.getPlotLinePath(a,null,null,!0);var c=[],d;if(a&&b)if(a.toString()===b.toString())c=a,c.flat=!0;else for(d=0;d<a.length;d+=6)c.push("M",a[d+1],a[d+2],"L",a[d+4],a[d+5],b[d+4],b[d+5],b[d+1],b[d+2],"z");else c=null;return c};q.prototype.crispPolyLine=function(a,b){var c;for(c=0;c<a.length;c+=6)a[c+1]===a[c+4]&&(a[c+1]=a[c+4]=Math.round(a[c+1])-b%2/2),a[c+2]===a[c+5]&&(a[c+2]=a[c+5]=Math.round(a[c+2])+b%2/2);return a};u===r&&(r.prototype.crispPolyLine=q.prototype.crispPolyLine);
	h(G.prototype,"hideCrosshair",function(a,b){a.call(this,b);this.crossLabel&&(this.crossLabel=this.crossLabel.hide())});h(G.prototype,"drawCrosshair",function(a,b,c){var d,e;a.call(this,b,c);if(w(this.crosshair.label)&&this.crosshair.label.enabled&&this.cross){a=this.chart;var f=this.options.crosshair.label,h=this.horiz;d=this.opposite;e=this.left;var k=this.top,l=this.crossLabel,m,n=f.format,p="",q="inside"===this.options.tickPosition,r=!1!==this.crosshair.snap,u=0;b||(b=this.cross&&this.cross.e);
	m=h?"center":d?"right"===this.labelAlign?"right":"left":"left"===this.labelAlign?"left":"center";l||(l=this.crossLabel=a.renderer.label(null,null,null,f.shape||"callout").addClass("highcharts-crosshair-label"+(this.series[0]&&" highcharts-color-"+this.series[0].colorIndex)).attr({align:f.align||m,padding:z(f.padding,8),r:z(f.borderRadius,3),zIndex:2}).add(this.labelGroup),l.attr({fill:f.backgroundColor||this.series[0]&&this.series[0].color||"#666666",stroke:f.borderColor||"","stroke-width":f.borderWidth||
	0}).css(t({color:"#ffffff",fontWeight:"normal",fontSize:"11px",textAlign:"center"},f.style)));h?(m=r?c.plotX+e:b.chartX,k+=d?0:this.height):(m=d?this.width+e:0,k=r?c.plotY+k:b.chartY);n||f.formatter||(this.isDatetimeAxis&&(p="%b %d, %Y"),n="{value"+(p?":"+p:"")+"}");b=r?c[this.isXAxis?"x":"y"]:this.toValue(h?b.chartX:b.chartY);l.attr({text:n?x(n,{value:b}):f.formatter.call(this,b),x:m,y:k,visibility:"visible"});b=l.getBBox();if(h){if(q&&!d||!q&&d)k=l.y-b.height}else k=l.y-b.height/2;h?(d=e-b.x,e=
	e+this.width-b.x):(d="left"===this.labelAlign?e:0,e="right"===this.labelAlign?e+this.width:a.chartWidth);l.translateX<d&&(u=d-l.translateX);l.translateX+b.width>=e&&(u=-(l.translateX+b.width-e));l.attr({x:m+u,y:k,anchorX:h?m:this.opposite?0:a.chartWidth,anchorY:h?this.opposite?a.chartHeight:0:k+b.height/2})}});E.init=function(){f.apply(this,arguments);this.setCompare(this.options.compare)};E.setCompare=function(a){this.modifyValue="value"===a||"percent"===a?function(b,c){var d=this.compareValue;if(void 0!==
	b&&void 0!==d)return b="value"===a?b-d:b/d*100-(100===this.options.compareBase?0:100),c&&(c.change=b),b}:null;this.userOptions.compare=a;this.chart.hasRendered&&(this.isDirty=!0)};E.processData=function(){var a,b=-1,c,d,e,f;v.apply(this,arguments);if(this.xAxis&&this.processedYData)for(c=this.processedXData,d=this.processedYData,e=d.length,this.pointArrayMap&&(b=p("close",this.pointArrayMap),-1===b&&(b=p(this.pointValKey||"y",this.pointArrayMap))),a=0;a<e-1;a++)if(f=-1<b?d[a][b]:d[a],m(f)&&c[a+1]>=
	this.xAxis.min&&0!==f){this.compareValue=f;break}};h(E,"getExtremes",function(a){var b;a.apply(this,[].slice.call(arguments,1));this.modifyValue&&(b=[this.modifyValue(this.dataMin),this.modifyValue(this.dataMax)],this.dataMin=A(b),this.dataMax=D(b))});G.prototype.setCompare=function(a,b){this.isXAxis||(k(this.series,function(b){b.setCompare(a)}),z(b,!0)&&this.chart.redraw())};b.prototype.tooltipFormatter=function(b){b=b.replace("{point.change}",(0<this.change?"+":"")+a.numberFormat(this.change,z(this.series.tooltipOptions.changeDecimals,
	2)));return n.apply(this,[b])};h(c.prototype,"render",function(a){this.chart.is3d&&this.chart.is3d()||this.chart.polar||!this.xAxis||this.xAxis.isRadial||(!this.clipBox&&this.animate?(this.clipBox=l(this.chart.clipBox),this.clipBox.width=this.xAxis.len,this.clipBox.height=this.yAxis.len):this.chart[this.sharedClipKey]?this.chart[this.sharedClipKey].attr({width:this.xAxis.len,height:this.yAxis.len}):this.clipBox&&(this.clipBox.width=this.xAxis.len,this.clipBox.height=this.yAxis.len));a.call(this)})})(K);
	return K});


/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var localize = __webpack_require__(428).localize;

	var HighchartUI = function () {
	    var common_time_style = void 0,
	        common_spot_style = void 0,
	        txt = void 0,
	        chart_options = void 0;

	    var initLabels = function initLabels() {
	        common_time_style = 'margin-bottom: 3px; margin-left: 10px; height: 0; width: 20px; border: 0; border-bottom: 2px; border-color: #e98024; display: inline-block;';
	        common_spot_style = 'margin-left: 10px; display: inline-block; border-radius: 6px;';
	    };

	    var getLabels = function getLabels(option) {
	        if (!common_time_style || !common_spot_style) {
	            initLabels();
	        }
	        switch (option) {
	            case 'start_time':
	                return '<div style="' + common_time_style + ' border-style: solid;"></div> ' + localize('Start time') + ' ';
	            case 'entry_spot':
	                return '<div style="' + common_spot_style + ' border: 3px solid orange; width: 4px; height: 4px;"></div> ' + localize('Entry spot') + ' ';
	            case 'exit_spot':
	                return '<div style="' + common_spot_style + ' background-color: orange; width:10px; height: 10px;"></div> ' + localize('Exit spot') + ' ';
	            case 'end_time':
	                return '<div style="' + common_time_style + ' border-style: dashed;"></div> ' + localize('End time') + ' ';
	            case 'delay':
	                return '<span class="chart-delay"> ' + localize('Charting for this underlying is delayed') + ' </span>';
	            default:
	                return null;
	        }
	    };

	    var setLabels = function setLabels(chart_delayed) {
	        // display a guide for clients to know how we are marking entry and exit spots
	        txt = (chart_delayed ? getLabels('delay') : '') + getLabels('start_time') + (history ? getLabels('entry_spot') + getLabels('exit_spot') : '') + getLabels('end_time');
	    };

	    var setChartOptions = function setChartOptions(params) {
	        chart_options = {
	            chart: {
	                backgroundColor: null, /* make background transparent */
	                height: Math.max(params.height, 450),
	                renderTo: params.el,
	                animation: false,
	                marginLeft: 30,
	                marginRight: 30
	            },
	            title: {
	                text: params.title,
	                style: { fontSize: '16px' }
	            },
	            credits: { enabled: false },
	            tooltip: {
	                xDateFormat: params.JPClient ? '%Y/%m/%d, %H:%M:%S' : '%A, %b %e, %H:%M:%S GMT',
	                valueDecimals: params.decimals.split('.')[1].length || 3
	            },
	            subtitle: {
	                text: txt,
	                useHTML: true
	            },
	            xAxis: {
	                labels: { overflow: 'justify', format: '{value:%H:%M:%S}' }
	            },
	            yAxis: {
	                opposite: false,
	                labels: { align: 'left' }
	            },
	            series: [{
	                type: params.type,
	                name: params.title,
	                data: params.data,
	                // zones are used to display color of the line
	                zones: [{
	                    // make the line grey until it reaches entry time or start time if entry spot time is not yet known
	                    value: params.entry_time,
	                    color: '#ccc'
	                }, {
	                    // make the line default color until exit time is reached
	                    value: params.exit_time,
	                    color: ''
	                }, {
	                    // make the line grey again after trade ended
	                    color: '#ccc'
	                }],
	                zoneAxis: 'x',
	                cropThreshold: Infinity,
	                softThreshold: false,
	                turboThreshold: Infinity,
	                connectNulls: true
	            }],
	            exporting: { enabled: false },
	            plotOptions: {
	                line: {
	                    marker: { radius: 2, enabled: true }
	                },
	                candlestick: {
	                    lineColor: 'black',
	                    color: 'red',
	                    upColor: 'green',
	                    upLineColor: 'black',
	                    shadow: true
	                }
	            },
	            rangeSelector: { enabled: false }
	        };
	        if (params.user_sold) {
	            chart_options.series[0].zones.pop();
	        }
	    };

	    var getHighchartOptions = function getHighchartOptions(JPClient) {
	        return {
	            // use comma as separator instead of space
	            lang: { thousandsSep: ',' },
	            global: {
	                timezoneOffset: JPClient ? -9 * 60 : 0 }
	        };
	    };

	    var replaceExitLabelWithSell = function replaceExitLabelWithSell(subtitle) {
	        var subtitle_length = subtitle.childNodes.length;
	        var textnode = document.createTextNode(' ' + localize('Sell time') + ' ');
	        for (var i = 0; i < subtitle_length; i++) {
	            var item = subtitle.childNodes[i];
	            if (/End time/.test(item.nodeValue)) {
	                subtitle.replaceChild(textnode, item);
	            }
	        }
	    };

	    var getPlotlineOptions = function getPlotlineOptions(params, type) {
	        var is_plotx = type === 'x';
	        var options = {
	            value: params.value,
	            id: params.id || (is_plotx ? params.value : params.label),
	            label: { text: params.label || '' },
	            color: params.color || (is_plotx ? '#e98024' : 'green'),
	            zIndex: is_plotx ? 2 : 1,
	            width: params.width || 2,
	            dashStyle: params.dashStyle || 'Solid'
	        };

	        if (is_plotx) {
	            options.label.x = params.textLeft ? -15 : 5;
	        } else {
	            options.label.align = 'center';
	        }

	        return options;
	    };

	    var showError = function showError(type, message) {
	        $('#analysis_live_chart').html($('<p/>', { class: 'error-msg', text: type === 'missing' ? localize('Ticks history returned an empty array.') : message }));
	    };

	    var getMarkerObject = function getMarkerObject(type) {
	        var color = type === 'entry' ? 'white' : 'orange';
	        return { fillColor: color, lineColor: 'orange', lineWidth: 3, radius: 4, states: { hover: { fillColor: color, lineColor: 'orange', lineWidth: 3, radius: 4 } } };
	    };

	    return {
	        setLabels: setLabels,
	        getLabels: getLabels,
	        setChartOptions: setChartOptions,
	        getChartOptions: function getChartOptions() {
	            return chart_options;
	        },
	        getHighchartOptions: getHighchartOptions,
	        replaceExitLabelWithSell: replaceExitLabelWithSell,
	        getPlotlineOptions: getPlotlineOptions,
	        showError: showError,
	        getMarkerObject: getMarkerObject
	    };
	}();

	module.exports = HighchartUI;

/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Barriers = __webpack_require__(442);
	var Barriers_Beta = __webpack_require__(450);
	var DigitInfo_Beta = __webpack_require__(452);
	var Purchase_Beta = __webpack_require__(455);
	var TickDisplay_Beta = __webpack_require__(456);
	var updateWarmChart = __webpack_require__(445).updateWarmChart;
	var DigitInfo = __webpack_require__(457);
	var Defaults = __webpack_require__(437);
	var getActiveTab = __webpack_require__(458).getActiveTab;
	var getActiveTab_Beta = __webpack_require__(458).getActiveTab_Beta;
	var Purchase = __webpack_require__(459);
	var Tick = __webpack_require__(448);
	var TickDisplay = __webpack_require__(460);
	var MBDefaults = __webpack_require__(416);
	var MBTick = __webpack_require__(462);
	var BinarySocket = __webpack_require__(427);
	var State = __webpack_require__(421).State;

	var GetTicks = function () {
	    var underlying = void 0;

	    var request = function request(symbol, req, _callback) {
	        underlying = State.get('is_mb_trading') ? MBDefaults.get('underlying') : Defaults.get('underlying');
	        if (underlying && req && _callback && (underlying !== req.ticks_history || !req.subscribe)) {
	            BinarySocket.send(req, { callback: _callback });
	        } else {
	            if (!req || req.subscribe) {
	                BinarySocket.send({ forget_all: 'ticks' });
	                BinarySocket.send({ forget_all: 'candles' });
	            }
	            BinarySocket.send(req || {
	                ticks_history: symbol,
	                style: 'ticks',
	                end: 'latest',
	                count: 20,
	                subscribe: 1
	            }, {
	                callback: function callback(response) {
	                    var type = response.msg_type;
	                    var is_digit = getActiveTab() === 'tab_last_digit';
	                    var is_digit_beta = getActiveTab_Beta() === 'tab_last_digit';
	                    if (typeof _callback === 'function') {
	                        _callback(response);
	                    }
	                    if (State.get('is_mb_trading')) {
	                        MBTick.processTickHistory(response);
	                        return;
	                    }
	                    if (type === 'tick') {
	                        if (State.get('is_trading')) {
	                            processTick(response);
	                            if (is_digit) {
	                                DigitInfo.updateChart(response);
	                            }
	                        } else if (State.get('is_beta_trading')) {
	                            processTick_Beta(response);
	                            if (is_digit_beta) {
	                                DigitInfo_Beta.updateChart(response);
	                            }
	                        }
	                    } else if (type === 'history') {
	                        processHistory(response);
	                        if (is_digit) {
	                            DigitInfo.showChart(response.echo_req.ticks_history, response.history.prices);
	                        } else if (is_digit_beta) {
	                            DigitInfo_Beta.showChart(response.echo_req.ticks_history, response.history.prices);
	                        }
	                    }
	                }
	            });
	        }
	    };

	    var processTick = function processTick(tick) {
	        var symbol = underlying;
	        if (tick.echo_req.ticks === symbol || tick.tick && tick.tick.symbol === symbol) {
	            Tick.details(tick);
	            Tick.display();
	            TickDisplay.updateChart(tick);
	            Purchase.updateSpotList();
	            if (!Barriers.isBarrierUpdated()) {
	                Barriers.display();
	                Barriers.setBarrierUpdate(true);
	            }
	            updateWarmChart();
	        }
	    };

	    var processHistory = function processHistory(res) {
	        if (res.history && res.history.times && res.history.prices) {
	            for (var i = 0; i < res.history.times.length; i++) {
	                Tick.details({
	                    tick: {
	                        epoch: res.history.times[i],
	                        quote: res.history.prices[i]
	                    }
	                });
	            }
	        }
	    };

	    var processTick_Beta = function processTick_Beta(tick) {
	        var symbol = underlying;
	        if (tick.echo_req.ticks === symbol || tick.tick && tick.tick.symbol === symbol) {
	            Tick.details(tick);
	            Tick.display();
	            TickDisplay_Beta.updateChart(tick);
	            Purchase_Beta.updateSpotList();
	            if (!Barriers_Beta.isBarrierUpdated()) {
	                Barriers_Beta.display();
	                Barriers_Beta.setBarrierUpdate(true);
	            }
	            updateWarmChart();
	        } else {
	            DigitInfo_Beta.updateChart(tick);
	        }
	    };

	    return {
	        request: request
	    };
	}();

	module.exports = GetTicks;

/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var countDecimalPlaces = __webpack_require__(443).countDecimalPlaces;
	var Contract = __webpack_require__(444);
	var Defaults = __webpack_require__(437);
	var Tick = __webpack_require__(448);
	var elementTextContent = __webpack_require__(430).elementTextContent;
	var isVisible = __webpack_require__(430).isVisible;

	/*
	 * Handles barrier processing and display
	 *
	 * It process `Contract.barriers` and display them if its applicable
	 * for current `Contract.form()
	 */

	var Barriers = function () {
	    'use strict';

	    var is_barrier_updated = false;

	    var display = function display() {
	        var barriers = Contract.barriers()[Defaults.get('underlying')];
	        var form_name = Contract.form();

	        if (barriers && form_name && Defaults.get('formname') !== 'risefall') {
	            var barrier = barriers[form_name];
	            if (barrier) {
	                var unit = document.getElementById('duration_units');
	                var end_time = document.getElementById('expiry_date');
	                var indicative_barrier_tooltip = document.getElementById('indicative_barrier_tooltip');
	                var indicative_high_barrier_tooltip = document.getElementById('indicative_high_barrier_tooltip');
	                var indicative_low_barrier_tooltip = document.getElementById('indicative_low_barrier_tooltip');
	                var current_tick = Tick.quote();
	                var decimal_places = countDecimalPlaces(current_tick);

	                if (barrier.count === 1) {
	                    document.getElementById('high_barrier_row').style.display = 'none';
	                    document.getElementById('low_barrier_row').style.display = 'none';
	                    document.getElementById('barrier_row').setAttribute('style', '');

	                    var defaults_barrier = Defaults.get('barrier');
	                    var elm = document.getElementById('barrier');
	                    var tooltip = document.getElementById('barrier_tooltip');
	                    var span = document.getElementById('barrier_span');
	                    var barrier_def = defaults_barrier && !isNaN(defaults_barrier) ? defaults_barrier : barrier.barrier || 0,
	                        value = void 0;
	                    if (unit && isVisible(unit) && unit.value === 'd' || end_time && isVisible(end_time) && moment(end_time.getAttribute('data-value')).isAfter(moment(), 'day') || !String(barrier.barrier).match(/^[+-]/)) {
	                        if (current_tick && !isNaN(current_tick) && String(barrier_def).match(/^[+-]/)) {
	                            value = (parseFloat(current_tick) + parseFloat(barrier_def)).toFixed(decimal_places);
	                        } else {
	                            value = parseFloat(barrier_def);
	                        }
	                        tooltip.style.display = 'none';
	                        span.style.display = 'inherit';
	                        // no need to display indicative barrier in case of absolute barrier
	                        elementTextContent(indicative_barrier_tooltip, '');
	                    } else {
	                        if (!String(barrier_def).match(/^[+-]/)) barrier_def = barrier.barrier; // override Defaults value, because it's changing from absolute to relative barrier
	                        value = barrier_def;
	                        span.style.display = 'none';
	                        tooltip.style.display = 'inherit';
	                        if (current_tick && !isNaN(current_tick)) {
	                            elementTextContent(indicative_barrier_tooltip, (parseFloat(current_tick) + parseFloat(barrier_def)).toFixed(decimal_places));
	                        } else {
	                            elementTextContent(indicative_barrier_tooltip, '');
	                        }
	                    }
	                    elm.value = elm.textContent = value;
	                    Defaults.set('barrier', elm.value);
	                    Defaults.remove('barrier_high', 'barrier_low');
	                    Barriers.validateBarrier();
	                    return;
	                } else if (barrier.count === 2) {
	                    document.getElementById('barrier_row').style.display = 'none';
	                    document.getElementById('high_barrier_row').setAttribute('style', '');
	                    document.getElementById('low_barrier_row').setAttribute('style', '');

	                    var high_elm = document.getElementById('barrier_high');
	                    var low_elm = document.getElementById('barrier_low');
	                    var high_tooltip = document.getElementById('barrier_high_tooltip');
	                    var high_span = document.getElementById('barrier_high_span');
	                    var low_tooltip = document.getElementById('barrier_low_tooltip');
	                    var low_span = document.getElementById('barrier_low_span');

	                    var defaults_high = Defaults.get('barrier_high');
	                    var defaults_low = Defaults.get('barrier_low');
	                    var barrier_high = defaults_high && !isNaN(defaults_high) ? defaults_high : barrier.barrier || 0,
	                        barrier_low = defaults_low && !isNaN(defaults_low) ? defaults_low : barrier.barrier1 || 0,
	                        value_high = void 0,
	                        value_low = void 0;
	                    if (unit && isVisible(unit) && unit.value === 'd' || end_time && isVisible(end_time) && moment(end_time.getAttribute('data-value')).isAfter(moment(), 'day') || !String(barrier.barrier).match(/^[+-]/)) {
	                        if (current_tick && !isNaN(current_tick) && String(barrier_high).match(/^[+-]/)) {
	                            value_high = (parseFloat(current_tick) + parseFloat(barrier_high)).toFixed(decimal_places);
	                            value_low = (parseFloat(current_tick) + parseFloat(barrier_low)).toFixed(decimal_places);
	                        } else {
	                            value_high = parseFloat(barrier_high);
	                            value_low = parseFloat(barrier_low);
	                        }

	                        high_span.style.display = 'inherit';
	                        high_tooltip.style.display = 'none';
	                        low_span.style.display = 'inherit';
	                        low_tooltip.style.display = 'none';

	                        elementTextContent(indicative_high_barrier_tooltip, '');
	                        elementTextContent(indicative_low_barrier_tooltip, '');
	                    } else {
	                        // override Defaults value, if it's changing from absolute to relative barrier
	                        if (!String(barrier_high).match(/^[+-]/) || !String(barrier_low).match(/^[+-]/)) {
	                            barrier_high = barrier.barrier;
	                            barrier_low = barrier.barrier1;
	                        }
	                        value_high = barrier_high;
	                        value_low = barrier_low;

	                        high_span.style.display = 'none';
	                        high_tooltip.style.display = 'inherit';
	                        low_span.style.display = 'none';
	                        low_tooltip.style.display = 'inherit';

	                        var barrierVal = function barrierVal(tick, barrier_value) {
	                            return (tick + parseFloat(barrier_value)).toFixed(decimal_places);
	                        };

	                        if (current_tick && !isNaN(current_tick)) {
	                            var tick = parseFloat(current_tick);
	                            elementTextContent(indicative_high_barrier_tooltip, barrierVal(tick, barrier_high));
	                            elementTextContent(indicative_low_barrier_tooltip, barrierVal(tick, barrier_low));
	                        } else {
	                            elementTextContent(indicative_high_barrier_tooltip, '');
	                            elementTextContent(indicative_low_barrier_tooltip, '');
	                        }
	                    }
	                    high_elm.value = high_elm.textContent = value_high;
	                    low_elm.value = low_elm.textContent = value_low;

	                    Defaults.set('barrier_high', high_elm.value);
	                    Defaults.set('barrier_low', low_elm.value);
	                    Defaults.remove('barrier');
	                    return;
	                }
	            }
	        }

	        var elements = document.getElementsByClassName('barrier_class');
	        for (var i = 0; i < elements.length; i++) {
	            elements[i].style.display = 'none';
	        }
	        Defaults.remove('barrier', 'barrier_high', 'barrier_low');
	    };

	    var validateBarrier = function validateBarrier() {
	        var barrier_element = document.getElementById('barrier');
	        var empty = isNaN(parseFloat(barrier_element.value)) || parseFloat(barrier_element.value) === 0;
	        if (isVisible(barrier_element) && empty) {
	            barrier_element.classList.add('error-field');
	        } else {
	            barrier_element.classList.remove('error-field');
	        }
	    };

	    return {
	        display: display,
	        isBarrierUpdated: function isBarrierUpdated() {
	            return is_barrier_updated;
	        },
	        setBarrierUpdate: function setBarrierUpdate(flag) {
	            is_barrier_updated = flag;
	        },
	        validateBarrier: validateBarrier
	    };
	}();

	module.exports = Barriers;

/***/ },
/* 443 */
/***/ function(module, exports) {

	'use strict';

	/*
	 * Display price/spot movement variation to depict price moved up or down
	 */
	var displayPriceMovement = function displayPriceMovement(element, old_value, current_value) {
	    'use strict';

	    element.classList.remove('price_moved_down');
	    element.classList.remove('price_moved_up');
	    if (parseFloat(current_value) > parseFloat(old_value)) {
	        element.classList.remove('price_moved_down');
	        element.classList.add('price_moved_up');
	    } else if (parseFloat(current_value) < parseFloat(old_value)) {
	        element.classList.remove('price_moved_up');
	        element.classList.add('price_moved_down');
	    }
	};

	/*
	 * count number of decimal places in spot so that we can make barrier to same decimal places
	 */
	var countDecimalPlaces = function countDecimalPlaces(num) {
	    'use strict';

	    if (!isNaN(num)) {
	        var str = num.toString();
	        if (str.indexOf('.') !== -1) {
	            return str.split('.')[1].length;
	        }
	    }
	    return 0;
	};

	var trading_times = {};

	var processTradingTimesAnswer = function processTradingTimesAnswer(response) {
	    if (!trading_times.hasOwnProperty(response.echo_req.trading_times) && response.hasOwnProperty('trading_times') && response.trading_times.hasOwnProperty('markets')) {
	        for (var i = 0; i < response.trading_times.markets.length; i++) {
	            var submarkets = response.trading_times.markets[i].submarkets;
	            if (submarkets) {
	                for (var j = 0; j < submarkets.length; j++) {
	                    var symbols = submarkets[j].symbols;
	                    if (symbols) {
	                        for (var k = 0; k < symbols.length; k++) {
	                            var symbol = symbols[k];
	                            if (!trading_times[response.echo_req.trading_times]) {
	                                trading_times[response.echo_req.trading_times] = {};
	                            }
	                            trading_times[response.echo_req.trading_times][symbol.symbol] = symbol.times.close;
	                        }
	                    }
	                }
	            }
	        }
	    }
	};

	var getElement = function getElement() {
	    return document.getElementById('date_start');
	};

	module.exports = {
	    displayPriceMovement: displayPriceMovement,
	    countDecimalPlaces: countDecimalPlaces,
	    processTradingTimesAnswer: processTradingTimesAnswer,
	    getTradingTimes: function getTradingTimes() {
	        return trading_times;
	    },
	    getStartDateNode: getElement
	};

/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var getFormNameBarrierCategory = __webpack_require__(445).getFormNameBarrierCategory;
	var getLanguage = __webpack_require__(424).get;
	var localize = __webpack_require__(428).localize;
	var isEmptyObject = __webpack_require__(417).isEmptyObject;

	/*
	 * Contract object mocks the trading form we have on our website
	 * It parses the contracts json we get from socket.send({contracts_for: 'R_50'})
	 * and gives back barriers, startDate, durations etc
	 *
	 *
	 * Usage:
	 *
	 * use `Contract.details` to populate this object
	 *
	 * then use
	 *
	 * `Contract.durations()` to get durations like seconds, hours etc
	 * `Contract.open()` `Contract.close()`
	 * `Contract.barriers` if applicable for current underlying
	 */
	var Contract = function () {
	    'use strict';

	    var contract_type = {};
	    var contract_details = {},
	        _barriers = {},
	        _durations = {},
	        start_dates = {},
	        _open = void 0,
	        _close = void 0,
	        _form = void 0,
	        _barrier = void 0;

	    var populateDurations = function populateDurations(current_contract) {
	        var current_category = current_contract.contract_category;
	        var expiry_type = current_contract.expiry_type;
	        var barrier_category = current_contract.barrier_category;
	        var start_type = current_contract.start_type;
	        var max_duration = current_contract.max_contract_duration;
	        var min_duration = current_contract.min_contract_duration;

	        if (!_durations[expiry_type]) {
	            _durations[expiry_type] = {};
	        }

	        if (!_durations[expiry_type][current_category]) {
	            _durations[expiry_type][current_category] = {};
	        }

	        if (!_durations[expiry_type][current_category][barrier_category]) {
	            _durations[expiry_type][current_category][barrier_category] = {};
	        }

	        if (!_durations[expiry_type][current_category][barrier_category][start_type]) {
	            _durations[expiry_type][current_category][barrier_category][start_type] = {};
	        }

	        _durations[expiry_type][current_category][barrier_category][start_type].max_contract_duration = max_duration;

	        _durations[expiry_type][current_category][barrier_category][start_type].min_contract_duration = min_duration;
	    };

	    var details = function details(form_name) {
	        var contracts = Contract.contracts().contracts_for;
	        var barrier_category = void 0;

	        if (!contracts) return;

	        start_dates = { has_spot: 0, list: [] };
	        _durations = {};
	        _open = contracts.open;
	        _close = contracts.close;

	        var form_barrier = getFormNameBarrierCategory(form_name);
	        _form = form_name = form_barrier.form_name;
	        _barrier = barrier_category = form_barrier.barrier_category;

	        contracts.available.forEach(function (current_obj) {
	            var contract_category = current_obj.contract_category;

	            if (form_name && form_name === contract_category) {
	                if (barrier_category) {
	                    if (barrier_category === current_obj.barrier_category) {
	                        populateDurations(current_obj);
	                    }
	                } else {
	                    populateDurations(current_obj);
	                }

	                if (current_obj.forward_starting_options && current_obj.start_type === 'forward' && sessionStorage.formname !== 'higherlower') {
	                    start_dates.list = current_obj.forward_starting_options;
	                } else if (current_obj.start_type === 'spot') {
	                    start_dates.has_spot = 1;
	                }

	                var symbol = current_obj.underlying_symbol;
	                if (current_obj.barrier_category && current_obj.barrier_category !== 'non_financial') {
	                    if (!_barriers.hasOwnProperty(symbol)) {
	                        _barriers[symbol] = {};
	                    }
	                    if (current_obj.barriers === 1) {
	                        _barriers[symbol][contract_category] = {
	                            count: 1,
	                            barrier: current_obj.barrier,
	                            barrier_category: current_obj.barrier_category
	                        };
	                    } else if (current_obj.barriers === 2) {
	                        _barriers[symbol][contract_category] = {
	                            count: 2,
	                            barrier: current_obj.high_barrier,
	                            barrier1: current_obj.low_barrier,
	                            barrier_category: current_obj.barrier_category
	                        };
	                    }
	                }

	                if (!contract_type[contract_category]) {
	                    contract_type[contract_category] = {};
	                }

	                var type = current_obj.contract_type;
	                if (!contract_type[contract_category].hasOwnProperty(type)) {
	                    contract_type[contract_category][type] = localize(current_obj.contract_display);
	                }
	            }
	        });

	        if (form_name && barrier_category) {
	            if (_barriers && _barriers[form_name] && _barriers[form_name].barrier_category !== barrier_category) {
	                _barriers = {};
	            }
	        }
	    };

	    var getContractForms = function getContractForms() {
	        var contracts = Contract.contracts().contracts_for;
	        var trade_contract_forms = {};

	        if (!contracts) return null;

	        contracts.available.forEach(function (current_obj) {
	            var contract_category = current_obj.contract_category;
	            if (contract_category && !trade_contract_forms.hasOwnProperty(contract_category)) {
	                if (contract_category === 'callput') {
	                    if (current_obj.barrier_category === 'euro_atm') {
	                        trade_contract_forms.risefall = localize('Rise/Fall');
	                    } else {
	                        trade_contract_forms.higherlower = localize('Higher/Lower');
	                    }
	                } else {
	                    trade_contract_forms[contract_category] = localize(current_obj.contract_category_display);
	                    if (contract_category === 'digits') {
	                        trade_contract_forms.matchdiff = localize('Matches/Differs');
	                        if (getLanguage() !== 'ID') {
	                            trade_contract_forms.evenodd = localize('Even/Odd');
	                            trade_contract_forms.overunder = localize('Over/Under');
	                        }
	                    }
	                }
	            }
	        });

	        if (isEmptyObject(trade_contract_forms)) return null;

	        if (trade_contract_forms.risefall || trade_contract_forms.higherlower) {
	            trade_contract_forms.updown = localize('Up/Down');
	        }

	        if (trade_contract_forms.endsinout || trade_contract_forms.staysinout) {
	            trade_contract_forms.inout = localize('In/Out');
	        }

	        return trade_contract_forms;
	    };

	    return {
	        details: details,
	        contractForms: getContractForms,
	        open: function open() {
	            return _open;
	        },
	        close: function close() {
	            return _close;
	        },
	        contracts: function contracts() {
	            return contract_details;
	        },
	        durations: function durations() {
	            return _durations;
	        },
	        startDates: function startDates() {
	            return start_dates;
	        },
	        barriers: function barriers() {
	            return _barriers;
	        },
	        contractType: function contractType() {
	            return contract_type;
	        },
	        form: function form() {
	            return _form;
	        },
	        barrier: function barrier() {
	            return _barrier;
	        },
	        setContracts: function setContracts(data) {
	            contract_details = data;
	        }
	    };
	}();

	module.exports = Contract;

/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var Moment = __webpack_require__(305);
	var Defaults = __webpack_require__(437);
	var Notifications = __webpack_require__(446);
	var Symbols = __webpack_require__(447);
	var Tick = __webpack_require__(448);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var urlFor = __webpack_require__(423).urlFor;
	var isEmptyObject = __webpack_require__(417).isEmptyObject;
	var formatMoney = __webpack_require__(433).formatMoney;
	var toISOFormat = __webpack_require__(449).toISOFormat;
	var elementInnerHtml = __webpack_require__(430).elementInnerHtml;
	var elementTextContent = __webpack_require__(430).elementTextContent;

	/*
	 * This contains common functions we need for processing the response
	 */

	var commonTrading = function () {
	    'use strict';

	    /*
	     * display contract form as element of ul
	     */

	    var displayContractForms = function displayContractForms(id, elements, selected) {
	        if (!id || !elements || !selected) return;
	        var target = document.getElementById(id);
	        var fragment = document.createDocumentFragment();

	        elementInnerHtml(target, '');

	        if (elements) {
	            var tree = getContractCategoryTree(elements);
	            for (var i = 0; i < tree.length; i++) {
	                var el1 = tree[i];
	                var li = document.createElement('li');

	                li.classList.add('tm-li');
	                if (i === 0) {
	                    li.classList.add('first');
	                } else if (i === tree.length - 1) {
	                    li.classList.add('last');
	                }

	                if ((typeof el1 === 'undefined' ? 'undefined' : _typeof(el1)) === 'object') {
	                    var fragment2 = document.createDocumentFragment();
	                    var flag = 0,
	                        first = '';
	                    for (var j = 0; j < el1[1].length; j++) {
	                        var el2 = el1[1][j];
	                        var li2 = document.createElement('li');
	                        var a2 = document.createElement('a');
	                        var content2 = document.createTextNode(elements[el2]);
	                        li2.classList.add('tm-li-2');

	                        if (j === 0) {
	                            first = el2.toLowerCase();
	                            li2.classList.add('first');
	                        } else if (j === el1[1].length - 1) {
	                            li2.classList.add('last');
	                        }

	                        if (selected && selected === el2.toLowerCase()) {
	                            li2.classList.add('active');
	                            a2.classList.add('a-active');
	                            flag = 1;
	                        }

	                        a2.classList.add('tm-a-2');
	                        a2.appendChild(content2);
	                        a2.setAttribute('menuitem', el2.toLowerCase());
	                        a2.setAttribute('id', el2.toLowerCase());

	                        li2.appendChild(a2);

	                        fragment2.appendChild(li2);
	                    }
	                    if (fragment2.hasChildNodes()) {
	                        var ul = document.createElement('ul');
	                        var a = document.createElement('a');
	                        var content = document.createTextNode(elements[el1[0]]);

	                        a.appendChild(content);
	                        a.setAttribute('class', 'tm-a');
	                        a.setAttribute('menuitem', first);
	                        ul.appendChild(fragment2);
	                        ul.setAttribute('class', 'tm-ul-2');
	                        ul.setAttribute('id', el1[0] + '-submenu');

	                        if (flag) {
	                            li.classList.add('active');
	                        }

	                        li.appendChild(a);
	                        li.appendChild(ul);
	                    }
	                } else {
	                    var content3 = document.createTextNode(elements[el1]);
	                    var a3 = document.createElement('a');

	                    if (selected && selected === el1.toLowerCase()) {
	                        a3.classList.add('a-active');
	                        li.classList.add('active');
	                    }
	                    a3.appendChild(content3);
	                    a3.classList.add('tm-a');
	                    a3.setAttribute('menuitem', el1);
	                    a3.setAttribute('id', el1.toLowerCase());
	                    li.appendChild(a3);
	                }
	                fragment.appendChild(li);
	            }
	            if (target) {
	                target.appendChild(fragment);
	                var list = target.getElementsByClassName('tm-li');
	                for (var k = 0; k < list.length; k++) {
	                    var li4 = list[k];
	                    li4.addEventListener('mouseover', function () {
	                        this.classList.add('hover');
	                    });
	                    li4.addEventListener('mouseout', function () {
	                        this.classList.remove('hover');
	                    });
	                }
	            }
	        }
	    };

	    var displayMarkets = function displayMarkets(id, elements, selected) {
	        var target = document.getElementById(id);
	        var fragment = document.createDocumentFragment();

	        while (target && target.firstChild) {
	            target.removeChild(target.firstChild);
	        }

	        var keys1 = Object.keys(elements).sort(submarketSort);
	        for (var i = 0; i < keys1.length; i++) {
	            var key = keys1[i];
	            var content = document.createTextNode(elements[key].name);
	            var option = document.createElement('option');
	            option.setAttribute('value', key);
	            if (selected && selected === key) {
	                option.setAttribute('selected', 'selected');
	            }
	            option.appendChild(content);
	            fragment.appendChild(option);

	            if (elements[key].submarkets && !isEmptyObject(elements[key].submarkets)) {
	                var keys2 = Object.keys(elements[key].submarkets).sort(submarketSort);
	                for (var j = 0; j < keys2.length; j++) {
	                    var key2 = keys2[j];
	                    option = document.createElement('option');
	                    option.setAttribute('value', key2);
	                    if (selected && selected === key2) {
	                        option.setAttribute('selected', 'selected');
	                    }
	                    elementTextContent(option, '\xA0\xA0\xA0\xA0' + elements[key].submarkets[key2].name);
	                    fragment.appendChild(option);
	                }
	            }
	        }
	        if (target) {
	            target.appendChild(fragment);

	            if (target.selectedIndex < 0) {
	                target.selectedIndex = 0;
	            }
	            var current = target.options[target.selectedIndex];
	            if (selected !== current.value) {
	                Defaults.set('market', current.value);
	            }

	            if (current.disabled) {
	                // there is no open market
	                Notifications.show({ text: localize('All markets are closed now. Please try again later.'), uid: 'MARKETS_CLOSED' });
	                document.getElementById('trading_init_progress').style.display = 'none';
	            }
	        }
	    };

	    /*
	     * display underlyings
	     */
	    var displayUnderlyings = function displayUnderlyings(id, elements, selected) {
	        var target = document.getElementById(id);

	        if (!target) return;

	        while (target.firstChild) {
	            target.removeChild(target.firstChild);
	        }

	        if (!isEmptyObject(elements)) {
	            target.appendChild(generateUnderlyingOptions(elements, selected));
	        }
	    };

	    var generateUnderlyingOptions = function generateUnderlyingOptions(elements, selected) {
	        var fragment = document.createDocumentFragment();
	        var keys = Object.keys(elements).sort(function (a, b) {
	            return elements[a].display.localeCompare(elements[b].display);
	        });
	        var submarkets = {};
	        for (var i = 0; i < keys.length; i++) {
	            if (!submarkets.hasOwnProperty(elements[keys[i]].submarket)) {
	                submarkets[elements[keys[i]].submarket] = [];
	            }
	            submarkets[elements[keys[i]].submarket].push(keys[i]);
	        }
	        var keys2 = Object.keys(submarkets).sort(submarketSort);
	        for (var j = 0; j < keys2.length; j++) {
	            for (var k = 0; k < submarkets[keys2[j]].length; k++) {
	                var key = submarkets[keys2[j]][k];
	                var option = document.createElement('option');
	                var content = document.createTextNode(localize(elements[key].display));
	                option.setAttribute('value', key);
	                if (selected && selected === key) {
	                    option.setAttribute('selected', 'selected');
	                }
	                option.appendChild(content);
	                fragment.appendChild(option);
	            }
	        }
	        return fragment;
	    };

	    /*
	     * This maps the form name and barrierCategory we display on
	     * trading form to the actual we send it to backend
	     * for e.g risefall is mapped to callput with barrierCategory euro_atm
	     */
	    var getFormNameBarrierCategory = function getFormNameBarrierCategory(form_name) {
	        return {
	            form_name: form_name && !/(risefall|higherlower|callput)/.test(form_name) ? /(overunder|evenodd|matchdiff)/.test(form_name) ? 'digits' : form_name : 'callput',
	            barrier_category: form_name && !/(risefall|callput)/.test(form_name) ? /higherlower/.test(form_name) ? 'euro_non_atm' : '' : 'euro_atm'
	        };
	    };

	    /*
	     * This maps the contract type to where we display on trading form
	     * and as there is no mapping on server side so need to create it
	     * on front end
	     *
	     * for example we display CALL on top and PUT to bottom
	     */
	    var obj = {
	        CALL: 'top',
	        PUT: 'bottom',
	        CALLE: 'top',
	        PUTE: 'bottom',
	        ASIANU: 'top',
	        ASIAND: 'bottom',
	        DIGITMATCH: 'top',
	        DIGITDIFF: 'bottom',
	        DIGITEVEN: 'top',
	        DIGITODD: 'bottom',
	        DIGITOVER: 'top',
	        DIGITUNDER: 'bottom',
	        EXPIRYRANGEE: 'top',
	        EXPIRYMISSE: 'bottom',
	        EXPIRYRANGE: 'top',
	        EXPIRYMISS: 'bottom',
	        RANGE: 'top',
	        UPORDOWN: 'bottom',
	        ONETOUCH: 'top',
	        NOTOUCH: 'bottom'
	    };

	    var contractTypeDisplayMapping = function contractTypeDisplayMapping(type) {
	        return type ? obj[type] : 'top';
	    };

	    var showHideOverlay = function showHideOverlay(el, display) {
	        var elm = document.getElementById(el);
	        if (elm) {
	            elm.style.display = display;
	        }
	    };

	    /*
	     * hide contract confirmation overlay container
	     */
	    var hideOverlayContainer = function hideOverlayContainer() {
	        showHideOverlay('contract_confirmation_container', 'none');
	        showHideOverlay('contracts_list', 'flex');
	        $('.purchase_button').css('visibility', '');
	    };

	    var getContractCategoryTree = function getContractCategoryTree(elements) {
	        var tree = [['updown', ['risefall', 'higherlower']], 'touchnotouch', ['inout', ['endsinout', 'staysinout']], 'asian', ['digits', ['matchdiff', 'evenodd', 'overunder']]];

	        if (elements) {
	            tree = tree.map(function (e) {
	                if ((typeof e === 'undefined' ? 'undefined' : _typeof(e)) === 'object') {
	                    e[1] = e[1].filter(function (e1) {
	                        return elements[e1];
	                    });
	                    if (!e[1].length) {
	                        e = '';
	                    }
	                } else if (!elements[e]) {
	                    e = '';
	                }
	                return e;
	            });
	            tree = tree.filter(function (v) {
	                return v.length;
	            });
	        }
	        return tree;
	    };

	    /*
	     * resets price movement color changing, to prevent coloring on some changes
	     * coloring will continue on the next proposal responses
	     */
	    var resetPriceMovement = function resetPriceMovement() {
	        var btns = document.getElementsByClassName('purchase_button');
	        for (var i = 0; i < btns.length; i++) {
	            btns[i].setAttribute('data-display_value', '');
	            btns[i].setAttribute('data-payout', '');
	        }
	    };

	    var toggleActiveCatMenuElement = function toggleActiveCatMenuElement(nav, event_element_id) {
	        var event_element = document.getElementById(event_element_id);
	        var li_elements = nav.querySelectorAll('.active, .a-active');
	        var classes = event_element.classList;
	        var i = void 0,
	            len = void 0;

	        if (!classes.contains('active')) {
	            for (i = 0, len = li_elements.length; i < len; i++) {
	                li_elements[i].classList.remove('active');
	                li_elements[i].classList.remove('a-active');
	            }
	            classes.add('a-active');

	            i = 0;
	            var parent = event_element.parentElement;
	            while (parent && parent.id !== nav.id && i < 10) {
	                if (parent.tagName === 'LI') {
	                    parent.classList.add('active');
	                }
	                parent = parent.parentElement;
	                i++;
	            }
	        }
	    };

	    /*
	     * display the profit and return of bet under each trade container
	     */
	    var displayCommentPrice = function displayCommentPrice(node, currency, type, payout) {
	        if (node && type && payout) {
	            var profit = payout - type;
	            var return_percent = profit / type * 100;
	            var comment = localize('Net profit') + ': ' + formatMoney(currency, profit) + ' | ' + localize('Return') + ' ' + return_percent.toFixed(1) + '%';

	            if (isNaN(profit) || isNaN(return_percent)) {
	                node.hide();
	            } else {
	                node.show();
	                elementTextContent(node, comment);
	            }
	        }
	    };

	    /*
	     * This is used in case where we have input and we don't want to fire
	     * event on every change while user is typing for example in case of amount if
	     * we want to change 10 to 1000 i.e. two zeros so two input events will be fired
	     * normally, this will delay the event based on delay specified in milliseconds
	     *
	     * Reference
	     * http://davidwalsh.name/javascript-debounce-function
	     */
	    var debounce = function debounce(func, wait, immediate) {
	        var timeout = void 0;
	        var delay = wait || 500;
	        return function () {
	            var context = this;
	            var args = arguments;
	            var later = function later() {
	                timeout = null;
	                if (!immediate) func.apply(context, args);
	            };
	            var call_now = immediate && !timeout;
	            clearTimeout(timeout);
	            timeout = setTimeout(later, delay);
	            if (call_now) func.apply(context, args);
	        };
	    };

	    /*
	     * check if selected market is allowed for current user
	     */
	    var getDefaultMarket = function getDefaultMarket() {
	        var mkt = Defaults.get('market');
	        var markets = Symbols.markets(1);
	        if (!mkt || !markets[mkt]) {
	            var sorted_markets = Object.keys(Symbols.markets()).filter(function (v) {
	                return markets[v].is_active;
	            }).sort(function (a, b) {
	                return getMarketsOrder(a) - getMarketsOrder(b);
	            });
	            mkt = sorted_markets[0];
	        }
	        return mkt;
	    };

	    // Order
	    var market_order = {
	        forex: 1,
	        volidx: 2,
	        indices: 3,
	        stocks: 4,
	        commodities: 5
	    };

	    var getMarketsOrder = function getMarketsOrder(market) {
	        return market_order[market] || 100;
	    };

	    /*
	     * this is invoked when submit button is clicked and prevents reloading of page
	     */
	    var addEventListenerForm = function addEventListenerForm() {
	        document.getElementById('websocket_form').addEventListener('submit', function (evt) {
	            evt.currentTarget.classList.add('submitted');
	            evt.preventDefault();
	            return false;
	        }, false);
	    };

	    /*
	     * this creates a button, clicks it, and destroys it to invoke the listener
	     */
	    var submitForm = function submitForm(form) {
	        var button = form.ownerDocument.createElement('input');
	        button.style.display = 'none';
	        button.type = 'submit';
	        form.appendChild(button).click();
	        form.removeChild(button);
	    };

	    /*
	     * sort the duration in ascending order
	     */
	    var duration_order = {
	        t: 1,
	        s: 2,
	        m: 3,
	        h: 4,
	        d: 5
	    };

	    var submarket_order = {
	        forex: 0,
	        major_pairs: 1,
	        minor_pairs: 2,
	        smart_fx: 3,
	        indices: 4,
	        asia_oceania: 5,
	        europe_africa: 6,
	        americas: 7,
	        otc_index: 8,
	        stocks: 9,
	        au_otc_stock: 10,
	        ge_otc_stock: 11,
	        india_otc_stock: 12,
	        uk_otc_stock: 13,
	        us_otc_stock: 14,
	        commodities: 15,
	        metals: 16,
	        energy: 17,
	        volidx: 18,
	        random_index: 19,
	        random_daily: 20,
	        random_nightly: 21
	    };

	    var submarketOrder = function submarketOrder(market) {
	        return submarket_order[market];
	    };

	    var submarketSort = function submarketSort(a, b) {
	        if (submarketOrder(a) > submarketOrder(b)) {
	            return 1;
	        } else if (submarketOrder(a) < submarketOrder(b)) {
	            return -1;
	        }

	        return 0;
	    };

	    var displayTooltip = function displayTooltip(market, symbol) {
	        var tip = document.getElementById('symbol_tip');
	        var guide = document.getElementById('guideBtn');
	        var app = document.getElementById('androidApp');
	        var appstore = document.getElementById('appstore');
	        var markets = document.getElementById('contract_markets').value;
	        if (!market || !symbol) return;
	        if (market.match(/^volidx/) || symbol.match(/^R/) || market.match(/^random_index/) || market.match(/^random_daily/)) {
	            if (guide) guide.hide();
	            tip.show();
	            tip.setAttribute('target', urlFor('/get-started/volidx-markets'));
	            app.show();
	            appstore.show();
	        } else {
	            app.hide();
	            appstore.hide();
	            tip.hide();
	            if (guide) guide.show();
	        }
	        if (market.match(/^otc_index/) || symbol.match(/^OTC_/) || market.match(/stock/) || markets.match(/stocks/)) {
	            tip.show();
	            tip.setAttribute('target', urlFor('/get-started/otc-indices-stocks'));
	        }
	        if (market.match(/^random_index/) || symbol.match(/^R_/)) {
	            tip.setAttribute('target', urlFor('/get-started/volidx-markets', '#volidx-indices'));
	        }
	        if (market.match(/^random_daily/) || symbol.match(/^RDB/) || symbol.match(/^RDMO/) || symbol.match(/^RDS/)) {
	            tip.setAttribute('target', urlFor('/get-started/volidx-markets', '#volidx-quotidians'));
	        }
	        if (market.match(/^smart_fx/) || symbol.match(/^WLD/)) {
	            tip.show();
	            tip.setAttribute('target', urlFor('/get-started/smart-indices', '#world-fx-indices'));
	        }
	    };

	    var selectOption = function selectOption(option, select) {
	        var options = select.getElementsByTagName('option');
	        var contains = 0;
	        for (var i = 0; i < options.length; i++) {
	            if (options[i].value === option && !options[i].hasAttribute('disabled')) {
	                contains = 1;
	                break;
	            }
	        }
	        if (contains) {
	            select.value = option;
	            return true;
	        }

	        return false;
	    };

	    var chart_config = {
	        type: 'line',
	        lineColor: '#606060',
	        fillColor: false,
	        spotColor: '#00f000',
	        minSpotColor: '#f00000',
	        maxSpotColor: '#0000f0',
	        highlightSpotColor: '#ffff00',
	        highlightLineColor: '#000000',
	        spotRadius: 1.25
	    };

	    var $chart = void 0;

	    var updateWarmChart = function updateWarmChart() {
	        $chart = $chart || $('#trading_worm_chart');
	        var spots = Object.keys(Tick.spots()).sort(function (a, b) {
	            return a - b;
	        }).map(function (v) {
	            return Tick.spots()[v];
	        });
	        if ($chart && typeof $chart.sparkline === 'function') {
	            $chart.sparkline(spots, chart_config);
	            if (spots.length) {
	                $chart.show();
	            } else {
	                $chart.hide();
	            }
	        }
	    };

	    var reloadPage = function reloadPage() {
	        Defaults.remove('market', 'underlying', 'formname', 'date_start', 'expiry_type', 'expiry_date', 'expirt_time', 'duration_units', 'diration_value', 'amount', 'amount_type', 'currency', 'prediction');
	        location.reload();
	    };

	    // ============= Functions used in /trading_beta =============

	    var updatePurchaseStatus_Beta = function updatePurchaseStatus_Beta(final_price, pnl, contract_status) {
	        final_price = String(final_price).replace(/,/g, '') * 1;
	        pnl = String(pnl).replace(/,/g, '') * 1;
	        $('#contract_purchase_heading').text(localize(contract_status));
	        var payout = document.getElementById('contract_purchase_payout');
	        var cost = document.getElementById('contract_purchase_cost');
	        var profit = document.getElementById('contract_purchase_profit');
	        var currency = Client.get('currency');

	        labelValue(cost, localize('Stake'), formatMoney(currency, Math.abs(pnl), 1));
	        labelValue(payout, localize('Payout'), formatMoney(currency, final_price, 1));

	        var isWin = final_price > 0;
	        $('#contract_purchase_profit_value').attr('class', isWin ? 'profit' : 'loss');
	        labelValue(profit, isWin ? localize('Profit') : localize('Loss'), formatMoney(currency, isWin ? Math.round((final_price - pnl) * 100) / 100 : -Math.abs(pnl), 1));
	    };

	    var displayTooltip_Beta = function displayTooltip_Beta(market, symbol) {
	        var tip = document.getElementById('symbol_tip');
	        var markets = document.getElementById('contract_markets').value;
	        if (!market || !symbol) return;
	        if (market.match(/^volidx/) || symbol.match(/^R/) || market.match(/^random_index/) || market.match(/^random_daily/)) {
	            tip.show();
	            tip.setAttribute('target', urlFor('/get-started/volidx-markets'));
	        } else {
	            tip.hide();
	        }
	        if (market.match(/^otc_index/) || symbol.match(/^OTC_/) || market.match(/stock/) || markets.match(/stocks/)) {
	            tip.show();
	            tip.setAttribute('target', urlFor('/get-started/otc-indices-stocks'));
	        }
	        if (market.match(/^random_index/) || symbol.match(/^R_/)) {
	            tip.setAttribute('target', urlFor('/get-started/volidx-markets', '#volidx-indices'));
	        }
	        if (market.match(/^random_daily/) || symbol.match(/^RDB/) || symbol.match(/^RDMO/) || symbol.match(/^RDS/)) {
	            tip.setAttribute('target', urlFor('/get-started/volidx-markets', '#volidx-quotidians'));
	        }
	        if (market.match(/^smart_fx/) || symbol.match(/^WLD/)) {
	            tip.show();
	            tip.setAttribute('target', urlFor('/get-started/smart-indices', '#world-fx-indices'));
	        }
	    };

	    var labelValue = function labelValue(label_elem, label, value, no_currency) {
	        var currency = Client.get('currency');
	        elementInnerHtml(label_elem, label);
	        var value_elem = document.getElementById(label_elem.id + '_value');
	        elementInnerHtml(value_elem, no_currency ? value : formatMoney(currency, value));
	        value_elem.setAttribute('value', String(value).replace(/,/g, ''));
	    };

	    var timeIsValid = function timeIsValid($element) {
	        var end_date_value = document.getElementById('expiry_date').getAttribute('data-value'),
	            start_date_value = document.getElementById('date_start').value,
	            end_time_value = document.getElementById('expiry_time').value;
	        var $invalid_time = $('#invalid-time');

	        if ($element.attr('id') === $('#expiry_time') && end_time_value && !/^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/.test(end_time_value)) {
	            $element.addClass('error-field');
	            if ($invalid_time.length === 0) {
	                $('#expiry_type_endtime').parent().append($('<p>', { class: 'error-msg', id: 'invalid-time', text: localize('Time is in the wrong format.') }));
	            }
	            return false;
	        }

	        $element.removeClass('error-field');
	        $invalid_time.remove();

	        end_date_value = end_date_value ? toISOFormat(Moment(end_date_value)) : toISOFormat(new Moment());
	        start_date_value = start_date_value === 'now' ? Math.floor(window.time._i / 1000) : start_date_value;
	        end_time_value = end_time_value || '23:59:59';

	        if (Moment.utc(end_date_value + ' ' + end_time_value).unix() <= start_date_value) {
	            $element.addClass('error-field');
	            if (!document.getElementById('end_time_validation')) {
	                $('#expiry_type_endtime').append($('<p/>', { class: 'error-msg', id: 'end_time_validation', text: localize('End time must be after start time.') }));
	            }
	            return false;
	        }

	        $element.removeClass('error-field');
	        $('#end_time_validation').remove();
	        return true;
	    };

	    return {
	        displayUnderlyings: displayUnderlyings,
	        generateUnderlyingOptions: generateUnderlyingOptions,
	        getFormNameBarrierCategory: getFormNameBarrierCategory,
	        contractTypeDisplayMapping: contractTypeDisplayMapping,
	        showPriceOverlay: function showPriceOverlay() {
	            showHideOverlay('loading_container2', 'block');
	        },
	        hidePriceOverlay: function hidePriceOverlay() {
	            showHideOverlay('loading_container2', 'none');
	        },
	        hideFormOverlay: function hideFormOverlay() {
	            showHideOverlay('loading_container3', 'none');
	        },
	        showFormOverlay: function showFormOverlay() {
	            showHideOverlay('loading_container3', 'block');
	        },
	        hideOverlayContainer: hideOverlayContainer,
	        getContractCategoryTree: getContractCategoryTree,
	        resetPriceMovement: resetPriceMovement,
	        toggleActiveCatMenuElement: toggleActiveCatMenuElement,
	        displayCommentPrice: displayCommentPrice,
	        debounce: debounce,
	        getDefaultMarket: getDefaultMarket,
	        addEventListenerForm: addEventListenerForm,
	        submitForm: submitForm,
	        durationOrder: function durationOrder(duration) {
	            return duration_order[duration];
	        },
	        displayTooltip: displayTooltip,
	        selectOption: selectOption,
	        updateWarmChart: updateWarmChart,
	        reloadPage: reloadPage,
	        displayContractForms: displayContractForms,
	        displayMarkets: displayMarkets,
	        updatePurchaseStatus_Beta: updatePurchaseStatus_Beta,
	        displayTooltip_Beta: displayTooltip_Beta,
	        labelValue: labelValue,
	        timeIsValid: timeIsValid,
	        clean: function clean() {
	            $chart = null;
	        }
	    };
	}();

	module.exports = commonTrading;

/***/ },
/* 446 */
/***/ function(module, exports) {

	'use strict';

	/*
	 * Notifications manages various notification messages
	 *
	 */

	var Notifications = function () {
	    'use strict';

	    /*
	     * options: Object {
	     *     text       : {string}  message text to display
	     *     uid        : {string}  unique id to prevent duplicating the same message and also used to hide the message
	     *     dismissible: {boolean} dismissible messages can be hidden by client
	     * }
	     */

	    var showErrorMessage = function showErrorMessage(options) {
	        var $note_wrapper = getContainer();
	        var $this_uid = $note_wrapper.find('#' + options.uid);

	        if (!options.uid || $this_uid.length === 0) {
	            $note_wrapper.prepend(generateMessage(options));
	        } else if ($this_uid.html() !== options.text) {
	            $this_uid.replaceWith(generateMessage(options));
	        }

	        $.scrollTo($note_wrapper, 500, { offset: -5 });
	    };

	    var generateMessage = function generateMessage(options) {
	        var $message = $('<div class="notice-msg center-text' + (options.dismissible ? ' dismissible' : '') + '"\n            ' + (options.uid ? ' id="' + options.uid + '"' : '') + '>' + options.text + '\n                ' + (options.dismissible ? '<div class="notification-dismiss">x</div>' : '') + '\n            </div>');

	        if (options.dismissible) {
	            $message.click(function () {
	                dismissMessage(this);
	            });
	        }

	        return $message;
	    };

	    var hideErrorMessage = function hideErrorMessage(uid) {
	        if (uid) {
	            getContainer().find('#' + uid).remove();
	        }
	    };

	    var dismissMessage = function dismissMessage(obj) {
	        $(obj).remove();
	    };

	    var getContainer = function getContainer() {
	        return $('#notifications_wrapper');
	    };

	    return {
	        show: showErrorMessage,
	        hide: hideErrorMessage
	    };
	}();

	module.exports = Notifications;

/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ActiveSymbols = __webpack_require__(419);

	/*
	 * Symbols object parses the active_symbols json that we get from socket.send({active_symbols: 'brief'}
	 * and outputs in usable form, it gives markets, underlyings
	 *
	 *
	 * Usage:
	 *
	 * use `Symbols.details` to populate this object first
	 *
	 * then use
	 *
	 * `Symbols.markets` to get markets like Forex, Random etc
	 * `Symbols.underlyings` to get underlyings
	 *
	 */

	var Symbols = function () {
	    'use strict';

	    var trade_markets = {},
	        trade_markets_list = {},
	        trade_underlyings = {},
	        names = {};

	    var details = function details(data) {
	        var all_symbols = data.active_symbols;
	        trade_markets = ActiveSymbols.getMarkets(all_symbols);
	        trade_markets_list = ActiveSymbols.getMarketsList(all_symbols);
	        trade_underlyings = ActiveSymbols.getTradeUnderlyings(all_symbols);
	        names = ActiveSymbols.getSymbolNames(all_symbols);
	    };

	    return {
	        details: details,
	        markets: function markets(list) {
	            return list ? trade_markets_list : trade_markets;
	        },
	        underlyings: function underlyings() {
	            return trade_underlyings;
	        },
	        getName: function getName(symbol) {
	            return names[symbol];
	        },
	        getAllSymbols: function getAllSymbols() {
	            return names;
	        }
	    };
	}();

	module.exports = Symbols;

/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var countDecimalPlaces = __webpack_require__(443).countDecimalPlaces;
	var displayPriceMovement = __webpack_require__(443).displayPriceMovement;
	var elementTextContent = __webpack_require__(430).elementTextContent;
	var isVisible = __webpack_require__(430).isVisible;

	/*
	 * Tick object handles all the process/display related to tick streaming
	 *
	 * We request tick stream for particular underlying to update current spot
	 *
	 *
	 * Usage:
	 * use `Tick.detail` to populate this object
	 *
	 * then use
	 *
	 * `Tick.quote()` to get current spot quote
	 * `Tick.id()` to get the unique for current stream
	 * `Tick.epoch()` to get the tick epoch time
	 * 'Tick.display()` to display current spot
	 */
	var Tick = function () {
	    'use strict';

	    var _quote = '',
	        _id = '',
	        _epoch = '',
	        _spots = {},
	        error_message = '';

	    var details = function details(data) {
	        error_message = '';

	        if (data) {
	            if (data.error) {
	                error_message = data.error.message;
	            } else {
	                var tick = data.tick;
	                _quote = tick.quote;
	                _id = tick.id;
	                _epoch = tick.epoch;

	                _spots[_epoch] = _quote;
	                var epoches = Object.keys(_spots).sort(function (a, b) {
	                    return a - b;
	                });
	                if (epoches.length > 20) {
	                    delete _spots[epoches[0]];
	                }
	            }
	        }
	    };

	    var display = function display() {
	        $('#spot').fadeIn(200);
	        var spot_element = document.getElementById('spot');
	        if (!spot_element) return;
	        var message = '';
	        if (error_message) {
	            message = error_message;
	        } else {
	            message = _quote;
	        }

	        if (parseFloat(message) !== +message) {
	            spot_element.className = 'error';
	        } else {
	            spot_element.classList.remove('error');
	            displayPriceMovement(spot_element, elementTextContent(spot_element), message);
	            displayIndicativeBarrier();
	        }

	        elementTextContent(spot_element, message);
	    };

	    /*
	     * display indicative barrier
	     */
	    var displayIndicativeBarrier = function displayIndicativeBarrier() {
	        var current_tick = Tick.quote();
	        var unit = document.getElementById('duration_units');
	        var indicative_barrier_tooltip = document.getElementById('indicative_barrier_tooltip');
	        var indicative_high_barrier_tooltip = document.getElementById('indicative_high_barrier_tooltip');
	        var indicative_low_barrier_tooltip = document.getElementById('indicative_low_barrier_tooltip');
	        var barrier_element = document.getElementById('barrier');
	        var high_barrier_element = document.getElementById('barrier_high');
	        var low_barrier_element = document.getElementById('barrier_low');
	        var tooltip = document.getElementById('barrier_tooltip');
	        var span = document.getElementById('barrier_span');
	        var high_tooltip = document.getElementById('barrier_high_tooltip');
	        var high_span = document.getElementById('barrier_high_span');
	        var low_tooltip = document.getElementById('barrier_low_tooltip');
	        var low_span = document.getElementById('barrier_low_span');
	        var value = void 0;

	        var end_time = document.getElementById('expiry_date');
	        if (unit && (!isVisible(unit) || unit.value !== 'd') && current_tick && !isNaN(current_tick) && end_time && (!isVisible(end_time) || moment(end_time.getAttribute('data-value')).isBefore(moment().add(1, 'day'), 'day'))) {
	            var decimal_places = countDecimalPlaces(current_tick);
	            if (indicative_barrier_tooltip && isVisible(indicative_barrier_tooltip) && String(barrier_element.value).match(/^[+-]/)) {
	                var barrier_value = isNaN(parseFloat(barrier_element.value)) ? 0 : parseFloat(barrier_element.value);
	                indicative_barrier_tooltip.textContent = (parseFloat(current_tick) + barrier_value).toFixed(decimal_places);
	                tooltip.style.display = 'inherit';
	                span.style.display = 'none';
	            } else {
	                elementTextContent(indicative_barrier_tooltip, '');
	                tooltip.style.display = 'none';
	                span.style.display = 'inherit';
	            }

	            if (indicative_high_barrier_tooltip && isVisible(indicative_high_barrier_tooltip) && String(high_barrier_element.value).match(/^[+-]/)) {
	                value = parseFloat(high_barrier_element.value);
	                value = isNaN(value) ? 0 : value;
	                indicative_high_barrier_tooltip.textContent = (parseFloat(current_tick) + value).toFixed(decimal_places);
	                high_tooltip.style.display = 'inherit';
	                high_span.style.display = 'none';
	            } else {
	                elementTextContent(indicative_high_barrier_tooltip, '');
	                high_tooltip.style.display = 'none';
	                high_span.style.display = 'inherit';
	            }

	            if (indicative_low_barrier_tooltip && isVisible(indicative_low_barrier_tooltip) && String(low_barrier_element.value).match(/^[+-]/)) {
	                value = parseFloat(low_barrier_element.value);
	                value = isNaN(value) ? 0 : value;
	                indicative_low_barrier_tooltip.textContent = (parseFloat(current_tick) + value).toFixed(decimal_places);
	                low_tooltip.style.display = 'inherit';
	                low_span.style.display = 'none';
	            } else {
	                elementTextContent(indicative_low_barrier_tooltip, '');
	                low_tooltip.style.display = 'none';
	                low_span.style.display = 'inherit';
	            }
	        } else {
	            elementTextContent(indicative_barrier_tooltip, '');
	            elementTextContent(indicative_high_barrier_tooltip, '');
	            elementTextContent(indicative_low_barrier_tooltip, '');
	        }
	    };

	    var clean = function clean() {
	        _spots = {};
	        _quote = '';
	        $('#spot').fadeOut(200, function () {
	            // resets spot movement coloring, will continue on the next tick responses
	            $(this).removeClass('price_moved_down price_moved_up').text('');
	        });
	    };

	    return {
	        details: details,
	        display: display,
	        clean: clean,
	        quote: function quote() {
	            return _quote;
	        },
	        id: function id() {
	            return _id;
	        },
	        epoch: function epoch() {
	            return _epoch;
	        },
	        errorMessage: function errorMessage() {
	            return error_message;
	        },
	        spots: function spots() {
	            return _spots;
	        },
	        setQuote: function setQuote(q) {
	            _quote = q;
	        }
	    };
	}();

	module.exports = Tick;

/***/ },
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var checkInput = __webpack_require__(430).checkInput;

	var toTitleCase = function toTitleCase(str) {
	    return str.replace(/\w[^\s\/\\]*/g, function (txt) {
	        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
	    });
	};

	var toISOFormat = function toISOFormat(date) {
	    return date.format('YYYY-MM-DD');
	};

	var toReadableFormat = function toReadableFormat(date) {
	    if ($(window).width() < 770 && checkInput('date', 'not-a-date')) {
	        return toISOFormat(date);
	    }
	    return date.format('DD MMM, YYYY');
	};

	var padLeft = function padLeft(text, len, char) {
	    text = String(text || '');
	    return text.length >= len ? text : '' + Array(len - text.length + 1).join(char) + text;
	};

	var compareBigUnsignedInt = function compareBigUnsignedInt(a, b) {
	    a = numberToString(a);
	    b = numberToString(b);
	    var max_length = Math.max(a.length, b.length);
	    a = padLeft(a, max_length, '0');
	    b = padLeft(b, max_length, '0');
	    return a > b ? 1 : a < b ? -1 : 0; // lexicographical comparison
	};

	var numberToString = function numberToString(n) {
	    return typeof n === 'number' ? String(n) : n;
	};

	module.exports = {
	    toISOFormat: toISOFormat,
	    toReadableFormat: toReadableFormat,
	    toTitleCase: toTitleCase,
	    padLeft: padLeft,

	    compareBigUnsignedInt: compareBigUnsignedInt
	};

/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var Contract_Beta = __webpack_require__(451);
	var countDecimalPlaces = __webpack_require__(443).countDecimalPlaces;
	var Defaults = __webpack_require__(437);
	var Tick = __webpack_require__(448);
	var elementTextContent = __webpack_require__(430).elementTextContent;
	var isVisible = __webpack_require__(430).isVisible;

	/*
	 * Handles barrier processing and display
	 *
	 * It process `Contract.barriers` and display them if its applicable
	 * for current `Contract.form()
	 */

	var Barriers_Beta = function () {
	    'use strict';

	    var is_barrier_updated = false;

	    var display = function display() {
	        var barriers = Contract_Beta.barriers()[Defaults.get('underlying')];
	        var form_name = Contract_Beta.form();

	        if (barriers && form_name && Defaults.get('formname') !== 'risefall') {
	            var barrier = barriers[form_name];
	            if (barrier) {
	                var unit = document.getElementById('duration_units');
	                var end_time = document.getElementById('expiry_date');
	                var current_tick = Tick.quote();
	                var decimal_places = countDecimalPlaces(current_tick);
	                var indicative_barrier_tooltip = document.getElementById('indicative_barrier_tooltip');
	                var indicative_high_barrier_tooltip = document.getElementById('indicative_high_barrier_tooltip');
	                var indicative_low_barrier_tooltip = document.getElementById('indicative_low_barrier_tooltip');

	                if (barrier.count === 1) {
	                    document.getElementById('high_barrier_row').style.display = 'none';
	                    document.getElementById('low_barrier_row').style.display = 'none';
	                    document.getElementById('barrier_row').setAttribute('style', '');

	                    var defaults_barrier = Defaults.get('barrier');
	                    var elm = document.getElementById('barrier');
	                    var tooltip = document.getElementById('barrier_tooltip');
	                    var span = document.getElementById('barrier_span');
	                    var barrier_def = defaults_barrier && !isNaN(defaults_barrier) ? defaults_barrier : barrier.barrier,
	                        value = void 0;
	                    if (unit && isVisible(unit) && unit.value === 'd' || end_time && isVisible(end_time) && moment(end_time.getAttribute('data-value')).isAfter(moment(), 'day') || !String(barrier.barrier).match(/^[+-]/)) {
	                        if (current_tick && !isNaN(current_tick) && String(barrier_def).match(/^[+-]/)) {
	                            value = (parseFloat(current_tick) + parseFloat(barrier_def)).toFixed(decimal_places);
	                        } else {
	                            value = parseFloat(barrier_def);
	                        }
	                        tooltip.style.display = 'none';
	                        span.style.display = 'inherit';
	                        // no need to display indicative barrier in case of absolute barrier
	                        elementTextContent(indicative_barrier_tooltip, '');
	                    } else {
	                        if (!String(barrier_def).match(/^[+-]/)) barrier_def = barrier.barrier; // override Defaults value, because it's changing from absolute to relative barrier
	                        value = barrier_def;
	                        span.style.display = 'none';
	                        tooltip.style.display = 'inherit';
	                        if (current_tick && !isNaN(current_tick)) {
	                            elementTextContent(indicative_barrier_tooltip, (parseFloat(current_tick) + parseFloat(barrier_def)).toFixed(decimal_places));
	                        } else {
	                            elementTextContent(indicative_barrier_tooltip, '');
	                        }
	                    }
	                    elm.value = elm.textContent = value;
	                    Defaults.set('barrier', elm.value);
	                    Defaults.remove('barrier_high', 'barrier_low');
	                    Barriers_Beta.validateBarrier();
	                    return;
	                } else if (barrier.count === 2) {
	                    document.getElementById('barrier_row').style.display = 'none';
	                    document.getElementById('high_barrier_row').setAttribute('style', '');
	                    document.getElementById('low_barrier_row').setAttribute('style', '');

	                    var high_elm = document.getElementById('barrier_high');
	                    var low_elm = document.getElementById('barrier_low');
	                    var high_tooltip = document.getElementById('barrier_high_tooltip');
	                    var high_span = document.getElementById('barrier_high_span');
	                    var low_tooltip = document.getElementById('barrier_low_tooltip');
	                    var low_span = document.getElementById('barrier_low_span');

	                    var defaults_barrier_high = Defaults.get('barrier_high');
	                    var defaults_barrier_low = Defaults.get('barrier_low');
	                    var barrier_high = defaults_barrier_high && !isNaN(defaults_barrier_high) ? defaults_barrier_high : barrier.barrier,
	                        barrier_low = defaults_barrier_low && !isNaN(defaults_barrier_low) ? defaults_barrier_low : barrier.barrier1,
	                        value_high = void 0,
	                        value_low = void 0;
	                    if (unit && isVisible(unit) && unit.value === 'd' || end_time && isVisible(end_time) && moment(end_time.getAttribute('data-value')).isAfter(moment(), 'day') || !String(barrier.barrier).match(/^[+-]/)) {
	                        if (current_tick && !isNaN(current_tick) && String(barrier_high).match(/^[+-]/)) {
	                            value_high = (parseFloat(current_tick) + parseFloat(barrier_high)).toFixed(decimal_places);
	                            value_low = (parseFloat(current_tick) + parseFloat(barrier_low)).toFixed(decimal_places);
	                        } else {
	                            value_high = parseFloat(barrier_high);
	                            value_low = parseFloat(barrier_low);
	                        }

	                        high_tooltip.style.display = 'none';
	                        high_span.style.display = 'inherit';
	                        low_tooltip.style.display = 'none';
	                        low_span.style.display = 'inherit';

	                        elementTextContent(indicative_high_barrier_tooltip, '');
	                        elementTextContent(indicative_low_barrier_tooltip, '');
	                    } else {
	                        // override Defaults value, if it's changing from absolute to relative barrier
	                        if (!String(barrier_high).match(/^[+-]/) || !String(barrier_low).match(/^[+-]/)) {
	                            barrier_high = barrier.barrier;
	                            barrier_low = barrier.barrier1;
	                        }
	                        value_high = barrier_high;
	                        value_low = barrier_low;

	                        high_span.style.display = 'none';
	                        high_tooltip.style.display = 'inherit';
	                        low_span.style.display = 'none';
	                        low_tooltip.style.display = 'inherit';

	                        if (current_tick && !isNaN(current_tick)) {
	                            elementTextContent(indicative_high_barrier_tooltip, (parseFloat(current_tick) + parseFloat(barrier_high)).toFixed(decimal_places));
	                            elementTextContent(indicative_low_barrier_tooltip, (parseFloat(current_tick) + parseFloat(barrier_low)).toFixed(decimal_places));
	                        } else {
	                            elementTextContent(indicative_high_barrier_tooltip, '');
	                            elementTextContent(indicative_low_barrier_tooltip, '');
	                        }
	                    }
	                    high_elm.value = high_elm.textContent = value_high;
	                    low_elm.value = low_elm.textContent = value_low;

	                    Defaults.set('barrier_high', high_elm.value);
	                    Defaults.set('barrier_low', low_elm.value);
	                    Defaults.remove('barrier');
	                    return;
	                }
	            }
	        }

	        var elements = document.getElementsByClassName('barrier_class');
	        for (var i = 0; i < elements.length; i++) {
	            elements[i].style.display = 'none';
	        }
	        Defaults.remove('barrier', 'barrier_high', 'barrier_low');
	    };

	    var validateBarrier = function validateBarrier() {
	        var barrier_element = document.getElementById('barrier');
	        if (isVisible(barrier_element) && (isNaN(parseFloat(barrier_element.value)) || parseFloat(barrier_element.value) === 0)) {
	            barrier_element.classList.add('error-field');
	        } else {
	            barrier_element.classList.remove('error-field');
	        }
	    };

	    return {
	        display: display,
	        validateBarrier: validateBarrier,
	        isBarrierUpdated: function isBarrierUpdated() {
	            return is_barrier_updated;
	        },
	        setBarrierUpdate: function setBarrierUpdate(flag) {
	            is_barrier_updated = flag;
	        }
	    };
	}();

	module.exports = Barriers_Beta;

/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var getFormNameBarrierCategory = __webpack_require__(445).getFormNameBarrierCategory;
	var getLanguage = __webpack_require__(424).get;
	var localize = __webpack_require__(428).localize;
	var isEmptyObject = __webpack_require__(417).isEmptyObject;

	/*
	 * Contract object mocks the trading form we have on our website
	 * It parses the contracts json we get from socket.send({contracts_for: 'R_50'})
	 * and gives back barriers, startDate, durations etc
	 *
	 *
	 * Usage:
	 *
	 * use `Contract.details` to populate this object
	 *
	 * then use
	 *
	 * `Contract.durations()` to get durations like seconds, hours etc
	 * `Contract.open()` `Contract.close()`
	 * `Contract.barriers` if applicable for current underlying
	 */
	var Contract_Beta = function () {
	    'use strict';

	    var contract_type = {};
	    var contract_details = {},
	        _durations = {},
	        start_dates = {},
	        _barriers = {},
	        _open = void 0,
	        _close = void 0,
	        _form = void 0,
	        _barrier = void 0;

	    var populateDurations = function populateDurations(current_contract) {
	        var current_category = current_contract.contract_category;
	        var expiry_type = current_contract.expiry_type;
	        var barrier_category = current_contract.barrier_category;
	        var start_type = current_contract.start_type;
	        var max_duration = current_contract.max_contract_duration;
	        var min_duration = current_contract.min_contract_duration;

	        if (!_durations[expiry_type]) {
	            _durations[expiry_type] = {};
	        }

	        if (!_durations[expiry_type][current_category]) {
	            _durations[expiry_type][current_category] = {};
	        }

	        if (!_durations[expiry_type][current_category][barrier_category]) {
	            _durations[expiry_type][current_category][barrier_category] = {};
	        }

	        if (!_durations[expiry_type][current_category][barrier_category][start_type]) {
	            _durations[expiry_type][current_category][barrier_category][start_type] = {};
	        }

	        _durations[expiry_type][current_category][barrier_category][start_type].max_contract_duration = max_duration;

	        _durations[expiry_type][current_category][barrier_category][start_type].min_contract_duration = min_duration;
	    };

	    var details = function details(form_name) {
	        var contracts = Contract_Beta.contracts().contracts_for;
	        var barrier_category = void 0;

	        if (!contracts) return;

	        start_dates = { has_spot: 0, list: [] };
	        _durations = {};
	        _open = contracts.open;
	        _close = contracts.close;

	        var form_barrier = getFormNameBarrierCategory(form_name);
	        _form = form_name = form_barrier.form_name;
	        _barrier = barrier_category = form_barrier.barrier_category;

	        contracts.available.forEach(function (current_obj) {
	            var contract_category = current_obj.contract_category;

	            if (form_name && form_name === contract_category) {
	                if (barrier_category) {
	                    if (barrier_category === current_obj.barrier_category) {
	                        populateDurations(current_obj);
	                    }
	                } else {
	                    populateDurations(current_obj);
	                }

	                if (current_obj.forward_starting_options && current_obj.start_type === 'forward' && sessionStorage.formname !== 'higherlower') {
	                    start_dates.list = current_obj.forward_starting_options;
	                } else if (current_obj.start_type === 'spot') {
	                    start_dates.has_spot = 1;
	                }

	                var symbol = current_obj.underlying_symbol;
	                if (current_obj.barrier_category && current_obj.barrier_category !== 'non_financial') {
	                    if (!_barriers.hasOwnProperty(symbol)) {
	                        _barriers[symbol] = {};
	                    }
	                    if (current_obj.barriers === 1) {
	                        _barriers[symbol][contract_category] = {
	                            count: 1,
	                            barrier: current_obj.barrier,
	                            barrier_category: current_obj.barrier_category
	                        };
	                    } else if (current_obj.barriers === 2) {
	                        _barriers[symbol][contract_category] = {
	                            count: 2,
	                            barrier: current_obj.high_barrier,
	                            barrier1: current_obj.low_barrier,
	                            barrier_category: current_obj.barrier_category
	                        };
	                    }
	                }

	                if (!contract_type[contract_category]) {
	                    contract_type[contract_category] = {};
	                }

	                if (!contract_type[contract_category].hasOwnProperty(current_obj.contract_type)) {
	                    contract_type[contract_category][current_obj.contract_type] = localize(current_obj.contract_display);
	                }
	            }
	        });

	        if (form_name && barrier_category) {
	            if (_barriers && _barriers[form_name] && _barriers[form_name].barrier_category !== barrier_category) {
	                _barriers = {};
	            }
	        }
	    };

	    var getContractForms = function getContractForms() {
	        var contracts = Contract_Beta.contracts().contracts_for;
	        var trade_contract_forms = {};

	        if (!contracts) return null;

	        contracts.available.forEach(function (current_obj) {
	            var contract_category = current_obj.contract_category;
	            if (contract_category && !trade_contract_forms.hasOwnProperty(contract_category)) {
	                if (contract_category === 'callput') {
	                    if (current_obj.barrier_category === 'euro_atm') {
	                        trade_contract_forms.risefall = localize('Rise/Fall');
	                    } else {
	                        trade_contract_forms.higherlower = localize('Higher/Lower');
	                    }
	                } else {
	                    trade_contract_forms[contract_category] = localize(current_obj.contract_category_display);
	                    if (contract_category === 'digits') {
	                        trade_contract_forms.matchdiff = localize('Matches/Differs');
	                        if (getLanguage() !== 'ID') {
	                            trade_contract_forms.evenodd = localize('Even/Odd');
	                            trade_contract_forms.overunder = localize('Over/Under');
	                        }
	                    }
	                }
	            }
	        });

	        if (isEmptyObject(trade_contract_forms)) return null;

	        if (trade_contract_forms.risefall || trade_contract_forms.higherlower) {
	            trade_contract_forms.updown = localize('Up/Down');
	        }

	        if (trade_contract_forms.endsinout || trade_contract_forms.staysinout) {
	            trade_contract_forms.inout = localize('In/Out');
	        }

	        return trade_contract_forms;
	    };

	    return {
	        details: details,
	        contractForms: getContractForms,
	        open: function open() {
	            return _open;
	        },
	        close: function close() {
	            return _close;
	        },
	        contracts: function contracts() {
	            return contract_details;
	        },
	        durations: function durations() {
	            return _durations;
	        },
	        startDates: function startDates() {
	            return start_dates;
	        },
	        barriers: function barriers() {
	            return _barriers;
	        },
	        contractType: function contractType() {
	            return contract_type;
	        },
	        form: function form() {
	            return _form;
	        },
	        barrier: function barrier() {
	            return _barrier;
	        },
	        setContracts: function setContracts(data) {
	            contract_details = data;
	        }
	    };
	}();

	module.exports = Contract_Beta;

/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var Highcharts = __webpack_require__(453);
	var Symbols = __webpack_require__(447);
	var BinarySocket = __webpack_require__(427);
	var localize = __webpack_require__(428).localize;
	var template = __webpack_require__(417).template;
	__webpack_require__(454)(Highcharts);

	var DigitInfo_Beta = function () {
	    'use strict';

	    var spots = [],
	        stream_id = null,
	        chart = void 0,

	    // To avoid too many greens and reds
	    prev_min_index = -1,
	        prev_max_index = -1;

	    var chart_config = {
	        chart: {
	            renderTo: 'last_digit_histo',
	            defaultSeriesType: 'column',
	            backgroundColor: '#eee',
	            borderWidth: 1,
	            borderColor: '#ccc',
	            plotBackgroundColor: '#fff',
	            plotBorderWidth: 1,
	            plotBorderColor: '#ccc',
	            height: 250 },
	        title: { text: '' },
	        credits: { enabled: false },
	        exporting: { enabled: false },
	        legend: {
	            enabled: false
	        },
	        tooltip: {
	            borderWidth: 1,
	            formatter: function formatter() {
	                var total = $('#tick_count').val();
	                var percentage = this.y / total * 100;
	                return '<b>' + localize('Digit') + ':</b> ' + this.x + '<br/><b>' + localize('Percentage') + ':</b> ' + percentage.toFixed(1) + '%';
	            }
	        },
	        plotOptions: {
	            column: {
	                shadow: false,
	                borderWidth: 0.5,
	                borderColor: '#666',
	                pointPadding: 0,
	                groupPadding: 0.0,
	                color: '#e1f0fb'
	            },
	            series: {
	                dataLabels: {
	                    enabled: true,
	                    allowOverlap: true,
	                    style: {
	                        textShadow: false,
	                        fontSize: '10px'
	                    },
	                    formatter: function formatter() {
	                        var total = $('#tick_count').val();
	                        var percentage = this.point.y / total * 100;
	                        return percentage.toFixed(2) + '%';
	                    }
	                }
	            }
	        },
	        xAxis: {
	            categories: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
	            lineWidth: 0,
	            lineColor: '#999',
	            tickLength: 10,
	            tickColor: '#ccc'
	        },
	        yAxis: {
	            title: { text: '' },
	            maxPadding: 0,
	            gridLineColor: '#e9e9e9',
	            tickWidth: 1,
	            tickLength: 3,
	            tickColor: '#ccc',
	            lineColor: '#ccc',
	            endOnTick: true,
	            opposite: false,

	            labels: {
	                align: 'left',
	                x: 0,
	                enabled: false,
	                formatter: function formatter() {
	                    var total = $('#tick_count').val();
	                    var percentage = parseInt(this.value / total * 100);
	                    return percentage + '%';
	                }
	            }
	        }
	    };

	    var addContent = function addContent(underlying) {
	        var domain = document.domain.split('.').slice(-2).join('.');
	        var symbols = Symbols.getAllSymbols();
	        var underlyings = [];
	        Object.keys(symbols).forEach(function (key) {
	            if (/^(R_|RD)/.test(key)) {
	                underlyings.push(key);
	            }
	        });
	        underlyings = underlyings.sort();
	        var elem = '';
	        for (var i = 0; i < underlyings.length; i++) {
	            elem += '<option value="' + underlyings[i] + '">' + localize(symbols[underlyings[i]]) + '</option>';
	        }
	        $('#digit_underlying').html($(elem)).val(underlying);
	        $('#digit_domain').text(domain.charAt(0).toUpperCase() + domain.slice(1));
	        $('#digit_info_underlying').text($('#digit_underlying option:selected').text());
	    };

	    var onLatest = function onLatest() {
	        var getLatest = function getLatest() {
	            var $digit_underlying_option = $('#digit_underlying option:selected');
	            var symbol = $digit_underlying_option.val();
	            var count = $('#tick_count').val();
	            $('#digit_info_underlying').text($digit_underlying_option.text());
	            $('#digit_info_count').text(count);
	            var request = {
	                ticks_history: symbol,
	                end: 'latest',
	                count: count
	            };
	            if (chart.series[0].name !== symbol) {
	                if ($('#underlying').find('option:selected').val() !== $('#digit_underlying').val()) {
	                    request.subscribe = 1;
	                    request.style = 'ticks';
	                }
	                if (stream_id !== null) {
	                    BinarySocket.send({ forget: stream_id });
	                    stream_id = null;
	                }
	            }
	            BinarySocket.send(request, { callback: function callback(response) {
	                    var type = response.msg_type;
	                    if (type === 'tick') {
	                        updateChart(response);
	                    } else if (type === 'history') {
	                        showChart(response.echo_req.ticks_history, response.history.prices);
	                    }
	                } });
	        };
	        $('#digit_underlying, #tick_count').off('change').on('change', getLatest);
	    };

	    var showChart = function showChart(underlying, underlying_spots) {
	        if (typeof underlying_spots === 'undefined' || underlying_spots.length <= 0) {
	            console.log('Unexpected error occured in the charts.');
	            return;
	        }
	        var dec = underlying_spots[0].split('.')[1].length;
	        for (var i = 0; i < underlying_spots.length; i++) {
	            var val = parseFloat(underlying_spots[i]).toFixed(dec);
	            underlying_spots[i] = val.substr(val.length - 1);
	        }

	        var getTitle = function getTitle() {
	            return { text: template($('#last_digit_title').html(), [underlying_spots.length, $('#digit_underlying option:selected').text()]) };
	        };

	        spots = underlying_spots;
	        if (chart && $('#last_digit_histo').html()) {
	            chart.xAxis[0].update({ title: getTitle() }, true);
	            chart.series[0].name = underlying;
	        } else {
	            addContent(underlying); // this creates #last_digit_title
	            chart_config.xAxis.title = getTitle();
	            chart = new Highcharts.Chart(chart_config);
	            chart.addSeries({ name: underlying, data: [] });
	            onLatest();
	            stream_id = null;
	        }
	        update();
	    };

	    var update = function update(symbol, latest_spot) {
	        if (typeof chart === 'undefined') {
	            return null;
	        }

	        var series = chart.series[0]; // Where we put the final data.
	        if (series.name !== symbol) {
	            latest_spot = undefined; // This simplifies the logic a bit later.
	        }

	        if (typeof latest_spot !== 'undefined') {
	            // This is a bit later. :D
	            spots.unshift(latest_spot.slice(-1)); // Only last digit matters
	            spots.pop();
	        }

	        // Always recompute and draw, even if theres no new data.
	        // This is especially useful on first reuqest, but maybe in other ways.
	        var filtered_spots = [];
	        var filterFunc = function filterFunc(el) {
	            return +el === digit;
	        };
	        var min_max_counter = [];
	        var digit = 10;
	        while (digit--) {
	            var val = spots.filter(filterFunc).length;
	            filtered_spots[digit] = val;
	            if (typeof min_max_counter[val] === 'undefined') {
	                min_max_counter[val] = 0;
	            }
	            min_max_counter[val]++;
	        }
	        var min = Math.min.apply(null, filtered_spots);
	        var max = Math.max.apply(null, filtered_spots);
	        var min_index = filtered_spots.indexOf(min);
	        var max_index = filtered_spots.indexOf(max);
	        // changing color
	        if (min_max_counter[min] >= 1) {
	            filtered_spots[min_index] = { y: min, color: '#CC0000' };
	            if (prev_min_index === -1) {
	                prev_min_index = min_index;
	            } else if (prev_min_index !== min_index) {
	                if (_typeof(filtered_spots[prev_min_index]) === 'object') {
	                    filtered_spots[prev_min_index] = { y: filtered_spots[prev_min_index].y, color: '#e1f0fb' };
	                } else {
	                    filtered_spots[prev_min_index] = { y: filtered_spots[prev_min_index], color: '#e1f0fb' };
	                }
	                prev_min_index = min_index;
	            }
	        }

	        if (min_max_counter[max] >= 1) {
	            filtered_spots[max_index] = { y: max, color: '#2E8836' };
	            if (prev_max_index === -1) {
	                prev_max_index = max_index;
	            } else if (prev_max_index !== max_index) {
	                if (_typeof(filtered_spots[prev_max_index]) === 'object') {
	                    filtered_spots[prev_max_index] = { y: filtered_spots[prev_max_index].y, color: '#e1f0fb' };
	                } else {
	                    filtered_spots[prev_max_index] = { y: filtered_spots[prev_max_index], color: '#e1f0fb' };
	                }
	                prev_max_index = max_index;
	            }
	        }
	        return series.setData(filtered_spots);
	    };

	    var updateChart = function updateChart(tick) {
	        if (stream_id) {
	            if (chart.series[0].name === tick.tick.symbol) {
	                stream_id = tick.tick.id || null;
	                update(tick.tick.symbol, tick.tick.quote);
	            } else {
	                BinarySocket.send({ forget: tick.tick.id.toString() });
	            }
	        } else {
	            update(tick.tick.symbol, tick.tick.quote);
	        }
	    };

	    return {
	        showChart: showChart,
	        updateChart: updateChart
	    };
	}();

	module.exports = DigitInfo_Beta;

/***/ },
/* 453 */
/***/ function(module, exports) {

	/*
	 Highcharts JS v5.0.9 (2017-03-08)

	 (c) 2009-2016 Torstein Honsi

	 License: www.highcharts.com/license
	*/
	(function(I,a){"object"===typeof module&&module.exports?module.exports=I.document?a(I):a:I.Highcharts=a(I)})("undefined"!==typeof window?window:this,function(I){I=function(){var a=window,B=a.document,z=a.navigator&&a.navigator.userAgent||"",C=B&&B.createElementNS&&!!B.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect,E=/(edge|msie|trident)/i.test(z)&&!window.opera,u=!C,h=/Firefox/.test(z),n=h&&4>parseInt(z.split("Firefox/")[1],10);return a.Highcharts?a.Highcharts.error(16,!0):{product:"Highcharts",
	version:"5.0.9",deg2rad:2*Math.PI/360,doc:B,hasBidiBug:n,hasTouch:B&&void 0!==B.documentElement.ontouchstart,isMS:E,isWebKit:/AppleWebKit/.test(z),isFirefox:h,isTouchDevice:/(Mobile|Android|Windows Phone)/.test(z),SVG_NS:"http://www.w3.org/2000/svg",chartCount:0,seriesTypes:{},symbolSizes:{},svg:C,vml:u,win:a,charts:[],marginNames:["plotTop","marginRight","marginBottom","plotLeft"],noop:function(){}}}();(function(a){var B=[],z=a.charts,C=a.doc,E=a.win;a.error=function(u,h){u=a.isNumber(u)?"Highcharts error #"+
	u+": www.highcharts.com/errors/"+u:u;if(h)throw Error(u);E.console&&console.log(u)};a.Fx=function(a,h,n){this.options=h;this.elem=a;this.prop=n};a.Fx.prototype={dSetter:function(){var a=this.paths[0],h=this.paths[1],n=[],t=this.now,l=a.length,k;if(1===t)n=this.toD;else if(l===h.length&&1>t)for(;l--;)k=parseFloat(a[l]),n[l]=isNaN(k)?a[l]:t*parseFloat(h[l]-k)+k;else n=h;this.elem.attr("d",n,null,!0)},update:function(){var a=this.elem,h=this.prop,n=this.now,t=this.options.step;if(this[h+"Setter"])this[h+
	"Setter"]();else a.attr?a.element&&a.attr(h,n,null,!0):a.style[h]=n+this.unit;t&&t.call(a,n,this)},run:function(a,h,n){var u=this,l=function(a){return l.stopped?!1:u.step(a)},k;this.startTime=+new Date;this.start=a;this.end=h;this.unit=n;this.now=this.start;this.pos=0;l.elem=this.elem;l.prop=this.prop;l()&&1===B.push(l)&&(l.timerId=setInterval(function(){for(k=0;k<B.length;k++)B[k]()||B.splice(k--,1);B.length||clearInterval(l.timerId)},13))},step:function(a){var h=+new Date,u,t=this.options;u=this.elem;
	var l=t.complete,k=t.duration,e=t.curAnim,c;if(u.attr&&!u.element)u=!1;else if(a||h>=k+this.startTime){this.now=this.end;this.pos=1;this.update();a=e[this.prop]=!0;for(c in e)!0!==e[c]&&(a=!1);a&&l&&l.call(u);u=!1}else this.pos=t.easing((h-this.startTime)/k),this.now=this.start+(this.end-this.start)*this.pos,this.update(),u=!0;return u},initPath:function(u,h,n){function t(a){var b,f;for(r=a.length;r--;)b="M"===a[r]||"L"===a[r],f=/[a-zA-Z]/.test(a[r+3]),b&&f&&a.splice(r+1,0,a[r+1],a[r+2],a[r+1],a[r+
	2])}function l(a,f){for(;a.length<m;){a[0]=f[m-a.length];var d=a.slice(0,b);[].splice.apply(a,[0,0].concat(d));A&&(d=a.slice(a.length-b),[].splice.apply(a,[a.length,0].concat(d)),r--)}a[0]="M"}function k(a,f){for(var c=(m-a.length)/b;0<c&&c--;)d=a.slice().splice(a.length/v-b,b*v),d[0]=f[m-b-c*b],H&&(d[b-6]=d[b-2],d[b-5]=d[b-1]),[].splice.apply(a,[a.length/v,0].concat(d)),A&&c--}h=h||"";var e,c=u.startX,p=u.endX,H=-1<h.indexOf("C"),b=H?7:3,m,d,r;h=h.split(" ");n=n.slice();var A=u.isArea,v=A?2:1,f;
	H&&(t(h),t(n));if(c&&p){for(r=0;r<c.length;r++)if(c[r]===p[0]){e=r;break}else if(c[0]===p[p.length-c.length+r]){e=r;f=!0;break}void 0===e&&(h=[])}h.length&&a.isNumber(e)&&(m=n.length+e*v*b,f?(l(h,n),k(n,h)):(l(n,h),k(h,n)));return[h,n]}};a.extend=function(a,h){var u;a||(a={});for(u in h)a[u]=h[u];return a};a.merge=function(){var u,h=arguments,n,t={},l=function(k,e){var c,p;"object"!==typeof k&&(k={});for(p in e)e.hasOwnProperty(p)&&(c=e[p],a.isObject(c,!0)&&"renderTo"!==p&&"number"!==typeof c.nodeType?
	k[p]=l(k[p]||{},c):k[p]=e[p]);return k};!0===h[0]&&(t=h[1],h=Array.prototype.slice.call(h,2));n=h.length;for(u=0;u<n;u++)t=l(t,h[u]);return t};a.pInt=function(a,h){return parseInt(a,h||10)};a.isString=function(a){return"string"===typeof a};a.isArray=function(a){a=Object.prototype.toString.call(a);return"[object Array]"===a||"[object Array Iterator]"===a};a.isObject=function(u,h){return u&&"object"===typeof u&&(!h||!a.isArray(u))};a.isNumber=function(a){return"number"===typeof a&&!isNaN(a)};a.erase=
	function(a,h){for(var u=a.length;u--;)if(a[u]===h){a.splice(u,1);break}};a.defined=function(a){return void 0!==a&&null!==a};a.attr=function(u,h,n){var t,l;if(a.isString(h))a.defined(n)?u.setAttribute(h,n):u&&u.getAttribute&&(l=u.getAttribute(h));else if(a.defined(h)&&a.isObject(h))for(t in h)u.setAttribute(t,h[t]);return l};a.splat=function(u){return a.isArray(u)?u:[u]};a.syncTimeout=function(a,h,n){if(h)return setTimeout(a,h,n);a.call(0,n)};a.pick=function(){var a=arguments,h,n,t=a.length;for(h=
	0;h<t;h++)if(n=a[h],void 0!==n&&null!==n)return n};a.css=function(u,h){a.isMS&&!a.svg&&h&&void 0!==h.opacity&&(h.filter="alpha(opacity\x3d"+100*h.opacity+")");a.extend(u.style,h)};a.createElement=function(u,h,n,t,l){u=C.createElement(u);var k=a.css;h&&a.extend(u,h);l&&k(u,{padding:0,border:"none",margin:0});n&&k(u,n);t&&t.appendChild(u);return u};a.extendClass=function(u,h){var n=function(){};n.prototype=new u;a.extend(n.prototype,h);return n};a.pad=function(a,h,n){return Array((h||2)+1-String(a).length).join(n||
	0)+a};a.relativeLength=function(a,h){return/%$/.test(a)?h*parseFloat(a)/100:parseFloat(a)};a.wrap=function(a,h,n){var t=a[h];a[h]=function(){var a=Array.prototype.slice.call(arguments),k=arguments,e=this;e.proceed=function(){t.apply(e,arguments.length?arguments:k)};a.unshift(t);a=n.apply(this,a);e.proceed=null;return a}};a.getTZOffset=function(u){var h=a.Date;return 6E4*(h.hcGetTimezoneOffset&&h.hcGetTimezoneOffset(u)||h.hcTimezoneOffset||0)};a.dateFormat=function(u,h,n){if(!a.defined(h)||isNaN(h))return a.defaultOptions.lang.invalidDate||
	"";u=a.pick(u,"%Y-%m-%d %H:%M:%S");var t=a.Date,l=new t(h-a.getTZOffset(h)),k,e=l[t.hcGetHours](),c=l[t.hcGetDay](),p=l[t.hcGetDate](),H=l[t.hcGetMonth](),b=l[t.hcGetFullYear](),m=a.defaultOptions.lang,d=m.weekdays,r=m.shortWeekdays,A=a.pad,t=a.extend({a:r?r[c]:d[c].substr(0,3),A:d[c],d:A(p),e:A(p,2," "),w:c,b:m.shortMonths[H],B:m.months[H],m:A(H+1),y:b.toString().substr(2,2),Y:b,H:A(e),k:e,I:A(e%12||12),l:e%12||12,M:A(l[t.hcGetMinutes]()),p:12>e?"AM":"PM",P:12>e?"am":"pm",S:A(l.getSeconds()),L:A(Math.round(h%
	1E3),3)},a.dateFormats);for(k in t)for(;-1!==u.indexOf("%"+k);)u=u.replace("%"+k,"function"===typeof t[k]?t[k](h):t[k]);return n?u.substr(0,1).toUpperCase()+u.substr(1):u};a.formatSingle=function(u,h){var n=/\.([0-9])/,t=a.defaultOptions.lang;/f$/.test(u)?(n=(n=u.match(n))?n[1]:-1,null!==h&&(h=a.numberFormat(h,n,t.decimalPoint,-1<u.indexOf(",")?t.thousandsSep:""))):h=a.dateFormat(u,h);return h};a.format=function(u,h){for(var n="{",t=!1,l,k,e,c,p=[],H;u;){n=u.indexOf(n);if(-1===n)break;l=u.slice(0,
	n);if(t){l=l.split(":");k=l.shift().split(".");c=k.length;H=h;for(e=0;e<c;e++)H=H[k[e]];l.length&&(H=a.formatSingle(l.join(":"),H));p.push(H)}else p.push(l);u=u.slice(n+1);n=(t=!t)?"}":"{"}p.push(u);return p.join("")};a.getMagnitude=function(a){return Math.pow(10,Math.floor(Math.log(a)/Math.LN10))};a.normalizeTickInterval=function(u,h,n,t,l){var k,e=u;n=a.pick(n,1);k=u/n;h||(h=l?[1,1.2,1.5,2,2.5,3,4,5,6,8,10]:[1,2,2.5,5,10],!1===t&&(1===n?h=a.grep(h,function(a){return 0===a%1}):.1>=n&&(h=[1/n])));
	for(t=0;t<h.length&&!(e=h[t],l&&e*n>=u||!l&&k<=(h[t]+(h[t+1]||h[t]))/2);t++);return e=a.correctFloat(e*n,-Math.round(Math.log(.001)/Math.LN10))};a.stableSort=function(a,h){var n=a.length,t,l;for(l=0;l<n;l++)a[l].safeI=l;a.sort(function(a,e){t=h(a,e);return 0===t?a.safeI-e.safeI:t});for(l=0;l<n;l++)delete a[l].safeI};a.arrayMin=function(a){for(var h=a.length,n=a[0];h--;)a[h]<n&&(n=a[h]);return n};a.arrayMax=function(a){for(var h=a.length,n=a[0];h--;)a[h]>n&&(n=a[h]);return n};a.destroyObjectProperties=
	function(a,h){for(var n in a)a[n]&&a[n]!==h&&a[n].destroy&&a[n].destroy(),delete a[n]};a.discardElement=function(u){var h=a.garbageBin;h||(h=a.createElement("div"));u&&h.appendChild(u);h.innerHTML=""};a.correctFloat=function(a,h){return parseFloat(a.toPrecision(h||14))};a.setAnimation=function(u,h){h.renderer.globalAnimation=a.pick(u,h.options.chart.animation,!0)};a.animObject=function(u){return a.isObject(u)?a.merge(u):{duration:u?500:0}};a.timeUnits={millisecond:1,second:1E3,minute:6E4,hour:36E5,
	day:864E5,week:6048E5,month:24192E5,year:314496E5};a.numberFormat=function(u,h,n,t){u=+u||0;h=+h;var l=a.defaultOptions.lang,k=(u.toString().split(".")[1]||"").length,e,c;-1===h?h=Math.min(k,20):a.isNumber(h)||(h=2);c=(Math.abs(u)+Math.pow(10,-Math.max(h,k)-1)).toFixed(h);k=String(a.pInt(c));e=3<k.length?k.length%3:0;n=a.pick(n,l.decimalPoint);t=a.pick(t,l.thousandsSep);u=(0>u?"-":"")+(e?k.substr(0,e)+t:"");u+=k.substr(e).replace(/(\d{3})(?=\d)/g,"$1"+t);h&&(u+=n+c.slice(-h));return u};Math.easeInOutSine=
	function(a){return-.5*(Math.cos(Math.PI*a)-1)};a.getStyle=function(u,h){return"width"===h?Math.min(u.offsetWidth,u.scrollWidth)-a.getStyle(u,"padding-left")-a.getStyle(u,"padding-right"):"height"===h?Math.min(u.offsetHeight,u.scrollHeight)-a.getStyle(u,"padding-top")-a.getStyle(u,"padding-bottom"):(u=E.getComputedStyle(u,void 0))&&a.pInt(u.getPropertyValue(h))};a.inArray=function(a,h){return h.indexOf?h.indexOf(a):[].indexOf.call(h,a)};a.grep=function(a,h){return[].filter.call(a,h)};a.find=function(a,
	h){return[].find.call(a,h)};a.map=function(a,h){for(var n=[],t=0,l=a.length;t<l;t++)n[t]=h.call(a[t],a[t],t,a);return n};a.offset=function(a){var h=C.documentElement;a=a.getBoundingClientRect();return{top:a.top+(E.pageYOffset||h.scrollTop)-(h.clientTop||0),left:a.left+(E.pageXOffset||h.scrollLeft)-(h.clientLeft||0)}};a.stop=function(a,h){for(var n=B.length;n--;)B[n].elem!==a||h&&h!==B[n].prop||(B[n].stopped=!0)};a.each=function(a,h,n){return Array.prototype.forEach.call(a,h,n)};a.addEvent=function(u,
	h,n){function t(a){a.target=a.srcElement||E;n.call(u,a)}var l=u.hcEvents=u.hcEvents||{};u.addEventListener?u.addEventListener(h,n,!1):u.attachEvent&&(u.hcEventsIE||(u.hcEventsIE={}),u.hcEventsIE[n.toString()]=t,u.attachEvent("on"+h,t));l[h]||(l[h]=[]);l[h].push(n);return function(){a.removeEvent(u,h,n)}};a.removeEvent=function(u,h,n){function t(a,c){u.removeEventListener?u.removeEventListener(a,c,!1):u.attachEvent&&(c=u.hcEventsIE[c.toString()],u.detachEvent("on"+a,c))}function l(){var a,c;if(u.nodeName)for(c in h?
	(a={},a[h]=!0):a=e,a)if(e[c])for(a=e[c].length;a--;)t(c,e[c][a])}var k,e=u.hcEvents,c;e&&(h?(k=e[h]||[],n?(c=a.inArray(n,k),-1<c&&(k.splice(c,1),e[h]=k),t(h,n)):(l(),e[h]=[])):(l(),u.hcEvents={}))};a.fireEvent=function(u,h,n,t){var l;l=u.hcEvents;var k,e;n=n||{};if(C.createEvent&&(u.dispatchEvent||u.fireEvent))l=C.createEvent("Events"),l.initEvent(h,!0,!0),a.extend(l,n),u.dispatchEvent?u.dispatchEvent(l):u.fireEvent(h,l);else if(l)for(l=l[h]||[],k=l.length,n.target||a.extend(n,{preventDefault:function(){n.defaultPrevented=
	!0},target:u,type:h}),h=0;h<k;h++)(e=l[h])&&!1===e.call(u,n)&&n.preventDefault();t&&!n.defaultPrevented&&t(n)};a.animate=function(u,h,n){var t,l="",k,e,c;a.isObject(n)||(t=arguments,n={duration:t[2],easing:t[3],complete:t[4]});a.isNumber(n.duration)||(n.duration=400);n.easing="function"===typeof n.easing?n.easing:Math[n.easing]||Math.easeInOutSine;n.curAnim=a.merge(h);for(c in h)a.stop(u,c),e=new a.Fx(u,n,c),k=null,"d"===c?(e.paths=e.initPath(u,u.d,h.d),e.toD=h.d,t=0,k=1):u.attr?t=u.attr(c):(t=parseFloat(a.getStyle(u,
	c))||0,"opacity"!==c&&(l="px")),k||(k=h[c]),k&&k.match&&k.match("px")&&(k=k.replace(/px/g,"")),e.run(t,k,l)};a.seriesType=function(u,h,n,t,l){var k=a.getOptions(),e=a.seriesTypes;k.plotOptions[u]=a.merge(k.plotOptions[h],n);e[u]=a.extendClass(e[h]||function(){},t);e[u].prototype.type=u;l&&(e[u].prototype.pointClass=a.extendClass(a.Point,l));return e[u]};a.uniqueKey=function(){var a=Math.random().toString(36).substring(2,9),h=0;return function(){return"highcharts-"+a+"-"+h++}}();E.jQuery&&(E.jQuery.fn.highcharts=
	function(){var u=[].slice.call(arguments);if(this[0])return u[0]?(new (a[a.isString(u[0])?u.shift():"Chart"])(this[0],u[0],u[1]),this):z[a.attr(this[0],"data-highcharts-chart")]});C&&!C.defaultView&&(a.getStyle=function(u,h){var n={width:"clientWidth",height:"clientHeight"}[h];if(u.style[h])return a.pInt(u.style[h]);"opacity"===h&&(h="filter");if(n)return u.style.zoom=1,Math.max(u[n]-2*a.getStyle(u,"padding"),0);u=u.currentStyle[h.replace(/\-(\w)/g,function(a,l){return l.toUpperCase()})];"filter"===
	h&&(u=u.replace(/alpha\(opacity=([0-9]+)\)/,function(a,l){return l/100}));return""===u?1:a.pInt(u)});Array.prototype.forEach||(a.each=function(a,h,n){for(var t=0,l=a.length;t<l;t++)if(!1===h.call(n,a[t],t,a))return t});Array.prototype.indexOf||(a.inArray=function(a,h){var n,t=0;if(h)for(n=h.length;t<n;t++)if(h[t]===a)return t;return-1});Array.prototype.filter||(a.grep=function(a,h){for(var n=[],t=0,l=a.length;t<l;t++)h(a[t],t)&&n.push(a[t]);return n});Array.prototype.find||(a.find=function(a,h){var n,
	t=a.length;for(n=0;n<t;n++)if(h(a[n],n))return a[n]})})(I);(function(a){var B=a.each,z=a.isNumber,C=a.map,E=a.merge,u=a.pInt;a.Color=function(h){if(!(this instanceof a.Color))return new a.Color(h);this.init(h)};a.Color.prototype={parsers:[{regex:/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,parse:function(a){return[u(a[1]),u(a[2]),u(a[3]),parseFloat(a[4],10)]}},{regex:/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,parse:function(a){return[u(a[1]),
	u(a[2]),u(a[3]),1]}}],names:{white:"#ffffff",black:"#000000"},init:function(h){var n,t,l,k;if((this.input=h=this.names[h]||h)&&h.stops)this.stops=C(h.stops,function(e){return new a.Color(e[1])});else if(h&&"#"===h[0]&&(n=h.length,h=parseInt(h.substr(1),16),7===n?t=[(h&16711680)>>16,(h&65280)>>8,h&255,1]:4===n&&(t=[(h&3840)>>4|(h&3840)>>8,(h&240)>>4|h&240,(h&15)<<4|h&15,1])),!t)for(l=this.parsers.length;l--&&!t;)k=this.parsers[l],(n=k.regex.exec(h))&&(t=k.parse(n));this.rgba=t||[]},get:function(a){var h=
	this.input,t=this.rgba,l;this.stops?(l=E(h),l.stops=[].concat(l.stops),B(this.stops,function(k,e){l.stops[e]=[l.stops[e][0],k.get(a)]})):l=t&&z(t[0])?"rgb"===a||!a&&1===t[3]?"rgb("+t[0]+","+t[1]+","+t[2]+")":"a"===a?t[3]:"rgba("+t.join(",")+")":h;return l},brighten:function(a){var h,t=this.rgba;if(this.stops)B(this.stops,function(l){l.brighten(a)});else if(z(a)&&0!==a)for(h=0;3>h;h++)t[h]+=u(255*a),0>t[h]&&(t[h]=0),255<t[h]&&(t[h]=255);return this},setOpacity:function(a){this.rgba[3]=a;return this}};
	a.color=function(h){return new a.Color(h)}})(I);(function(a){var B,z,C=a.addEvent,E=a.animate,u=a.attr,h=a.charts,n=a.color,t=a.css,l=a.createElement,k=a.defined,e=a.deg2rad,c=a.destroyObjectProperties,p=a.doc,H=a.each,b=a.extend,m=a.erase,d=a.grep,r=a.hasTouch,A=a.inArray,v=a.isArray,f=a.isFirefox,y=a.isMS,G=a.isObject,F=a.isString,q=a.isWebKit,x=a.merge,J=a.noop,K=a.pick,L=a.pInt,g=a.removeEvent,D=a.stop,S=a.svg,M=a.SVG_NS,R=a.symbolSizes,N=a.win;B=a.SVGElement=function(){return this};B.prototype=
	{opacity:1,SVG_NS:M,textProps:"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline".split(" "),init:function(a,g){this.element="span"===g?l(g):p.createElementNS(this.SVG_NS,g);this.renderer=a},animate:function(w,g,b){g=a.animObject(K(g,this.renderer.globalAnimation,!0));0!==g.duration?(b&&(g.complete=b),E(this,w,g)):(this.attr(w,null,b),g.step&&g.step.call(this));return this},colorGradient:function(w,g,b){var f=this.renderer,
	d,c,q,D,O,y,r,G,e,m,p,l=[],Q;w.linearGradient?c="linearGradient":w.radialGradient&&(c="radialGradient");if(c){q=w[c];O=f.gradients;r=w.stops;m=b.radialReference;v(q)&&(w[c]=q={x1:q[0],y1:q[1],x2:q[2],y2:q[3],gradientUnits:"userSpaceOnUse"});"radialGradient"===c&&m&&!k(q.gradientUnits)&&(D=q,q=x(q,f.getRadialAttr(m,D),{gradientUnits:"userSpaceOnUse"}));for(p in q)"id"!==p&&l.push(p,q[p]);for(p in r)l.push(r[p]);l=l.join(",");O[l]?m=O[l].attr("id"):(q.id=m=a.uniqueKey(),O[l]=y=f.createElement(c).attr(q).add(f.defs),
	y.radAttr=D,y.stops=[],H(r,function(w){0===w[1].indexOf("rgba")?(d=a.color(w[1]),G=d.get("rgb"),e=d.get("a")):(G=w[1],e=1);w=f.createElement("stop").attr({offset:w[0],"stop-color":G,"stop-opacity":e}).add(y);y.stops.push(w)}));Q="url("+f.url+"#"+m+")";b.setAttribute(g,Q);b.gradient=l;w.toString=function(){return Q}}},applyTextOutline:function(a){var w=this.element,g,b,f,d;-1!==a.indexOf("contrast")&&(a=a.replace(/contrast/g,this.renderer.getContrast(w.style.fill)));this.fakeTS=!0;this.ySetter=this.xSetter;
	g=[].slice.call(w.getElementsByTagName("tspan"));a=a.split(" ");b=a[a.length-1];(f=a[0])&&"none"!==f&&(f=f.replace(/(^[\d\.]+)(.*?)$/g,function(a,w,g){return 2*w+g}),H(g,function(a){"highcharts-text-outline"===a.getAttribute("class")&&m(g,w.removeChild(a))}),d=w.firstChild,H(g,function(a,g){0===g&&(a.setAttribute("x",w.getAttribute("x")),g=w.getAttribute("y"),a.setAttribute("y",g||0),null===g&&w.setAttribute("y",0));a=a.cloneNode(1);u(a,{"class":"highcharts-text-outline",fill:b,stroke:b,"stroke-width":f,
	"stroke-linejoin":"round"});w.insertBefore(a,d)}))},attr:function(a,g,b,f){var w,d=this.element,q,c=this,y;"string"===typeof a&&void 0!==g&&(w=a,a={},a[w]=g);if("string"===typeof a)c=(this[a+"Getter"]||this._defaultGetter).call(this,a,d);else{for(w in a)g=a[w],y=!1,f||D(this,w),this.symbolName&&/^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(w)&&(q||(this.symbolAttr(a),q=!0),y=!0),!this.rotation||"x"!==w&&"y"!==w||(this.doTransform=!0),y||(y=this[w+"Setter"]||this._defaultSetter,y.call(this,
	g,w,d),this.shadows&&/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(w)&&this.updateShadows(w,g,y));this.doTransform&&(this.updateTransform(),this.doTransform=!1)}b&&b();return c},updateShadows:function(a,g,b){for(var w=this.shadows,f=w.length;f--;)b.call(w[f],"height"===a?Math.max(g-(w[f].cutHeight||0),0):"d"===a?this.d:g,a,w[f])},addClass:function(a,g){var w=this.attr("class")||"";-1===w.indexOf(a)&&(g||(a=(w+(w?" ":"")+a).replace("  "," ")),this.attr("class",a));return this},hasClass:function(a){return-1!==
	u(this.element,"class").indexOf(a)},removeClass:function(a){u(this.element,"class",(u(this.element,"class")||"").replace(a,""));return this},symbolAttr:function(a){var w=this;H("x y r start end width height innerR anchorX anchorY".split(" "),function(g){w[g]=K(a[g],w[g])});w.attr({d:w.renderer.symbols[w.symbolName](w.x,w.y,w.width,w.height,w)})},clip:function(a){return this.attr("clip-path",a?"url("+this.renderer.url+"#"+a.id+")":"none")},crisp:function(a,g){var w,f={},b;g=g||a.strokeWidth||0;b=Math.round(g)%
	2/2;a.x=Math.floor(a.x||this.x||0)+b;a.y=Math.floor(a.y||this.y||0)+b;a.width=Math.floor((a.width||this.width||0)-2*b);a.height=Math.floor((a.height||this.height||0)-2*b);k(a.strokeWidth)&&(a.strokeWidth=g);for(w in a)this[w]!==a[w]&&(this[w]=f[w]=a[w]);return f},css:function(a){var w=this.styles,g={},f=this.element,d,q="",c=!w,D=["textOverflow","width"];a&&a.color&&(a.fill=a.color);if(w)for(d in a)a[d]!==w[d]&&(g[d]=a[d],c=!0);if(c){w&&(a=b(w,g));w=this.textWidth=a&&a.width&&"auto"!==a.width&&"text"===
	f.nodeName.toLowerCase()&&L(a.width);this.styles=a;w&&!S&&this.renderer.forExport&&delete a.width;if(y&&!S)t(this.element,a);else{w=function(a,w){return"-"+w.toLowerCase()};for(d in a)-1===A(d,D)&&(q+=d.replace(/([A-Z])/g,w)+":"+a[d]+";");q&&u(f,"style",q)}this.added&&("text"===this.element.nodeName&&this.renderer.buildText(this),a&&a.textOutline&&this.applyTextOutline(a.textOutline))}return this},strokeWidth:function(){return this["stroke-width"]||0},on:function(a,g){var w=this,f=w.element;r&&"click"===
	a?(f.ontouchstart=function(a){w.touchEventFired=Date.now();a.preventDefault();g.call(f,a)},f.onclick=function(a){(-1===N.navigator.userAgent.indexOf("Android")||1100<Date.now()-(w.touchEventFired||0))&&g.call(f,a)}):f["on"+a]=g;return this},setRadialReference:function(a){var w=this.renderer.gradients[this.element.gradient];this.element.radialReference=a;w&&w.radAttr&&w.animate(this.renderer.getRadialAttr(a,w.radAttr));return this},translate:function(a,g){return this.attr({translateX:a,translateY:g})},
	invert:function(a){this.inverted=a;this.updateTransform();return this},updateTransform:function(){var a=this.translateX||0,g=this.translateY||0,f=this.scaleX,b=this.scaleY,d=this.inverted,q=this.rotation,c=this.element;d&&(a+=this.width,g+=this.height);a=["translate("+a+","+g+")"];d?a.push("rotate(90) scale(-1,1)"):q&&a.push("rotate("+q+" "+(c.getAttribute("x")||0)+" "+(c.getAttribute("y")||0)+")");(k(f)||k(b))&&a.push("scale("+K(f,1)+" "+K(b,1)+")");a.length&&c.setAttribute("transform",a.join(" "))},
	toFront:function(){var a=this.element;a.parentNode.appendChild(a);return this},align:function(a,g,f){var w,b,d,q,c={};b=this.renderer;d=b.alignedObjects;var D,y;if(a){if(this.alignOptions=a,this.alignByTranslate=g,!f||F(f))this.alignTo=w=f||"renderer",m(d,this),d.push(this),f=null}else a=this.alignOptions,g=this.alignByTranslate,w=this.alignTo;f=K(f,b[w],b);w=a.align;b=a.verticalAlign;d=(f.x||0)+(a.x||0);q=(f.y||0)+(a.y||0);"right"===w?D=1:"center"===w&&(D=2);D&&(d+=(f.width-(a.width||0))/D);c[g?
	"translateX":"x"]=Math.round(d);"bottom"===b?y=1:"middle"===b&&(y=2);y&&(q+=(f.height-(a.height||0))/y);c[g?"translateY":"y"]=Math.round(q);this[this.placed?"animate":"attr"](c);this.placed=!0;this.alignAttr=c;return this},getBBox:function(a,g){var w,f=this.renderer,d,q=this.element,c=this.styles,D,y=this.textStr,x,r=f.cache,G=f.cacheKeys,m;g=K(g,this.rotation);d=g*e;D=c&&c.fontSize;void 0!==y&&(m=y.toString(),-1===m.indexOf("\x3c")&&(m=m.replace(/[0-9]/g,"0")),m+=["",g||0,D,c&&c.width,c&&c.textOverflow].join());
	m&&!a&&(w=r[m]);if(!w){if(q.namespaceURI===this.SVG_NS||f.forExport){try{(x=this.fakeTS&&function(a){H(q.querySelectorAll(".highcharts-text-outline"),function(w){w.style.display=a})})&&x("none"),w=q.getBBox?b({},q.getBBox()):{width:q.offsetWidth,height:q.offsetHeight},x&&x("")}catch(X){}if(!w||0>w.width)w={width:0,height:0}}else w=this.htmlGetBBox();f.isSVG&&(a=w.width,f=w.height,c&&"11px"===c.fontSize&&17===Math.round(f)&&(w.height=f=14),g&&(w.width=Math.abs(f*Math.sin(d))+Math.abs(a*Math.cos(d)),
	w.height=Math.abs(f*Math.cos(d))+Math.abs(a*Math.sin(d))));if(m&&0<w.height){for(;250<G.length;)delete r[G.shift()];r[m]||G.push(m);r[m]=w}}return w},show:function(a){return this.attr({visibility:a?"inherit":"visible"})},hide:function(){return this.attr({visibility:"hidden"})},fadeOut:function(a){var w=this;w.animate({opacity:0},{duration:a||150,complete:function(){w.attr({y:-9999})}})},add:function(a){var w=this.renderer,g=this.element,f;a&&(this.parentGroup=a);this.parentInverted=a&&a.inverted;
	void 0!==this.textStr&&w.buildText(this);this.added=!0;if(!a||a.handleZ||this.zIndex)f=this.zIndexSetter();f||(a?a.element:w.box).appendChild(g);if(this.onAdd)this.onAdd();return this},safeRemoveChild:function(a){var w=a.parentNode;w&&w.removeChild(a)},destroy:function(){var a=this.element||{},g=this.renderer.isSVG&&"SPAN"===a.nodeName&&this.parentGroup,f,b;a.onclick=a.onmouseout=a.onmouseover=a.onmousemove=a.point=null;D(this);this.clipPath&&(this.clipPath=this.clipPath.destroy());if(this.stops){for(b=
	0;b<this.stops.length;b++)this.stops[b]=this.stops[b].destroy();this.stops=null}this.safeRemoveChild(a);for(this.destroyShadows();g&&g.div&&0===g.div.childNodes.length;)a=g.parentGroup,this.safeRemoveChild(g.div),delete g.div,g=a;this.alignTo&&m(this.renderer.alignedObjects,this);for(f in this)delete this[f];return null},shadow:function(a,g,f){var w=[],b,d,c=this.element,q,D,y,x;if(!a)this.destroyShadows();else if(!this.shadows){D=K(a.width,3);y=(a.opacity||.15)/D;x=this.parentInverted?"(-1,-1)":
	"("+K(a.offsetX,1)+", "+K(a.offsetY,1)+")";for(b=1;b<=D;b++)d=c.cloneNode(0),q=2*D+1-2*b,u(d,{isShadow:"true",stroke:a.color||"#000000","stroke-opacity":y*b,"stroke-width":q,transform:"translate"+x,fill:"none"}),f&&(u(d,"height",Math.max(u(d,"height")-q,0)),d.cutHeight=q),g?g.element.appendChild(d):c.parentNode.insertBefore(d,c),w.push(d);this.shadows=w}return this},destroyShadows:function(){H(this.shadows||[],function(a){this.safeRemoveChild(a)},this);this.shadows=void 0},xGetter:function(a){"circle"===
	this.element.nodeName&&("x"===a?a="cx":"y"===a&&(a="cy"));return this._defaultGetter(a)},_defaultGetter:function(a){a=K(this[a],this.element?this.element.getAttribute(a):null,0);/^[\-0-9\.]+$/.test(a)&&(a=parseFloat(a));return a},dSetter:function(a,g,f){a&&a.join&&(a=a.join(" "));/(NaN| {2}|^$)/.test(a)&&(a="M 0 0");f.setAttribute(g,a);this[g]=a},dashstyleSetter:function(a){var w,g=this["stroke-width"];"inherit"===g&&(g=1);if(a=a&&a.toLowerCase()){a=a.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot",
	"3,1,1,1").replace("shortdot","1,1,").replace("shortdash","3,1,").replace("longdash","8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");for(w=a.length;w--;)a[w]=L(a[w])*g;a=a.join(",").replace(/NaN/g,"none");this.element.setAttribute("stroke-dasharray",a)}},alignSetter:function(a){this.element.setAttribute("text-anchor",{left:"start",center:"middle",right:"end"}[a])},opacitySetter:function(a,g,f){this[g]=a;f.setAttribute(g,a)},titleSetter:function(a){var w=this.element.getElementsByTagName("title")[0];
	w||(w=p.createElementNS(this.SVG_NS,"title"),this.element.appendChild(w));w.firstChild&&w.removeChild(w.firstChild);w.appendChild(p.createTextNode(String(K(a),"").replace(/<[^>]*>/g,"")))},textSetter:function(a){a!==this.textStr&&(delete this.bBox,this.textStr=a,this.added&&this.renderer.buildText(this))},fillSetter:function(a,g,f){"string"===typeof a?f.setAttribute(g,a):a&&this.colorGradient(a,g,f)},visibilitySetter:function(a,g,f){"inherit"===a?f.removeAttribute(g):f.setAttribute(g,a)},zIndexSetter:function(a,
	g){var w=this.renderer,f=this.parentGroup,b=(f||w).element||w.box,d,c=this.element,q;d=this.added;var D;k(a)&&(c.zIndex=a,a=+a,this[g]===a&&(d=!1),this[g]=a);if(d){(a=this.zIndex)&&f&&(f.handleZ=!0);g=b.childNodes;for(D=0;D<g.length&&!q;D++)f=g[D],d=f.zIndex,f!==c&&(L(d)>a||!k(a)&&k(d)||0>a&&!k(d)&&b!==w.box)&&(b.insertBefore(c,f),q=!0);q||b.appendChild(c)}return q},_defaultSetter:function(a,g,f){f.setAttribute(g,a)}};B.prototype.yGetter=B.prototype.xGetter;B.prototype.translateXSetter=B.prototype.translateYSetter=
	B.prototype.rotationSetter=B.prototype.verticalAlignSetter=B.prototype.scaleXSetter=B.prototype.scaleYSetter=function(a,g){this[g]=a;this.doTransform=!0};B.prototype["stroke-widthSetter"]=B.prototype.strokeSetter=function(a,g,f){this[g]=a;this.stroke&&this["stroke-width"]?(B.prototype.fillSetter.call(this,this.stroke,"stroke",f),f.setAttribute("stroke-width",this["stroke-width"]),this.hasStroke=!0):"stroke-width"===g&&0===a&&this.hasStroke&&(f.removeAttribute("stroke"),this.hasStroke=!1)};z=a.SVGRenderer=
	function(){this.init.apply(this,arguments)};z.prototype={Element:B,SVG_NS:M,init:function(a,g,b,d,c,D){var w;d=this.createElement("svg").attr({version:"1.1","class":"highcharts-root"}).css(this.getStyle(d));w=d.element;a.appendChild(w);-1===a.innerHTML.indexOf("xmlns")&&u(w,"xmlns",this.SVG_NS);this.isSVG=!0;this.box=w;this.boxWrapper=d;this.alignedObjects=[];this.url=(f||q)&&p.getElementsByTagName("base").length?N.location.href.replace(/#.*?$/,"").replace(/<[^>]*>/g,"").replace(/([\('\)])/g,"\\$1").replace(/ /g,
	"%20"):"";this.createElement("desc").add().element.appendChild(p.createTextNode("Created with Highcharts 5.0.9"));this.defs=this.createElement("defs").add();this.allowHTML=D;this.forExport=c;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.setSize(g,b,!1);var y;f&&a.getBoundingClientRect&&(g=function(){t(a,{left:0,top:0});y=a.getBoundingClientRect();t(a,{left:Math.ceil(y.left)-y.left+"px",top:Math.ceil(y.top)-y.top+"px"})},g(),this.unSubPixelFix=C(N,"resize",g))},getStyle:function(a){return this.style=
	b({fontFamily:'"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',fontSize:"12px"},a)},setStyle:function(a){this.boxWrapper.css(this.getStyle(a))},isHidden:function(){return!this.boxWrapper.getBBox().width},destroy:function(){var a=this.defs;this.box=null;this.boxWrapper=this.boxWrapper.destroy();c(this.gradients||{});this.gradients=null;a&&(this.defs=a.destroy());this.unSubPixelFix&&this.unSubPixelFix();return this.alignedObjects=null},createElement:function(a){var g=new this.Element;
	g.init(this,a);return g},draw:J,getRadialAttr:function(a,g){return{cx:a[0]-a[2]/2+g.cx*a[2],cy:a[1]-a[2]/2+g.cy*a[2],r:g.r*a[2]}},buildText:function(a){var g=a.element,f=this,w=f.forExport,b=K(a.textStr,"").toString(),c=-1!==b.indexOf("\x3c"),q=g.childNodes,D,y,x,r,G=u(g,"x"),m=a.styles,e=a.textWidth,l=m&&m.lineHeight,v=m&&m.textOutline,k=m&&"ellipsis"===m.textOverflow,h=m&&"nowrap"===m.whiteSpace,F=m&&m.fontSize,A,J=q.length,m=e&&!a.added&&this.box,n=function(a){var w;w=/(px|em)$/.test(a&&a.style.fontSize)?
	a.style.fontSize:F||f.style.fontSize||12;return l?L(l):f.fontMetrics(w,a.getAttribute("style")?a:g).h};A=[b,k,h,l,v,F,e].join();if(A!==a.textCache){for(a.textCache=A;J--;)g.removeChild(q[J]);c||v||k||e||-1!==b.indexOf(" ")?(D=/<.*class="([^"]+)".*>/,y=/<.*style="([^"]+)".*>/,x=/<.*href="(http[^"]+)".*>/,m&&m.appendChild(g),b=c?b.replace(/<(b|strong)>/g,'\x3cspan style\x3d"font-weight:bold"\x3e').replace(/<(i|em)>/g,'\x3cspan style\x3d"font-style:italic"\x3e').replace(/<a/g,"\x3cspan").replace(/<\/(b|strong|i|em|a)>/g,
	"\x3c/span\x3e").split(/<br.*?>/g):[b],b=d(b,function(a){return""!==a}),H(b,function(b,d){var c,q=0;b=b.replace(/^\s+|\s+$/g,"").replace(/<span/g,"|||\x3cspan").replace(/<\/span>/g,"\x3c/span\x3e|||");c=b.split("|||");H(c,function(b){if(""!==b||1===c.length){var m={},v=p.createElementNS(f.SVG_NS,"tspan"),l,F;D.test(b)&&(l=b.match(D)[1],u(v,"class",l));y.test(b)&&(F=b.match(y)[1].replace(/(;| |^)color([ :])/,"$1fill$2"),u(v,"style",F));x.test(b)&&!w&&(u(v,"onclick",'location.href\x3d"'+b.match(x)[1]+
	'"'),t(v,{cursor:"pointer"}));b=(b.replace(/<(.|\n)*?>/g,"")||" ").replace(/&lt;/g,"\x3c").replace(/&gt;/g,"\x3e");if(" "!==b){v.appendChild(p.createTextNode(b));q?m.dx=0:d&&null!==G&&(m.x=G);u(v,m);g.appendChild(v);!q&&d&&(!S&&w&&t(v,{display:"block"}),u(v,"dy",n(v)));if(e){m=b.replace(/([^\^])-/g,"$1- ").split(" ");l=1<c.length||d||1<m.length&&!h;for(var A,H,O=[],J=n(v),K=a.rotation,L=b,P=L.length;(l||k)&&(m.length||O.length);)a.rotation=0,A=a.getBBox(!0),H=A.width,!S&&f.forExport&&(H=f.measureSpanWidth(v.firstChild.data,
	a.styles)),A=H>e,void 0===r&&(r=A),k&&r?(P/=2,""===L||!A&&.5>P?m=[]:(L=b.substring(0,L.length+(A?-1:1)*Math.ceil(P)),m=[L+(3<e?"\u2026":"")],v.removeChild(v.firstChild))):A&&1!==m.length?(v.removeChild(v.firstChild),O.unshift(m.pop())):(m=O,O=[],m.length&&!h&&(v=p.createElementNS(M,"tspan"),u(v,{dy:J,x:G}),F&&u(v,"style",F),g.appendChild(v)),H>e&&(e=H)),m.length&&v.appendChild(p.createTextNode(m.join(" ").replace(/- /g,"-")));a.rotation=K}q++}}})}),r&&a.attr("title",a.textStr),m&&m.removeChild(g),
	v&&a.applyTextOutline&&a.applyTextOutline(v)):g.appendChild(p.createTextNode(b.replace(/&lt;/g,"\x3c").replace(/&gt;/g,"\x3e")))}},getContrast:function(a){a=n(a).rgba;return 510<a[0]+a[1]+a[2]?"#000000":"#FFFFFF"},button:function(a,g,f,d,c,q,D,m,r){var w=this.label(a,g,f,r,null,null,null,null,"button"),G=0;w.attr(x({padding:8,r:2},c));var e,v,p,l;c=x({fill:"#f7f7f7",stroke:"#cccccc","stroke-width":1,style:{color:"#333333",cursor:"pointer",fontWeight:"normal"}},c);e=c.style;delete c.style;q=x(c,{fill:"#e6e6e6"},
	q);v=q.style;delete q.style;D=x(c,{fill:"#e6ebf5",style:{color:"#000000",fontWeight:"bold"}},D);p=D.style;delete D.style;m=x(c,{style:{color:"#cccccc"}},m);l=m.style;delete m.style;C(w.element,y?"mouseover":"mouseenter",function(){3!==G&&w.setState(1)});C(w.element,y?"mouseout":"mouseleave",function(){3!==G&&w.setState(G)});w.setState=function(a){1!==a&&(w.state=G=a);w.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-"+["normal","hover","pressed","disabled"][a||
	0]);w.attr([c,q,D,m][a||0]).css([e,v,p,l][a||0])};w.attr(c).css(b({cursor:"default"},e));return w.on("click",function(a){3!==G&&d.call(w,a)})},crispLine:function(a,g){a[1]===a[4]&&(a[1]=a[4]=Math.round(a[1])-g%2/2);a[2]===a[5]&&(a[2]=a[5]=Math.round(a[2])+g%2/2);return a},path:function(a){var g={fill:"none"};v(a)?g.d=a:G(a)&&b(g,a);return this.createElement("path").attr(g)},circle:function(a,g,f){a=G(a)?a:{x:a,y:g,r:f};g=this.createElement("circle");g.xSetter=g.ySetter=function(a,g,f){f.setAttribute("c"+
	g,a)};return g.attr(a)},arc:function(a,g,f,b,d,c){G(a)?(b=a,g=b.y,f=b.r,a=b.x):b={innerR:b,start:d,end:c};a=this.symbol("arc",a,g,f,f,b);a.r=f;return a},rect:function(a,g,f,b,d,c){d=G(a)?a.r:d;var w=this.createElement("rect");a=G(a)?a:void 0===a?{}:{x:a,y:g,width:Math.max(f,0),height:Math.max(b,0)};void 0!==c&&(a.strokeWidth=c,a=w.crisp(a));a.fill="none";d&&(a.r=d);w.rSetter=function(a,g,f){u(f,{rx:a,ry:a})};return w.attr(a)},setSize:function(a,g,f){var b=this.alignedObjects,d=b.length;this.width=
	a;this.height=g;for(this.boxWrapper.animate({width:a,height:g},{step:function(){this.attr({viewBox:"0 0 "+this.attr("width")+" "+this.attr("height")})},duration:K(f,!0)?void 0:0});d--;)b[d].align()},g:function(a){var g=this.createElement("g");return a?g.attr({"class":"highcharts-"+a}):g},image:function(a,g,f,d,c){var w={preserveAspectRatio:"none"};1<arguments.length&&b(w,{x:g,y:f,width:d,height:c});w=this.createElement("image").attr(w);w.element.setAttributeNS?w.element.setAttributeNS("http://www.w3.org/1999/xlink",
	"href",a):w.element.setAttribute("hc-svg-href",a);return w},symbol:function(a,g,f,d,c,q){var w=this,D,y=this.symbols[a],m=k(g)&&y&&this.symbols[a](Math.round(g),Math.round(f),d,c,q),x=/^url\((.*?)\)$/,G,r;y?(D=this.path(m),D.attr("fill","none"),b(D,{symbolName:a,x:g,y:f,width:d,height:c}),q&&b(D,q)):x.test(a)&&(G=a.match(x)[1],D=this.image(G),D.imgwidth=K(R[G]&&R[G].width,q&&q.width),D.imgheight=K(R[G]&&R[G].height,q&&q.height),r=function(){D.attr({width:D.width,height:D.height})},H(["width","height"],
	function(a){D[a+"Setter"]=function(a,g){var f={},b=this["img"+g],d="width"===g?"translateX":"translateY";this[g]=a;k(b)&&(this.element&&this.element.setAttribute(g,b),this.alignByTranslate||(f[d]=((this[g]||0)-b)/2,this.attr(f)))}}),k(g)&&D.attr({x:g,y:f}),D.isImg=!0,k(D.imgwidth)&&k(D.imgheight)?r():(D.attr({width:0,height:0}),l("img",{onload:function(){var a=h[w.chartIndex];0===this.width&&(t(this,{position:"absolute",top:"-999em"}),p.body.appendChild(this));R[G]={width:this.width,height:this.height};
	D.imgwidth=this.width;D.imgheight=this.height;D.element&&r();this.parentNode&&this.parentNode.removeChild(this);w.imgCount--;if(!w.imgCount&&a&&a.onload)a.onload()},src:G}),this.imgCount++));return D},symbols:{circle:function(a,g,f,b){return this.arc(a+f/2,g+b/2,f/2,b/2,{start:0,end:2*Math.PI,open:!1})},square:function(a,g,f,b){return["M",a,g,"L",a+f,g,a+f,g+b,a,g+b,"Z"]},triangle:function(a,g,f,b){return["M",a+f/2,g,"L",a+f,g+b,a,g+b,"Z"]},"triangle-down":function(a,g,f,b){return["M",a,g,"L",a+f,
	g,a+f/2,g+b,"Z"]},diamond:function(a,g,f,b){return["M",a+f/2,g,"L",a+f,g+b/2,a+f/2,g+b,a,g+b/2,"Z"]},arc:function(a,g,f,b,d){var c=d.start,w=d.r||f,q=d.r||b||f,D=d.end-.001;f=d.innerR;b=d.open;var y=Math.cos(c),m=Math.sin(c),x=Math.cos(D),D=Math.sin(D);d=d.end-c<Math.PI?0:1;w=["M",a+w*y,g+q*m,"A",w,q,0,d,1,a+w*x,g+q*D];k(f)&&w.push(b?"M":"L",a+f*x,g+f*D,"A",f,f,0,d,0,a+f*y,g+f*m);w.push(b?"":"Z");return w},callout:function(a,g,f,b,d){var c=Math.min(d&&d.r||0,f,b),q=c+6,D=d&&d.anchorX;d=d&&d.anchorY;
	var w;w=["M",a+c,g,"L",a+f-c,g,"C",a+f,g,a+f,g,a+f,g+c,"L",a+f,g+b-c,"C",a+f,g+b,a+f,g+b,a+f-c,g+b,"L",a+c,g+b,"C",a,g+b,a,g+b,a,g+b-c,"L",a,g+c,"C",a,g,a,g,a+c,g];D&&D>f?d>g+q&&d<g+b-q?w.splice(13,3,"L",a+f,d-6,a+f+6,d,a+f,d+6,a+f,g+b-c):w.splice(13,3,"L",a+f,b/2,D,d,a+f,b/2,a+f,g+b-c):D&&0>D?d>g+q&&d<g+b-q?w.splice(33,3,"L",a,d+6,a-6,d,a,d-6,a,g+c):w.splice(33,3,"L",a,b/2,D,d,a,b/2,a,g+c):d&&d>b&&D>a+q&&D<a+f-q?w.splice(23,3,"L",D+6,g+b,D,g+b+6,D-6,g+b,a+c,g+b):d&&0>d&&D>a+q&&D<a+f-q&&w.splice(3,
	3,"L",D-6,g,D,g-6,D+6,g,f-c,g);return w}},clipRect:function(g,f,b,d){var c=a.uniqueKey(),q=this.createElement("clipPath").attr({id:c}).add(this.defs);g=this.rect(g,f,b,d,0).add(q);g.id=c;g.clipPath=q;g.count=0;return g},text:function(a,g,f,b){var d=!S&&this.forExport,c={};if(b&&(this.allowHTML||!this.forExport))return this.html(a,g,f);c.x=Math.round(g||0);f&&(c.y=Math.round(f));if(a||0===a)c.text=a;a=this.createElement("text").attr(c);d&&a.css({position:"absolute"});b||(a.xSetter=function(a,g,f){var b=
	f.getElementsByTagName("tspan"),d,c=f.getAttribute(g),q;for(q=0;q<b.length;q++)d=b[q],d.getAttribute(g)===c&&d.setAttribute(g,a);f.setAttribute(g,a)});return a},fontMetrics:function(a,g){a=a||g&&g.style&&g.style.fontSize||this.style&&this.style.fontSize;a=/px/.test(a)?L(a):/em/.test(a)?parseFloat(a)*(g?this.fontMetrics(null,g.parentNode).f:16):12;g=24>a?a+3:Math.round(1.2*a);return{h:g,b:Math.round(.8*g),f:a}},rotCorr:function(a,g,f){var b=a;g&&f&&(b=Math.max(b*Math.cos(g*e),4));return{x:-a/3*Math.sin(g*
	e),y:b}},label:function(f,d,c,q,D,y,m,G,r){var w=this,e=w.g("button"!==r&&"label"),v=e.text=w.text("",0,0,m).attr({zIndex:1}),p,l,F=0,A=3,h=0,J,t,S,n,M,K={},L,u,O=/^url\((.*?)\)$/.test(q),R=O,P,Q,N,U;r&&e.addClass("highcharts-"+r);R=O;P=function(){return(L||0)%2/2};Q=function(){var a=v.element.style,g={};l=(void 0===J||void 0===t||M)&&k(v.textStr)&&v.getBBox();e.width=(J||l.width||0)+2*A+h;e.height=(t||l.height||0)+2*A;u=A+w.fontMetrics(a&&a.fontSize,v).b;R&&(p||(e.box=p=w.symbols[q]||O?w.symbol(q):
	w.rect(),p.addClass(("button"===r?"":"highcharts-label-box")+(r?" highcharts-"+r+"-box":"")),p.add(e),a=P(),g.x=a,g.y=(G?-u:0)+a),g.width=Math.round(e.width),g.height=Math.round(e.height),p.attr(b(g,K)),K={})};N=function(){var a=h+A,g;g=G?0:u;k(J)&&l&&("center"===M||"right"===M)&&(a+={center:.5,right:1}[M]*(J-l.width));if(a!==v.x||g!==v.y)v.attr("x",a),void 0!==g&&v.attr("y",g);v.x=a;v.y=g};U=function(a,g){p?p.attr(a,g):K[a]=g};e.onAdd=function(){v.add(e);e.attr({text:f||0===f?f:"",x:d,y:c});p&&k(D)&&
	e.attr({anchorX:D,anchorY:y})};e.widthSetter=function(g){J=a.isNumber(g)?g:null};e.heightSetter=function(a){t=a};e["text-alignSetter"]=function(a){M=a};e.paddingSetter=function(a){k(a)&&a!==A&&(A=e.padding=a,N())};e.paddingLeftSetter=function(a){k(a)&&a!==h&&(h=a,N())};e.alignSetter=function(a){a={left:0,center:.5,right:1}[a];a!==F&&(F=a,l&&e.attr({x:S}))};e.textSetter=function(a){void 0!==a&&v.textSetter(a);Q();N()};e["stroke-widthSetter"]=function(a,g){a&&(R=!0);L=this["stroke-width"]=a;U(g,a)};
	e.strokeSetter=e.fillSetter=e.rSetter=function(a,g){"fill"===g&&a&&(R=!0);U(g,a)};e.anchorXSetter=function(a,g){D=a;U(g,Math.round(a)-P()-S)};e.anchorYSetter=function(a,g){y=a;U(g,a-n)};e.xSetter=function(a){e.x=a;F&&(a-=F*((J||l.width)+2*A));S=Math.round(a);e.attr("translateX",S)};e.ySetter=function(a){n=e.y=Math.round(a);e.attr("translateY",n)};var W=e.css;return b(e,{css:function(a){if(a){var g={};a=x(a);H(e.textProps,function(f){void 0!==a[f]&&(g[f]=a[f],delete a[f])});v.css(g)}return W.call(e,
	a)},getBBox:function(){return{width:l.width+2*A,height:l.height+2*A,x:l.x-A,y:l.y-A}},shadow:function(a){a&&(Q(),p&&p.shadow(a));return e},destroy:function(){g(e.element,"mouseenter");g(e.element,"mouseleave");v&&(v=v.destroy());p&&(p=p.destroy());B.prototype.destroy.call(e);e=w=Q=N=U=null}})}};a.Renderer=z})(I);(function(a){var B=a.attr,z=a.createElement,C=a.css,E=a.defined,u=a.each,h=a.extend,n=a.isFirefox,t=a.isMS,l=a.isWebKit,k=a.pInt,e=a.SVGRenderer,c=a.win,p=a.wrap;h(a.SVGElement.prototype,
	{htmlCss:function(a){var b=this.element;if(b=a&&"SPAN"===b.tagName&&a.width)delete a.width,this.textWidth=b,this.updateTransform();a&&"ellipsis"===a.textOverflow&&(a.whiteSpace="nowrap",a.overflow="hidden");this.styles=h(this.styles,a);C(this.element,a);return this},htmlGetBBox:function(){var a=this.element;"text"===a.nodeName&&(a.style.position="absolute");return{x:a.offsetLeft,y:a.offsetTop,width:a.offsetWidth,height:a.offsetHeight}},htmlUpdateTransform:function(){if(this.added){var a=this.renderer,
	b=this.element,c=this.translateX||0,d=this.translateY||0,e=this.x||0,p=this.y||0,v=this.textAlign||"left",f={left:0,center:.5,right:1}[v],y=this.styles;C(b,{marginLeft:c,marginTop:d});this.shadows&&u(this.shadows,function(a){C(a,{marginLeft:c+1,marginTop:d+1})});this.inverted&&u(b.childNodes,function(f){a.invertChild(f,b)});if("SPAN"===b.tagName){var G=this.rotation,F=k(this.textWidth),q=y&&y.whiteSpace,x=[G,v,b.innerHTML,this.textWidth,this.textAlign].join();x!==this.cTT&&(y=a.fontMetrics(b.style.fontSize).b,
	E(G)&&this.setSpanRotation(G,f,y),C(b,{width:"",whiteSpace:q||"nowrap"}),b.offsetWidth>F&&/[ \-]/.test(b.textContent||b.innerText)&&C(b,{width:F+"px",display:"block",whiteSpace:q||"normal"}),this.getSpanCorrection(b.offsetWidth,y,f,G,v));C(b,{left:e+(this.xCorr||0)+"px",top:p+(this.yCorr||0)+"px"});l&&(y=b.offsetHeight);this.cTT=x}}else this.alignOnAdd=!0},setSpanRotation:function(a,b,e){var d={},m=t?"-ms-transform":l?"-webkit-transform":n?"MozTransform":c.opera?"-o-transform":"";d[m]=d.transform=
	"rotate("+a+"deg)";d[m+(n?"Origin":"-origin")]=d.transformOrigin=100*b+"% "+e+"px";C(this.element,d)},getSpanCorrection:function(a,b,c){this.xCorr=-a*c;this.yCorr=-b}});h(e.prototype,{html:function(a,b,c){var d=this.createElement("span"),e=d.element,m=d.renderer,v=m.isSVG,f=function(a,f){u(["opacity","visibility"],function(b){p(a,b+"Setter",function(a,b,d,c){a.call(this,b,d,c);f[d]=b})})};d.textSetter=function(a){a!==e.innerHTML&&delete this.bBox;e.innerHTML=this.textStr=a;d.htmlUpdateTransform()};
	v&&f(d,d.element.style);d.xSetter=d.ySetter=d.alignSetter=d.rotationSetter=function(a,f){"align"===f&&(f="textAlign");d[f]=a;d.htmlUpdateTransform()};d.attr({text:a,x:Math.round(b),y:Math.round(c)}).css({fontFamily:this.style.fontFamily,fontSize:this.style.fontSize,position:"absolute"});e.style.whiteSpace="nowrap";d.css=d.htmlCss;v&&(d.add=function(a){var b,c=m.box.parentNode,q=[];if(this.parentGroup=a){if(b=a.div,!b){for(;a;)q.push(a),a=a.parentGroup;u(q.reverse(),function(a){var y,e=B(a.element,
	"class");e&&(e={className:e});b=a.div=a.div||z("div",e,{position:"absolute",left:(a.translateX||0)+"px",top:(a.translateY||0)+"px",display:a.display,opacity:a.opacity,pointerEvents:a.styles&&a.styles.pointerEvents},b||c);y=b.style;h(a,{on:function(){d.on.apply({element:q[0].div},arguments);return a},translateXSetter:function(f,g){y.left=f+"px";a[g]=f;a.doTransform=!0},translateYSetter:function(f,g){y.top=f+"px";a[g]=f;a.doTransform=!0}});f(a,y)})}}else b=c;b.appendChild(e);d.added=!0;d.alignOnAdd&&
	d.htmlUpdateTransform();return d});return d}})})(I);(function(a){var B,z,C=a.createElement,E=a.css,u=a.defined,h=a.deg2rad,n=a.discardElement,t=a.doc,l=a.each,k=a.erase,e=a.extend;B=a.extendClass;var c=a.isArray,p=a.isNumber,H=a.isObject,b=a.merge;z=a.noop;var m=a.pick,d=a.pInt,r=a.SVGElement,A=a.SVGRenderer,v=a.win;a.svg||(z={docMode8:t&&8===t.documentMode,init:function(a,b){var f=["\x3c",b,' filled\x3d"f" stroked\x3d"f"'],d=["position: ","absolute",";"],c="div"===b;("shape"===b||c)&&d.push("left:0;top:0;width:1px;height:1px;");
	d.push("visibility: ",c?"hidden":"visible");f.push(' style\x3d"',d.join(""),'"/\x3e');b&&(f=c||"span"===b||"img"===b?f.join(""):a.prepVML(f),this.element=C(f));this.renderer=a},add:function(a){var f=this.renderer,b=this.element,d=f.box,c=a&&a.inverted,d=a?a.element||a:d;a&&(this.parentGroup=a);c&&f.invertChild(b,d);d.appendChild(b);this.added=!0;this.alignOnAdd&&!this.deferUpdateTransform&&this.updateTransform();if(this.onAdd)this.onAdd();this.className&&this.attr("class",this.className);return this},
	updateTransform:r.prototype.htmlUpdateTransform,setSpanRotation:function(){var a=this.rotation,b=Math.cos(a*h),d=Math.sin(a*h);E(this.element,{filter:a?["progid:DXImageTransform.Microsoft.Matrix(M11\x3d",b,", M12\x3d",-d,", M21\x3d",d,", M22\x3d",b,", sizingMethod\x3d'auto expand')"].join(""):"none"})},getSpanCorrection:function(a,b,d,c,q){var f=c?Math.cos(c*h):1,e=c?Math.sin(c*h):0,y=m(this.elemHeight,this.element.offsetHeight),r;this.xCorr=0>f&&-a;this.yCorr=0>e&&-y;r=0>f*e;this.xCorr+=e*b*(r?1-
	d:d);this.yCorr-=f*b*(c?r?d:1-d:1);q&&"left"!==q&&(this.xCorr-=a*d*(0>f?-1:1),c&&(this.yCorr-=y*d*(0>e?-1:1)),E(this.element,{textAlign:q}))},pathToVML:function(a){for(var f=a.length,b=[];f--;)p(a[f])?b[f]=Math.round(10*a[f])-5:"Z"===a[f]?b[f]="x":(b[f]=a[f],!a.isArc||"wa"!==a[f]&&"at"!==a[f]||(b[f+5]===b[f+7]&&(b[f+7]+=a[f+7]>a[f+5]?1:-1),b[f+6]===b[f+8]&&(b[f+8]+=a[f+8]>a[f+6]?1:-1)));return b.join(" ")||"x"},clip:function(a){var f=this,b;a?(b=a.members,k(b,f),b.push(f),f.destroyClip=function(){k(b,
	f)},a=a.getCSS(f)):(f.destroyClip&&f.destroyClip(),a={clip:f.docMode8?"inherit":"rect(auto)"});return f.css(a)},css:r.prototype.htmlCss,safeRemoveChild:function(a){a.parentNode&&n(a)},destroy:function(){this.destroyClip&&this.destroyClip();return r.prototype.destroy.apply(this)},on:function(a,b){this.element["on"+a]=function(){var a=v.event;a.target=a.srcElement;b(a)};return this},cutOffPath:function(a,b){var f;a=a.split(/[ ,]/);f=a.length;if(9===f||11===f)a[f-4]=a[f-2]=d(a[f-2])-10*b;return a.join(" ")},
	shadow:function(a,b,c){var f=[],q,e=this.element,y=this.renderer,r,v=e.style,g,D=e.path,p,l,G,k;D&&"string"!==typeof D.value&&(D="x");l=D;if(a){G=m(a.width,3);k=(a.opacity||.15)/G;for(q=1;3>=q;q++)p=2*G+1-2*q,c&&(l=this.cutOffPath(D.value,p+.5)),g=['\x3cshape isShadow\x3d"true" strokeweight\x3d"',p,'" filled\x3d"false" path\x3d"',l,'" coordsize\x3d"10 10" style\x3d"',e.style.cssText,'" /\x3e'],r=C(y.prepVML(g),null,{left:d(v.left)+m(a.offsetX,1),top:d(v.top)+m(a.offsetY,1)}),c&&(r.cutOff=p+1),g=['\x3cstroke color\x3d"',
	a.color||"#000000",'" opacity\x3d"',k*q,'"/\x3e'],C(y.prepVML(g),null,null,r),b?b.element.appendChild(r):e.parentNode.insertBefore(r,e),f.push(r);this.shadows=f}return this},updateShadows:z,setAttr:function(a,b){this.docMode8?this.element[a]=b:this.element.setAttribute(a,b)},classSetter:function(a){(this.added?this.element:this).className=a},dashstyleSetter:function(a,b,d){(d.getElementsByTagName("stroke")[0]||C(this.renderer.prepVML(["\x3cstroke/\x3e"]),null,null,d))[b]=a||"solid";this[b]=a},dSetter:function(a,
	b,d){var f=this.shadows;a=a||[];this.d=a.join&&a.join(" ");d.path=a=this.pathToVML(a);if(f)for(d=f.length;d--;)f[d].path=f[d].cutOff?this.cutOffPath(a,f[d].cutOff):a;this.setAttr(b,a)},fillSetter:function(a,b,d){var f=d.nodeName;"SPAN"===f?d.style.color=a:"IMG"!==f&&(d.filled="none"!==a,this.setAttr("fillcolor",this.renderer.color(a,d,b,this)))},"fill-opacitySetter":function(a,b,d){C(this.renderer.prepVML(["\x3c",b.split("-")[0],' opacity\x3d"',a,'"/\x3e']),null,null,d)},opacitySetter:z,rotationSetter:function(a,
	b,d){d=d.style;this[b]=d[b]=a;d.left=-Math.round(Math.sin(a*h)+1)+"px";d.top=Math.round(Math.cos(a*h))+"px"},strokeSetter:function(a,b,d){this.setAttr("strokecolor",this.renderer.color(a,d,b,this))},"stroke-widthSetter":function(a,b,d){d.stroked=!!a;this[b]=a;p(a)&&(a+="px");this.setAttr("strokeweight",a)},titleSetter:function(a,b){this.setAttr(b,a)},visibilitySetter:function(a,b,d){"inherit"===a&&(a="visible");this.shadows&&l(this.shadows,function(f){f.style[b]=a});"DIV"===d.nodeName&&(a="hidden"===
	a?"-999em":0,this.docMode8||(d.style[b]=a?"visible":"hidden"),b="top");d.style[b]=a},xSetter:function(a,b,d){this[b]=a;"x"===b?b="left":"y"===b&&(b="top");this.updateClipping?(this[b]=a,this.updateClipping()):d.style[b]=a},zIndexSetter:function(a,b,d){d.style[b]=a}},z["stroke-opacitySetter"]=z["fill-opacitySetter"],a.VMLElement=z=B(r,z),z.prototype.ySetter=z.prototype.widthSetter=z.prototype.heightSetter=z.prototype.xSetter,z={Element:z,isIE8:-1<v.navigator.userAgent.indexOf("MSIE 8.0"),init:function(a,
	b,d){var f,c;this.alignedObjects=[];f=this.createElement("div").css({position:"relative"});c=f.element;a.appendChild(f.element);this.isVML=!0;this.box=c;this.boxWrapper=f;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.setSize(b,d,!1);if(!t.namespaces.hcv){t.namespaces.add("hcv","urn:schemas-microsoft-com:vml");try{t.createStyleSheet().cssText="hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } "}catch(x){t.styleSheets[0].cssText+=
	"hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } "}}},isHidden:function(){return!this.box.offsetWidth},clipRect:function(a,b,d,c){var f=this.createElement(),m=H(a);return e(f,{members:[],count:0,left:(m?a.x:a)+1,top:(m?a.y:b)+1,width:(m?a.width:d)-1,height:(m?a.height:c)-1,getCSS:function(a){var b=a.element,d=b.nodeName,g=a.inverted,f=this.top-("shape"===d?b.offsetTop:0),c=this.left,b=c+this.width,q=f+this.height,f={clip:"rect("+Math.round(g?
	c:f)+"px,"+Math.round(g?q:b)+"px,"+Math.round(g?b:q)+"px,"+Math.round(g?f:c)+"px)"};!g&&a.docMode8&&"DIV"===d&&e(f,{width:b+"px",height:q+"px"});return f},updateClipping:function(){l(f.members,function(a){a.element&&a.css(f.getCSS(a))})}})},color:function(b,d,c,e){var f=this,m,r=/^rgba/,v,p,g="none";b&&b.linearGradient?p="gradient":b&&b.radialGradient&&(p="pattern");if(p){var D,y,k=b.linearGradient||b.radialGradient,A,h,w,G,t,F="";b=b.stops;var n,H=[],u=function(){v=['\x3cfill colors\x3d"'+H.join(",")+
	'" opacity\x3d"',w,'" o:opacity2\x3d"',h,'" type\x3d"',p,'" ',F,'focus\x3d"100%" method\x3d"any" /\x3e'];C(f.prepVML(v),null,null,d)};A=b[0];n=b[b.length-1];0<A[0]&&b.unshift([0,A[1]]);1>n[0]&&b.push([1,n[1]]);l(b,function(g,b){r.test(g[1])?(m=a.color(g[1]),D=m.get("rgb"),y=m.get("a")):(D=g[1],y=1);H.push(100*g[0]+"% "+D);b?(w=y,G=D):(h=y,t=D)});if("fill"===c)if("gradient"===p)c=k.x1||k[0]||0,b=k.y1||k[1]||0,A=k.x2||k[2]||0,k=k.y2||k[3]||0,F='angle\x3d"'+(90-180*Math.atan((k-b)/(A-c))/Math.PI)+'"',
	u();else{var g=k.r,z=2*g,B=2*g,E=k.cx,V=k.cy,I=d.radialReference,T,g=function(){I&&(T=e.getBBox(),E+=(I[0]-T.x)/T.width-.5,V+=(I[1]-T.y)/T.height-.5,z*=I[2]/T.width,B*=I[2]/T.height);F='src\x3d"'+a.getOptions().global.VMLRadialGradientURL+'" size\x3d"'+z+","+B+'" origin\x3d"0.5,0.5" position\x3d"'+E+","+V+'" color2\x3d"'+t+'" ';u()};e.added?g():e.onAdd=g;g=G}else g=D}else r.test(b)&&"IMG"!==d.tagName?(m=a.color(b),e[c+"-opacitySetter"](m.get("a"),c,d),g=m.get("rgb")):(g=d.getElementsByTagName(c),
	g.length&&(g[0].opacity=1,g[0].type="solid"),g=b);return g},prepVML:function(a){var b=this.isIE8;a=a.join("");b?(a=a.replace("/\x3e",' xmlns\x3d"urn:schemas-microsoft-com:vml" /\x3e'),a=-1===a.indexOf('style\x3d"')?a.replace("/\x3e",' style\x3d"display:inline-block;behavior:url(#default#VML);" /\x3e'):a.replace('style\x3d"','style\x3d"display:inline-block;behavior:url(#default#VML);')):a=a.replace("\x3c","\x3chcv:");return a},text:A.prototype.html,path:function(a){var b={coordsize:"10 10"};c(a)?b.d=
	a:H(a)&&e(b,a);return this.createElement("shape").attr(b)},circle:function(a,b,d){var f=this.symbol("circle");H(a)&&(d=a.r,b=a.y,a=a.x);f.isCircle=!0;f.r=d;return f.attr({x:a,y:b})},g:function(a){var b;a&&(b={className:"highcharts-"+a,"class":"highcharts-"+a});return this.createElement("div").attr(b)},image:function(a,b,d,c,q){var f=this.createElement("img").attr({src:a});1<arguments.length&&f.attr({x:b,y:d,width:c,height:q});return f},createElement:function(a){return"rect"===a?this.symbol(a):A.prototype.createElement.call(this,
	a)},invertChild:function(a,b){var f=this;b=b.style;var c="IMG"===a.tagName&&a.style;E(a,{flip:"x",left:d(b.width)-(c?d(c.top):1),top:d(b.height)-(c?d(c.left):1),rotation:-90});l(a.childNodes,function(b){f.invertChild(b,a)})},symbols:{arc:function(a,b,d,c,q){var f=q.start,e=q.end,m=q.r||d||c;d=q.innerR;c=Math.cos(f);var r=Math.sin(f),g=Math.cos(e),D=Math.sin(e);if(0===e-f)return["x"];f=["wa",a-m,b-m,a+m,b+m,a+m*c,b+m*r,a+m*g,b+m*D];q.open&&!d&&f.push("e","M",a,b);f.push("at",a-d,b-d,a+d,b+d,a+d*g,
	b+d*D,a+d*c,b+d*r,"x","e");f.isArc=!0;return f},circle:function(a,b,d,c,q){q&&u(q.r)&&(d=c=2*q.r);q&&q.isCircle&&(a-=d/2,b-=c/2);return["wa",a,b,a+d,b+c,a+d,b+c/2,a+d,b+c/2,"e"]},rect:function(a,b,d,c,q){return A.prototype.symbols[u(q)&&q.r?"callout":"square"].call(0,a,b,d,c,q)}}},a.VMLRenderer=B=function(){this.init.apply(this,arguments)},B.prototype=b(A.prototype,z),a.Renderer=B);A.prototype.measureSpanWidth=function(a,b){var d=t.createElement("span");a=t.createTextNode(a);d.appendChild(a);E(d,
	b);this.box.appendChild(d);b=d.offsetWidth;n(d);return b}})(I);(function(a){function B(){var l=a.defaultOptions.global,k=t.moment;if(l.timezone){if(k)return function(a){return-k.tz(a,l.timezone).utcOffset()};a.error(25)}return l.useUTC&&l.getTimezoneOffset}function z(){var l=a.defaultOptions.global,k,e=l.useUTC,c=e?"getUTC":"get",p=e?"setUTC":"set";a.Date=k=l.Date||t.Date;k.hcTimezoneOffset=e&&l.timezoneOffset;k.hcGetTimezoneOffset=B();k.hcMakeTime=function(a,b,c,d,r,p){var m;e?(m=k.UTC.apply(0,arguments),
	m+=u(m)):m=(new k(a,b,n(c,1),n(d,0),n(r,0),n(p,0))).getTime();return m};E("Minutes Hours Day Date Month FullYear".split(" "),function(a){k["hcGet"+a]=c+a});E("Milliseconds Seconds Minutes Hours Date Month FullYear".split(" "),function(a){k["hcSet"+a]=p+a})}var C=a.color,E=a.each,u=a.getTZOffset,h=a.merge,n=a.pick,t=a.win;a.defaultOptions={colors:"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),symbols:["circle","diamond","square","triangle","triangle-down"],
	lang:{loading:"Loading...",months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),weekdays:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),decimalPoint:".",numericSymbols:"kMGTPE".split(""),resetZoom:"Reset zoom",resetZoomTitle:"Reset zoom level 1:1",thousandsSep:" "},global:{useUTC:!0,VMLRadialGradientURL:"http://code.highcharts.com/5.0.9/gfx/vml-radial-gradient.png"},
	chart:{borderRadius:0,defaultSeriesType:"line",ignoreHiddenSeries:!0,spacing:[10,10,15,10],resetZoomButton:{theme:{zIndex:20},position:{align:"right",x:-10,y:10}},width:null,height:null,borderColor:"#335cad",backgroundColor:"#ffffff",plotBorderColor:"#cccccc"},title:{text:"Chart title",align:"center",margin:15,widthAdjust:-44},subtitle:{text:"",align:"center",widthAdjust:-44},plotOptions:{},labels:{style:{position:"absolute",color:"#333333"}},legend:{enabled:!0,align:"center",layout:"horizontal",
	labelFormatter:function(){return this.name},borderColor:"#999999",borderRadius:0,navigation:{activeColor:"#003399",inactiveColor:"#cccccc"},itemStyle:{color:"#333333",fontSize:"12px",fontWeight:"bold"},itemHoverStyle:{color:"#000000"},itemHiddenStyle:{color:"#cccccc"},shadow:!1,itemCheckboxStyle:{position:"absolute",width:"13px",height:"13px"},squareSymbol:!0,symbolPadding:5,verticalAlign:"bottom",x:0,y:0,title:{style:{fontWeight:"bold"}}},loading:{labelStyle:{fontWeight:"bold",position:"relative",
	top:"45%"},style:{position:"absolute",backgroundColor:"#ffffff",opacity:.5,textAlign:"center"}},tooltip:{enabled:!0,animation:a.svg,borderRadius:3,dateTimeLabelFormats:{millisecond:"%A, %b %e, %H:%M:%S.%L",second:"%A, %b %e, %H:%M:%S",minute:"%A, %b %e, %H:%M",hour:"%A, %b %e, %H:%M",day:"%A, %b %e, %Y",week:"Week from %A, %b %e, %Y",month:"%B %Y",year:"%Y"},footerFormat:"",padding:8,snap:a.isTouchDevice?25:10,backgroundColor:C("#f7f7f7").setOpacity(.85).get(),borderWidth:1,headerFormat:'\x3cspan style\x3d"font-size: 10px"\x3e{point.key}\x3c/span\x3e\x3cbr/\x3e',
	pointFormat:'\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e {series.name}: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e',shadow:!0,style:{color:"#333333",cursor:"default",fontSize:"12px",pointerEvents:"none",whiteSpace:"nowrap"}},credits:{enabled:!0,href:"http://www.highcharts.com",position:{align:"right",x:-10,verticalAlign:"bottom",y:-5},style:{cursor:"pointer",color:"#999999",fontSize:"9px"},text:"Highcharts.com"}};a.setOptions=function(l){a.defaultOptions=h(!0,a.defaultOptions,l);z();
	return a.defaultOptions};a.getOptions=function(){return a.defaultOptions};a.defaultPlotOptions=a.defaultOptions.plotOptions;z()})(I);(function(a){var B=a.arrayMax,z=a.arrayMin,C=a.defined,E=a.destroyObjectProperties,u=a.each,h=a.erase,n=a.merge,t=a.pick;a.PlotLineOrBand=function(a,k){this.axis=a;k&&(this.options=k,this.id=k.id)};a.PlotLineOrBand.prototype={render:function(){var a=this,k=a.axis,e=k.horiz,c=a.options,p=c.label,h=a.label,b=c.to,m=c.from,d=c.value,r=C(m)&&C(b),A=C(d),v=a.svgElem,f=!v,
	y=[],G,F=c.color,q=t(c.zIndex,0),x=c.events,y={"class":"highcharts-plot-"+(r?"band ":"line ")+(c.className||"")},J={},u=k.chart.renderer,L=r?"bands":"lines",g=k.log2lin;k.isLog&&(m=g(m),b=g(b),d=g(d));A?(y={stroke:F,"stroke-width":c.width},c.dashStyle&&(y.dashstyle=c.dashStyle)):r&&(F&&(y.fill=F),c.borderWidth&&(y.stroke=c.borderColor,y["stroke-width"]=c.borderWidth));J.zIndex=q;L+="-"+q;(F=k[L])||(k[L]=F=u.g("plot-"+L).attr(J).add());f&&(a.svgElem=v=u.path().attr(y).add(F));if(A)y=k.getPlotLinePath(d,
	v.strokeWidth());else if(r)y=k.getPlotBandPath(m,b,c);else return;if(f&&y&&y.length){if(v.attr({d:y}),x)for(G in c=function(b){v.on(b,function(g){x[b].apply(a,[g])})},x)c(G)}else v&&(y?(v.show(),v.animate({d:y})):(v.hide(),h&&(a.label=h=h.destroy())));p&&C(p.text)&&y&&y.length&&0<k.width&&0<k.height&&!y.flat?(p=n({align:e&&r&&"center",x:e?!r&&4:10,verticalAlign:!e&&r&&"middle",y:e?r?16:10:r?6:-4,rotation:e&&!r&&90},p),this.renderLabel(p,y,r,q)):h&&h.hide();return a},renderLabel:function(a,k,e,c){var p=
	this.label,l=this.axis.chart.renderer;p||(p={align:a.textAlign||a.align,rotation:a.rotation,"class":"highcharts-plot-"+(e?"band":"line")+"-label "+(a.className||"")},p.zIndex=c,this.label=p=l.text(a.text,0,0,a.useHTML).attr(p).add(),p.css(a.style));c=[k[1],k[4],e?k[6]:k[1]];k=[k[2],k[5],e?k[7]:k[2]];e=z(c);l=z(k);p.align(a,!1,{x:e,y:l,width:B(c)-e,height:B(k)-l});p.show()},destroy:function(){h(this.axis.plotLinesAndBands,this);delete this.axis;E(this)}};a.AxisPlotLineOrBandExtension={getPlotBandPath:function(a,
	k){k=this.getPlotLinePath(k,null,null,!0);(a=this.getPlotLinePath(a,null,null,!0))&&k?(a.flat=a.toString()===k.toString(),a.push(k[4],k[5],k[1],k[2],"z")):a=null;return a},addPlotBand:function(a){return this.addPlotBandOrLine(a,"plotBands")},addPlotLine:function(a){return this.addPlotBandOrLine(a,"plotLines")},addPlotBandOrLine:function(l,k){var e=(new a.PlotLineOrBand(this,l)).render(),c=this.userOptions;e&&(k&&(c[k]=c[k]||[],c[k].push(l)),this.plotLinesAndBands.push(e));return e},removePlotBandOrLine:function(a){for(var k=
	this.plotLinesAndBands,e=this.options,c=this.userOptions,p=k.length;p--;)k[p].id===a&&k[p].destroy();u([e.plotLines||[],c.plotLines||[],e.plotBands||[],c.plotBands||[]],function(c){for(p=c.length;p--;)c[p].id===a&&h(c,c[p])})}}})(I);(function(a){var B=a.correctFloat,z=a.defined,C=a.destroyObjectProperties,E=a.isNumber,u=a.merge,h=a.pick,n=a.deg2rad;a.Tick=function(a,l,k,e){this.axis=a;this.pos=l;this.type=k||"";this.isNew=!0;k||e||this.addLabel()};a.Tick.prototype={addLabel:function(){var a=this.axis,
	l=a.options,k=a.chart,e=a.categories,c=a.names,p=this.pos,n=l.labels,b=a.tickPositions,m=p===b[0],d=p===b[b.length-1],c=e?h(e[p],c[p],p):p,e=this.label,b=b.info,r;a.isDatetimeAxis&&b&&(r=l.dateTimeLabelFormats[b.higherRanks[p]||b.unitName]);this.isFirst=m;this.isLast=d;l=a.labelFormatter.call({axis:a,chart:k,isFirst:m,isLast:d,dateTimeLabelFormat:r,value:a.isLog?B(a.lin2log(c)):c});z(e)?e&&e.attr({text:l}):(this.labelLength=(this.label=e=z(l)&&n.enabled?k.renderer.text(l,0,0,n.useHTML).css(u(n.style)).add(a.labelGroup):
	null)&&e.getBBox().width,this.rotation=0)},getLabelSize:function(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0},handleOverflow:function(a){var l=this.axis,k=a.x,e=l.chart.chartWidth,c=l.chart.spacing,p=h(l.labelLeft,Math.min(l.pos,c[3])),c=h(l.labelRight,Math.max(l.pos+l.len,e-c[1])),t=this.label,b=this.rotation,m={left:0,center:.5,right:1}[l.labelAlign],d=t.getBBox().width,r=l.getSlotWidth(),A=r,v=1,f,y={};if(b)0>b&&k-m*d<p?f=Math.round(k/Math.cos(b*n)-p):0<b&&k+m*
	d>c&&(f=Math.round((e-k)/Math.cos(b*n)));else if(e=k+(1-m)*d,k-m*d<p?A=a.x+A*(1-m)-p:e>c&&(A=c-a.x+A*m,v=-1),A=Math.min(r,A),A<r&&"center"===l.labelAlign&&(a.x+=v*(r-A-m*(r-Math.min(d,A)))),d>A||l.autoRotation&&(t.styles||{}).width)f=A;f&&(y.width=f,(l.options.labels.style||{}).textOverflow||(y.textOverflow="ellipsis"),t.css(y))},getPosition:function(a,l,k,e){var c=this.axis,p=c.chart,h=e&&p.oldChartHeight||p.chartHeight;return{x:a?c.translate(l+k,null,null,e)+c.transB:c.left+c.offset+(c.opposite?
	(e&&p.oldChartWidth||p.chartWidth)-c.right-c.left:0),y:a?h-c.bottom+c.offset-(c.opposite?c.height:0):h-c.translate(l+k,null,null,e)-c.transB}},getLabelPosition:function(a,h,k,e,c,p,H,b){var m=this.axis,d=m.transA,r=m.reversed,l=m.staggerLines,v=m.tickRotCorr||{x:0,y:0},f=c.y;z(f)||(f=0===m.side?k.rotation?-8:-k.getBBox().height:2===m.side?v.y+8:Math.cos(k.rotation*n)*(v.y-k.getBBox(!1,0).height/2));a=a+c.x+v.x-(p&&e?p*d*(r?-1:1):0);h=h+f-(p&&!e?p*d*(r?1:-1):0);l&&(k=H/(b||1)%l,m.opposite&&(k=l-k-
	1),h+=m.labelOffset/l*k);return{x:a,y:Math.round(h)}},getMarkPath:function(a,h,k,e,c,p){return p.crispLine(["M",a,h,"L",a+(c?0:-k),h+(c?k:0)],e)},renderGridLine:function(a,h,k){var e=this.axis,c=e.options,p=this.gridLine,l={},b=this.pos,m=this.type,d=e.tickmarkOffset,r=e.chart.renderer,A=m?m+"Grid":"grid",v=c[A+"LineWidth"],f=c[A+"LineColor"],c=c[A+"LineDashStyle"];p||(l.stroke=f,l["stroke-width"]=v,c&&(l.dashstyle=c),m||(l.zIndex=1),a&&(l.opacity=0),this.gridLine=p=r.path().attr(l).addClass("highcharts-"+
	(m?m+"-":"")+"grid-line").add(e.gridGroup));if(!a&&p&&(a=e.getPlotLinePath(b+d,p.strokeWidth()*k,a,!0)))p[this.isNew?"attr":"animate"]({d:a,opacity:h})},renderMark:function(a,l,k){var e=this.axis,c=e.options,p=e.chart.renderer,n=this.type,b=n?n+"Tick":"tick",m=e.tickSize(b),d=this.mark,r=!d,A=a.x;a=a.y;var v=h(c[b+"Width"],!n&&e.isXAxis?1:0),c=c[b+"Color"];m&&(e.opposite&&(m[0]=-m[0]),r&&(this.mark=d=p.path().addClass("highcharts-"+(n?n+"-":"")+"tick").add(e.axisGroup),d.attr({stroke:c,"stroke-width":v})),
	d[r?"attr":"animate"]({d:this.getMarkPath(A,a,m[0],d.strokeWidth()*k,e.horiz,p),opacity:l}))},renderLabel:function(a,l,k,e){var c=this.axis,p=c.horiz,n=c.options,b=this.label,m=n.labels,d=m.step,r=c.tickmarkOffset,A=!0,v=a.x;a=a.y;b&&E(v)&&(b.xy=a=this.getLabelPosition(v,a,b,p,m,r,e,d),this.isFirst&&!this.isLast&&!h(n.showFirstLabel,1)||this.isLast&&!this.isFirst&&!h(n.showLastLabel,1)?A=!1:!p||c.isRadial||m.step||m.rotation||l||0===k||this.handleOverflow(a),d&&e%d&&(A=!1),A&&E(a.y)?(a.opacity=k,
	b[this.isNew?"attr":"animate"](a)):b.attr("y",-9999),this.isNew=!1)},render:function(a,l,k){var e=this.axis,c=e.horiz,p=this.getPosition(c,this.pos,e.tickmarkOffset,l),n=p.x,b=p.y,e=c&&n===e.pos+e.len||!c&&b===e.pos?-1:1;k=h(k,1);this.isActive=!0;this.renderGridLine(l,k,e);this.renderMark(p,k,e);this.renderLabel(p,l,k,a)},destroy:function(){C(this,this.axis)}}})(I);(function(a){var B=a.addEvent,z=a.animObject,C=a.arrayMax,E=a.arrayMin,u=a.AxisPlotLineOrBandExtension,h=a.color,n=a.correctFloat,t=a.defaultOptions,
	l=a.defined,k=a.deg2rad,e=a.destroyObjectProperties,c=a.each,p=a.extend,H=a.fireEvent,b=a.format,m=a.getMagnitude,d=a.grep,r=a.inArray,A=a.isArray,v=a.isNumber,f=a.isString,y=a.merge,G=a.normalizeTickInterval,F=a.pick,q=a.PlotLineOrBand,x=a.removeEvent,J=a.splat,K=a.syncTimeout,L=a.Tick;a.Axis=function(){this.init.apply(this,arguments)};a.Axis.prototype={defaultOptions:{dateTimeLabelFormats:{millisecond:"%H:%M:%S.%L",second:"%H:%M:%S",minute:"%H:%M",hour:"%H:%M",day:"%e. %b",week:"%e. %b",month:"%b '%y",
	year:"%Y"},endOnTick:!1,labels:{enabled:!0,style:{color:"#666666",cursor:"default",fontSize:"11px"},x:0},minPadding:.01,maxPadding:.01,minorTickLength:2,minorTickPosition:"outside",startOfWeek:1,startOnTick:!1,tickLength:10,tickmarkPlacement:"between",tickPixelInterval:100,tickPosition:"outside",title:{align:"middle",style:{color:"#666666"}},type:"linear",minorGridLineColor:"#f2f2f2",minorGridLineWidth:1,minorTickColor:"#999999",lineColor:"#ccd6eb",lineWidth:1,gridLineColor:"#e6e6e6",tickColor:"#ccd6eb"},
	defaultYAxisOptions:{endOnTick:!0,tickPixelInterval:72,showLastLabel:!0,labels:{x:-8},maxPadding:.05,minPadding:.05,startOnTick:!0,title:{rotation:270,text:"Values"},stackLabels:{enabled:!1,formatter:function(){return a.numberFormat(this.total,-1)},style:{fontSize:"11px",fontWeight:"bold",color:"#000000",textOutline:"1px contrast"}},gridLineWidth:1,lineWidth:0},defaultLeftAxisOptions:{labels:{x:-15},title:{rotation:270}},defaultRightAxisOptions:{labels:{x:15},title:{rotation:90}},defaultBottomAxisOptions:{labels:{autoRotation:[-45],
	x:0},title:{rotation:0}},defaultTopAxisOptions:{labels:{autoRotation:[-45],x:0},title:{rotation:0}},init:function(a,b){var g=b.isX;this.chart=a;this.horiz=a.inverted?!g:g;this.isXAxis=g;this.coll=this.coll||(g?"xAxis":"yAxis");this.opposite=b.opposite;this.side=b.side||(this.horiz?this.opposite?0:2:this.opposite?1:3);this.setOptions(b);var d=this.options,c=d.type;this.labelFormatter=d.labels.formatter||this.defaultLabelFormatter;this.userOptions=b;this.minPixelPadding=0;this.reversed=d.reversed;this.visible=
	!1!==d.visible;this.zoomEnabled=!1!==d.zoomEnabled;this.hasNames="category"===c||!0===d.categories;this.categories=d.categories||this.hasNames;this.names=this.names||[];this.isLog="logarithmic"===c;this.isDatetimeAxis="datetime"===c;this.positiveValuesOnly=this.isLog&&!this.allowNegativeLog;this.isLinked=l(d.linkedTo);this.ticks={};this.labelEdge=[];this.minorTicks={};this.plotLinesAndBands=[];this.alternateBands={};this.len=0;this.minRange=this.userMinRange=d.minRange||d.maxZoom;this.range=d.range;
	this.offset=d.offset||0;this.stacks={};this.oldStacks={};this.stacksTouched=0;this.min=this.max=null;this.crosshair=F(d.crosshair,J(a.options.tooltip.crosshairs)[g?0:1],!1);var f;b=this.options.events;-1===r(this,a.axes)&&(g?a.axes.splice(a.xAxis.length,0,this):a.axes.push(this),a[this.coll].push(this));this.series=this.series||[];a.inverted&&g&&void 0===this.reversed&&(this.reversed=!0);this.removePlotLine=this.removePlotBand=this.removePlotBandOrLine;for(f in b)B(this,f,b[f]);this.lin2log=d.linearToLogConverter||
	this.lin2log;this.isLog&&(this.val2lin=this.log2lin,this.lin2val=this.lin2log)},setOptions:function(a){this.options=y(this.defaultOptions,"yAxis"===this.coll&&this.defaultYAxisOptions,[this.defaultTopAxisOptions,this.defaultRightAxisOptions,this.defaultBottomAxisOptions,this.defaultLeftAxisOptions][this.side],y(t[this.coll],a))},defaultLabelFormatter:function(){var g=this.axis,d=this.value,c=g.categories,f=this.dateTimeLabelFormat,q=t.lang,e=q.numericSymbols,q=q.numericSymbolMagnitude||1E3,w=e&&e.length,
	m,r=g.options.labels.format,g=g.isLog?Math.abs(d):g.tickInterval;if(r)m=b(r,this);else if(c)m=d;else if(f)m=a.dateFormat(f,d);else if(w&&1E3<=g)for(;w--&&void 0===m;)c=Math.pow(q,w+1),g>=c&&0===10*d%c&&null!==e[w]&&0!==d&&(m=a.numberFormat(d/c,-1)+e[w]);void 0===m&&(m=1E4<=Math.abs(d)?a.numberFormat(d,-1):a.numberFormat(d,-1,void 0,""));return m},getSeriesExtremes:function(){var a=this,b=a.chart;a.hasVisibleSeries=!1;a.dataMin=a.dataMax=a.threshold=null;a.softThreshold=!a.isXAxis;a.buildStacks&&a.buildStacks();
	c(a.series,function(g){if(g.visible||!b.options.chart.ignoreHiddenSeries){var c=g.options,f=c.threshold,q;a.hasVisibleSeries=!0;a.positiveValuesOnly&&0>=f&&(f=null);if(a.isXAxis)c=g.xData,c.length&&(g=E(c),v(g)||g instanceof Date||(c=d(c,function(a){return v(a)}),g=E(c)),a.dataMin=Math.min(F(a.dataMin,c[0]),g),a.dataMax=Math.max(F(a.dataMax,c[0]),C(c)));else if(g.getExtremes(),q=g.dataMax,g=g.dataMin,l(g)&&l(q)&&(a.dataMin=Math.min(F(a.dataMin,g),g),a.dataMax=Math.max(F(a.dataMax,q),q)),l(f)&&(a.threshold=
	f),!c.softThreshold||a.positiveValuesOnly)a.softThreshold=!1}})},translate:function(a,b,d,c,f,q){var g=this.linkedParent||this,D=1,e=0,m=c?g.oldTransA:g.transA;c=c?g.oldMin:g.min;var r=g.minPixelPadding;f=(g.isOrdinal||g.isBroken||g.isLog&&f)&&g.lin2val;m||(m=g.transA);d&&(D*=-1,e=g.len);g.reversed&&(D*=-1,e-=D*(g.sector||g.len));b?(a=(a*D+e-r)/m+c,f&&(a=g.lin2val(a))):(f&&(a=g.val2lin(a)),a=D*(a-c)*m+e+D*r+(v(q)?m*q:0));return a},toPixels:function(a,b){return this.translate(a,!1,!this.horiz,null,
	!0)+(b?0:this.pos)},toValue:function(a,b){return this.translate(a-(b?0:this.pos),!0,!this.horiz,null,!0)},getPlotLinePath:function(a,b,d,c,f){var g=this.chart,q=this.left,D=this.top,e,m,r=d&&g.oldChartHeight||g.chartHeight,p=d&&g.oldChartWidth||g.chartWidth,x;e=this.transB;var k=function(a,b,g){if(a<b||a>g)c?a=Math.min(Math.max(b,a),g):x=!0;return a};f=F(f,this.translate(a,null,null,d));a=d=Math.round(f+e);e=m=Math.round(r-f-e);v(f)?this.horiz?(e=D,m=r-this.bottom,a=d=k(a,q,q+this.width)):(a=q,d=
	p-this.right,e=m=k(e,D,D+this.height)):x=!0;return x&&!c?null:g.renderer.crispLine(["M",a,e,"L",d,m],b||1)},getLinearTickPositions:function(a,b,d){var g,c=n(Math.floor(b/a)*a);d=n(Math.ceil(d/a)*a);var f=[];if(this.single)return[b];for(b=c;b<=d;){f.push(b);b=n(b+a);if(b===g)break;g=b}return f},getMinorTickPositions:function(){var a=this,b=a.options,d=a.tickPositions,f=a.minorTickInterval,q=[],e=a.pointRangePadding||0,m=a.min-e,e=a.max+e,r=e-m;if(r&&r/f<a.len/3)if(a.isLog)c(this.paddedTicks,function(b,
	g,d){g&&q.push.apply(q,a.getLogTickPositions(f,d[g-1],d[g],!0))});else if(a.isDatetimeAxis&&"auto"===b.minorTickInterval)q=q.concat(a.getTimeTicks(a.normalizeTimeTickInterval(f),m,e,b.startOfWeek));else for(b=m+(d[0]-m)%f;b<=e&&b!==q[0];b+=f)q.push(b);0!==q.length&&a.trimTicks(q);return q},adjustForMinRange:function(){var a=this.options,b=this.min,d=this.max,f,q=this.dataMax-this.dataMin>=this.minRange,e,m,r,p,v,x;this.isXAxis&&void 0===this.minRange&&!this.isLog&&(l(a.min)||l(a.max)?this.minRange=
	null:(c(this.series,function(a){p=a.xData;for(m=v=a.xIncrement?1:p.length-1;0<m;m--)if(r=p[m]-p[m-1],void 0===e||r<e)e=r}),this.minRange=Math.min(5*e,this.dataMax-this.dataMin)));d-b<this.minRange&&(x=this.minRange,f=(x-d+b)/2,f=[b-f,F(a.min,b-f)],q&&(f[2]=this.isLog?this.log2lin(this.dataMin):this.dataMin),b=C(f),d=[b+x,F(a.max,b+x)],q&&(d[2]=this.isLog?this.log2lin(this.dataMax):this.dataMax),d=E(d),d-b<x&&(f[0]=d-x,f[1]=F(a.min,d-x),b=C(f)));this.min=b;this.max=d},getClosest:function(){var a;this.categories?
	a=1:c(this.series,function(b){var g=b.closestPointRange,d=b.visible||!b.chart.options.chart.ignoreHiddenSeries;!b.noSharedTooltip&&l(g)&&d&&(a=l(a)?Math.min(a,g):g)});return a},nameToX:function(a){var b=A(this.categories),g=b?this.categories:this.names,d=a.options.x,c;a.series.requireSorting=!1;l(d)||(d=!1===this.options.uniqueNames?a.series.autoIncrement():r(a.name,g));-1===d?b||(c=g.length):c=d;this.names[c]=a.name;return c},updateNames:function(){var a=this;0<this.names.length&&(this.names.length=
	0,this.minRange=void 0,c(this.series||[],function(b){b.xIncrement=null;if(!b.points||b.isDirtyData)b.processData(),b.generatePoints();c(b.points,function(g,d){var c;g.options&&(c=a.nameToX(g),c!==g.x&&(g.x=c,b.xData[d]=c))})}))},setAxisTranslation:function(a){var b=this,g=b.max-b.min,d=b.axisPointRange||0,q,e=0,m=0,r=b.linkedParent,p=!!b.categories,v=b.transA,x=b.isXAxis;if(x||p||d)q=b.getClosest(),r?(e=r.minPointOffset,m=r.pointRangePadding):c(b.series,function(a){var g=p?1:x?F(a.options.pointRange,
	q,0):b.axisPointRange||0;a=a.options.pointPlacement;d=Math.max(d,g);b.single||(e=Math.max(e,f(a)?0:g/2),m=Math.max(m,"on"===a?0:g))}),r=b.ordinalSlope&&q?b.ordinalSlope/q:1,b.minPointOffset=e*=r,b.pointRangePadding=m*=r,b.pointRange=Math.min(d,g),x&&(b.closestPointRange=q);a&&(b.oldTransA=v);b.translationSlope=b.transA=v=b.options.staticScale||b.len/(g+m||1);b.transB=b.horiz?b.left:b.bottom;b.minPixelPadding=v*e},minFromRange:function(){return this.max-this.range},setTickInterval:function(b){var g=
	this,d=g.chart,f=g.options,q=g.isLog,e=g.log2lin,r=g.isDatetimeAxis,p=g.isXAxis,x=g.isLinked,k=f.maxPadding,h=f.minPadding,y=f.tickInterval,A=f.tickPixelInterval,J=g.categories,t=g.threshold,u=g.softThreshold,L,K,z,B;r||J||x||this.getTickAmount();z=F(g.userMin,f.min);B=F(g.userMax,f.max);x?(g.linkedParent=d[g.coll][f.linkedTo],d=g.linkedParent.getExtremes(),g.min=F(d.min,d.dataMin),g.max=F(d.max,d.dataMax),f.type!==g.linkedParent.options.type&&a.error(11,1)):(!u&&l(t)&&(g.dataMin>=t?(L=t,h=0):g.dataMax<=
	t&&(K=t,k=0)),g.min=F(z,L,g.dataMin),g.max=F(B,K,g.dataMax));q&&(g.positiveValuesOnly&&!b&&0>=Math.min(g.min,F(g.dataMin,g.min))&&a.error(10,1),g.min=n(e(g.min),15),g.max=n(e(g.max),15));g.range&&l(g.max)&&(g.userMin=g.min=z=Math.max(g.min,g.minFromRange()),g.userMax=B=g.max,g.range=null);H(g,"foundExtremes");g.beforePadding&&g.beforePadding();g.adjustForMinRange();!(J||g.axisPointRange||g.usePercentage||x)&&l(g.min)&&l(g.max)&&(e=g.max-g.min)&&(!l(z)&&h&&(g.min-=e*h),!l(B)&&k&&(g.max+=e*k));v(f.floor)?
	g.min=Math.max(g.min,f.floor):v(f.softMin)&&(g.min=Math.min(g.min,f.softMin));v(f.ceiling)?g.max=Math.min(g.max,f.ceiling):v(f.softMax)&&(g.max=Math.max(g.max,f.softMax));u&&l(g.dataMin)&&(t=t||0,!l(z)&&g.min<t&&g.dataMin>=t?g.min=t:!l(B)&&g.max>t&&g.dataMax<=t&&(g.max=t));g.tickInterval=g.min===g.max||void 0===g.min||void 0===g.max?1:x&&!y&&A===g.linkedParent.options.tickPixelInterval?y=g.linkedParent.tickInterval:F(y,this.tickAmount?(g.max-g.min)/Math.max(this.tickAmount-1,1):void 0,J?1:(g.max-
	g.min)*A/Math.max(g.len,A));p&&!b&&c(g.series,function(a){a.processData(g.min!==g.oldMin||g.max!==g.oldMax)});g.setAxisTranslation(!0);g.beforeSetTickPositions&&g.beforeSetTickPositions();g.postProcessTickInterval&&(g.tickInterval=g.postProcessTickInterval(g.tickInterval));g.pointRange&&!y&&(g.tickInterval=Math.max(g.pointRange,g.tickInterval));b=F(f.minTickInterval,g.isDatetimeAxis&&g.closestPointRange);!y&&g.tickInterval<b&&(g.tickInterval=b);r||q||y||(g.tickInterval=G(g.tickInterval,null,m(g.tickInterval),
	F(f.allowDecimals,!(.5<g.tickInterval&&5>g.tickInterval&&1E3<g.max&&9999>g.max)),!!this.tickAmount));this.tickAmount||(g.tickInterval=g.unsquish());this.setTickPositions()},setTickPositions:function(){var a=this.options,b,d=a.tickPositions,c=a.tickPositioner,f=a.startOnTick,q=a.endOnTick;this.tickmarkOffset=this.categories&&"between"===a.tickmarkPlacement&&1===this.tickInterval?.5:0;this.minorTickInterval="auto"===a.minorTickInterval&&this.tickInterval?this.tickInterval/5:a.minorTickInterval;this.single=
	this.min===this.max&&l(this.min)&&!this.tickAmount&&!1!==a.allowDecimals;this.tickPositions=b=d&&d.slice();!b&&(b=this.isDatetimeAxis?this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval,a.units),this.min,this.max,a.startOfWeek,this.ordinalPositions,this.closestPointRange,!0):this.isLog?this.getLogTickPositions(this.tickInterval,this.min,this.max):this.getLinearTickPositions(this.tickInterval,this.min,this.max),b.length>this.len&&(b=[b[0],b.pop()]),this.tickPositions=b,c&&(c=c.apply(this,
	[this.min,this.max])))&&(this.tickPositions=b=c);this.paddedTicks=b.slice(0);this.trimTicks(b,f,q);this.isLinked||(this.single&&(this.min-=.5,this.max+=.5),d||c||this.adjustTickAmount())},trimTicks:function(a,b,d){var g=a[0],c=a[a.length-1],f=this.minPointOffset||0;if(!this.isLinked){if(b)this.min=g;else for(;this.min-f>a[0];)a.shift();if(d)this.max=c;else for(;this.max+f<a[a.length-1];)a.pop();0===a.length&&l(g)&&a.push((c+g)/2)}},alignToOthers:function(){var a={},b,d=this.options;!1===this.chart.options.chart.alignTicks||
	!1===d.alignTicks||this.isLog||c(this.chart[this.coll],function(g){var d=g.options,d=[g.horiz?d.left:d.top,d.width,d.height,d.pane].join();g.series.length&&(a[d]?b=!0:a[d]=1)});return b},getTickAmount:function(){var a=this.options,b=a.tickAmount,d=a.tickPixelInterval;!l(a.tickInterval)&&this.len<d&&!this.isRadial&&!this.isLog&&a.startOnTick&&a.endOnTick&&(b=2);!b&&this.alignToOthers()&&(b=Math.ceil(this.len/d)+1);4>b&&(this.finalTickAmt=b,b=5);this.tickAmount=b},adjustTickAmount:function(){var a=
	this.tickInterval,b=this.tickPositions,d=this.tickAmount,c=this.finalTickAmt,f=b&&b.length;if(f<d){for(;b.length<d;)b.push(n(b[b.length-1]+a));this.transA*=(f-1)/(d-1);this.max=b[b.length-1]}else f>d&&(this.tickInterval*=2,this.setTickPositions());if(l(c)){for(a=d=b.length;a--;)(3===c&&1===a%2||2>=c&&0<a&&a<d-1)&&b.splice(a,1);this.finalTickAmt=void 0}},setScale:function(){var a,b;this.oldMin=this.min;this.oldMax=this.max;this.oldAxisLength=this.len;this.setAxisSize();b=this.len!==this.oldAxisLength;
	c(this.series,function(b){if(b.isDirtyData||b.isDirty||b.xAxis.isDirty)a=!0});b||a||this.isLinked||this.forceRedraw||this.userMin!==this.oldUserMin||this.userMax!==this.oldUserMax||this.alignToOthers()?(this.resetStacks&&this.resetStacks(),this.forceRedraw=!1,this.getSeriesExtremes(),this.setTickInterval(),this.oldUserMin=this.userMin,this.oldUserMax=this.userMax,this.isDirty||(this.isDirty=b||this.min!==this.oldMin||this.max!==this.oldMax)):this.cleanStacks&&this.cleanStacks()},setExtremes:function(a,
	b,d,f,q){var g=this,e=g.chart;d=F(d,!0);c(g.series,function(a){delete a.kdTree});q=p(q,{min:a,max:b});H(g,"setExtremes",q,function(){g.userMin=a;g.userMax=b;g.eventArgs=q;d&&e.redraw(f)})},zoom:function(a,b){var g=this.dataMin,d=this.dataMax,c=this.options,f=Math.min(g,F(c.min,g)),c=Math.max(d,F(c.max,d));if(a!==this.min||b!==this.max)this.allowZoomOutside||(l(g)&&(a<f&&(a=f),a>c&&(a=c)),l(d)&&(b<f&&(b=f),b>c&&(b=c))),this.displayBtn=void 0!==a||void 0!==b,this.setExtremes(a,b,!1,void 0,{trigger:"zoom"});
	return!0},setAxisSize:function(){var a=this.chart,b=this.options,d=b.offsets||[0,0,0,0],c=this.horiz,f=F(b.width,a.plotWidth-d[3]+d[1]),q=F(b.height,a.plotHeight-d[0]+d[2]),e=F(b.top,a.plotTop+d[0]),b=F(b.left,a.plotLeft+d[3]),d=/%$/;d.test(q)&&(q=Math.round(parseFloat(q)/100*a.plotHeight));d.test(e)&&(e=Math.round(parseFloat(e)/100*a.plotHeight+a.plotTop));this.left=b;this.top=e;this.width=f;this.height=q;this.bottom=a.chartHeight-q-e;this.right=a.chartWidth-f-b;this.len=Math.max(c?f:q,0);this.pos=
	c?b:e},getExtremes:function(){var a=this.isLog,b=this.lin2log;return{min:a?n(b(this.min)):this.min,max:a?n(b(this.max)):this.max,dataMin:this.dataMin,dataMax:this.dataMax,userMin:this.userMin,userMax:this.userMax}},getThreshold:function(a){var b=this.isLog,g=this.lin2log,d=b?g(this.min):this.min,b=b?g(this.max):this.max;null===a?a=d:d>a?a=d:b<a&&(a=b);return this.translate(a,0,1,0,1)},autoLabelAlign:function(a){a=(F(a,0)-90*this.side+720)%360;return 15<a&&165>a?"right":195<a&&345>a?"left":"center"},
	tickSize:function(a){var b=this.options,g=b[a+"Length"],d=F(b[a+"Width"],"tick"===a&&this.isXAxis?1:0);if(d&&g)return"inside"===b[a+"Position"]&&(g=-g),[g,d]},labelMetrics:function(){return this.chart.renderer.fontMetrics(this.options.labels.style&&this.options.labels.style.fontSize,this.ticks[0]&&this.ticks[0].label)},unsquish:function(){var a=this.options.labels,b=this.horiz,d=this.tickInterval,f=d,q=this.len/(((this.categories?1:0)+this.max-this.min)/d),e,m=a.rotation,r=this.labelMetrics(),p,x=
	Number.MAX_VALUE,v,h=function(a){a/=q||1;a=1<a?Math.ceil(a):1;return a*d};b?(v=!a.staggerLines&&!a.step&&(l(m)?[m]:q<F(a.autoRotationLimit,80)&&a.autoRotation))&&c(v,function(a){var b;if(a===m||a&&-90<=a&&90>=a)p=h(Math.abs(r.h/Math.sin(k*a))),b=p+Math.abs(a/360),b<x&&(x=b,e=a,f=p)}):a.step||(f=h(r.h));this.autoRotation=v;this.labelRotation=F(e,m);return f},getSlotWidth:function(){var a=this.chart,b=this.horiz,d=this.options.labels,c=Math.max(this.tickPositions.length-(this.categories?0:1),1),f=a.margin[3];
	return b&&2>(d.step||0)&&!d.rotation&&(this.staggerLines||1)*this.len/c||!b&&(f&&f-a.spacing[3]||.33*a.chartWidth)},renderUnsquish:function(){var a=this.chart,b=a.renderer,d=this.tickPositions,q=this.ticks,e=this.options.labels,m=this.horiz,r=this.getSlotWidth(),p=Math.max(1,Math.round(r-2*(e.padding||5))),x={},v=this.labelMetrics(),k=e.style&&e.style.textOverflow,h,l=0,A,n;f(e.rotation)||(x.rotation=e.rotation||0);c(d,function(a){(a=q[a])&&a.labelLength>l&&(l=a.labelLength)});this.maxLabelLength=
	l;if(this.autoRotation)l>p&&l>v.h?x.rotation=this.labelRotation:this.labelRotation=0;else if(r&&(h={width:p+"px"},!k))for(h.textOverflow="clip",A=d.length;!m&&A--;)if(n=d[A],p=q[n].label)p.styles&&"ellipsis"===p.styles.textOverflow?p.css({textOverflow:"clip"}):q[n].labelLength>r&&p.css({width:r+"px"}),p.getBBox().height>this.len/d.length-(v.h-v.f)&&(p.specCss={textOverflow:"ellipsis"});x.rotation&&(h={width:(l>.5*a.chartHeight?.33*a.chartHeight:a.chartHeight)+"px"},k||(h.textOverflow="ellipsis"));
	if(this.labelAlign=e.align||this.autoLabelAlign(this.labelRotation))x.align=this.labelAlign;c(d,function(a){var b=(a=q[a])&&a.label;b&&(b.attr(x),h&&b.css(y(h,b.specCss)),delete b.specCss,a.rotation=x.rotation)});this.tickRotCorr=b.rotCorr(v.b,this.labelRotation||0,0!==this.side)},hasData:function(){return this.hasVisibleSeries||l(this.min)&&l(this.max)&&!!this.tickPositions},addTitle:function(a){var b=this.chart.renderer,d=this.horiz,g=this.opposite,c=this.options.title,f;this.axisTitle||((f=c.textAlign)||
	(f=(d?{low:"left",middle:"center",high:"right"}:{low:g?"right":"left",middle:"center",high:g?"left":"right"})[c.align]),this.axisTitle=b.text(c.text,0,0,c.useHTML).attr({zIndex:7,rotation:c.rotation||0,align:f}).addClass("highcharts-axis-title").css(c.style).add(this.axisGroup),this.axisTitle.isNew=!0);this.axisTitle[a?"show":"hide"](!0)},generateTick:function(a){var b=this.ticks;b[a]?b[a].addLabel():b[a]=new L(this,a)},getOffset:function(){var a=this,b=a.chart,d=b.renderer,f=a.options,q=a.tickPositions,
	e=a.ticks,m=a.horiz,r=a.side,p=b.inverted?[1,0,3,2][r]:r,x,v,h=0,k,y=0,A=f.title,n=f.labels,G=0,J=b.axisOffset,b=b.clipOffset,t=[-1,1,1,-1][r],u,H=f.className,L=a.axisParent,K=this.tickSize("tick");x=a.hasData();a.showAxis=v=x||F(f.showEmpty,!0);a.staggerLines=a.horiz&&n.staggerLines;a.axisGroup||(a.gridGroup=d.g("grid").attr({zIndex:f.gridZIndex||1}).addClass("highcharts-"+this.coll.toLowerCase()+"-grid "+(H||"")).add(L),a.axisGroup=d.g("axis").attr({zIndex:f.zIndex||2}).addClass("highcharts-"+this.coll.toLowerCase()+
	" "+(H||"")).add(L),a.labelGroup=d.g("axis-labels").attr({zIndex:n.zIndex||7}).addClass("highcharts-"+a.coll.toLowerCase()+"-labels "+(H||"")).add(L));if(x||a.isLinked)c(q,function(b,d){a.generateTick(b,d)}),a.renderUnsquish(),!1===n.reserveSpace||0!==r&&2!==r&&{1:"left",3:"right"}[r]!==a.labelAlign&&"center"!==a.labelAlign||c(q,function(a){G=Math.max(e[a].getLabelSize(),G)}),a.staggerLines&&(G*=a.staggerLines,a.labelOffset=G*(a.opposite?-1:1));else for(u in e)e[u].destroy(),delete e[u];A&&A.text&&
	!1!==A.enabled&&(a.addTitle(v),v&&(h=a.axisTitle.getBBox()[m?"height":"width"],k=A.offset,y=l(k)?0:F(A.margin,m?5:10)));a.renderLine();a.offset=t*F(f.offset,J[r]);a.tickRotCorr=a.tickRotCorr||{x:0,y:0};d=0===r?-a.labelMetrics().h:2===r?a.tickRotCorr.y:0;y=Math.abs(G)+y;G&&(y=y-d+t*(m?F(n.y,a.tickRotCorr.y+8*t):n.x));a.axisTitleMargin=F(k,y);J[r]=Math.max(J[r],a.axisTitleMargin+h+t*a.offset,y,x&&q.length&&K?K[0]+t*a.offset:0);f=f.offset?0:2*Math.floor(a.axisLine.strokeWidth()/2);b[p]=Math.max(b[p],
	f)},getLinePath:function(a){var b=this.chart,d=this.opposite,g=this.offset,f=this.horiz,c=this.left+(d?this.width:0)+g,g=b.chartHeight-this.bottom-(d?this.height:0)+g;d&&(a*=-1);return b.renderer.crispLine(["M",f?this.left:c,f?g:this.top,"L",f?b.chartWidth-this.right:c,f?g:b.chartHeight-this.bottom],a)},renderLine:function(){this.axisLine||(this.axisLine=this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup),this.axisLine.attr({stroke:this.options.lineColor,"stroke-width":this.options.lineWidth,
	zIndex:7}))},getTitlePosition:function(){var a=this.horiz,b=this.left,d=this.top,f=this.len,c=this.options.title,q=a?b:d,e=this.opposite,m=this.offset,r=c.x||0,p=c.y||0,x=this.chart.renderer.fontMetrics(c.style&&c.style.fontSize,this.axisTitle).f,f={low:q+(a?0:f),middle:q+f/2,high:q+(a?f:0)}[c.align],b=(a?d+this.height:b)+(a?1:-1)*(e?-1:1)*this.axisTitleMargin+(2===this.side?x:0);return{x:a?f+r:b+(e?this.width:0)+m+r,y:a?b+p-(e?this.height:0)+m:f+p}},renderMinorTick:function(a){var b=this.chart.hasRendered&&
	v(this.oldMin),d=this.minorTicks;d[a]||(d[a]=new L(this,a,"minor"));b&&d[a].isNew&&d[a].render(null,!0);d[a].render(null,!1,1)},renderTick:function(a,b){var d=this.isLinked,g=this.ticks,f=this.chart.hasRendered&&v(this.oldMin);if(!d||a>=this.min&&a<=this.max)g[a]||(g[a]=new L(this,a)),f&&g[a].isNew&&g[a].render(b,!0,.1),g[a].render(b)},render:function(){var a=this,b=a.chart,d=a.options,f=a.isLog,e=a.lin2log,m=a.isLinked,r=a.tickPositions,p=a.axisTitle,x=a.ticks,v=a.minorTicks,h=a.alternateBands,k=
	d.stackLabels,y=d.alternateGridColor,l=a.tickmarkOffset,A=a.axisLine,n=a.showAxis,G=z(b.renderer.globalAnimation),J,t;a.labelEdge.length=0;a.overlap=!1;c([x,v,h],function(a){for(var b in a)a[b].isActive=!1});if(a.hasData()||m)a.minorTickInterval&&!a.categories&&c(a.getMinorTickPositions(),function(b){a.renderMinorTick(b)}),r.length&&(c(r,function(b,d){a.renderTick(b,d)}),l&&(0===a.min||a.single)&&(x[-1]||(x[-1]=new L(a,-1,null,!0)),x[-1].render(-1))),y&&c(r,function(d,g){t=void 0!==r[g+1]?r[g+1]+
	l:a.max-l;0===g%2&&d<a.max&&t<=a.max+(b.polar?-l:l)&&(h[d]||(h[d]=new q(a)),J=d+l,h[d].options={from:f?e(J):J,to:f?e(t):t,color:y},h[d].render(),h[d].isActive=!0)}),a._addedPlotLB||(c((d.plotLines||[]).concat(d.plotBands||[]),function(b){a.addPlotBandOrLine(b)}),a._addedPlotLB=!0);c([x,v,h],function(a){var d,g,f=[],c=G.duration;for(d in a)a[d].isActive||(a[d].render(d,!1,0),a[d].isActive=!1,f.push(d));K(function(){for(g=f.length;g--;)a[f[g]]&&!a[f[g]].isActive&&(a[f[g]].destroy(),delete a[f[g]])},
	a!==h&&b.hasRendered&&c?c:0)});A&&(A[A.isPlaced?"animate":"attr"]({d:this.getLinePath(A.strokeWidth())}),A.isPlaced=!0,A[n?"show":"hide"](!0));p&&n&&(p[p.isNew?"attr":"animate"](a.getTitlePosition()),p.isNew=!1);k&&k.enabled&&a.renderStackTotals();a.isDirty=!1},redraw:function(){this.visible&&(this.render(),c(this.plotLinesAndBands,function(a){a.render()}));c(this.series,function(a){a.isDirty=!0})},keepProps:"extKey hcEvents names series userMax userMin".split(" "),destroy:function(a){var b=this,
	d=b.stacks,g,f=b.plotLinesAndBands,q;a||x(b);for(g in d)e(d[g]),d[g]=null;c([b.ticks,b.minorTicks,b.alternateBands],function(a){e(a)});if(f)for(a=f.length;a--;)f[a].destroy();c("stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross".split(" "),function(a){b[a]&&(b[a]=b[a].destroy())});for(q in b)b.hasOwnProperty(q)&&-1===r(q,b.keepProps)&&delete b[q]},drawCrosshair:function(a,b){var d,f=this.crosshair,g=F(f.snap,!0),c,q=this.cross;a||(a=this.cross&&this.cross.e);this.crosshair&&
	!1!==(l(b)||!g)?(g?l(b)&&(c=this.isXAxis?b.plotX:this.len-b.plotY):c=a&&(this.horiz?a.chartX-this.pos:this.len-a.chartY+this.pos),l(c)&&(d=this.getPlotLinePath(b&&(this.isXAxis?b.x:F(b.stackY,b.y)),null,null,null,c)||null),l(d)?(b=this.categories&&!this.isRadial,q||(this.cross=q=this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-"+(b?"category ":"thin ")+f.className).attr({zIndex:F(f.zIndex,2)}).add(),q.attr({stroke:f.color||(b?h("#ccd6eb").setOpacity(.25).get():"#cccccc"),
	"stroke-width":F(f.width,1)}),f.dashStyle&&q.attr({dashstyle:f.dashStyle})),q.show().attr({d:d}),b&&!f.width&&q.attr({"stroke-width":this.transA}),this.cross.e=a):this.hideCrosshair()):this.hideCrosshair()},hideCrosshair:function(){this.cross&&this.cross.hide()}};p(a.Axis.prototype,u)})(I);(function(a){var B=a.Axis,z=a.Date,C=a.dateFormat,E=a.defaultOptions,u=a.defined,h=a.each,n=a.extend,t=a.getMagnitude,l=a.getTZOffset,k=a.normalizeTickInterval,e=a.pick,c=a.timeUnits;B.prototype.getTimeTicks=function(a,
	k,b,m){var d=[],r={},p=E.global.useUTC,v,f=new z(k-Math.abs(l(k))),y=z.hcMakeTime,G=a.unitRange,t=a.count,q;if(u(k)){f[z.hcSetMilliseconds](G>=c.second?0:t*Math.floor(f.getMilliseconds()/t));if(G>=c.second)f[z.hcSetSeconds](G>=c.minute?0:t*Math.floor(f.getSeconds()/t));if(G>=c.minute)f[z.hcSetMinutes](G>=c.hour?0:t*Math.floor(f[z.hcGetMinutes]()/t));if(G>=c.hour)f[z.hcSetHours](G>=c.day?0:t*Math.floor(f[z.hcGetHours]()/t));if(G>=c.day)f[z.hcSetDate](G>=c.month?1:t*Math.floor(f[z.hcGetDate]()/t));
	G>=c.month&&(f[z.hcSetMonth](G>=c.year?0:t*Math.floor(f[z.hcGetMonth]()/t)),v=f[z.hcGetFullYear]());if(G>=c.year)f[z.hcSetFullYear](v-v%t);if(G===c.week)f[z.hcSetDate](f[z.hcGetDate]()-f[z.hcGetDay]()+e(m,1));v=f[z.hcGetFullYear]();m=f[z.hcGetMonth]();var x=f[z.hcGetDate](),J=f[z.hcGetHours]();if(z.hcTimezoneOffset||z.hcGetTimezoneOffset)q=(!p||!!z.hcGetTimezoneOffset)&&(b-k>4*c.month||l(k)!==l(b)),f=f.getTime(),f=new z(f+l(f));p=f.getTime();for(k=1;p<b;)d.push(p),p=G===c.year?y(v+k*t,0):G===c.month?
	y(v,m+k*t):!q||G!==c.day&&G!==c.week?q&&G===c.hour?y(v,m,x,J+k*t):p+G*t:y(v,m,x+k*t*(G===c.day?1:7)),k++;d.push(p);G<=c.hour&&1E4>d.length&&h(d,function(a){0===a%18E5&&"000000000"===C("%H%M%S%L",a)&&(r[a]="day")})}d.info=n(a,{higherRanks:r,totalRange:G*t});return d};B.prototype.normalizeTimeTickInterval=function(a,e){var b=e||[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1,2]],["week",[1,2]],["month",[1,2,
	3,4,6]],["year",null]];e=b[b.length-1];var m=c[e[0]],d=e[1],r;for(r=0;r<b.length&&!(e=b[r],m=c[e[0]],d=e[1],b[r+1]&&a<=(m*d[d.length-1]+c[b[r+1][0]])/2);r++);m===c.year&&a<5*m&&(d=[1,2,5]);a=k(a/m,d,"year"===e[0]?Math.max(t(a/m),1):1);return{unitRange:m,count:a,unitName:e[0]}}})(I);(function(a){var B=a.Axis,z=a.getMagnitude,C=a.map,E=a.normalizeTickInterval,u=a.pick;B.prototype.getLogTickPositions=function(a,n,t,l){var k=this.options,e=this.len,c=this.lin2log,p=this.log2lin,h=[];l||(this._minorAutoInterval=
	null);if(.5<=a)a=Math.round(a),h=this.getLinearTickPositions(a,n,t);else if(.08<=a)for(var e=Math.floor(n),b,m,d,r,A,k=.3<a?[1,2,4]:.15<a?[1,2,4,6,8]:[1,2,3,4,5,6,7,8,9];e<t+1&&!A;e++)for(m=k.length,b=0;b<m&&!A;b++)d=p(c(e)*k[b]),d>n&&(!l||r<=t)&&void 0!==r&&h.push(r),r>t&&(A=!0),r=d;else n=c(n),t=c(t),a=k[l?"minorTickInterval":"tickInterval"],a=u("auto"===a?null:a,this._minorAutoInterval,k.tickPixelInterval/(l?5:1)*(t-n)/((l?e/this.tickPositions.length:e)||1)),a=E(a,null,z(a)),h=C(this.getLinearTickPositions(a,
	n,t),p),l||(this._minorAutoInterval=a/5);l||(this.tickInterval=a);return h};B.prototype.log2lin=function(a){return Math.log(a)/Math.LN10};B.prototype.lin2log=function(a){return Math.pow(10,a)}})(I);(function(a){var B=a.dateFormat,z=a.each,C=a.extend,E=a.format,u=a.isNumber,h=a.map,n=a.merge,t=a.pick,l=a.splat,k=a.syncTimeout,e=a.timeUnits;a.Tooltip=function(){this.init.apply(this,arguments)};a.Tooltip.prototype={init:function(a,e){this.chart=a;this.options=e;this.crosshairs=[];this.now={x:0,y:0};
	this.isHidden=!0;this.split=e.split&&!a.inverted;this.shared=e.shared||this.split},cleanSplit:function(a){z(this.chart.series,function(c){var e=c&&c.tt;e&&(!e.isActive||a?c.tt=e.destroy():e.isActive=!1)})},getLabel:function(){var a=this.chart.renderer,e=this.options;this.label||(this.split?this.label=a.g("tooltip"):(this.label=a.label("",0,0,e.shape||"callout",null,null,e.useHTML,null,"tooltip").attr({padding:e.padding,r:e.borderRadius}),this.label.attr({fill:e.backgroundColor,"stroke-width":e.borderWidth}).css(e.style).shadow(e.shadow)),
	this.label.attr({zIndex:8}).add());return this.label},update:function(a){this.destroy();this.init(this.chart,n(!0,this.options,a))},destroy:function(){this.label&&(this.label=this.label.destroy());this.split&&this.tt&&(this.cleanSplit(this.chart,!0),this.tt=this.tt.destroy());clearTimeout(this.hideTimer);clearTimeout(this.tooltipTimeout)},move:function(a,e,k,b){var c=this,d=c.now,r=!1!==c.options.animation&&!c.isHidden&&(1<Math.abs(a-d.x)||1<Math.abs(e-d.y)),p=c.followPointer||1<c.len;C(d,{x:r?(2*
	d.x+a)/3:a,y:r?(d.y+e)/2:e,anchorX:p?void 0:r?(2*d.anchorX+k)/3:k,anchorY:p?void 0:r?(d.anchorY+b)/2:b});c.getLabel().attr(d);r&&(clearTimeout(this.tooltipTimeout),this.tooltipTimeout=setTimeout(function(){c&&c.move(a,e,k,b)},32))},hide:function(a){var c=this;clearTimeout(this.hideTimer);a=t(a,this.options.hideDelay,500);this.isHidden||(this.hideTimer=k(function(){c.getLabel()[a?"fadeOut":"hide"]();c.isHidden=!0},a))},getAnchor:function(a,e){var c,b=this.chart,m=b.inverted,d=b.plotTop,r=b.plotLeft,
	p=0,v=0,f,k;a=l(a);c=a[0].tooltipPos;this.followPointer&&e&&(void 0===e.chartX&&(e=b.pointer.normalize(e)),c=[e.chartX-b.plotLeft,e.chartY-d]);c||(z(a,function(a){f=a.series.yAxis;k=a.series.xAxis;p+=a.plotX+(!m&&k?k.left-r:0);v+=(a.plotLow?(a.plotLow+a.plotHigh)/2:a.plotY)+(!m&&f?f.top-d:0)}),p/=a.length,v/=a.length,c=[m?b.plotWidth-v:p,this.shared&&!m&&1<a.length&&e?e.chartY-d:m?b.plotHeight-p:v]);return h(c,Math.round)},getPosition:function(a,e,k){var b=this.chart,c=this.distance,d={},r=k.h||0,
	p,v=["y",b.chartHeight,e,k.plotY+b.plotTop,b.plotTop,b.plotTop+b.plotHeight],f=["x",b.chartWidth,a,k.plotX+b.plotLeft,b.plotLeft,b.plotLeft+b.plotWidth],h=!this.followPointer&&t(k.ttBelow,!b.inverted===!!k.negative),l=function(a,b,f,g,q,e){var m=f<g-c,x=g+c+f<b,v=g-c-f;g+=c;if(h&&x)d[a]=g;else if(!h&&m)d[a]=v;else if(m)d[a]=Math.min(e-f,0>v-r?v:v-r);else if(x)d[a]=Math.max(q,g+r+f>b?g:g+r);else return!1},n=function(a,b,f,g){var q;g<c||g>b-c?q=!1:d[a]=g<f/2?1:g>b-f/2?b-f-2:g-f/2;return q},q=function(a){var b=
	v;v=f;f=b;p=a},x=function(){!1!==l.apply(0,v)?!1!==n.apply(0,f)||p||(q(!0),x()):p?d.x=d.y=0:(q(!0),x())};(b.inverted||1<this.len)&&q();x();return d},defaultFormatter:function(a){var c=this.points||l(this),e;e=[a.tooltipFooterHeaderFormatter(c[0])];e=e.concat(a.bodyFormatter(c));e.push(a.tooltipFooterHeaderFormatter(c[0],!0));return e},refresh:function(a,e){var c,b=this.options,m,d=a,r,p={},v=[];c=b.formatter||this.defaultFormatter;var p=this.shared,f;clearTimeout(this.hideTimer);this.followPointer=
	l(d)[0].series.tooltipOptions.followPointer;r=this.getAnchor(d,e);e=r[0];m=r[1];!p||d.series&&d.series.noSharedTooltip?p=d.getLabelConfig():(z(d,function(a){a.setState("hover");v.push(a.getLabelConfig())}),p={x:d[0].category,y:d[0].y},p.points=v,d=d[0]);this.len=v.length;p=c.call(p,this);f=d.series;this.distance=t(f.tooltipOptions.distance,16);!1===p?this.hide():(c=this.getLabel(),this.isHidden&&c.attr({opacity:1}).show(),this.split?this.renderSplit(p,a):(c.attr({text:p&&p.join?p.join(""):p}),c.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-"+
	t(d.colorIndex,f.colorIndex)),c.attr({stroke:b.borderColor||d.color||f.color||"#666666"}),this.updatePosition({plotX:e,plotY:m,negative:d.negative,ttBelow:d.ttBelow,h:r[2]||0})),this.isHidden=!1)},renderSplit:function(c,e){var p=this,b=[],m=this.chart,d=m.renderer,r=!0,k=this.options,v,f=this.getLabel();z(c.slice(0,e.length+1),function(a,c){c=e[c-1]||{isHeader:!0,plotX:e[0].plotX};var h=c.series||p,q=h.tt,x=c.series||{},l="highcharts-color-"+t(c.colorIndex,x.colorIndex,"none");q||(h.tt=q=d.label(null,
	null,null,"callout").addClass("highcharts-tooltip-box "+l).attr({padding:k.padding,r:k.borderRadius,fill:k.backgroundColor,stroke:c.color||x.color||"#333333","stroke-width":k.borderWidth}).add(f));q.isActive=!0;q.attr({text:a});q.css(k.style);a=q.getBBox();x=a.width+q.strokeWidth();c.isHeader?(v=a.height,x=Math.max(0,Math.min(c.plotX+m.plotLeft-x/2,m.chartWidth-x))):x=c.plotX+m.plotLeft-t(k.distance,16)-x;0>x&&(r=!1);a=(c.series&&c.series.yAxis&&c.series.yAxis.pos)+(c.plotY||0);a-=m.plotTop;b.push({target:c.isHeader?
	m.plotHeight+v:a,rank:c.isHeader?1:0,size:h.tt.getBBox().height+1,point:c,x:x,tt:q})});this.cleanSplit();a.distribute(b,m.plotHeight+v);z(b,function(a){var b=a.point,d=b.series;a.tt.attr({visibility:void 0===a.pos?"hidden":"inherit",x:r||b.isHeader?a.x:b.plotX+m.plotLeft+t(k.distance,16),y:a.pos+m.plotTop,anchorX:b.isHeader?b.plotX+m.plotLeft:b.plotX+d.xAxis.pos,anchorY:b.isHeader?a.pos+m.plotTop-15:b.plotY+d.yAxis.pos})})},updatePosition:function(a){var c=this.chart,e=this.getLabel(),e=(this.options.positioner||
	this.getPosition).call(this,e.width,e.height,a);this.move(Math.round(e.x),Math.round(e.y||0),a.plotX+c.plotLeft,a.plotY+c.plotTop)},getDateFormat:function(a,p,k,b){var c=B("%m-%d %H:%M:%S.%L",p),d,r,h={millisecond:15,second:12,minute:9,hour:6,day:3},v="millisecond";for(r in e){if(a===e.week&&+B("%w",p)===k&&"00:00:00.000"===c.substr(6)){r="week";break}if(e[r]>a){r=v;break}if(h[r]&&c.substr(h[r])!=="01-01 00:00:00.000".substr(h[r]))break;"week"!==r&&(v=r)}r&&(d=b[r]);return d},getXDateFormat:function(a,
	e,k){e=e.dateTimeLabelFormats;var b=k&&k.closestPointRange;return(b?this.getDateFormat(b,a.x,k.options.startOfWeek,e):e.day)||e.year},tooltipFooterHeaderFormatter:function(a,e){var c=e?"footer":"header";e=a.series;var b=e.tooltipOptions,m=b.xDateFormat,d=e.xAxis,r=d&&"datetime"===d.options.type&&u(a.key),c=b[c+"Format"];r&&!m&&(m=this.getXDateFormat(a,b,d));r&&m&&(c=c.replace("{point.key}","{point.key:"+m+"}"));return E(c,{point:a,series:e})},bodyFormatter:function(a){return h(a,function(a){var c=
	a.series.tooltipOptions;return(c.pointFormatter||a.point.tooltipFormatter).call(a.point,c.pointFormat)})}}})(I);(function(a){var B=a.addEvent,z=a.attr,C=a.charts,E=a.color,u=a.css,h=a.defined,n=a.doc,t=a.each,l=a.extend,k=a.fireEvent,e=a.offset,c=a.pick,p=a.removeEvent,H=a.splat,b=a.Tooltip,m=a.win;a.Pointer=function(a,b){this.init(a,b)};a.Pointer.prototype={init:function(a,e){this.options=e;this.chart=a;this.runChartClick=e.chart.events&&!!e.chart.events.click;this.pinchDown=[];this.lastValidTouch=
	{};b&&e.tooltip.enabled&&(a.tooltip=new b(a,e.tooltip),this.followTouchMove=c(e.tooltip.followTouchMove,!0));this.setDOMEvents()},zoomOption:function(a){var b=this.chart,d=b.options.chart,e=d.zoomType||"",b=b.inverted;/touch/.test(a.type)&&(e=c(d.pinchType,e));this.zoomX=a=/x/.test(e);this.zoomY=e=/y/.test(e);this.zoomHor=a&&!b||e&&b;this.zoomVert=e&&!b||a&&b;this.hasZoom=a||e},normalize:function(a,b){var d,c;a=a||m.event;a.target||(a.target=a.srcElement);c=a.touches?a.touches.length?a.touches.item(0):
	a.changedTouches[0]:a;b||(this.chartPosition=b=e(this.chart.container));void 0===c.pageX?(d=Math.max(a.x,a.clientX-b.left),b=a.y):(d=c.pageX-b.left,b=c.pageY-b.top);return l(a,{chartX:Math.round(d),chartY:Math.round(b)})},getCoordinates:function(a){var b={xAxis:[],yAxis:[]};t(this.chart.axes,function(d){b[d.isXAxis?"xAxis":"yAxis"].push({axis:d,value:d.toValue(a[d.horiz?"chartX":"chartY"])})});return b},getKDPoints:function(a,b,e){var d=[],f,m,r;t(a,function(a){f=a.noSharedTooltip&&b;m=!b&&a.directTouch;
	a.visible&&!f&&!m&&c(a.options.enableMouseTracking,!0)&&(r=a.searchPoint(e,!f&&1===a.kdDimensions))&&r.series&&d.push(r)});d.sort(function(a,d){var f=a.distX-d.distX,c=a.dist-d.dist,e=(d.series.group&&d.series.group.zIndex)-(a.series.group&&a.series.group.zIndex);return 0!==f&&b?f:0!==c?c:0!==e?e:a.series.index>d.series.index?-1:1});if(b)for(a=d.length;a--;)(d[a].x!==d[0].x||d[a].series.noSharedTooltip)&&d.splice(a,1);return d},getPointFromEvent:function(a){a=a.target;for(var b;a&&!b;)b=a.point,a=
	a.parentNode;return b},getHoverData:function(a,b,e,m,f,k){var d=a;a=b;var r;if(m)f?(r=[],t(e,function(a){var b=a.noSharedTooltip&&f,e=!f&&a.directTouch;a.visible&&!b&&!e&&c(a.options.enableMouseTracking,!0)&&(a=a.searchKDTree({clientX:d.clientX,plotY:d.plotY},!b&&1===a.kdDimensions))&&a.series&&r.push(a)}),0===r.length&&(r=[d])):r=[d];else{if(a&&!a.options.stickyTracking)r=this.getKDPoints([a],f,k);else{if(!f)if(a)a.options.stickyTracking||(e=[a]);else for(m=0;m<e.length;m++)if(e[m].directTouch||
	!e[m].options.stickyTracking)e=[];r=this.getKDPoints(e,f,k)}a=(d=r[0])&&d.series}r.sort(function(a,b){return a.series.index-b.series.index});return{hoverPoint:d,hoverSeries:a,hoverPoints:r}},runPointActions:function(b,c){var d=this.chart,e=d.tooltip,f=e?e.shared:!1,m=c||d.hoverPoint,r=m&&m.series||d.hoverSeries;c=this.getHoverData(m,r,d.series,!!c||r&&r.directTouch,f,b);var k,q,m=c.hoverPoint;k=(r=c.hoverSeries)&&r.tooltipOptions.followPointer;q=(f=f&&m&&!m.series.noSharedTooltip)?c.hoverPoints:[m];
	if(m&&(m!==d.hoverPoint||e&&e.isHidden)){t(d.hoverPoints||[],function(b){-1===a.inArray(b,q)&&b.setState()});t(q||[],function(a){a.setState("hover")});if(d.hoverSeries!==r)r.onMouseOver();r&&!r.directTouch&&(d.hoverPoint&&d.hoverPoint.firePointEvent("mouseOut"),m.firePointEvent("mouseOver"));d.hoverPoints=q;d.hoverPoint=m;e&&e.refresh(f?q:m,b)}else k&&e&&!e.isHidden&&(m=e.getAnchor([{}],b),e.updatePosition({plotX:m[0],plotY:m[1]}));this.unDocMouseMove||(this.unDocMouseMove=B(n,"mousemove",function(b){var d=
	C[a.hoverChartIndex];if(d)d.pointer.onDocumentMouseMove(b)}));t(q,function(a){t(d.axes,function(d){(!a||a.series&&a.series[d.coll]===d)&&d.drawCrosshair(b,a)})})},reset:function(a,b){var d=this.chart,c=d.hoverSeries,f=d.hoverPoint,e=d.hoverPoints,m=d.tooltip,r=m&&m.shared?e:f;a&&r&&t(H(r),function(b){b.series.isCartesian&&void 0===b.plotX&&(a=!1)});if(a)m&&r&&(m.refresh(r),f&&(f.setState(f.state,!0),t(d.axes,function(a){a.crosshair&&a.drawCrosshair(null,f)})));else{if(f)f.onMouseOut();e&&t(e,function(a){a.setState()});
	if(c)c.onMouseOut();m&&m.hide(b);this.unDocMouseMove&&(this.unDocMouseMove=this.unDocMouseMove());t(d.axes,function(a){a.hideCrosshair()});this.hoverX=d.hoverPoints=d.hoverPoint=null}},scaleGroups:function(a,b){var d=this.chart,c;t(d.series,function(f){c=a||f.getPlotBox();f.xAxis&&f.xAxis.zoomEnabled&&f.group&&(f.group.attr(c),f.markerGroup&&(f.markerGroup.attr(c),f.markerGroup.clip(b?d.clipRect:null)),f.dataLabelsGroup&&f.dataLabelsGroup.attr(c))});d.clipRect.attr(b||d.clipBox)},dragStart:function(a){var b=
	this.chart;b.mouseIsDown=a.type;b.cancelClick=!1;b.mouseDownX=this.mouseDownX=a.chartX;b.mouseDownY=this.mouseDownY=a.chartY},drag:function(a){var b=this.chart,d=b.options.chart,c=a.chartX,f=a.chartY,e=this.zoomHor,m=this.zoomVert,k=b.plotLeft,q=b.plotTop,x=b.plotWidth,p=b.plotHeight,h,l=this.selectionMarker,g=this.mouseDownX,n=this.mouseDownY,t=d.panKey&&a[d.panKey+"Key"];l&&l.touch||(c<k?c=k:c>k+x&&(c=k+x),f<q?f=q:f>q+p&&(f=q+p),this.hasDragged=Math.sqrt(Math.pow(g-c,2)+Math.pow(n-f,2)),10<this.hasDragged&&
	(h=b.isInsidePlot(g-k,n-q),b.hasCartesianSeries&&(this.zoomX||this.zoomY)&&h&&!t&&!l&&(this.selectionMarker=l=b.renderer.rect(k,q,e?1:x,m?1:p,0).attr({fill:d.selectionMarkerFill||E("#335cad").setOpacity(.25).get(),"class":"highcharts-selection-marker",zIndex:7}).add()),l&&e&&(c-=g,l.attr({width:Math.abs(c),x:(0<c?0:c)+g})),l&&m&&(c=f-n,l.attr({height:Math.abs(c),y:(0<c?0:c)+n})),h&&!l&&d.panning&&b.pan(a,d.panning)))},drop:function(a){var b=this,d=this.chart,c=this.hasPinched;if(this.selectionMarker){var f=
	{originalEvent:a,xAxis:[],yAxis:[]},e=this.selectionMarker,m=e.attr?e.attr("x"):e.x,p=e.attr?e.attr("y"):e.y,q=e.attr?e.attr("width"):e.width,x=e.attr?e.attr("height"):e.height,n;if(this.hasDragged||c)t(d.axes,function(d){if(d.zoomEnabled&&h(d.min)&&(c||b[{xAxis:"zoomX",yAxis:"zoomY"}[d.coll]])){var e=d.horiz,g="touchend"===a.type?d.minPixelPadding:0,r=d.toValue((e?m:p)+g),e=d.toValue((e?m+q:p+x)-g);f[d.coll].push({axis:d,min:Math.min(r,e),max:Math.max(r,e)});n=!0}}),n&&k(d,"selection",f,function(a){d.zoom(l(a,
	c?{animation:!1}:null))});this.selectionMarker=this.selectionMarker.destroy();c&&this.scaleGroups()}d&&(u(d.container,{cursor:d._cursor}),d.cancelClick=10<this.hasDragged,d.mouseIsDown=this.hasDragged=this.hasPinched=!1,this.pinchDown=[])},onContainerMouseDown:function(a){a=this.normalize(a);this.zoomOption(a);a.preventDefault&&a.preventDefault();this.dragStart(a)},onDocumentMouseUp:function(b){C[a.hoverChartIndex]&&C[a.hoverChartIndex].pointer.drop(b)},onDocumentMouseMove:function(a){var b=this.chart,
	d=this.chartPosition;a=this.normalize(a,d);!d||this.inClass(a.target,"highcharts-tracker")||b.isInsidePlot(a.chartX-b.plotLeft,a.chartY-b.plotTop)||this.reset()},onContainerMouseLeave:function(b){var d=C[a.hoverChartIndex];d&&(b.relatedTarget||b.toElement)&&(d.pointer.reset(),d.pointer.chartPosition=null)},onContainerMouseMove:function(b){var d=this.chart;h(a.hoverChartIndex)&&C[a.hoverChartIndex]&&C[a.hoverChartIndex].mouseIsDown||(a.hoverChartIndex=d.index);b=this.normalize(b);b.returnValue=!1;
	"mousedown"===d.mouseIsDown&&this.drag(b);!this.inClass(b.target,"highcharts-tracker")&&!d.isInsidePlot(b.chartX-d.plotLeft,b.chartY-d.plotTop)||d.openMenu||this.runPointActions(b)},inClass:function(a,b){for(var d;a;){if(d=z(a,"class")){if(-1!==d.indexOf(b))return!0;if(-1!==d.indexOf("highcharts-container"))return!1}a=a.parentNode}},onTrackerMouseOut:function(a){var b=this.chart.hoverSeries;a=a.relatedTarget||a.toElement;if(!(!b||!a||b.options.stickyTracking||this.inClass(a,"highcharts-tooltip")||
	this.inClass(a,"highcharts-series-"+b.index)&&this.inClass(a,"highcharts-tracker")))b.onMouseOut()},onContainerClick:function(a){var b=this.chart,d=b.hoverPoint,c=b.plotLeft,f=b.plotTop;a=this.normalize(a);b.cancelClick||(d&&this.inClass(a.target,"highcharts-tracker")?(k(d.series,"click",l(a,{point:d})),b.hoverPoint&&d.firePointEvent("click",a)):(l(a,this.getCoordinates(a)),b.isInsidePlot(a.chartX-c,a.chartY-f)&&k(b,"click",a)))},setDOMEvents:function(){var b=this,c=b.chart.container;c.onmousedown=
	function(a){b.onContainerMouseDown(a)};c.onmousemove=function(a){b.onContainerMouseMove(a)};c.onclick=function(a){b.onContainerClick(a)};B(c,"mouseleave",b.onContainerMouseLeave);1===a.chartCount&&B(n,"mouseup",b.onDocumentMouseUp);a.hasTouch&&(c.ontouchstart=function(a){b.onContainerTouchStart(a)},c.ontouchmove=function(a){b.onContainerTouchMove(a)},1===a.chartCount&&B(n,"touchend",b.onDocumentTouchEnd))},destroy:function(){var b;p(this.chart.container,"mouseleave",this.onContainerMouseLeave);a.chartCount||
	(p(n,"mouseup",this.onDocumentMouseUp),p(n,"touchend",this.onDocumentTouchEnd));clearInterval(this.tooltipTimeout);for(b in this)this[b]=null}}})(I);(function(a){var B=a.charts,z=a.each,C=a.extend,E=a.map,u=a.noop,h=a.pick;C(a.Pointer.prototype,{pinchTranslate:function(a,h,l,k,e,c){this.zoomHor&&this.pinchTranslateDirection(!0,a,h,l,k,e,c);this.zoomVert&&this.pinchTranslateDirection(!1,a,h,l,k,e,c)},pinchTranslateDirection:function(a,h,l,k,e,c,p,u){var b=this.chart,m=a?"x":"y",d=a?"X":"Y",r="chart"+
	d,n=a?"width":"height",v=b["plot"+(a?"Left":"Top")],f,y,t=u||1,F=b.inverted,q=b.bounds[a?"h":"v"],x=1===h.length,J=h[0][r],K=l[0][r],L=!x&&h[1][r],g=!x&&l[1][r],D;l=function(){!x&&20<Math.abs(J-L)&&(t=u||Math.abs(K-g)/Math.abs(J-L));y=(v-K)/t+J;f=b["plot"+(a?"Width":"Height")]/t};l();h=y;h<q.min?(h=q.min,D=!0):h+f>q.max&&(h=q.max-f,D=!0);D?(K-=.8*(K-p[m][0]),x||(g-=.8*(g-p[m][1])),l()):p[m]=[K,g];F||(c[m]=y-v,c[n]=f);c=F?1/t:t;e[n]=f;e[m]=h;k[F?a?"scaleY":"scaleX":"scale"+d]=t;k["translate"+d]=c*
	v+(K-c*J)},pinch:function(a){var n=this,l=n.chart,k=n.pinchDown,e=a.touches,c=e.length,p=n.lastValidTouch,H=n.hasZoom,b=n.selectionMarker,m={},d=1===c&&(n.inClass(a.target,"highcharts-tracker")&&l.runTrackerClick||n.runChartClick),r={};1<c&&(n.initiated=!0);H&&n.initiated&&!d&&a.preventDefault();E(e,function(a){return n.normalize(a)});"touchstart"===a.type?(z(e,function(a,b){k[b]={chartX:a.chartX,chartY:a.chartY}}),p.x=[k[0].chartX,k[1]&&k[1].chartX],p.y=[k[0].chartY,k[1]&&k[1].chartY],z(l.axes,function(a){if(a.zoomEnabled){var b=
	l.bounds[a.horiz?"h":"v"],d=a.minPixelPadding,c=a.toPixels(h(a.options.min,a.dataMin)),e=a.toPixels(h(a.options.max,a.dataMax)),m=Math.max(c,e);b.min=Math.min(a.pos,Math.min(c,e)-d);b.max=Math.max(a.pos+a.len,m+d)}}),n.res=!0):n.followTouchMove&&1===c?this.runPointActions(n.normalize(a)):k.length&&(b||(n.selectionMarker=b=C({destroy:u,touch:!0},l.plotBox)),n.pinchTranslate(k,e,m,b,r,p),n.hasPinched=H,n.scaleGroups(m,r),n.res&&(n.res=!1,this.reset(!1,0)))},touch:function(n,t){var l=this.chart,k,e;
	if(l.index!==a.hoverChartIndex)this.onContainerMouseLeave({relatedTarget:!0});a.hoverChartIndex=l.index;1===n.touches.length?(n=this.normalize(n),(e=l.isInsidePlot(n.chartX-l.plotLeft,n.chartY-l.plotTop))&&!l.openMenu?(t&&this.runPointActions(n),"touchmove"===n.type&&(t=this.pinchDown,k=t[0]?4<=Math.sqrt(Math.pow(t[0].chartX-n.chartX,2)+Math.pow(t[0].chartY-n.chartY,2)):!1),h(k,!0)&&this.pinch(n)):t&&this.reset()):2===n.touches.length&&this.pinch(n)},onContainerTouchStart:function(a){this.zoomOption(a);
	this.touch(a,!0)},onContainerTouchMove:function(a){this.touch(a)},onDocumentTouchEnd:function(h){B[a.hoverChartIndex]&&B[a.hoverChartIndex].pointer.drop(h)}})})(I);(function(a){var B=a.addEvent,z=a.charts,C=a.css,E=a.doc,u=a.extend,h=a.noop,n=a.Pointer,t=a.removeEvent,l=a.win,k=a.wrap;if(l.PointerEvent||l.MSPointerEvent){var e={},c=!!l.PointerEvent,p=function(){var a,c=[];c.item=function(a){return this[a]};for(a in e)e.hasOwnProperty(a)&&c.push({pageX:e[a].pageX,pageY:e[a].pageY,target:e[a].target});
	return c},H=function(b,c,d,e){"touch"!==b.pointerType&&b.pointerType!==b.MSPOINTER_TYPE_TOUCH||!z[a.hoverChartIndex]||(e(b),e=z[a.hoverChartIndex].pointer,e[c]({type:d,target:b.currentTarget,preventDefault:h,touches:p()}))};u(n.prototype,{onContainerPointerDown:function(a){H(a,"onContainerTouchStart","touchstart",function(a){e[a.pointerId]={pageX:a.pageX,pageY:a.pageY,target:a.currentTarget}})},onContainerPointerMove:function(a){H(a,"onContainerTouchMove","touchmove",function(a){e[a.pointerId]={pageX:a.pageX,
	pageY:a.pageY};e[a.pointerId].target||(e[a.pointerId].target=a.currentTarget)})},onDocumentPointerUp:function(a){H(a,"onDocumentTouchEnd","touchend",function(a){delete e[a.pointerId]})},batchMSEvents:function(a){a(this.chart.container,c?"pointerdown":"MSPointerDown",this.onContainerPointerDown);a(this.chart.container,c?"pointermove":"MSPointerMove",this.onContainerPointerMove);a(E,c?"pointerup":"MSPointerUp",this.onDocumentPointerUp)}});k(n.prototype,"init",function(a,c,d){a.call(this,c,d);this.hasZoom&&
	C(c.container,{"-ms-touch-action":"none","touch-action":"none"})});k(n.prototype,"setDOMEvents",function(a){a.apply(this);(this.hasZoom||this.followTouchMove)&&this.batchMSEvents(B)});k(n.prototype,"destroy",function(a){this.batchMSEvents(t);a.call(this)})}})(I);(function(a){var B,z=a.addEvent,C=a.css,E=a.discardElement,u=a.defined,h=a.each,n=a.isFirefox,t=a.marginNames,l=a.merge,k=a.pick,e=a.setAnimation,c=a.stableSort,p=a.win,H=a.wrap;B=a.Legend=function(a,c){this.init(a,c)};B.prototype={init:function(a,
	c){this.chart=a;this.setOptions(c);c.enabled&&(this.render(),z(this.chart,"endResize",function(){this.legend.positionCheckboxes()}))},setOptions:function(a){var b=k(a.padding,8);this.options=a;this.itemStyle=a.itemStyle;this.itemHiddenStyle=l(this.itemStyle,a.itemHiddenStyle);this.itemMarginTop=a.itemMarginTop||0;this.initialItemX=this.padding=b;this.initialItemY=b-5;this.itemHeight=this.maxItemWidth=0;this.symbolWidth=k(a.symbolWidth,16);this.pages=[]},update:function(a,c){var b=this.chart;this.setOptions(l(!0,
	this.options,a));this.destroy();b.isDirtyLegend=b.isDirtyBox=!0;k(c,!0)&&b.redraw()},colorizeItem:function(a,c){a.legendGroup[c?"removeClass":"addClass"]("highcharts-legend-item-hidden");var b=this.options,e=a.legendItem,m=a.legendLine,k=a.legendSymbol,f=this.itemHiddenStyle.color,b=c?b.itemStyle.color:f,p=c?a.color||f:f,h=a.options&&a.options.marker,l={fill:p},q;e&&e.css({fill:b,color:b});m&&m.attr({stroke:p});if(k){if(h&&k.isMarker&&(l=a.pointAttribs(),!c))for(q in l)l[q]=f;k.attr(l)}},positionItem:function(a){var b=
	this.options,d=b.symbolPadding,b=!b.rtl,c=a._legendItemPos,e=c[0],c=c[1],k=a.checkbox;(a=a.legendGroup)&&a.element&&a.translate(b?e:this.legendWidth-e-2*d-4,c);k&&(k.x=e,k.y=c)},destroyItem:function(a){var b=a.checkbox;h(["legendItem","legendLine","legendSymbol","legendGroup"],function(b){a[b]&&(a[b]=a[b].destroy())});b&&E(a.checkbox)},destroy:function(){function a(a){this[a]&&(this[a]=this[a].destroy())}h(this.getAllItems(),function(b){h(["legendItem","legendGroup"],a,b)});h("clipRect up down pager nav box title group".split(" "),
	a,this);this.display=null},positionCheckboxes:function(a){var b=this.group&&this.group.alignAttr,d,c=this.clipHeight||this.legendHeight,e=this.titleHeight;b&&(d=b.translateY,h(this.allItems,function(m){var f=m.checkbox,k;f&&(k=d+e+f.y+(a||0)+3,C(f,{left:b.translateX+m.checkboxOffset+f.x-20+"px",top:k+"px",display:k>d-6&&k<d+c-6?"":"none"}))}))},renderTitle:function(){var a=this.padding,c=this.options.title,d=0;c.text&&(this.title||(this.title=this.chart.renderer.label(c.text,a-3,a-4,null,null,null,
	null,null,"legend-title").attr({zIndex:1}).css(c.style).add(this.group)),a=this.title.getBBox(),d=a.height,this.offsetWidth=a.width,this.contentGroup.attr({translateY:d}));this.titleHeight=d},setText:function(b){var c=this.options;b.legendItem.attr({text:c.labelFormat?a.format(c.labelFormat,b):c.labelFormatter.call(b)})},renderItem:function(a){var b=this.chart,d=b.renderer,c=this.options,e="horizontal"===c.layout,p=this.symbolWidth,f=c.symbolPadding,h=this.itemStyle,n=this.itemHiddenStyle,t=this.padding,
	q=e?k(c.itemDistance,20):0,x=!c.rtl,J=c.width,u=c.itemMarginBottom||0,L=this.itemMarginTop,g=this.initialItemX,D=a.legendItem,H=!a.series,z=!H&&a.series.drawLegendSymbol?a.series:a,B=z.options,B=this.createCheckboxForItem&&B&&B.showCheckbox,C=c.useHTML;D||(a.legendGroup=d.g("legend-item").addClass("highcharts-"+z.type+"-series highcharts-color-"+a.colorIndex+(a.options.className?" "+a.options.className:"")+(H?" highcharts-series-"+a.index:"")).attr({zIndex:1}).add(this.scrollGroup),a.legendItem=D=
	d.text("",x?p+f:-f,this.baseline||0,C).css(l(a.visible?h:n)).attr({align:x?"left":"right",zIndex:2}).add(a.legendGroup),this.baseline||(h=h.fontSize,this.fontMetrics=d.fontMetrics(h,D),this.baseline=this.fontMetrics.f+3+L,D.attr("y",this.baseline)),this.symbolHeight=c.symbolHeight||this.fontMetrics.f,z.drawLegendSymbol(this,a),this.setItemEvents&&this.setItemEvents(a,D,C),B&&this.createCheckboxForItem(a));this.colorizeItem(a,a.visible);this.setText(a);d=D.getBBox();p=a.checkboxOffset=c.itemWidth||
	a.legendItemWidth||p+f+d.width+q+(B?20:0);this.itemHeight=f=Math.round(a.legendItemHeight||d.height);e&&this.itemX-g+p>(J||b.chartWidth-2*t-g-c.x)&&(this.itemX=g,this.itemY+=L+this.lastLineHeight+u,this.lastLineHeight=0);this.maxItemWidth=Math.max(this.maxItemWidth,p);this.lastItemY=L+this.itemY+u;this.lastLineHeight=Math.max(f,this.lastLineHeight);a._legendItemPos=[this.itemX,this.itemY];e?this.itemX+=p:(this.itemY+=L+f+u,this.lastLineHeight=f);this.offsetWidth=J||Math.max((e?this.itemX-g-q:p)+t,
	this.offsetWidth)},getAllItems:function(){var a=[];h(this.chart.series,function(b){var d=b&&b.options;b&&k(d.showInLegend,u(d.linkedTo)?!1:void 0,!0)&&(a=a.concat(b.legendItems||("point"===d.legendType?b.data:b)))});return a},adjustMargins:function(a,c){var b=this.chart,e=this.options,m=e.align.charAt(0)+e.verticalAlign.charAt(0)+e.layout.charAt(0);e.floating||h([/(lth|ct|rth)/,/(rtv|rm|rbv)/,/(rbh|cb|lbh)/,/(lbv|lm|ltv)/],function(d,f){d.test(m)&&!u(a[f])&&(b[t[f]]=Math.max(b[t[f]],b.legend[(f+1)%
	2?"legendHeight":"legendWidth"]+[1,-1,-1,1][f]*e[f%2?"x":"y"]+k(e.margin,12)+c[f]))})},render:function(){var a=this,e=a.chart,d=e.renderer,k=a.group,p,n,f,y,t=a.box,u=a.options,q=a.padding;a.itemX=a.initialItemX;a.itemY=a.initialItemY;a.offsetWidth=0;a.lastItemY=0;k||(a.group=k=d.g("legend").attr({zIndex:7}).add(),a.contentGroup=d.g().attr({zIndex:1}).add(k),a.scrollGroup=d.g().add(a.contentGroup));a.renderTitle();p=a.getAllItems();c(p,function(a,b){return(a.options&&a.options.legendIndex||0)-(b.options&&
	b.options.legendIndex||0)});u.reversed&&p.reverse();a.allItems=p;a.display=n=!!p.length;a.lastLineHeight=0;h(p,function(b){a.renderItem(b)});f=(u.width||a.offsetWidth)+q;y=a.lastItemY+a.lastLineHeight+a.titleHeight;y=a.handleOverflow(y);y+=q;t||(a.box=t=d.rect().addClass("highcharts-legend-box").attr({r:u.borderRadius}).add(k),t.isNew=!0);t.attr({stroke:u.borderColor,"stroke-width":u.borderWidth||0,fill:u.backgroundColor||"none"}).shadow(u.shadow);0<f&&0<y&&(t[t.isNew?"attr":"animate"](t.crisp({x:0,
	y:0,width:f,height:y},t.strokeWidth())),t.isNew=!1);t[n?"show":"hide"]();a.legendWidth=f;a.legendHeight=y;h(p,function(b){a.positionItem(b)});n&&k.align(l(u,{width:f,height:y}),!0,"spacingBox");e.isResizing||this.positionCheckboxes()},handleOverflow:function(a){var b=this,d=this.chart,c=d.renderer,e=this.options,p=e.y,d=d.spacingBox.height+("top"===e.verticalAlign?-p:p)-this.padding,p=e.maxHeight,f,l=this.clipRect,n=e.navigation,t=k(n.animation,!0),q=n.arrowSize||12,x=this.nav,u=this.pages,K=this.padding,
	L,g=this.allItems,D=function(a){a?l.attr({height:a}):l&&(b.clipRect=l.destroy(),b.contentGroup.clip());b.contentGroup.div&&(b.contentGroup.div.style.clip=a?"rect("+K+"px,9999px,"+(K+a)+"px,0)":"auto")};"horizontal"!==e.layout||"middle"===e.verticalAlign||e.floating||(d/=2);p&&(d=Math.min(d,p));u.length=0;a>d&&!1!==n.enabled?(this.clipHeight=f=Math.max(d-20-this.titleHeight-K,0),this.currentPage=k(this.currentPage,1),this.fullHeight=a,h(g,function(a,b){var d=a._legendItemPos[1];a=Math.round(a.legendItem.getBBox().height);
	var c=u.length;if(!c||d-u[c-1]>f&&(L||d)!==u[c-1])u.push(L||d),c++;b===g.length-1&&d+a-u[c-1]>f&&u.push(d);d!==L&&(L=d)}),l||(l=b.clipRect=c.clipRect(0,K,9999,0),b.contentGroup.clip(l)),D(f),x||(this.nav=x=c.g().attr({zIndex:1}).add(this.group),this.up=c.symbol("triangle",0,0,q,q).on("click",function(){b.scroll(-1,t)}).add(x),this.pager=c.text("",15,10).addClass("highcharts-legend-navigation").css(n.style).add(x),this.down=c.symbol("triangle-down",0,0,q,q).on("click",function(){b.scroll(1,t)}).add(x)),
	b.scroll(0),a=d):x&&(D(),this.nav=x.destroy(),this.scrollGroup.attr({translateY:1}),this.clipHeight=0);return a},scroll:function(a,c){var b=this.pages,m=b.length;a=this.currentPage+a;var k=this.clipHeight,p=this.options.navigation,f=this.pager,h=this.padding;a>m&&(a=m);0<a&&(void 0!==c&&e(c,this.chart),this.nav.attr({translateX:h,translateY:k+this.padding+7+this.titleHeight,visibility:"visible"}),this.up.attr({"class":1===a?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"}),f.attr({text:a+
	"/"+m}),this.down.attr({x:18+this.pager.getBBox().width,"class":a===m?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"}),this.up.attr({fill:1===a?p.inactiveColor:p.activeColor}).css({cursor:1===a?"default":"pointer"}),this.down.attr({fill:a===m?p.inactiveColor:p.activeColor}).css({cursor:a===m?"default":"pointer"}),c=-b[a-1]+this.initialItemY,this.scrollGroup.animate({translateY:c}),this.currentPage=a,this.positionCheckboxes(c))}};a.LegendSymbolMixin={drawRectangle:function(a,c){var b=
	a.symbolHeight,e=a.options.squareSymbol;c.legendSymbol=this.chart.renderer.rect(e?(a.symbolWidth-b)/2:0,a.baseline-b+1,e?b:a.symbolWidth,b,k(a.options.symbolRadius,b/2)).addClass("highcharts-point").attr({zIndex:3}).add(c.legendGroup)},drawLineMarker:function(a){var b=this.options,c=b.marker,e=a.symbolWidth,p=a.symbolHeight,h=p/2,f=this.chart.renderer,n=this.legendGroup;a=a.baseline-Math.round(.3*a.fontMetrics.b);var t;t={"stroke-width":b.lineWidth||0};b.dashStyle&&(t.dashstyle=b.dashStyle);this.legendLine=
	f.path(["M",0,a,"L",e,a]).addClass("highcharts-graph").attr(t).add(n);c&&!1!==c.enabled&&(b=Math.min(k(c.radius,h),h),0===this.symbol.indexOf("url")&&(c=l(c,{width:p,height:p}),b=0),this.legendSymbol=c=f.symbol(this.symbol,e/2-b,a-b,2*b,2*b,c).addClass("highcharts-point").add(n),c.isMarker=!0)}};(/Trident\/7\.0/.test(p.navigator.userAgent)||n)&&H(B.prototype,"positionItem",function(a,c){var b=this,e=function(){c._legendItemPos&&a.call(b,c)};e();setTimeout(e)})})(I);(function(a){var B=a.addEvent,z=
	a.animate,C=a.animObject,E=a.attr,u=a.doc,h=a.Axis,n=a.createElement,t=a.defaultOptions,l=a.discardElement,k=a.charts,e=a.css,c=a.defined,p=a.each,H=a.extend,b=a.find,m=a.fireEvent,d=a.getStyle,r=a.grep,A=a.isNumber,v=a.isObject,f=a.isString,y=a.Legend,G=a.marginNames,F=a.merge,q=a.Pointer,x=a.pick,J=a.pInt,K=a.removeEvent,L=a.seriesTypes,g=a.splat,D=a.svg,S=a.syncTimeout,M=a.win,R=a.Renderer,N=a.Chart=function(){this.getArgs.apply(this,arguments)};a.chart=function(a,b,c){return new N(a,b,c)};N.prototype=
	{callbacks:[],getArgs:function(){var a=[].slice.call(arguments);if(f(a[0])||a[0].nodeName)this.renderTo=a.shift();this.init(a[0],a[1])},init:function(b,c){var d,f=b.series;b.series=null;d=F(t,b);d.series=b.series=f;this.userOptions=b;b=d.chart;f=b.events;this.margin=[];this.spacing=[];this.bounds={h:{},v:{}};this.callback=c;this.isResizing=0;this.options=d;this.axes=[];this.series=[];this.hasCartesianSeries=b.showAxes;var g;this.index=k.length;k.push(this);a.chartCount++;if(f)for(g in f)B(this,g,
	f[g]);this.xAxis=[];this.yAxis=[];this.pointCount=this.colorCounter=this.symbolCounter=0;this.firstRender()},initSeries:function(b){var c=this.options.chart;(c=L[b.type||c.type||c.defaultSeriesType])||a.error(17,!0);c=new c;c.init(this,b);return c},orderSeries:function(a){var b=this.series;for(a=a||0;a<b.length;a++)b[a]&&(b[a].index=a,b[a].name=b[a].name||"Series "+(b[a].index+1))},isInsidePlot:function(a,b,c){var d=c?b:a;a=c?a:b;return 0<=d&&d<=this.plotWidth&&0<=a&&a<=this.plotHeight},redraw:function(b){var c=
	this.axes,d=this.series,f=this.pointer,g=this.legend,e=this.isDirtyLegend,q,k,h=this.hasCartesianSeries,x=this.isDirtyBox,l,w=this.renderer,r=w.isHidden(),n=[];this.setResponsive&&this.setResponsive(!1);a.setAnimation(b,this);r&&this.cloneRenderTo();this.layOutTitles();for(b=d.length;b--;)if(l=d[b],l.options.stacking&&(q=!0,l.isDirty)){k=!0;break}if(k)for(b=d.length;b--;)l=d[b],l.options.stacking&&(l.isDirty=!0);p(d,function(a){a.isDirty&&"point"===a.options.legendType&&(a.updateTotals&&a.updateTotals(),
	e=!0);a.isDirtyData&&m(a,"updatedData")});e&&g.options.enabled&&(g.render(),this.isDirtyLegend=!1);q&&this.getStacks();h&&p(c,function(a){a.updateNames();a.setScale()});this.getMargins();h&&(p(c,function(a){a.isDirty&&(x=!0)}),p(c,function(a){var b=a.min+","+a.max;a.extKey!==b&&(a.extKey=b,n.push(function(){m(a,"afterSetExtremes",H(a.eventArgs,a.getExtremes()));delete a.eventArgs}));(x||q)&&a.redraw()}));x&&this.drawChartBox();m(this,"predraw");p(d,function(a){(x||a.isDirty)&&a.visible&&a.redraw();
	a.isDirtyData=!1});f&&f.reset(!0);w.draw();m(this,"redraw");m(this,"render");r&&this.cloneRenderTo(!0);p(n,function(a){a.call()})},get:function(a){function c(b){return b.id===a||b.options&&b.options.id===a}var d,f=this.series,g;d=b(this.axes,c)||b(this.series,c);for(g=0;!d&&g<f.length;g++)d=b(f[g].points||[],c);return d},getAxes:function(){var a=this,b=this.options,c=b.xAxis=g(b.xAxis||{}),b=b.yAxis=g(b.yAxis||{});p(c,function(a,b){a.index=b;a.isX=!0});p(b,function(a,b){a.index=b});c=c.concat(b);
	p(c,function(b){new h(a,b)})},getSelectedPoints:function(){var a=[];p(this.series,function(b){a=a.concat(r(b.points||[],function(a){return a.selected}))});return a},getSelectedSeries:function(){return r(this.series,function(a){return a.selected})},setTitle:function(a,b,c){var d=this,f=d.options,g;g=f.title=F({style:{color:"#333333",fontSize:f.isStock?"16px":"18px"}},f.title,a);f=f.subtitle=F({style:{color:"#666666"}},f.subtitle,b);p([["title",a,g],["subtitle",b,f]],function(a,b){var c=a[0],f=d[c],
	g=a[1];a=a[2];f&&g&&(d[c]=f=f.destroy());a&&a.text&&!f&&(d[c]=d.renderer.text(a.text,0,0,a.useHTML).attr({align:a.align,"class":"highcharts-"+c,zIndex:a.zIndex||4}).add(),d[c].update=function(a){d.setTitle(!b&&a,b&&a)},d[c].css(a.style))});d.layOutTitles(c)},layOutTitles:function(a){var b=0,c,d=this.renderer,f=this.spacingBox;p(["title","subtitle"],function(a){var c=this[a],g=this.options[a],e;c&&(e=g.style.fontSize,e=d.fontMetrics(e,c).b,c.css({width:(g.width||f.width+g.widthAdjust)+"px"}).align(H({y:b+
	e+("title"===a?-3:2)},g),!1,"spacingBox"),g.floating||g.verticalAlign||(b=Math.ceil(b+c.getBBox().height)))},this);c=this.titleOffset!==b;this.titleOffset=b;!this.isDirtyBox&&c&&(this.isDirtyBox=c,this.hasRendered&&x(a,!0)&&this.isDirtyBox&&this.redraw())},getChartSize:function(){var b=this.options.chart,f=b.width,b=b.height,g=this.renderToClone||this.renderTo;c(f)||(this.containerWidth=d(g,"width"));c(b)||(this.containerHeight=d(g,"height"));this.chartWidth=Math.max(0,f||this.containerWidth||600);
	this.chartHeight=Math.max(0,a.relativeLength(b,this.chartWidth)||this.containerHeight||400)},cloneRenderTo:function(a){var b=this.renderToClone,c=this.container;if(a){if(b){for(;b.childNodes.length;)this.renderTo.appendChild(b.firstChild);l(b);delete this.renderToClone}}else c&&c.parentNode===this.renderTo&&this.renderTo.removeChild(c),this.renderToClone=b=this.renderTo.cloneNode(0),e(b,{position:"absolute",top:"-9999px",display:"block"}),b.style.setProperty&&b.style.setProperty("display","block",
	"important"),u.body.appendChild(b),c&&b.appendChild(c)},setClassName:function(a){this.container.className="highcharts-container "+(a||"")},getContainer:function(){var b,c=this.options,d=c.chart,g,e;b=this.renderTo;var q=a.uniqueKey(),m;b||(this.renderTo=b=d.renderTo);f(b)&&(this.renderTo=b=u.getElementById(b));b||a.error(13,!0);g=J(E(b,"data-highcharts-chart"));A(g)&&k[g]&&k[g].hasRendered&&k[g].destroy();E(b,"data-highcharts-chart",this.index);b.innerHTML="";d.skipClone||b.offsetWidth||this.cloneRenderTo();
	this.getChartSize();g=this.chartWidth;e=this.chartHeight;m=H({position:"relative",overflow:"hidden",width:g+"px",height:e+"px",textAlign:"left",lineHeight:"normal",zIndex:0,"-webkit-tap-highlight-color":"rgba(0,0,0,0)"},d.style);this.container=b=n("div",{id:q},m,this.renderToClone||b);this._cursor=b.style.cursor;this.renderer=new (a[d.renderer]||R)(b,g,e,null,d.forExport,c.exporting&&c.exporting.allowHTML);this.setClassName(d.className);this.renderer.setStyle(d.style);this.renderer.chartIndex=this.index},
	getMargins:function(a){var b=this.spacing,d=this.margin,f=this.titleOffset;this.resetMargins();f&&!c(d[0])&&(this.plotTop=Math.max(this.plotTop,f+this.options.title.margin+b[0]));this.legend.display&&this.legend.adjustMargins(d,b);this.extraMargin&&(this[this.extraMargin.type]=(this[this.extraMargin.type]||0)+this.extraMargin.value);this.extraTopMargin&&(this.plotTop+=this.extraTopMargin);a||this.getAxisMargins()},getAxisMargins:function(){var a=this,b=a.axisOffset=[0,0,0,0],d=a.margin;a.hasCartesianSeries&&
	p(a.axes,function(a){a.visible&&a.getOffset()});p(G,function(f,g){c(d[g])||(a[f]+=b[g])});a.setChartSize()},reflow:function(a){var b=this,f=b.options.chart,g=b.renderTo,e=c(f.width),q=f.width||d(g,"width"),f=f.height||d(g,"height"),g=a?a.target:M;if(!e&&!b.isPrinting&&q&&f&&(g===M||g===u)){if(q!==b.containerWidth||f!==b.containerHeight)clearTimeout(b.reflowTimeout),b.reflowTimeout=S(function(){b.container&&b.setSize(void 0,void 0,!1)},a?100:0);b.containerWidth=q;b.containerHeight=f}},initReflow:function(){var a=
	this,b;b=B(M,"resize",function(b){a.reflow(b)});B(a,"destroy",b)},setSize:function(b,c,d){var f=this,g=f.renderer;f.isResizing+=1;a.setAnimation(d,f);f.oldChartHeight=f.chartHeight;f.oldChartWidth=f.chartWidth;void 0!==b&&(f.options.chart.width=b);void 0!==c&&(f.options.chart.height=c);f.getChartSize();b=g.globalAnimation;(b?z:e)(f.container,{width:f.chartWidth+"px",height:f.chartHeight+"px"},b);f.setChartSize(!0);g.setSize(f.chartWidth,f.chartHeight,d);p(f.axes,function(a){a.isDirty=!0;a.setScale()});
	f.isDirtyLegend=!0;f.isDirtyBox=!0;f.layOutTitles();f.getMargins();f.redraw(d);f.oldChartHeight=null;m(f,"resize");S(function(){f&&m(f,"endResize",null,function(){--f.isResizing})},C(b).duration)},setChartSize:function(a){var b=this.inverted,c=this.renderer,d=this.chartWidth,f=this.chartHeight,g=this.options.chart,e=this.spacing,q=this.clipOffset,k,m,h,x;this.plotLeft=k=Math.round(this.plotLeft);this.plotTop=m=Math.round(this.plotTop);this.plotWidth=h=Math.max(0,Math.round(d-k-this.marginRight));
	this.plotHeight=x=Math.max(0,Math.round(f-m-this.marginBottom));this.plotSizeX=b?x:h;this.plotSizeY=b?h:x;this.plotBorderWidth=g.plotBorderWidth||0;this.spacingBox=c.spacingBox={x:e[3],y:e[0],width:d-e[3]-e[1],height:f-e[0]-e[2]};this.plotBox=c.plotBox={x:k,y:m,width:h,height:x};d=2*Math.floor(this.plotBorderWidth/2);b=Math.ceil(Math.max(d,q[3])/2);c=Math.ceil(Math.max(d,q[0])/2);this.clipBox={x:b,y:c,width:Math.floor(this.plotSizeX-Math.max(d,q[1])/2-b),height:Math.max(0,Math.floor(this.plotSizeY-
	Math.max(d,q[2])/2-c))};a||p(this.axes,function(a){a.setAxisSize();a.setAxisTranslation()})},resetMargins:function(){var a=this,b=a.options.chart;p(["margin","spacing"],function(c){var d=b[c],f=v(d)?d:[d,d,d,d];p(["Top","Right","Bottom","Left"],function(d,g){a[c][g]=x(b[c+d],f[g])})});p(G,function(b,c){a[b]=x(a.margin[c],a.spacing[c])});a.axisOffset=[0,0,0,0];a.clipOffset=[0,0,0,0]},drawChartBox:function(){var a=this.options.chart,b=this.renderer,c=this.chartWidth,d=this.chartHeight,f=this.chartBackground,
	g=this.plotBackground,e=this.plotBorder,q,k=this.plotBGImage,m=a.backgroundColor,p=a.plotBackgroundColor,h=a.plotBackgroundImage,x,l=this.plotLeft,r=this.plotTop,n=this.plotWidth,v=this.plotHeight,t=this.plotBox,y=this.clipRect,u=this.clipBox,J="animate";f||(this.chartBackground=f=b.rect().addClass("highcharts-background").add(),J="attr");q=a.borderWidth||0;x=q+(a.shadow?8:0);m={fill:m||"none"};if(q||f["stroke-width"])m.stroke=a.borderColor,m["stroke-width"]=q;f.attr(m).shadow(a.shadow);f[J]({x:x/
	2,y:x/2,width:c-x-q%2,height:d-x-q%2,r:a.borderRadius});J="animate";g||(J="attr",this.plotBackground=g=b.rect().addClass("highcharts-plot-background").add());g[J](t);g.attr({fill:p||"none"}).shadow(a.plotShadow);h&&(k?k.animate(t):this.plotBGImage=b.image(h,l,r,n,v).add());y?y.animate({width:u.width,height:u.height}):this.clipRect=b.clipRect(u);J="animate";e||(J="attr",this.plotBorder=e=b.rect().addClass("highcharts-plot-border").attr({zIndex:1}).add());e.attr({stroke:a.plotBorderColor,"stroke-width":a.plotBorderWidth||
	0,fill:"none"});e[J](e.crisp({x:l,y:r,width:n,height:v},-e.strokeWidth()));this.isDirtyBox=!1},propFromSeries:function(){var a=this,b=a.options.chart,c,d=a.options.series,f,g;p(["inverted","angular","polar"],function(e){c=L[b.type||b.defaultSeriesType];g=b[e]||c&&c.prototype[e];for(f=d&&d.length;!g&&f--;)(c=L[d[f].type])&&c.prototype[e]&&(g=!0);a[e]=g})},linkSeries:function(){var a=this,b=a.series;p(b,function(a){a.linkedSeries.length=0});p(b,function(b){var c=b.options.linkedTo;f(c)&&(c=":previous"===
	c?a.series[b.index-1]:a.get(c))&&c.linkedParent!==b&&(c.linkedSeries.push(b),b.linkedParent=c,b.visible=x(b.options.visible,c.options.visible,b.visible))})},renderSeries:function(){p(this.series,function(a){a.translate();a.render()})},renderLabels:function(){var a=this,b=a.options.labels;b.items&&p(b.items,function(c){var d=H(b.style,c.style),f=J(d.left)+a.plotLeft,g=J(d.top)+a.plotTop+12;delete d.left;delete d.top;a.renderer.text(c.html,f,g).attr({zIndex:2}).css(d).add()})},render:function(){var a=
	this.axes,b=this.renderer,c=this.options,d,f,g;this.setTitle();this.legend=new y(this,c.legend);this.getStacks&&this.getStacks();this.getMargins(!0);this.setChartSize();c=this.plotWidth;d=this.plotHeight-=21;p(a,function(a){a.setScale()});this.getAxisMargins();f=1.1<c/this.plotWidth;g=1.05<d/this.plotHeight;if(f||g)p(a,function(a){(a.horiz&&f||!a.horiz&&g)&&a.setTickInterval(!0)}),this.getMargins();this.drawChartBox();this.hasCartesianSeries&&p(a,function(a){a.visible&&a.render()});this.seriesGroup||
	(this.seriesGroup=b.g("series-group").attr({zIndex:3}).add());this.renderSeries();this.renderLabels();this.addCredits();this.setResponsive&&this.setResponsive();this.hasRendered=!0},addCredits:function(a){var b=this;a=F(!0,this.options.credits,a);a.enabled&&!this.credits&&(this.credits=this.renderer.text(a.text+(this.mapCredits||""),0,0).addClass("highcharts-credits").on("click",function(){a.href&&(M.location.href=a.href)}).attr({align:a.position.align,zIndex:8}).css(a.style).add().align(a.position),
	this.credits.update=function(a){b.credits=b.credits.destroy();b.addCredits(a)})},destroy:function(){var b=this,c=b.axes,d=b.series,f=b.container,g,e=f&&f.parentNode;m(b,"destroy");k[b.index]=void 0;a.chartCount--;b.renderTo.removeAttribute("data-highcharts-chart");K(b);for(g=c.length;g--;)c[g]=c[g].destroy();this.scroller&&this.scroller.destroy&&this.scroller.destroy();for(g=d.length;g--;)d[g]=d[g].destroy();p("title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" "),
	function(a){var c=b[a];c&&c.destroy&&(b[a]=c.destroy())});f&&(f.innerHTML="",K(f),e&&l(f));for(g in b)delete b[g]},isReadyToRender:function(){var a=this;return D||M!=M.top||"complete"===u.readyState?!0:(u.attachEvent("onreadystatechange",function(){u.detachEvent("onreadystatechange",a.firstRender);"complete"===u.readyState&&a.firstRender()}),!1)},firstRender:function(){var a=this,b=a.options;if(a.isReadyToRender()){a.getContainer();m(a,"init");a.resetMargins();a.setChartSize();a.propFromSeries();
	a.getAxes();p(b.series||[],function(b){a.initSeries(b)});a.linkSeries();m(a,"beforeRender");q&&(a.pointer=new q(a,b));a.render();if(!a.renderer.imgCount&&a.onload)a.onload();a.cloneRenderTo(!0)}},onload:function(){p([this.callback].concat(this.callbacks),function(a){a&&void 0!==this.index&&a.apply(this,[this])},this);m(this,"load");m(this,"render");c(this.index)&&!1!==this.options.chart.reflow&&this.initReflow();this.onload=null}}})(I);(function(a){var B,z=a.each,C=a.extend,E=a.erase,u=a.fireEvent,
	h=a.format,n=a.isArray,t=a.isNumber,l=a.pick,k=a.removeEvent;B=a.Point=function(){};B.prototype={init:function(a,c,k){this.series=a;this.color=a.color;this.applyOptions(c,k);a.options.colorByPoint?(c=a.options.colors||a.chart.options.colors,this.color=this.color||c[a.colorCounter],c=c.length,k=a.colorCounter,a.colorCounter++,a.colorCounter===c&&(a.colorCounter=0)):k=a.colorIndex;this.colorIndex=l(this.colorIndex,k);a.chart.pointCount++;return this},applyOptions:function(a,c){var e=this.series,k=e.options.pointValKey||
	e.pointValKey;a=B.prototype.optionsToObject.call(this,a);C(this,a);this.options=this.options?C(this.options,a):a;a.group&&delete this.group;k&&(this.y=this[k]);this.isNull=l(this.isValid&&!this.isValid(),null===this.x||!t(this.y,!0));this.selected&&(this.state="select");"name"in this&&void 0===c&&e.xAxis&&e.xAxis.hasNames&&(this.x=e.xAxis.nameToX(this));void 0===this.x&&e&&(this.x=void 0===c?e.autoIncrement(this):c);return this},optionsToObject:function(a){var c={},e=this.series,k=e.options.keys,
	b=k||e.pointArrayMap||["y"],m=b.length,d=0,h=0;if(t(a)||null===a)c[b[0]]=a;else if(n(a))for(!k&&a.length>m&&(e=typeof a[0],"string"===e?c.name=a[0]:"number"===e&&(c.x=a[0]),d++);h<m;)k&&void 0===a[d]||(c[b[h]]=a[d]),d++,h++;else"object"===typeof a&&(c=a,a.dataLabels&&(e._hasPointLabels=!0),a.marker&&(e._hasPointMarkers=!0));return c},getClassName:function(){return"highcharts-point"+(this.selected?" highcharts-point-select":"")+(this.negative?" highcharts-negative":"")+(this.isNull?" highcharts-null-point":
	"")+(void 0!==this.colorIndex?" highcharts-color-"+this.colorIndex:"")+(this.options.className?" "+this.options.className:"")+(this.zone&&this.zone.className?" "+this.zone.className.replace("highcharts-negative",""):"")},getZone:function(){var a=this.series,c=a.zones,a=a.zoneAxis||"y",k=0,h;for(h=c[k];this[a]>=h.value;)h=c[++k];h&&h.color&&!this.options.color&&(this.color=h.color);return h},destroy:function(){var a=this.series.chart,c=a.hoverPoints,h;a.pointCount--;c&&(this.setState(),E(c,this),c.length||
	(a.hoverPoints=null));if(this===a.hoverPoint)this.onMouseOut();if(this.graphic||this.dataLabel)k(this),this.destroyElements();this.legendItem&&a.legend.destroyItem(this);for(h in this)this[h]=null},destroyElements:function(){for(var a=["graphic","dataLabel","dataLabelUpper","connector","shadowGroup"],c,k=6;k--;)c=a[k],this[c]&&(this[c]=this[c].destroy())},getLabelConfig:function(){return{x:this.category,y:this.y,color:this.color,colorIndex:this.colorIndex,key:this.name||this.category,series:this.series,
	point:this,percentage:this.percentage,total:this.total||this.stackTotal}},tooltipFormatter:function(a){var c=this.series,e=c.tooltipOptions,k=l(e.valueDecimals,""),b=e.valuePrefix||"",m=e.valueSuffix||"";z(c.pointArrayMap||["y"],function(c){c="{point."+c;if(b||m)a=a.replace(c+"}",b+c+"}"+m);a=a.replace(c+"}",c+":,."+k+"f}")});return h(a,{point:this,series:this.series})},firePointEvent:function(a,c,k){var e=this,b=this.series.options;(b.point.events[a]||e.options&&e.options.events&&e.options.events[a])&&
	this.importEvents();"click"===a&&b.allowPointSelect&&(k=function(a){e.select&&e.select(null,a.ctrlKey||a.metaKey||a.shiftKey)});u(this,a,c,k)},visible:!0}})(I);(function(a){var B=a.addEvent,z=a.animObject,C=a.arrayMax,E=a.arrayMin,u=a.correctFloat,h=a.Date,n=a.defaultOptions,t=a.defaultPlotOptions,l=a.defined,k=a.each,e=a.erase,c=a.extend,p=a.fireEvent,H=a.grep,b=a.isArray,m=a.isNumber,d=a.isString,r=a.merge,A=a.pick,v=a.removeEvent,f=a.splat,y=a.SVGElement,G=a.syncTimeout,F=a.win;a.Series=a.seriesType("line",
	null,{lineWidth:2,allowPointSelect:!1,showCheckbox:!1,animation:{duration:1E3},events:{},marker:{lineWidth:0,lineColor:"#ffffff",radius:4,states:{hover:{animation:{duration:50},enabled:!0,radiusPlus:2,lineWidthPlus:1},select:{fillColor:"#cccccc",lineColor:"#000000",lineWidth:2}}},point:{events:{}},dataLabels:{align:"center",formatter:function(){return null===this.y?"":a.numberFormat(this.y,-1)},style:{fontSize:"11px",fontWeight:"bold",color:"contrast",textOutline:"1px contrast"},verticalAlign:"bottom",
	x:0,y:0,padding:5},cropThreshold:300,pointRange:0,softThreshold:!0,states:{hover:{animation:{duration:50},lineWidthPlus:1,marker:{},halo:{size:10,opacity:.25}},select:{marker:{}}},stickyTracking:!0,turboThreshold:1E3},{isCartesian:!0,pointClass:a.Point,sorted:!0,requireSorting:!0,directTouch:!1,axisTypes:["xAxis","yAxis"],colorCounter:0,parallelArrays:["x","y"],coll:"series",init:function(a,b){var d=this,f,e,g=a.series,q;d.chart=a;d.options=b=d.setOptions(b);d.linkedSeries=[];d.bindAxes();c(d,{name:b.name,
	state:"",visible:!1!==b.visible,selected:!0===b.selected});e=b.events;for(f in e)B(d,f,e[f]);if(e&&e.click||b.point&&b.point.events&&b.point.events.click||b.allowPointSelect)a.runTrackerClick=!0;d.getColor();d.getSymbol();k(d.parallelArrays,function(a){d[a+"Data"]=[]});d.setData(b.data,!1);d.isCartesian&&(a.hasCartesianSeries=!0);g.length&&(q=g[g.length-1]);d._i=A(q&&q._i,-1)+1;a.orderSeries(this.insert(g))},insert:function(a){var b=this.options.index,c;if(m(b)){for(c=a.length;c--;)if(b>=A(a[c].options.index,
	a[c]._i)){a.splice(c+1,0,this);break}-1===c&&a.unshift(this);c+=1}else a.push(this);return A(c,a.length-1)},bindAxes:function(){var b=this,c=b.options,d=b.chart,f;k(b.axisTypes||[],function(e){k(d[e],function(a){f=a.options;if(c[e]===f.index||void 0!==c[e]&&c[e]===f.id||void 0===c[e]&&0===f.index)b.insert(a.series),b[e]=a,a.isDirty=!0});b[e]||b.optionalAxis===e||a.error(18,!0)})},updateParallelArrays:function(a,b){var c=a.series,d=arguments,f=m(b)?function(d){var f="y"===d&&c.toYData?c.toYData(a):
	a[d];c[d+"Data"][b]=f}:function(a){Array.prototype[b].apply(c[a+"Data"],Array.prototype.slice.call(d,2))};k(c.parallelArrays,f)},autoIncrement:function(){var a=this.options,b=this.xIncrement,c,d=a.pointIntervalUnit,b=A(b,a.pointStart,0);this.pointInterval=c=A(this.pointInterval,a.pointInterval,1);d&&(a=new h(b),"day"===d?a=+a[h.hcSetDate](a[h.hcGetDate]()+c):"month"===d?a=+a[h.hcSetMonth](a[h.hcGetMonth]()+c):"year"===d&&(a=+a[h.hcSetFullYear](a[h.hcGetFullYear]()+c)),c=a-b);this.xIncrement=b+c;return b},
	setOptions:function(a){var b=this.chart,c=b.options.plotOptions,b=b.userOptions||{},d=b.plotOptions||{},f=c[this.type];this.userOptions=a;c=r(f,c.series,a);this.tooltipOptions=r(n.tooltip,n.plotOptions[this.type].tooltip,b.tooltip,d.series&&d.series.tooltip,d[this.type]&&d[this.type].tooltip,a.tooltip);null===f.marker&&delete c.marker;this.zoneAxis=c.zoneAxis;a=this.zones=(c.zones||[]).slice();!c.negativeColor&&!c.negativeFillColor||c.zones||a.push({value:c[this.zoneAxis+"Threshold"]||c.threshold||
	0,className:"highcharts-negative",color:c.negativeColor,fillColor:c.negativeFillColor});a.length&&l(a[a.length-1].value)&&a.push({color:this.color,fillColor:this.fillColor});return c},getCyclic:function(a,b,c){var d,f=this.chart,g=this.userOptions,e=a+"Index",q=a+"Counter",k=c?c.length:A(f.options.chart[a+"Count"],f[a+"Count"]);b||(d=A(g[e],g["_"+e]),l(d)||(f.series.length||(f[q]=0),g["_"+e]=d=f[q]%k,f[q]+=1),c&&(b=c[d]));void 0!==d&&(this[e]=d);this[a]=b},getColor:function(){this.options.colorByPoint?
	this.options.color=null:this.getCyclic("color",this.options.color||t[this.type].color,this.chart.options.colors)},getSymbol:function(){this.getCyclic("symbol",this.options.marker.symbol,this.chart.options.symbols)},drawLegendSymbol:a.LegendSymbolMixin.drawLineMarker,setData:function(c,f,e,h){var q=this,g=q.points,p=g&&g.length||0,l,x=q.options,r=q.chart,n=null,v=q.xAxis,t=x.turboThreshold,y=this.xData,u=this.yData,G=(l=q.pointArrayMap)&&l.length;c=c||[];l=c.length;f=A(f,!0);if(!1!==h&&l&&p===l&&!q.cropped&&
	!q.hasGroupedData&&q.visible)k(c,function(a,b){g[b].update&&a!==x.data[b]&&g[b].update(a,!1,null,!1)});else{q.xIncrement=null;q.colorCounter=0;k(this.parallelArrays,function(a){q[a+"Data"].length=0});if(t&&l>t){for(e=0;null===n&&e<l;)n=c[e],e++;if(m(n))for(e=0;e<l;e++)y[e]=this.autoIncrement(),u[e]=c[e];else if(b(n))if(G)for(e=0;e<l;e++)n=c[e],y[e]=n[0],u[e]=n.slice(1,G+1);else for(e=0;e<l;e++)n=c[e],y[e]=n[0],u[e]=n[1];else a.error(12)}else for(e=0;e<l;e++)void 0!==c[e]&&(n={series:q},q.pointClass.prototype.applyOptions.apply(n,
	[c[e]]),q.updateParallelArrays(n,e));d(u[0])&&a.error(14,!0);q.data=[];q.options.data=q.userOptions.data=c;for(e=p;e--;)g[e]&&g[e].destroy&&g[e].destroy();v&&(v.minRange=v.userMinRange);q.isDirty=r.isDirtyBox=!0;q.isDirtyData=!!g;e=!1}"point"===x.legendType&&(this.processData(),this.generatePoints());f&&r.redraw(e)},processData:function(b){var c=this.xData,d=this.yData,f=c.length,e;e=0;var g,q,k=this.xAxis,m,h=this.options;m=h.cropThreshold;var l=this.getExtremesFromAll||h.getExtremesFromAll,p=this.isCartesian,
	h=k&&k.val2lin,n=k&&k.isLog,r,v;if(p&&!this.isDirty&&!k.isDirty&&!this.yAxis.isDirty&&!b)return!1;k&&(b=k.getExtremes(),r=b.min,v=b.max);if(p&&this.sorted&&!l&&(!m||f>m||this.forceCrop))if(c[f-1]<r||c[0]>v)c=[],d=[];else if(c[0]<r||c[f-1]>v)e=this.cropData(this.xData,this.yData,r,v),c=e.xData,d=e.yData,e=e.start,g=!0;for(m=c.length||1;--m;)f=n?h(c[m])-h(c[m-1]):c[m]-c[m-1],0<f&&(void 0===q||f<q)?q=f:0>f&&this.requireSorting&&a.error(15);this.cropped=g;this.cropStart=e;this.processedXData=c;this.processedYData=
	d;this.closestPointRange=q},cropData:function(a,b,c,d){var f=a.length,g=0,e=f,q=A(this.cropShoulder,1),k;for(k=0;k<f;k++)if(a[k]>=c){g=Math.max(0,k-q);break}for(c=k;c<f;c++)if(a[c]>d){e=c+q;break}return{xData:a.slice(g,e),yData:b.slice(g,e),start:g,end:e}},generatePoints:function(){var a=this.options.data,b=this.data,c,d=this.processedXData,e=this.processedYData,g=this.pointClass,k=d.length,m=this.cropStart||0,h,l=this.hasGroupedData,p,n=[],r;b||l||(b=[],b.length=a.length,b=this.data=b);for(r=0;r<
	k;r++)h=m+r,l?(p=(new g).init(this,[d[r]].concat(f(e[r]))),p.dataGroup=this.groupMap[r]):(p=b[h])||void 0===a[h]||(b[h]=p=(new g).init(this,a[h],d[r])),p.index=h,n[r]=p;if(b&&(k!==(c=b.length)||l))for(r=0;r<c;r++)r!==m||l||(r+=k),b[r]&&(b[r].destroyElements(),b[r].plotX=void 0);this.data=b;this.points=n},getExtremes:function(a){var c=this.yAxis,d=this.processedXData,f,e=[],g=0;f=this.xAxis.getExtremes();var q=f.min,k=f.max,h,l,p,r;a=a||this.stackedYData||this.processedYData||[];f=a.length;for(r=0;r<
	f;r++)if(l=d[r],p=a[r],h=(m(p,!0)||b(p))&&(!c.positiveValuesOnly||p.length||0<p),l=this.getExtremesFromAll||this.options.getExtremesFromAll||this.cropped||(d[r+1]||l)>=q&&(d[r-1]||l)<=k,h&&l)if(h=p.length)for(;h--;)null!==p[h]&&(e[g++]=p[h]);else e[g++]=p;this.dataMin=E(e);this.dataMax=C(e)},translate:function(){this.processedXData||this.processData();this.generatePoints();var a=this.options,b=a.stacking,c=this.xAxis,d=c.categories,f=this.yAxis,e=this.points,k=e.length,h=!!this.modifyValue,p=a.pointPlacement,
	r="between"===p||m(p),n=a.threshold,v=a.startFromThreshold?n:0,t,y,G,F,H=Number.MAX_VALUE;"between"===p&&(p=.5);m(p)&&(p*=A(a.pointRange||c.pointRange));for(a=0;a<k;a++){var z=e[a],B=z.x,C=z.y;y=z.low;var E=b&&f.stacks[(this.negStacks&&C<(v?0:n)?"-":"")+this.stackKey],I;f.positiveValuesOnly&&null!==C&&0>=C&&(z.isNull=!0);z.plotX=t=u(Math.min(Math.max(-1E5,c.translate(B,0,0,0,1,p,"flags"===this.type)),1E5));b&&this.visible&&!z.isNull&&E&&E[B]&&(F=this.getStackIndicator(F,B,this.index),I=E[B],C=I.points[F.key],
	y=C[0],C=C[1],y===v&&F.key===E[B].base&&(y=A(n,f.min)),f.positiveValuesOnly&&0>=y&&(y=null),z.total=z.stackTotal=I.total,z.percentage=I.total&&z.y/I.total*100,z.stackY=C,I.setOffset(this.pointXOffset||0,this.barW||0));z.yBottom=l(y)?f.translate(y,0,1,0,1):null;h&&(C=this.modifyValue(C,z));z.plotY=y="number"===typeof C&&Infinity!==C?Math.min(Math.max(-1E5,f.translate(C,0,1,0,1)),1E5):void 0;z.isInside=void 0!==y&&0<=y&&y<=f.len&&0<=t&&t<=c.len;z.clientX=r?u(c.translate(B,0,0,0,1,p)):t;z.negative=z.y<
	(n||0);z.category=d&&void 0!==d[z.x]?d[z.x]:z.x;z.isNull||(void 0!==G&&(H=Math.min(H,Math.abs(t-G))),G=t);z.zone=this.zones.length&&z.getZone()}this.closestPointRangePx=H},getValidPoints:function(a,b){var c=this.chart;return H(a||this.points||[],function(a){return b&&!c.isInsidePlot(a.plotX,a.plotY,c.inverted)?!1:!a.isNull})},setClip:function(a){var b=this.chart,c=this.options,d=b.renderer,f=b.inverted,e=this.clipBox,q=e||b.clipBox,k=this.sharedClipKey||["_sharedClip",a&&a.duration,a&&a.easing,q.height,
	c.xAxis,c.yAxis].join(),m=b[k],h=b[k+"m"];m||(a&&(q.width=0,b[k+"m"]=h=d.clipRect(-99,f?-b.plotLeft:-b.plotTop,99,f?b.chartWidth:b.chartHeight)),b[k]=m=d.clipRect(q),m.count={length:0});a&&!m.count[this.index]&&(m.count[this.index]=!0,m.count.length+=1);!1!==c.clip&&(this.group.clip(a||e?m:b.clipRect),this.markerGroup.clip(h),this.sharedClipKey=k);a||(m.count[this.index]&&(delete m.count[this.index],--m.count.length),0===m.count.length&&k&&b[k]&&(e||(b[k]=b[k].destroy()),b[k+"m"]&&(this.markerGroup.clip(),
	b[k+"m"]=b[k+"m"].destroy())))},animate:function(a){var b=this.chart,c=z(this.options.animation),d;a?this.setClip(c):(d=this.sharedClipKey,(a=b[d])&&a.animate({width:b.plotSizeX},c),b[d+"m"]&&b[d+"m"].animate({width:b.plotSizeX+99},c),this.animate=null)},afterAnimate:function(){this.setClip();p(this,"afterAnimate")},drawPoints:function(){var a=this.points,b=this.chart,c,d,f,e,k=this.options.marker,h,p,l,r,n=this.markerGroup,v=A(k.enabled,this.xAxis.isRadial?!0:null,this.closestPointRangePx>=2*k.radius);
	if(!1!==k.enabled||this._hasPointMarkers)for(d=0;d<a.length;d++)f=a[d],c=f.plotY,e=f.graphic,h=f.marker||{},p=!!f.marker,l=v&&void 0===h.enabled||h.enabled,r=f.isInside,l&&m(c)&&null!==f.y?(c=A(h.symbol,this.symbol),f.hasImage=0===c.indexOf("url"),l=this.markerAttribs(f,f.selected&&"select"),e?e[r?"show":"hide"](!0).animate(l):r&&(0<l.width||f.hasImage)&&(f.graphic=e=b.renderer.symbol(c,l.x,l.y,l.width,l.height,p?h:k).add(n)),e&&e.attr(this.pointAttribs(f,f.selected&&"select")),e&&e.addClass(f.getClassName(),
	!0)):e&&(f.graphic=e.destroy())},markerAttribs:function(a,b){var c=this.options.marker,d=a.marker||{},f=A(d.radius,c.radius);b&&(c=c.states[b],b=d.states&&d.states[b],f=A(b&&b.radius,c&&c.radius,f+(c&&c.radiusPlus||0)));a.hasImage&&(f=0);a={x:Math.floor(a.plotX)-f,y:a.plotY-f};f&&(a.width=a.height=2*f);return a},pointAttribs:function(a,b){var c=this.options.marker,d=a&&a.options,f=d&&d.marker||{},e=this.color,q=d&&d.color,k=a&&a.color,d=A(f.lineWidth,c.lineWidth);a=a&&a.zone&&a.zone.color;e=q||a||
	k||e;a=f.fillColor||c.fillColor||e;e=f.lineColor||c.lineColor||e;b&&(c=c.states[b],b=f.states&&f.states[b]||{},d=A(b.lineWidth,c.lineWidth,d+A(b.lineWidthPlus,c.lineWidthPlus,0)),a=b.fillColor||c.fillColor||a,e=b.lineColor||c.lineColor||e);return{stroke:e,"stroke-width":d,fill:a}},destroy:function(){var a=this,b=a.chart,c=/AppleWebKit\/533/.test(F.navigator.userAgent),d,f=a.data||[],g,m,h;p(a,"destroy");v(a);k(a.axisTypes||[],function(b){(h=a[b])&&h.series&&(e(h.series,a),h.isDirty=h.forceRedraw=
	!0)});a.legendItem&&a.chart.legend.destroyItem(a);for(d=f.length;d--;)(g=f[d])&&g.destroy&&g.destroy();a.points=null;clearTimeout(a.animationTimeout);for(m in a)a[m]instanceof y&&!a[m].survive&&(d=c&&"group"===m?"hide":"destroy",a[m][d]());b.hoverSeries===a&&(b.hoverSeries=null);e(b.series,a);b.orderSeries();for(m in a)delete a[m]},getGraphPath:function(a,b,c){var d=this,f=d.options,e=f.step,q,m=[],h=[],p;a=a||d.points;(q=a.reversed)&&a.reverse();(e={right:1,center:2}[e]||e&&3)&&q&&(e=4-e);!f.connectNulls||
	b||c||(a=this.getValidPoints(a));k(a,function(g,k){var q=g.plotX,r=g.plotY,n=a[k-1];(g.leftCliff||n&&n.rightCliff)&&!c&&(p=!0);g.isNull&&!l(b)&&0<k?p=!f.connectNulls:g.isNull&&!b?p=!0:(0===k||p?k=["M",g.plotX,g.plotY]:d.getPointSpline?k=d.getPointSpline(a,g,k):e?(k=1===e?["L",n.plotX,r]:2===e?["L",(n.plotX+q)/2,n.plotY,"L",(n.plotX+q)/2,r]:["L",q,n.plotY],k.push("L",q,r)):k=["L",q,r],h.push(g.x),e&&h.push(g.x),m.push.apply(m,k),p=!1)});m.xMap=h;return d.graphPath=m},drawGraph:function(){var a=this,
	b=this.options,c=(this.gappedPath||this.getGraphPath).call(this),d=[["graph","highcharts-graph",b.lineColor||this.color,b.dashStyle]];k(this.zones,function(c,f){d.push(["zone-graph-"+f,"highcharts-graph highcharts-zone-graph-"+f+" "+(c.className||""),c.color||a.color,c.dashStyle||b.dashStyle])});k(d,function(d,f){var e=d[0],g=a[e];g?(g.endX=c.xMap,g.animate({d:c})):c.length&&(a[e]=a.chart.renderer.path(c).addClass(d[1]).attr({zIndex:1}).add(a.group),g={stroke:d[2],"stroke-width":b.lineWidth,fill:a.fillGraph&&
	a.color||"none"},d[3]?g.dashstyle=d[3]:"square"!==b.linecap&&(g["stroke-linecap"]=g["stroke-linejoin"]="round"),g=a[e].attr(g).shadow(2>f&&b.shadow));g&&(g.startX=c.xMap,g.isArea=c.isArea)})},applyZones:function(){var a=this,b=this.chart,c=b.renderer,d=this.zones,f,e,m=this.clips||[],h,p=this.graph,l=this.area,r=Math.max(b.chartWidth,b.chartHeight),n=this[(this.zoneAxis||"y")+"Axis"],v,t,y=b.inverted,u,G,F,H,z=!1;d.length&&(p||l)&&n&&void 0!==n.min&&(t=n.reversed,u=n.horiz,p&&p.hide(),l&&l.hide(),
	v=n.getExtremes(),k(d,function(d,g){f=t?u?b.plotWidth:0:u?0:n.toPixels(v.min);f=Math.min(Math.max(A(e,f),0),r);e=Math.min(Math.max(Math.round(n.toPixels(A(d.value,v.max),!0)),0),r);z&&(f=e=n.toPixels(v.max));G=Math.abs(f-e);F=Math.min(f,e);H=Math.max(f,e);n.isXAxis?(h={x:y?H:F,y:0,width:G,height:r},u||(h.x=b.plotHeight-h.x)):(h={x:0,y:y?H:F,width:r,height:G},u&&(h.y=b.plotWidth-h.y));y&&c.isVML&&(h=n.isXAxis?{x:0,y:t?F:H,height:h.width,width:b.chartWidth}:{x:h.y-b.plotLeft-b.spacingBox.x,y:0,width:h.height,
	height:b.chartHeight});m[g]?m[g].animate(h):(m[g]=c.clipRect(h),p&&a["zone-graph-"+g].clip(m[g]),l&&a["zone-area-"+g].clip(m[g]));z=d.value>v.max}),this.clips=m)},invertGroups:function(a){function b(){k(["group","markerGroup"],function(b){c[b]&&(d.renderer.isVML&&c[b].attr({width:c.yAxis.len,height:c.xAxis.len}),c[b].width=c.yAxis.len,c[b].height=c.xAxis.len,c[b].invert(a))})}var c=this,d=c.chart,f;c.xAxis&&(f=B(d,"resize",b),B(c,"destroy",f),b(a),c.invertGroups=b)},plotGroup:function(a,b,c,d,f){var e=
	this[a],k=!e;k&&(this[a]=e=this.chart.renderer.g(b).attr({zIndex:d||.1}).add(f),e.addClass("highcharts-series-"+this.index+" highcharts-"+this.type+"-series highcharts-color-"+this.colorIndex+" "+(this.options.className||"")));e.attr({visibility:c})[k?"attr":"animate"](this.getPlotBox());return e},getPlotBox:function(){var a=this.chart,b=this.xAxis,c=this.yAxis;a.inverted&&(b=c,c=this.xAxis);return{translateX:b?b.left:a.plotLeft,translateY:c?c.top:a.plotTop,scaleX:1,scaleY:1}},render:function(){var a=
	this,b=a.chart,c,d=a.options,f=!!a.animate&&b.renderer.isSVG&&z(d.animation).duration,e=a.visible?"inherit":"hidden",k=d.zIndex,m=a.hasRendered,h=b.seriesGroup,p=b.inverted;c=a.plotGroup("group","series",e,k,h);a.markerGroup=a.plotGroup("markerGroup","markers",e,k,h);f&&a.animate(!0);c.inverted=a.isCartesian?p:!1;a.drawGraph&&(a.drawGraph(),a.applyZones());a.drawDataLabels&&a.drawDataLabels();a.visible&&a.drawPoints();a.drawTracker&&!1!==a.options.enableMouseTracking&&a.drawTracker();a.invertGroups(p);
	!1===d.clip||a.sharedClipKey||m||c.clip(b.clipRect);f&&a.animate();m||(a.animationTimeout=G(function(){a.afterAnimate()},f));a.isDirty=!1;a.hasRendered=!0},redraw:function(){var a=this.chart,b=this.isDirty||this.isDirtyData,c=this.group,d=this.xAxis,f=this.yAxis;c&&(a.inverted&&c.attr({width:a.plotWidth,height:a.plotHeight}),c.animate({translateX:A(d&&d.left,a.plotLeft),translateY:A(f&&f.top,a.plotTop)}));this.translate();this.render();b&&delete this.kdTree},kdDimensions:1,kdAxisArray:["clientX",
	"plotY"],searchPoint:function(a,b){var c=this.xAxis,d=this.yAxis,f=this.chart.inverted;return this.searchKDTree({clientX:f?c.len-a.chartY+c.pos:a.chartX-c.pos,plotY:f?d.len-a.chartX+d.pos:a.chartY-d.pos},b)},buildKDTree:function(){function a(c,d,f){var e,g;if(g=c&&c.length)return e=b.kdAxisArray[d%f],c.sort(function(a,b){return a[e]-b[e]}),g=Math.floor(g/2),{point:c[g],left:a(c.slice(0,g),d+1,f),right:a(c.slice(g+1),d+1,f)}}this.buildingKdTree=!0;var b=this,c=b.kdDimensions;delete b.kdTree;G(function(){b.kdTree=
	a(b.getValidPoints(null,!b.directTouch),c,c);b.buildingKdTree=!1},b.options.kdNow?0:1)},searchKDTree:function(a,b){function c(a,b,g,m){var h=b.point,p=d.kdAxisArray[g%m],q,r,n=h;r=l(a[f])&&l(h[f])?Math.pow(a[f]-h[f],2):null;q=l(a[e])&&l(h[e])?Math.pow(a[e]-h[e],2):null;q=(r||0)+(q||0);h.dist=l(q)?Math.sqrt(q):Number.MAX_VALUE;h.distX=l(r)?Math.sqrt(r):Number.MAX_VALUE;p=a[p]-h[p];q=0>p?"left":"right";r=0>p?"right":"left";b[q]&&(q=c(a,b[q],g+1,m),n=q[k]<n[k]?q:h);b[r]&&Math.sqrt(p*p)<n[k]&&(a=c(a,
	b[r],g+1,m),n=a[k]<n[k]?a:n);return n}var d=this,f=this.kdAxisArray[0],e=this.kdAxisArray[1],k=b?"distX":"dist";this.kdTree||this.buildingKdTree||this.buildKDTree();if(this.kdTree)return c(a,this.kdTree,this.kdDimensions,this.kdDimensions)}})})(I);(function(a){function B(a,e,c,h,n){var b=a.chart.inverted;this.axis=a;this.isNegative=c;this.options=e;this.x=h;this.total=null;this.points={};this.stack=n;this.rightCliff=this.leftCliff=0;this.alignOptions={align:e.align||(b?c?"left":"right":"center"),
	verticalAlign:e.verticalAlign||(b?"middle":c?"bottom":"top"),y:l(e.y,b?4:c?14:-6),x:l(e.x,b?c?-6:6:0)};this.textAlign=e.textAlign||(b?c?"right":"left":"center")}var z=a.Axis,C=a.Chart,E=a.correctFloat,u=a.defined,h=a.destroyObjectProperties,n=a.each,t=a.format,l=a.pick;a=a.Series;B.prototype={destroy:function(){h(this,this.axis)},render:function(a){var e=this.options,c=e.format,c=c?t(c,this):e.formatter.call(this);this.label?this.label.attr({text:c,visibility:"hidden"}):this.label=this.axis.chart.renderer.text(c,
	null,null,e.useHTML).css(e.style).attr({align:this.textAlign,rotation:e.rotation,visibility:"hidden"}).add(a)},setOffset:function(a,e){var c=this.axis,k=c.chart,h=k.inverted,b=c.reversed,b=this.isNegative&&!b||!this.isNegative&&b,m=c.translate(c.usePercentage?100:this.total,0,0,0,1),c=c.translate(0),c=Math.abs(m-c);a=k.xAxis[0].translate(this.x)+a;var d=k.plotHeight,h={x:h?b?m:m-c:a,y:h?d-a-e:b?d-m-c:d-m,width:h?c:e,height:h?e:c};if(e=this.label)e.align(this.alignOptions,null,h),h=e.alignAttr,e[!1===
	this.options.crop||k.isInsidePlot(h.x,h.y)?"show":"hide"](!0)}};C.prototype.getStacks=function(){var a=this;n(a.yAxis,function(a){a.stacks&&a.hasVisibleSeries&&(a.oldStacks=a.stacks)});n(a.series,function(e){!e.options.stacking||!0!==e.visible&&!1!==a.options.chart.ignoreHiddenSeries||(e.stackKey=e.type+l(e.options.stack,""))})};z.prototype.buildStacks=function(){var a=this.series,e,c=l(this.options.reversedStacks,!0),h=a.length,n;if(!this.isXAxis){this.usePercentage=!1;for(n=h;n--;)a[c?n:h-n-1].setStackedPoints();
	for(n=h;n--;)e=a[c?n:h-n-1],e.setStackCliffs&&e.setStackCliffs();if(this.usePercentage)for(n=0;n<h;n++)a[n].setPercentStacks()}};z.prototype.renderStackTotals=function(){var a=this.chart,e=a.renderer,c=this.stacks,h,l,b=this.stackTotalGroup;b||(this.stackTotalGroup=b=e.g("stack-labels").attr({visibility:"visible",zIndex:6}).add());b.translate(a.plotLeft,a.plotTop);for(h in c)for(l in a=c[h],a)a[l].render(b)};z.prototype.resetStacks=function(){var a=this.stacks,e,c;if(!this.isXAxis)for(e in a)for(c in a[e])a[e][c].touched<
	this.stacksTouched?(a[e][c].destroy(),delete a[e][c]):(a[e][c].total=null,a[e][c].cum=null)};z.prototype.cleanStacks=function(){var a,e,c;if(!this.isXAxis)for(e in this.oldStacks&&(a=this.stacks=this.oldStacks),a)for(c in a[e])a[e][c].cum=a[e][c].total};a.prototype.setStackedPoints=function(){if(this.options.stacking&&(!0===this.visible||!1===this.chart.options.chart.ignoreHiddenSeries)){var a=this.processedXData,e=this.processedYData,c=[],h=e.length,n=this.options,b=n.threshold,m=n.startFromThreshold?
	b:0,d=n.stack,n=n.stacking,r=this.stackKey,t="-"+r,v=this.negStacks,f=this.yAxis,y=f.stacks,G=f.oldStacks,F,q,x,z,K,C,g;f.stacksTouched+=1;for(K=0;K<h;K++)C=a[K],g=e[K],F=this.getStackIndicator(F,C,this.index),z=F.key,x=(q=v&&g<(m?0:b))?t:r,y[x]||(y[x]={}),y[x][C]||(G[x]&&G[x][C]?(y[x][C]=G[x][C],y[x][C].total=null):y[x][C]=new B(f,f.options.stackLabels,q,C,d)),x=y[x][C],null!==g&&(x.points[z]=x.points[this.index]=[l(x.cum,m)],u(x.cum)||(x.base=z),x.touched=f.stacksTouched,0<F.index&&!1===this.singleStacks&&
	(x.points[z][0]=x.points[this.index+","+C+",0"][0])),"percent"===n?(q=q?r:t,v&&y[q]&&y[q][C]?(q=y[q][C],x.total=q.total=Math.max(q.total,x.total)+Math.abs(g)||0):x.total=E(x.total+(Math.abs(g)||0))):x.total=E(x.total+(g||0)),x.cum=l(x.cum,m)+(g||0),null!==g&&(x.points[z].push(x.cum),c[K]=x.cum);"percent"===n&&(f.usePercentage=!0);this.stackedYData=c;f.oldStacks={}}};a.prototype.setPercentStacks=function(){var a=this,e=a.stackKey,c=a.yAxis.stacks,h=a.processedXData,l;n([e,"-"+e],function(b){for(var e=
	h.length,d,k;e--;)if(d=h[e],l=a.getStackIndicator(l,d,a.index,b),d=(k=c[b]&&c[b][d])&&k.points[l.key])k=k.total?100/k.total:0,d[0]=E(d[0]*k),d[1]=E(d[1]*k),a.stackedYData[e]=d[1]})};a.prototype.getStackIndicator=function(a,e,c,h){!u(a)||a.x!==e||h&&a.key!==h?a={x:e,index:0,key:h}:a.index++;a.key=[c,e,a.index].join();return a}})(I);(function(a){var B=a.addEvent,z=a.animate,C=a.Axis,E=a.createElement,u=a.css,h=a.defined,n=a.each,t=a.erase,l=a.extend,k=a.fireEvent,e=a.inArray,c=a.isNumber,p=a.isObject,
	H=a.merge,b=a.pick,m=a.Point,d=a.Series,r=a.seriesTypes,A=a.setAnimation,v=a.splat;l(a.Chart.prototype,{addSeries:function(a,c,d){var f,e=this;a&&(c=b(c,!0),k(e,"addSeries",{options:a},function(){f=e.initSeries(a);e.isDirtyLegend=!0;e.linkSeries();c&&e.redraw(d)}));return f},addAxis:function(a,c,d,e){var f=c?"xAxis":"yAxis",h=this.options;a=H(a,{index:this[f].length,isX:c});new C(this,a);h[f]=v(h[f]||{});h[f].push(a);b(d,!0)&&this.redraw(e)},showLoading:function(a){var b=this,c=b.options,d=b.loadingDiv,
	f=c.loading,e=function(){d&&u(d,{left:b.plotLeft+"px",top:b.plotTop+"px",width:b.plotWidth+"px",height:b.plotHeight+"px"})};d||(b.loadingDiv=d=E("div",{className:"highcharts-loading highcharts-loading-hidden"},null,b.container),b.loadingSpan=E("span",{className:"highcharts-loading-inner"},null,d),B(b,"redraw",e));d.className="highcharts-loading";b.loadingSpan.innerHTML=a||c.lang.loading;u(d,l(f.style,{zIndex:10}));u(b.loadingSpan,f.labelStyle);b.loadingShown||(u(d,{opacity:0,display:""}),z(d,{opacity:f.style.opacity||
	.5},{duration:f.showDuration||0}));b.loadingShown=!0;e()},hideLoading:function(){var a=this.options,b=this.loadingDiv;b&&(b.className="highcharts-loading highcharts-loading-hidden",z(b,{opacity:0},{duration:a.loading.hideDuration||100,complete:function(){u(b,{display:"none"})}}));this.loadingShown=!1},propsRequireDirtyBox:"backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
	propsRequireUpdateSeries:"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions".split(" "),update:function(a,d){var f,k={credits:"addCredits",title:"setTitle",subtitle:"setSubtitle"},m=a.chart,l,p;if(m){H(!0,this.options.chart,m);"className"in m&&this.setClassName(m.className);if("inverted"in m||"polar"in m)this.propFromSeries(),l=!0;for(f in m)m.hasOwnProperty(f)&&(-1!==e("chart."+f,this.propsRequireUpdateSeries)&&(p=!0),-1!==e(f,this.propsRequireDirtyBox)&&(this.isDirtyBox=
	!0));"style"in m&&this.renderer.setStyle(m.style)}for(f in a){if(this[f]&&"function"===typeof this[f].update)this[f].update(a[f],!1);else if("function"===typeof this[k[f]])this[k[f]](a[f]);"chart"!==f&&-1!==e(f,this.propsRequireUpdateSeries)&&(p=!0)}a.colors&&(this.options.colors=a.colors);a.plotOptions&&H(!0,this.options.plotOptions,a.plotOptions);n(["xAxis","yAxis","series"],function(b){a[b]&&n(v(a[b]),function(a,c){(c=h(a.id)&&this.get(a.id)||this[b][c])&&c.coll===b&&c.update(a,!1)},this)},this);
	l&&n(this.axes,function(a){a.update({},!1)});p&&n(this.series,function(a){a.update({},!1)});a.loading&&H(!0,this.options.loading,a.loading);f=m&&m.width;m=m&&m.height;c(f)&&f!==this.chartWidth||c(m)&&m!==this.chartHeight?this.setSize(f,m):b(d,!0)&&this.redraw()},setSubtitle:function(a){this.setTitle(void 0,a)}});l(m.prototype,{update:function(a,c,d,e){function f(){h.applyOptions(a);null===h.y&&k&&(h.graphic=k.destroy());p(a,!0)&&(k&&k.element&&a&&a.marker&&a.marker.symbol&&(h.graphic=k.destroy()),
	a&&a.dataLabels&&h.dataLabel&&(h.dataLabel=h.dataLabel.destroy()));l=h.index;m.updateParallelArrays(h,l);n.data[l]=p(n.data[l],!0)||p(a,!0)?h.options:a;m.isDirty=m.isDirtyData=!0;!m.fixedBox&&m.hasCartesianSeries&&(g.isDirtyBox=!0);"point"===n.legendType&&(g.isDirtyLegend=!0);c&&g.redraw(d)}var h=this,m=h.series,k=h.graphic,l,g=m.chart,n=m.options;c=b(c,!0);!1===e?f():h.firePointEvent("update",{options:a},f)},remove:function(a,b){this.series.removePoint(e(this,this.series.data),a,b)}});l(d.prototype,
	{addPoint:function(a,c,d,e){var f=this.options,h=this.data,m=this.chart,k=this.xAxis,k=k&&k.hasNames&&k.names,l=f.data,g,p,n=this.xData,r,v;c=b(c,!0);g={series:this};this.pointClass.prototype.applyOptions.apply(g,[a]);v=g.x;r=n.length;if(this.requireSorting&&v<n[r-1])for(p=!0;r&&n[r-1]>v;)r--;this.updateParallelArrays(g,"splice",r,0,0);this.updateParallelArrays(g,r);k&&g.name&&(k[v]=g.name);l.splice(r,0,a);p&&(this.data.splice(r,0,null),this.processData());"point"===f.legendType&&this.generatePoints();
	d&&(h[0]&&h[0].remove?h[0].remove(!1):(h.shift(),this.updateParallelArrays(g,"shift"),l.shift()));this.isDirtyData=this.isDirty=!0;c&&m.redraw(e)},removePoint:function(a,c,d){var f=this,e=f.data,h=e[a],m=f.points,k=f.chart,l=function(){m&&m.length===e.length&&m.splice(a,1);e.splice(a,1);f.options.data.splice(a,1);f.updateParallelArrays(h||{series:f},"splice",a,1);h&&h.destroy();f.isDirty=!0;f.isDirtyData=!0;c&&k.redraw()};A(d,k);c=b(c,!0);h?h.firePointEvent("remove",null,l):l()},remove:function(a,
	c,d){function f(){e.destroy();h.isDirtyLegend=h.isDirtyBox=!0;h.linkSeries();b(a,!0)&&h.redraw(c)}var e=this,h=e.chart;!1!==d?k(e,"remove",null,f):f()},update:function(a,c){var d=this,f=this.chart,e=this.userOptions,h=this.oldType||this.type,m=a.type||e.type||f.options.chart.type,k=r[h].prototype,p=["group","markerGroup","dataLabelsGroup"],g;if(m&&m!==h||void 0!==a.zIndex)p.length=0;n(p,function(a){p[a]=d[a];delete d[a]});a=H(e,{animation:!1,index:this.index,pointStart:this.xData[0]},{data:this.options.data},
	a);this.remove(!1,null,!1);for(g in k)this[g]=void 0;l(this,r[m||h].prototype);n(p,function(a){d[a]=p[a]});this.init(f,a);this.oldType=h;f.linkSeries();b(c,!0)&&f.redraw(!1)}});l(C.prototype,{update:function(a,c){var d=this.chart;a=d.options[this.coll][this.options.index]=H(this.userOptions,a);this.destroy(!0);this.init(d,l(a,{events:void 0}));d.isDirtyBox=!0;b(c,!0)&&d.redraw()},remove:function(a){for(var c=this.chart,d=this.coll,f=this.series,e=f.length;e--;)f[e]&&f[e].remove(!1);t(c.axes,this);
	t(c[d],this);c.options[d].splice(this.options.index,1);n(c[d],function(a,b){a.options.index=b});this.destroy();c.isDirtyBox=!0;b(a,!0)&&c.redraw()},setTitle:function(a,b){this.update({title:a},b)},setCategories:function(a,b){this.update({categories:a},b)}})})(I);(function(a){var B=a.color,z=a.each,C=a.map,E=a.pick,u=a.Series,h=a.seriesType;h("area","line",{softThreshold:!1,threshold:0},{singleStacks:!1,getStackPoints:function(){var a=[],h=[],l=this.xAxis,k=this.yAxis,e=k.stacks[this.stackKey],c={},
	p=this.points,u=this.index,b=k.series,m=b.length,d,r=E(k.options.reversedStacks,!0)?1:-1,A,v;if(this.options.stacking){for(A=0;A<p.length;A++)c[p[A].x]=p[A];for(v in e)null!==e[v].total&&h.push(v);h.sort(function(a,b){return a-b});d=C(b,function(){return this.visible});z(h,function(b,p){var f=0,n,q;if(c[b]&&!c[b].isNull)a.push(c[b]),z([-1,1],function(a){var f=1===a?"rightNull":"leftNull",k=0,l=e[h[p+a]];if(l)for(A=u;0<=A&&A<m;)n=l.points[A],n||(A===u?c[b][f]=!0:d[A]&&(q=e[b].points[A])&&(k-=q[1]-
	q[0])),A+=r;c[b][1===a?"rightCliff":"leftCliff"]=k});else{for(A=u;0<=A&&A<m;){if(n=e[b].points[A]){f=n[1];break}A+=r}f=k.translate(f,0,1,0,1);a.push({isNull:!0,plotX:l.translate(b,0,0,0,1),x:b,plotY:f,yBottom:f})}})}return a},getGraphPath:function(a){var h=u.prototype.getGraphPath,l=this.options,k=l.stacking,e=this.yAxis,c,p,n=[],b=[],m=this.index,d,r=e.stacks[this.stackKey],A=l.threshold,v=e.getThreshold(l.threshold),f,l=l.connectNulls||"percent"===k,y=function(c,f,h){var l=a[c];c=k&&r[l.x].points[m];
	var p=l[h+"Null"]||0;h=l[h+"Cliff"]||0;var q,t,l=!0;h||p?(q=(p?c[0]:c[1])+h,t=c[0]+h,l=!!p):!k&&a[f]&&a[f].isNull&&(q=t=A);void 0!==q&&(b.push({plotX:d,plotY:null===q?v:e.getThreshold(q),isNull:l,isCliff:!0}),n.push({plotX:d,plotY:null===t?v:e.getThreshold(t),doCurve:!1}))};a=a||this.points;k&&(a=this.getStackPoints());for(c=0;c<a.length;c++)if(p=a[c].isNull,d=E(a[c].rectPlotX,a[c].plotX),f=E(a[c].yBottom,v),!p||l)l||y(c,c-1,"left"),p&&!k&&l||(b.push(a[c]),n.push({x:c,plotX:d,plotY:f})),l||y(c,c+
	1,"right");c=h.call(this,b,!0,!0);n.reversed=!0;p=h.call(this,n,!0,!0);p.length&&(p[0]="L");p=c.concat(p);h=h.call(this,b,!1,l);p.xMap=c.xMap;this.areaPath=p;return h},drawGraph:function(){this.areaPath=[];u.prototype.drawGraph.apply(this);var a=this,h=this.areaPath,l=this.options,k=[["area","highcharts-area",this.color,l.fillColor]];z(this.zones,function(e,c){k.push(["zone-area-"+c,"highcharts-area highcharts-zone-area-"+c+" "+e.className,e.color||a.color,e.fillColor||l.fillColor])});z(k,function(e){var c=
	e[0],k=a[c];k?(k.endX=h.xMap,k.animate({d:h})):(k=a[c]=a.chart.renderer.path(h).addClass(e[1]).attr({fill:E(e[3],B(e[2]).setOpacity(E(l.fillOpacity,.75)).get()),zIndex:0}).add(a.group),k.isArea=!0);k.startX=h.xMap;k.shiftUnit=l.step?2:1})},drawLegendSymbol:a.LegendSymbolMixin.drawRectangle})})(I);(function(a){var B=a.pick;a=a.seriesType;a("spline","line",{},{getPointSpline:function(a,C,E){var u=C.plotX,h=C.plotY,n=a[E-1];E=a[E+1];var t,l,k,e;if(n&&!n.isNull&&!1!==n.doCurve&&!C.isCliff&&E&&!E.isNull&&
	!1!==E.doCurve&&!C.isCliff){a=n.plotY;k=E.plotX;E=E.plotY;var c=0;t=(1.5*u+n.plotX)/2.5;l=(1.5*h+a)/2.5;k=(1.5*u+k)/2.5;e=(1.5*h+E)/2.5;k!==t&&(c=(e-l)*(k-u)/(k-t)+h-e);l+=c;e+=c;l>a&&l>h?(l=Math.max(a,h),e=2*h-l):l<a&&l<h&&(l=Math.min(a,h),e=2*h-l);e>E&&e>h?(e=Math.max(E,h),l=2*h-e):e<E&&e<h&&(e=Math.min(E,h),l=2*h-e);C.rightContX=k;C.rightContY=e}C=["C",B(n.rightContX,n.plotX),B(n.rightContY,n.plotY),B(t,u),B(l,h),u,h];n.rightContX=n.rightContY=null;return C}})})(I);(function(a){var B=a.seriesTypes.area.prototype,
	z=a.seriesType;z("areaspline","spline",a.defaultPlotOptions.area,{getStackPoints:B.getStackPoints,getGraphPath:B.getGraphPath,setStackCliffs:B.setStackCliffs,drawGraph:B.drawGraph,drawLegendSymbol:a.LegendSymbolMixin.drawRectangle})})(I);(function(a){var B=a.animObject,z=a.color,C=a.each,E=a.extend,u=a.isNumber,h=a.merge,n=a.pick,t=a.Series,l=a.seriesType,k=a.svg;l("column","line",{borderRadius:0,groupPadding:.2,marker:null,pointPadding:.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{halo:!1,
	brightness:.1,shadow:!1},select:{color:"#cccccc",borderColor:"#000000",shadow:!1}},dataLabels:{align:null,verticalAlign:null,y:null},softThreshold:!1,startFromThreshold:!0,stickyTracking:!1,tooltip:{distance:6},threshold:0,borderColor:"#ffffff"},{cropShoulder:0,directTouch:!0,trackerGroups:["group","dataLabelsGroup"],negStacks:!0,init:function(){t.prototype.init.apply(this,arguments);var a=this,c=a.chart;c.hasRendered&&C(c.series,function(c){c.type===a.type&&(c.isDirty=!0)})},getColumnMetrics:function(){var a=
	this,c=a.options,h=a.xAxis,k=a.yAxis,b=h.reversed,m,d={},l=0;!1===c.grouping?l=1:C(a.chart.series,function(b){var c=b.options,f=b.yAxis,e;b.type===a.type&&b.visible&&k.len===f.len&&k.pos===f.pos&&(c.stacking?(m=b.stackKey,void 0===d[m]&&(d[m]=l++),e=d[m]):!1!==c.grouping&&(e=l++),b.columnIndex=e)});var t=Math.min(Math.abs(h.transA)*(h.ordinalSlope||c.pointRange||h.closestPointRange||h.tickInterval||1),h.len),v=t*c.groupPadding,f=(t-2*v)/(l||1),c=Math.min(c.maxPointWidth||h.len,n(c.pointWidth,f*(1-
	2*c.pointPadding)));a.columnMetrics={width:c,offset:(f-c)/2+(v+((a.columnIndex||0)+(b?1:0))*f-t/2)*(b?-1:1)};return a.columnMetrics},crispCol:function(a,c,h,k){var b=this.chart,e=this.borderWidth,d=-(e%2?.5:0),e=e%2?.5:1;b.inverted&&b.renderer.isVML&&(e+=1);h=Math.round(a+h)+d;a=Math.round(a)+d;k=Math.round(c+k)+e;d=.5>=Math.abs(c)&&.5<k;c=Math.round(c)+e;k-=c;d&&k&&(--c,k+=1);return{x:a,y:c,width:h-a,height:k}},translate:function(){var a=this,c=a.chart,h=a.options,k=a.dense=2>a.closestPointRange*
	a.xAxis.transA,k=a.borderWidth=n(h.borderWidth,k?0:1),b=a.yAxis,m=a.translatedThreshold=b.getThreshold(h.threshold),d=n(h.minPointLength,5),l=a.getColumnMetrics(),u=l.width,v=a.barW=Math.max(u,1+2*k),f=a.pointXOffset=l.offset;c.inverted&&(m-=.5);h.pointPadding&&(v=Math.ceil(v));t.prototype.translate.apply(a);C(a.points,function(e){var h=n(e.yBottom,m),k=999+Math.abs(h),k=Math.min(Math.max(-k,e.plotY),b.len+k),l=e.plotX+f,p=v,r=Math.min(k,h),t,y=Math.max(k,h)-r;Math.abs(y)<d&&d&&(y=d,t=!b.reversed&&
	!e.negative||b.reversed&&e.negative,r=Math.abs(r-m)>d?h-d:m-(t?d:0));e.barX=l;e.pointWidth=u;e.tooltipPos=c.inverted?[b.len+b.pos-c.plotLeft-k,a.xAxis.len-l-p/2,y]:[l+p/2,k+b.pos-c.plotTop,y];e.shapeType="rect";e.shapeArgs=a.crispCol.apply(a,e.isNull?[e.plotX,b.len/2,0,0]:[l,r,p,y])})},getSymbol:a.noop,drawLegendSymbol:a.LegendSymbolMixin.drawRectangle,drawGraph:function(){this.group[this.dense?"addClass":"removeClass"]("highcharts-dense-data")},pointAttribs:function(a,c){var e=this.options,k,b=this.pointAttrToOptions||
	{};k=b.stroke||"borderColor";var m=b["stroke-width"]||"borderWidth",d=a&&a.color||this.color,l=a[k]||e[k]||this.color||d,n=a[m]||e[m]||this[m]||0,b=e.dashStyle;a&&this.zones.length&&(d=(d=a.getZone())&&d.color||a.options.color||this.color);c&&(a=h(e.states[c],a.options.states&&a.options.states[c]||{}),c=a.brightness,d=a.color||void 0!==c&&z(d).brighten(a.brightness).get()||d,l=a[k]||l,n=a[m]||n,b=a.dashStyle||b);k={fill:d,stroke:l,"stroke-width":n};e.borderRadius&&(k.r=e.borderRadius);b&&(k.dashstyle=
	b);return k},drawPoints:function(){var a=this,c=this.chart,k=a.options,l=c.renderer,b=k.animationLimit||250,m;C(a.points,function(d){var e=d.graphic;if(u(d.plotY)&&null!==d.y){m=d.shapeArgs;if(e)e[c.pointCount<b?"animate":"attr"](h(m));else d.graphic=e=l[d.shapeType](m).add(d.group||a.group);e.attr(a.pointAttribs(d,d.selected&&"select")).shadow(k.shadow,null,k.stacking&&!k.borderRadius);e.addClass(d.getClassName(),!0)}else e&&(d.graphic=e.destroy())})},animate:function(a){var c=this,e=this.yAxis,
	h=c.options,b=this.chart.inverted,m={};k&&(a?(m.scaleY=.001,a=Math.min(e.pos+e.len,Math.max(e.pos,e.toPixels(h.threshold))),b?m.translateX=a-e.len:m.translateY=a,c.group.attr(m)):(m[b?"translateX":"translateY"]=e.pos,c.group.animate(m,E(B(c.options.animation),{step:function(a,b){c.group.attr({scaleY:Math.max(.001,b.pos)})}})),c.animate=null))},remove:function(){var a=this,c=a.chart;c.hasRendered&&C(c.series,function(c){c.type===a.type&&(c.isDirty=!0)});t.prototype.remove.apply(a,arguments)}})})(I);
	(function(a){a=a.seriesType;a("bar","column",null,{inverted:!0})})(I);(function(a){var B=a.Series;a=a.seriesType;a("scatter","line",{lineWidth:0,marker:{enabled:!0},tooltip:{headerFormat:'\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e \x3cspan style\x3d"font-size: 0.85em"\x3e {series.name}\x3c/span\x3e\x3cbr/\x3e',pointFormat:"x: \x3cb\x3e{point.x}\x3c/b\x3e\x3cbr/\x3ey: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e"}},{sorted:!1,requireSorting:!1,noSharedTooltip:!0,trackerGroups:["group",
	"markerGroup","dataLabelsGroup"],takeOrdinalPosition:!1,kdDimensions:2,drawGraph:function(){this.options.lineWidth&&B.prototype.drawGraph.call(this)}})})(I);(function(a){var B=a.pick,z=a.relativeLength;a.CenteredSeriesMixin={getCenter:function(){var a=this.options,E=this.chart,u=2*(a.slicedOffset||0),h=E.plotWidth-2*u,E=E.plotHeight-2*u,n=a.center,n=[B(n[0],"50%"),B(n[1],"50%"),a.size||"100%",a.innerSize||0],t=Math.min(h,E),l,k;for(l=0;4>l;++l)k=n[l],a=2>l||2===l&&/%$/.test(k),n[l]=z(k,[h,E,t,n[2]][l])+
	(a?u:0);n[3]>n[2]&&(n[3]=n[2]);return n}}})(I);(function(a){var B=a.addEvent,z=a.defined,C=a.each,E=a.extend,u=a.inArray,h=a.noop,n=a.pick,t=a.Point,l=a.Series,k=a.seriesType,e=a.setAnimation;k("pie","line",{center:[null,null],clip:!1,colorByPoint:!0,dataLabels:{distance:30,enabled:!0,formatter:function(){return null===this.y?void 0:this.point.name},x:0},ignoreHiddenPoint:!0,legendType:"point",marker:null,size:null,showInLegend:!1,slicedOffset:10,stickyTracking:!1,tooltip:{followPointer:!0},borderColor:"#ffffff",
	borderWidth:1,states:{hover:{brightness:.1,shadow:!1}}},{isCartesian:!1,requireSorting:!1,directTouch:!0,noSharedTooltip:!0,trackerGroups:["group","dataLabelsGroup"],axisTypes:[],pointAttribs:a.seriesTypes.column.prototype.pointAttribs,animate:function(a){var c=this,e=c.points,b=c.startAngleRad;a||(C(e,function(a){var d=a.graphic,e=a.shapeArgs;d&&(d.attr({r:a.startR||c.center[3]/2,start:b,end:b}),d.animate({r:e.r,start:e.start,end:e.end},c.options.animation))}),c.animate=null)},updateTotals:function(){var a,
	e=0,h=this.points,b=h.length,k,d=this.options.ignoreHiddenPoint;for(a=0;a<b;a++)k=h[a],0>k.y&&(k.y=null),e+=d&&!k.visible?0:k.y;this.total=e;for(a=0;a<b;a++)k=h[a],k.percentage=0<e&&(k.visible||!d)?k.y/e*100:0,k.total=e},generatePoints:function(){l.prototype.generatePoints.call(this);this.updateTotals()},translate:function(a){this.generatePoints();var c=0,e=this.options,b=e.slicedOffset,h=b+(e.borderWidth||0),d,k,l,v=e.startAngle||0,f=this.startAngleRad=Math.PI/180*(v-90),v=(this.endAngleRad=Math.PI/
	180*(n(e.endAngle,v+360)-90))-f,t=this.points,u=e.dataLabels.distance,e=e.ignoreHiddenPoint,F,q=t.length,x;a||(this.center=a=this.getCenter());this.getX=function(b,c){l=Math.asin(Math.min((b-a[1])/(a[2]/2+u),1));return a[0]+(c?-1:1)*Math.cos(l)*(a[2]/2+u)};for(F=0;F<q;F++){x=t[F];d=f+c*v;if(!e||x.visible)c+=x.percentage/100;k=f+c*v;x.shapeType="arc";x.shapeArgs={x:a[0],y:a[1],r:a[2]/2,innerR:a[3]/2,start:Math.round(1E3*d)/1E3,end:Math.round(1E3*k)/1E3};l=(k+d)/2;l>1.5*Math.PI?l-=2*Math.PI:l<-Math.PI/
	2&&(l+=2*Math.PI);x.slicedTranslation={translateX:Math.round(Math.cos(l)*b),translateY:Math.round(Math.sin(l)*b)};d=Math.cos(l)*a[2]/2;k=Math.sin(l)*a[2]/2;x.tooltipPos=[a[0]+.7*d,a[1]+.7*k];x.half=l<-Math.PI/2||l>Math.PI/2?1:0;x.angle=l;h=Math.min(h,u/5);x.labelPos=[a[0]+d+Math.cos(l)*u,a[1]+k+Math.sin(l)*u,a[0]+d+Math.cos(l)*h,a[1]+k+Math.sin(l)*h,a[0]+d,a[1]+k,0>u?"center":x.half?"right":"left",l]}},drawGraph:null,drawPoints:function(){var a=this,e=a.chart.renderer,h,b,k,d,l=a.options.shadow;l&&
	!a.shadowGroup&&(a.shadowGroup=e.g("shadow").add(a.group));C(a.points,function(c){if(null!==c.y){b=c.graphic;d=c.shapeArgs;h=c.getTranslate();var m=c.shadowGroup;l&&!m&&(m=c.shadowGroup=e.g("shadow").add(a.shadowGroup));m&&m.attr(h);k=a.pointAttribs(c,c.selected&&"select");b?b.setRadialReference(a.center).attr(k).animate(E(d,h)):(c.graphic=b=e[c.shapeType](d).setRadialReference(a.center).attr(h).add(a.group),c.visible||b.attr({visibility:"hidden"}),b.attr(k).attr({"stroke-linejoin":"round"}).shadow(l,
	m));b.addClass(c.getClassName())}})},searchPoint:h,sortByAngle:function(a,e){a.sort(function(a,b){return void 0!==a.angle&&(b.angle-a.angle)*e})},drawLegendSymbol:a.LegendSymbolMixin.drawRectangle,getCenter:a.CenteredSeriesMixin.getCenter,getSymbol:h},{init:function(){t.prototype.init.apply(this,arguments);var a=this,e;a.name=n(a.name,"Slice");e=function(c){a.slice("select"===c.type)};B(a,"select",e);B(a,"unselect",e);return a},setVisible:function(a,e){var c=this,b=c.series,h=b.chart,d=b.options.ignoreHiddenPoint;
	e=n(e,d);a!==c.visible&&(c.visible=c.options.visible=a=void 0===a?!c.visible:a,b.options.data[u(c,b.data)]=c.options,C(["graphic","dataLabel","connector","shadowGroup"],function(b){if(c[b])c[b][a?"show":"hide"](!0)}),c.legendItem&&h.legend.colorizeItem(c,a),a||"hover"!==c.state||c.setState(""),d&&(b.isDirty=!0),e&&h.redraw())},slice:function(a,h,k){var b=this.series;e(k,b.chart);n(h,!0);this.sliced=this.options.sliced=z(a)?a:!this.sliced;b.options.data[u(this,b.data)]=this.options;this.graphic.animate(this.getTranslate());
	this.shadowGroup&&this.shadowGroup.animate(this.getTranslate())},getTranslate:function(){return this.sliced?this.slicedTranslation:{translateX:0,translateY:0}},haloPath:function(a){var c=this.shapeArgs;return this.sliced||!this.visible?[]:this.series.chart.renderer.symbols.arc(c.x,c.y,c.r+a,c.r+a,{innerR:this.shapeArgs.r,start:c.start,end:c.end})}})})(I);(function(a){var B=a.addEvent,z=a.arrayMax,C=a.defined,E=a.each,u=a.extend,h=a.format,n=a.map,t=a.merge,l=a.noop,k=a.pick,e=a.relativeLength,c=a.Series,
	p=a.seriesTypes,H=a.stableSort;a.distribute=function(a,c){function b(a,b){return a.target-b.target}var e,h=!0,k=a,f=[],l;l=0;for(e=a.length;e--;)l+=a[e].size;if(l>c){H(a,function(a,b){return(b.rank||0)-(a.rank||0)});for(l=e=0;l<=c;)l+=a[e].size,e++;f=a.splice(e-1,a.length)}H(a,b);for(a=n(a,function(a){return{size:a.size,targets:[a.target]}});h;){for(e=a.length;e--;)h=a[e],l=(Math.min.apply(0,h.targets)+Math.max.apply(0,h.targets))/2,h.pos=Math.min(Math.max(0,l-h.size/2),c-h.size);e=a.length;for(h=
	!1;e--;)0<e&&a[e-1].pos+a[e-1].size>a[e].pos&&(a[e-1].size+=a[e].size,a[e-1].targets=a[e-1].targets.concat(a[e].targets),a[e-1].pos+a[e-1].size>c&&(a[e-1].pos=c-a[e-1].size),a.splice(e,1),h=!0)}e=0;E(a,function(a){var b=0;E(a.targets,function(){k[e].pos=a.pos+b;b+=k[e].size;e++})});k.push.apply(k,f);H(k,b)};c.prototype.drawDataLabels=function(){var a=this,c=a.options,d=c.dataLabels,e=a.points,l,n,f=a.hasRendered||0,p,u,F=k(d.defer,!0),q=a.chart.renderer;if(d.enabled||a._hasPointLabels)a.dlProcessOptions&&
	a.dlProcessOptions(d),u=a.plotGroup("dataLabelsGroup","data-labels",F&&!f?"hidden":"visible",d.zIndex||6),F&&(u.attr({opacity:+f}),f||B(a,"afterAnimate",function(){a.visible&&u.show(!0);u[c.animation?"animate":"attr"]({opacity:1},{duration:200})})),n=d,E(e,function(b){var f,e=b.dataLabel,m,g,r,v=b.connector,y=!e,x;l=b.dlOptions||b.options&&b.options.dataLabels;if(f=k(l&&l.enabled,n.enabled)&&null!==b.y)for(g in d=t(n,l),m=b.getLabelConfig(),p=d.format?h(d.format,m):d.formatter.call(m,d),x=d.style,
	r=d.rotation,x.color=k(d.color,x.color,a.color,"#000000"),"contrast"===x.color&&(x.color=d.inside||0>d.distance||c.stacking?q.getContrast(b.color||a.color):"#000000"),c.cursor&&(x.cursor=c.cursor),m={fill:d.backgroundColor,stroke:d.borderColor,"stroke-width":d.borderWidth,r:d.borderRadius||0,rotation:r,padding:d.padding,zIndex:1},m)void 0===m[g]&&delete m[g];!e||f&&C(p)?f&&C(p)&&(e?m.text=p:(e=b.dataLabel=q[r?"text":"label"](p,0,-9999,d.shape,null,null,d.useHTML,null,"data-label"),e.addClass("highcharts-data-label-color-"+
	b.colorIndex+" "+(d.className||"")+(d.useHTML?"highcharts-tracker":""))),e.attr(m),e.css(x).shadow(d.shadow),e.added||e.add(u),a.alignDataLabel(b,e,d,null,y)):(b.dataLabel=e.destroy(),v&&(b.connector=v.destroy()))})};c.prototype.alignDataLabel=function(a,c,d,e,h){var b=this.chart,f=b.inverted,l=k(a.plotX,-9999),m=k(a.plotY,-9999),n=c.getBBox(),q,p=d.rotation,r=d.align,t=this.visible&&(a.series.forceDL||b.isInsidePlot(l,Math.round(m),f)||e&&b.isInsidePlot(l,f?e.x+1:e.y+e.height-1,f)),A="justify"===
	k(d.overflow,"justify");t&&(q=d.style.fontSize,q=b.renderer.fontMetrics(q,c).b,e=u({x:f?b.plotWidth-m:l,y:Math.round(f?b.plotHeight-l:m),width:0,height:0},e),u(d,{width:n.width,height:n.height}),p?(A=!1,f=b.renderer.rotCorr(q,p),f={x:e.x+d.x+e.width/2+f.x,y:e.y+d.y+{top:0,middle:.5,bottom:1}[d.verticalAlign]*e.height},c[h?"attr":"animate"](f).attr({align:r}),l=(p+720)%360,l=180<l&&360>l,"left"===r?f.y-=l?n.height:0:"center"===r?(f.x-=n.width/2,f.y-=n.height/2):"right"===r&&(f.x-=n.width,f.y-=l?0:
	n.height)):(c.align(d,null,e),f=c.alignAttr),A?this.justifyDataLabel(c,d,f,n,e,h):k(d.crop,!0)&&(t=b.isInsidePlot(f.x,f.y)&&b.isInsidePlot(f.x+n.width,f.y+n.height)),d.shape&&!p&&c.attr({anchorX:a.plotX,anchorY:a.plotY}));t||(c.attr({y:-9999}),c.placed=!1)};c.prototype.justifyDataLabel=function(a,c,d,e,h,k){var b=this.chart,l=c.align,m=c.verticalAlign,n,q,p=a.box?0:a.padding||0;n=d.x+p;0>n&&("right"===l?c.align="left":c.x=-n,q=!0);n=d.x+e.width-p;n>b.plotWidth&&("left"===l?c.align="right":c.x=b.plotWidth-
	n,q=!0);n=d.y+p;0>n&&("bottom"===m?c.verticalAlign="top":c.y=-n,q=!0);n=d.y+e.height-p;n>b.plotHeight&&("top"===m?c.verticalAlign="bottom":c.y=b.plotHeight-n,q=!0);q&&(a.placed=!k,a.align(c,null,h))};p.pie&&(p.pie.prototype.drawDataLabels=function(){var b=this,e=b.data,d,h=b.chart,l=b.options.dataLabels,p=k(l.connectorPadding,10),f=k(l.connectorWidth,1),t=h.plotWidth,u=h.plotHeight,F,q=l.distance,x=b.center,B=x[2]/2,C=x[1],H=0<q,g,D,I,M,R=[[],[]],N,w,O,Q,P=[0,0,0,0];b.visible&&(l.enabled||b._hasPointLabels)&&
	(E(e,function(a){a.dataLabel&&a.visible&&a.dataLabel.shortened&&(a.dataLabel.attr({width:"auto"}).css({width:"auto",textOverflow:"clip"}),a.dataLabel.shortened=!1)}),c.prototype.drawDataLabels.apply(b),E(e,function(a){a.dataLabel&&a.visible&&(R[a.half].push(a),a.dataLabel._pos=null)}),E(R,function(c,f){var e,k,m=c.length,r,v,y;if(m)for(b.sortByAngle(c,f-.5),0<q&&(e=Math.max(0,C-B-q),k=Math.min(C+B+q,h.plotHeight),r=n(c,function(a){if(a.dataLabel)return y=a.dataLabel.getBBox().height||21,{target:a.labelPos[1]-
	e+y/2,size:y,rank:a.y}}),a.distribute(r,k+y-e)),Q=0;Q<m;Q++)d=c[Q],I=d.labelPos,g=d.dataLabel,O=!1===d.visible?"hidden":"inherit",v=I[1],r?void 0===r[Q].pos?O="hidden":(M=r[Q].size,w=e+r[Q].pos):w=v,N=l.justify?x[0]+(f?-1:1)*(B+q):b.getX(w<e+2||w>k-2?v:w,f),g._attr={visibility:O,align:I[6]},g._pos={x:N+l.x+({left:p,right:-p}[I[6]]||0),y:w+l.y-10},I.x=N,I.y=w,null===b.options.size&&(D=g.getBBox().width,v=null,N-D<p?(v=Math.round(D-N+p),P[3]=Math.max(v,P[3])):N+D>t-p&&(v=Math.round(N+D-t+p),P[1]=Math.max(v,
	P[1])),0>w-M/2?P[0]=Math.max(Math.round(-w+M/2),P[0]):w+M/2>u&&(P[2]=Math.max(Math.round(w+M/2-u),P[2])),g.sideOverflow=v)}),0===z(P)||this.verifyDataLabelOverflow(P))&&(this.placeDataLabels(),H&&f&&E(this.points,function(a){var c;F=a.connector;if((g=a.dataLabel)&&g._pos&&a.visible){O=g._attr.visibility;if(c=!F)a.connector=F=h.renderer.path().addClass("highcharts-data-label-connector highcharts-color-"+a.colorIndex).add(b.dataLabelsGroup),F.attr({"stroke-width":f,stroke:l.connectorColor||a.color||
	"#666666"});F[c?"attr":"animate"]({d:b.connectorPath(a.labelPos)});F.attr("visibility",O)}else F&&(a.connector=F.destroy())}))},p.pie.prototype.connectorPath=function(a){var b=a.x,c=a.y;return k(this.options.dataLabels.softConnector,!0)?["M",b+("left"===a[6]?5:-5),c,"C",b,c,2*a[2]-a[4],2*a[3]-a[5],a[2],a[3],"L",a[4],a[5]]:["M",b+("left"===a[6]?5:-5),c,"L",a[2],a[3],"L",a[4],a[5]]},p.pie.prototype.placeDataLabels=function(){E(this.points,function(a){var b=a.dataLabel;b&&a.visible&&((a=b._pos)?(b.sideOverflow&&
	(b._attr.width=b.getBBox().width-b.sideOverflow,b.css({width:b._attr.width+"px",textOverflow:"ellipsis"}),b.shortened=!0),b.attr(b._attr),b[b.moved?"animate":"attr"](a),b.moved=!0):b&&b.attr({y:-9999}))},this)},p.pie.prototype.alignDataLabel=l,p.pie.prototype.verifyDataLabelOverflow=function(a){var b=this.center,c=this.options,h=c.center,k=c.minSize||80,l,f;null!==h[0]?l=Math.max(b[2]-Math.max(a[1],a[3]),k):(l=Math.max(b[2]-a[1]-a[3],k),b[0]+=(a[3]-a[1])/2);null!==h[1]?l=Math.max(Math.min(l,b[2]-
	Math.max(a[0],a[2])),k):(l=Math.max(Math.min(l,b[2]-a[0]-a[2]),k),b[1]+=(a[0]-a[2])/2);l<b[2]?(b[2]=l,b[3]=Math.min(e(c.innerSize||0,l),l),this.translate(b),this.drawDataLabels&&this.drawDataLabels()):f=!0;return f});p.column&&(p.column.prototype.alignDataLabel=function(a,e,d,h,l){var b=this.chart.inverted,f=a.series,m=a.dlBox||a.shapeArgs,n=k(a.below,a.plotY>k(this.translatedThreshold,f.yAxis.len)),p=k(d.inside,!!this.options.stacking);m&&(h=t(m),0>h.y&&(h.height+=h.y,h.y=0),m=h.y+h.height-f.yAxis.len,
	0<m&&(h.height-=m),b&&(h={x:f.yAxis.len-h.y-h.height,y:f.xAxis.len-h.x-h.width,width:h.height,height:h.width}),p||(b?(h.x+=n?0:h.width,h.width=0):(h.y+=n?h.height:0,h.height=0)));d.align=k(d.align,!b||p?"center":n?"right":"left");d.verticalAlign=k(d.verticalAlign,b||p?"middle":n?"top":"bottom");c.prototype.alignDataLabel.call(this,a,e,d,h,l)})})(I);(function(a){var B=a.Chart,z=a.each,C=a.pick,E=a.addEvent;B.prototype.callbacks.push(function(a){function h(){var h=[];z(a.series||[],function(a){var l=
	a.options.dataLabels,k=a.dataLabelCollections||["dataLabel"];(l.enabled||a._hasPointLabels)&&!l.allowOverlap&&a.visible&&z(k,function(e){z(a.points,function(a){a[e]&&(a[e].labelrank=C(a.labelrank,a.shapeArgs&&a.shapeArgs.height),h.push(a[e]))})})});a.hideOverlappingLabels(h)}h();E(a,"redraw",h)});B.prototype.hideOverlappingLabels=function(a){var h=a.length,n,t,l,k,e,c,p,u,b,m=function(a,b,c,e,f,h,k,l){return!(f>a+c||f+k<a||h>b+e||h+l<b)};for(t=0;t<h;t++)if(n=a[t])n.oldOpacity=n.opacity,n.newOpacity=
	1;a.sort(function(a,b){return(b.labelrank||0)-(a.labelrank||0)});for(t=0;t<h;t++)for(l=a[t],n=t+1;n<h;++n)if(k=a[n],l&&k&&l.placed&&k.placed&&0!==l.newOpacity&&0!==k.newOpacity&&(e=l.alignAttr,c=k.alignAttr,p=l.parentGroup,u=k.parentGroup,b=2*(l.box?0:l.padding),e=m(e.x+p.translateX,e.y+p.translateY,l.width-b,l.height-b,c.x+u.translateX,c.y+u.translateY,k.width-b,k.height-b)))(l.labelrank<k.labelrank?l:k).newOpacity=0;z(a,function(a){var b,c;a&&(c=a.newOpacity,a.oldOpacity!==c&&a.placed&&(c?a.show(!0):
	b=function(){a.hide()},a.alignAttr.opacity=c,a[a.isOld?"animate":"attr"](a.alignAttr,null,b)),a.isOld=!0)})}})(I);(function(a){var B=a.addEvent,z=a.Chart,C=a.createElement,E=a.css,u=a.defaultOptions,h=a.defaultPlotOptions,n=a.each,t=a.extend,l=a.fireEvent,k=a.hasTouch,e=a.inArray,c=a.isObject,p=a.Legend,H=a.merge,b=a.pick,m=a.Point,d=a.Series,r=a.seriesTypes,A=a.svg;a=a.TrackerMixin={drawTrackerPoint:function(){var a=this,b=a.chart.pointer,c=function(a){var c=b.getPointFromEvent(a);if(void 0!==c)c.onMouseOver(a)};
	n(a.points,function(a){a.graphic&&(a.graphic.element.point=a);a.dataLabel&&(a.dataLabel.div?a.dataLabel.div.point=a:a.dataLabel.element.point=a)});a._hasTracking||(n(a.trackerGroups,function(d){if(a[d]){a[d].addClass("highcharts-tracker").on("mouseover",c).on("mouseout",function(a){b.onTrackerMouseOut(a)});if(k)a[d].on("touchstart",c);a.options.cursor&&a[d].css(E).css({cursor:a.options.cursor})}}),a._hasTracking=!0)},drawTrackerGraph:function(){var a=this,b=a.options,c=b.trackByArea,d=[].concat(c?
	a.areaPath:a.graphPath),e=d.length,h=a.chart,l=h.pointer,m=h.renderer,p=h.options.tooltip.snap,t=a.tracker,g,r=function(){if(h.hoverSeries!==a)a.onMouseOver()},u="rgba(192,192,192,"+(A?.0001:.002)+")";if(e&&!c)for(g=e+1;g--;)"M"===d[g]&&d.splice(g+1,0,d[g+1]-p,d[g+2],"L"),(g&&"M"===d[g]||g===e)&&d.splice(g,0,"L",d[g-2]+p,d[g-1]);t?t.attr({d:d}):a.graph&&(a.tracker=m.path(d).attr({"stroke-linejoin":"round",visibility:a.visible?"visible":"hidden",stroke:u,fill:c?u:"none","stroke-width":a.graph.strokeWidth()+
	(c?0:2*p),zIndex:2}).add(a.group),n([a.tracker,a.markerGroup],function(a){a.addClass("highcharts-tracker").on("mouseover",r).on("mouseout",function(a){l.onTrackerMouseOut(a)});b.cursor&&a.css({cursor:b.cursor});if(k)a.on("touchstart",r)}))}};r.column&&(r.column.prototype.drawTracker=a.drawTrackerPoint);r.pie&&(r.pie.prototype.drawTracker=a.drawTrackerPoint);r.scatter&&(r.scatter.prototype.drawTracker=a.drawTrackerPoint);t(p.prototype,{setItemEvents:function(a,b,c){var d=this,e=d.chart.renderer.boxWrapper,
	f="highcharts-legend-"+(a.series?"point":"series")+"-active";(c?b:a.legendGroup).on("mouseover",function(){a.setState("hover");e.addClass(f);b.css(d.options.itemHoverStyle)}).on("mouseout",function(){b.css(a.visible?d.itemStyle:d.itemHiddenStyle);e.removeClass(f);a.setState()}).on("click",function(b){var c=function(){a.setVisible&&a.setVisible()};b={browserEvent:b};a.firePointEvent?a.firePointEvent("legendItemClick",b,c):l(a,"legendItemClick",b,c)})},createCheckboxForItem:function(a){a.checkbox=C("input",
	{type:"checkbox",checked:a.selected,defaultChecked:a.selected},this.options.itemCheckboxStyle,this.chart.container);B(a.checkbox,"click",function(b){l(a.series||a,"checkboxClick",{checked:b.target.checked,item:a},function(){a.select()})})}});u.legend.itemStyle.cursor="pointer";t(z.prototype,{showResetZoom:function(){var a=this,b=u.lang,c=a.options.chart.resetZoomButton,d=c.theme,e=d.states,h="chart"===c.relativeTo?null:"plotBox";this.resetZoomButton=a.renderer.button(b.resetZoom,null,null,function(){a.zoomOut()},
	d,e&&e.hover).attr({align:c.position.align,title:b.resetZoomTitle}).addClass("highcharts-reset-zoom").add().align(c.position,!1,h)},zoomOut:function(){var a=this;l(a,"selection",{resetSelection:!0},function(){a.zoom()})},zoom:function(a){var d,e=this.pointer,h=!1,k;!a||a.resetSelection?n(this.axes,function(a){d=a.zoom()}):n(a.xAxis.concat(a.yAxis),function(a){var b=a.axis;e[b.isXAxis?"zoomX":"zoomY"]&&(d=b.zoom(a.min,a.max),b.displayBtn&&(h=!0))});k=this.resetZoomButton;h&&!k?this.showResetZoom():
	!h&&c(k)&&(this.resetZoomButton=k.destroy());d&&this.redraw(b(this.options.chart.animation,a&&a.animation,100>this.pointCount))},pan:function(a,b){var c=this,d=c.hoverPoints,e;d&&n(d,function(a){a.setState()});n("xy"===b?[1,0]:[1],function(b){b=c[b?"xAxis":"yAxis"][0];var d=b.horiz,f=a[d?"chartX":"chartY"],d=d?"mouseDownX":"mouseDownY",h=c[d],k=(b.pointRange||0)/2,g=b.getExtremes(),l=b.toValue(h-f,!0)+k,k=b.toValue(h+b.len-f,!0)-k,m=k<l,h=m?k:l,l=m?l:k,m=b.toValue(b.toPixels(g.min)-b.minPixelPadding),
	k=b.toValue(b.toPixels(g.max)+b.minPixelPadding),m=Math.min(g.dataMin,m)-h,g=l-Math.max(g.dataMax,k);b.series.length&&0>m&&0>g&&(b.setExtremes(h,l,!1,!1,{trigger:"pan"}),e=!0);c[d]=f});e&&c.redraw(!1);E(c.container,{cursor:"move"})}});t(m.prototype,{select:function(a,c){var d=this,f=d.series,h=f.chart;a=b(a,!d.selected);d.firePointEvent(a?"select":"unselect",{accumulate:c},function(){d.selected=d.options.selected=a;f.options.data[e(d,f.data)]=d.options;d.setState(a&&"select");c||n(h.getSelectedPoints(),
	function(a){a.selected&&a!==d&&(a.selected=a.options.selected=!1,f.options.data[e(a,f.data)]=a.options,a.setState(""),a.firePointEvent("unselect"))})})},onMouseOver:function(a){var b=this.series.chart.pointer;this.firePointEvent("mouseOver");b.runPointActions(a,this)},onMouseOut:function(){var a=this.series.chart;this.firePointEvent("mouseOut");n(a.hoverPoints||[],function(a){a.setState()});a.hoverPoints=a.hoverPoint=null},importEvents:function(){if(!this.hasImportedEvents){var a=H(this.series.options.point,
	this.options).events,b;this.events=a;for(b in a)B(this,b,a[b]);this.hasImportedEvents=!0}},setState:function(a,c){var d=Math.floor(this.plotX),e=this.plotY,f=this.series,k=f.options.states[a]||{},l=h[f.type].marker&&f.options.marker,m=l&&!1===l.enabled,n=l&&l.states&&l.states[a]||{},p=!1===n.enabled,g=f.stateMarkerGraphic,r=this.marker||{},u=f.chart,v=f.halo,z,A=l&&f.markerAttribs;a=a||"";if(!(a===this.state&&!c||this.selected&&"select"!==a||!1===k.enabled||a&&(p||m&&!1===n.enabled)||a&&r.states&&
	r.states[a]&&!1===r.states[a].enabled)){A&&(z=f.markerAttribs(this,a));if(this.graphic)this.state&&this.graphic.removeClass("highcharts-point-"+this.state),a&&this.graphic.addClass("highcharts-point-"+a),this.graphic.attr(f.pointAttribs(this,a)),z&&this.graphic.animate(z,b(u.options.chart.animation,n.animation,l.animation)),g&&g.hide();else{if(a&&n){l=r.symbol||f.symbol;g&&g.currentSymbol!==l&&(g=g.destroy());if(g)g[c?"animate":"attr"]({x:z.x,y:z.y});else l&&(f.stateMarkerGraphic=g=u.renderer.symbol(l,
	z.x,z.y,z.width,z.height).add(f.markerGroup),g.currentSymbol=l);g&&g.attr(f.pointAttribs(this,a))}g&&(g[a&&u.isInsidePlot(d,e,u.inverted)?"show":"hide"](),g.element.point=this)}(d=k.halo)&&d.size?(v||(f.halo=v=u.renderer.path().add(A?f.markerGroup:f.group)),v[c?"animate":"attr"]({d:this.haloPath(d.size)}),v.attr({"class":"highcharts-halo highcharts-color-"+b(this.colorIndex,f.colorIndex)}),v.point=this,v.attr(t({fill:this.color||f.color,"fill-opacity":d.opacity,zIndex:-1},d.attributes))):v&&v.point&&
	v.point.haloPath&&v.animate({d:v.point.haloPath(0)});this.state=a}},haloPath:function(a){return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX)-a,this.plotY-a,2*a,2*a)}});t(d.prototype,{onMouseOver:function(){var a=this.chart,b=a.hoverSeries;if(b&&b!==this)b.onMouseOut();this.options.events.mouseOver&&l(this,"mouseOver");this.setState("hover");a.hoverSeries=this},onMouseOut:function(){var a=this.options,b=this.chart,c=b.tooltip,d=b.hoverPoint;b.hoverSeries=null;if(d)d.onMouseOut();
	this&&a.events.mouseOut&&l(this,"mouseOut");!c||a.stickyTracking||c.shared&&!this.noSharedTooltip||c.hide();this.setState()},setState:function(a){var c=this,d=c.options,e=c.graph,h=d.states,k=d.lineWidth,d=0;a=a||"";if(c.state!==a&&(n([c.group,c.markerGroup,c.dataLabelsGroup],function(b){b&&(c.state&&b.removeClass("highcharts-series-"+c.state),a&&b.addClass("highcharts-series-"+a))}),c.state=a,!h[a]||!1!==h[a].enabled)&&(a&&(k=h[a].lineWidth||k+(h[a].lineWidthPlus||0)),e&&!e.dashstyle))for(k={"stroke-width":k},
	e.animate(k,b(c.chart.options.chart.animation,h[a]&&h[a].animation));c["zone-graph-"+d];)c["zone-graph-"+d].attr(k),d+=1},setVisible:function(a,b){var c=this,d=c.chart,e=c.legendItem,f,h=d.options.chart.ignoreHiddenSeries,k=c.visible;f=(c.visible=a=c.options.visible=c.userOptions.visible=void 0===a?!k:a)?"show":"hide";n(["group","dataLabelsGroup","markerGroup","tracker","tt"],function(a){if(c[a])c[a][f]()});if(d.hoverSeries===c||(d.hoverPoint&&d.hoverPoint.series)===c)c.onMouseOut();e&&d.legend.colorizeItem(c,
	a);c.isDirty=!0;c.options.stacking&&n(d.series,function(a){a.options.stacking&&a.visible&&(a.isDirty=!0)});n(c.linkedSeries,function(b){b.setVisible(a,!1)});h&&(d.isDirtyBox=!0);!1!==b&&d.redraw();l(c,f)},show:function(){this.setVisible(!0)},hide:function(){this.setVisible(!1)},select:function(a){this.selected=a=void 0===a?!this.selected:a;this.checkbox&&(this.checkbox.checked=a);l(this,a?"select":"unselect")},drawTracker:a.drawTrackerGraph})})(I);(function(a){var B=a.Chart,z=a.each,C=a.inArray,E=
	a.isArray,u=a.isObject,h=a.pick,n=a.splat;B.prototype.setResponsive=function(h){var l=this.options.responsive,k=[],e=this.currentResponsive;l&&l.rules&&z(l.rules,function(c){void 0===c._id&&(c._id=a.uniqueKey());this.matchResponsiveRule(c,k,h)},this);var c=a.merge.apply(0,a.map(k,function(c){return a.find(l.rules,function(a){return a._id===c}).chartOptions})),k=k.toString()||void 0;k!==(e&&e.ruleIds)&&(e&&this.update(e.undoOptions,h),k?(this.currentResponsive={ruleIds:k,mergedOptions:c,undoOptions:this.currentOptions(c)},
	this.update(c,h)):this.currentResponsive=void 0)};B.prototype.matchResponsiveRule=function(a,l){var k=a.condition;(k.callback||function(){return this.chartWidth<=h(k.maxWidth,Number.MAX_VALUE)&&this.chartHeight<=h(k.maxHeight,Number.MAX_VALUE)&&this.chartWidth>=h(k.minWidth,0)&&this.chartHeight>=h(k.minHeight,0)}).call(this)&&l.push(a._id)};B.prototype.currentOptions=function(a){function h(a,c,k,l){var b,e;for(b in a)if(!l&&-1<C(b,["series","xAxis","yAxis"]))for(a[b]=n(a[b]),k[b]=[],e=0;e<a[b].length;e++)c[b][e]&&
	(k[b][e]={},h(a[b][e],c[b][e],k[b][e],l+1));else u(a[b])?(k[b]=E(a[b])?[]:{},h(a[b],c[b]||{},k[b],l+1)):k[b]=c[b]||null}var k={};h(a,this.options,k,0);return k}})(I);return I});


/***/ },
/* 454 */
/***/ function(module, exports) {

	/*
	 Highcharts JS v5.0.9 (2017-03-08)
	 Exporting module

	 (c) 2010-2016 Torstein Honsi

	 License: www.highcharts.com/license
	*/
	(function(h){"object"===typeof module&&module.exports?module.exports=h:h(Highcharts)})(function(h){(function(f){var h=f.defaultOptions,n=f.doc,A=f.Chart,u=f.addEvent,F=f.removeEvent,D=f.fireEvent,q=f.createElement,B=f.discardElement,v=f.css,p=f.merge,C=f.pick,k=f.each,r=f.extend,G=f.isTouchDevice,E=f.win,H=f.Renderer.prototype.symbols;r(h.lang,{printChart:"Print chart",downloadPNG:"Download PNG image",downloadJPEG:"Download JPEG image",downloadPDF:"Download PDF document",downloadSVG:"Download SVG vector image",
	contextButtonTitle:"Chart context menu"});h.navigation={buttonOptions:{theme:{},symbolSize:14,symbolX:12.5,symbolY:10.5,align:"right",buttonSpacing:3,height:22,verticalAlign:"top",width:24}};p(!0,h.navigation,{menuStyle:{border:"1px solid #999999",background:"#ffffff",padding:"5px 0"},menuItemStyle:{padding:"0.5em 1em",background:"none",color:"#333333",fontSize:G?"14px":"11px",transition:"background 250ms, color 250ms"},menuItemHoverStyle:{background:"#335cad",color:"#ffffff"},buttonOptions:{symbolFill:"#666666",
	symbolStroke:"#666666",symbolStrokeWidth:3,theme:{fill:"#ffffff",stroke:"none",padding:5}}});h.exporting={type:"image/png",url:"https://export.highcharts.com/",printMaxWidth:780,scale:2,buttons:{contextButton:{className:"highcharts-contextbutton",menuClassName:"highcharts-contextmenu",symbol:"menu",_titleKey:"contextButtonTitle",menuItems:[{textKey:"printChart",onclick:function(){this.print()}},{separator:!0},{textKey:"downloadPNG",onclick:function(){this.exportChart()}},{textKey:"downloadJPEG",onclick:function(){this.exportChart({type:"image/jpeg"})}},
	{textKey:"downloadPDF",onclick:function(){this.exportChart({type:"application/pdf"})}},{textKey:"downloadSVG",onclick:function(){this.exportChart({type:"image/svg+xml"})}}]}}};f.post=function(a,c,e){var b;a=q("form",p({method:"post",action:a,enctype:"multipart/form-data"},e),{display:"none"},n.body);for(b in c)q("input",{type:"hidden",name:b,value:c[b]},null,a);a.submit();B(a)};r(A.prototype,{sanitizeSVG:function(a,c){if(c&&c.exporting&&c.exporting.allowHTML){var e=a.match(/<\/svg>(.*?$)/);e&&(e=
	'\x3cforeignObject x\x3d"0" y\x3d"0" width\x3d"'+c.chart.width+'" height\x3d"'+c.chart.height+'"\x3e\x3cbody xmlns\x3d"http://www.w3.org/1999/xhtml"\x3e'+e[1]+"\x3c/body\x3e\x3c/foreignObject\x3e",a=a.replace("\x3c/svg\x3e",e+"\x3c/svg\x3e"))}a=a.replace(/zIndex="[^"]+"/g,"").replace(/isShadow="[^"]+"/g,"").replace(/symbolName="[^"]+"/g,"").replace(/jQuery[0-9]+="[^"]+"/g,"").replace(/url\(("|&quot;)(\S+)("|&quot;)\)/g,"url($2)").replace(/url\([^#]+#/g,"url(#").replace(/<svg /,'\x3csvg xmlns:xlink\x3d"http://www.w3.org/1999/xlink" ').replace(/ (NS[0-9]+\:)?href=/g,
	" xlink:href\x3d").replace(/\n/," ").replace(/<\/svg>.*?$/,"\x3c/svg\x3e").replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g,'$1\x3d"rgb($2)" $1-opacity\x3d"$3"').replace(/&nbsp;/g,"\u00a0").replace(/&shy;/g,"\u00ad");return a=a.replace(/<IMG /g,"\x3cimage ").replace(/<(\/?)TITLE>/g,"\x3c$1title\x3e").replace(/height=([^" ]+)/g,'height\x3d"$1"').replace(/width=([^" ]+)/g,'width\x3d"$1"').replace(/hc-svg-href="([^"]+)">/g,'xlink:href\x3d"$1"/\x3e').replace(/ id=([^" >]+)/g,' id\x3d"$1"').replace(/class=([^" >]+)/g,
	'class\x3d"$1"').replace(/ transform /g," ").replace(/:(path|rect)/g,"$1").replace(/style="([^"]+)"/g,function(a){return a.toLowerCase()})},getChartHTML:function(){return this.container.innerHTML},getSVG:function(a){var c,e,b,w,m,g=p(this.options,a);n.createElementNS||(n.createElementNS=function(a,c){return n.createElement(c)});e=q("div",null,{position:"absolute",top:"-9999em",width:this.chartWidth+"px",height:this.chartHeight+"px"},n.body);b=this.renderTo.style.width;m=this.renderTo.style.height;
	b=g.exporting.sourceWidth||g.chart.width||/px$/.test(b)&&parseInt(b,10)||600;m=g.exporting.sourceHeight||g.chart.height||/px$/.test(m)&&parseInt(m,10)||400;r(g.chart,{animation:!1,renderTo:e,forExport:!0,renderer:"SVGRenderer",width:b,height:m});g.exporting.enabled=!1;delete g.data;g.series=[];k(this.series,function(a){w=p(a.userOptions,{animation:!1,enableMouseTracking:!1,showCheckbox:!1,visible:a.visible});w.isInternal||g.series.push(w)});k(this.axes,function(a){a.userOptions.internalKey=f.uniqueKey()});
	c=new f.Chart(g,this.callback);a&&k(["xAxis","yAxis","series"],function(b){var d={};a[b]&&(d[b]=a[b],c.update(d))});k(this.axes,function(a){var b=f.find(c.axes,function(b){return b.options.internalKey===a.userOptions.internalKey}),d=a.getExtremes(),e=d.userMin,d=d.userMax;!b||void 0===e&&void 0===d||b.setExtremes(e,d,!0,!1)});b=c.getChartHTML();b=this.sanitizeSVG(b,g);g=null;c.destroy();B(e);return b},getSVGForExport:function(a,c){var e=this.options.exporting;return this.getSVG(p({chart:{borderRadius:0}},
	e.chartOptions,c,{exporting:{sourceWidth:a&&a.sourceWidth||e.sourceWidth,sourceHeight:a&&a.sourceHeight||e.sourceHeight}}))},exportChart:function(a,c){c=this.getSVGForExport(a,c);a=p(this.options.exporting,a);f.post(a.url,{filename:a.filename||"chart",type:a.type,width:a.width||0,scale:a.scale,svg:c},a.formAttributes)},print:function(){var a=this,c=a.container,e=[],b=c.parentNode,f=n.body,m=f.childNodes,g=a.options.exporting.printMaxWidth,d,t;if(!a.isPrinting){a.isPrinting=!0;a.pointer.reset(null,
	0);D(a,"beforePrint");if(t=g&&a.chartWidth>g)d=[a.options.chart.width,void 0,!1],a.setSize(g,void 0,!1);k(m,function(a,b){1===a.nodeType&&(e[b]=a.style.display,a.style.display="none")});f.appendChild(c);E.focus();E.print();setTimeout(function(){b.appendChild(c);k(m,function(a,b){1===a.nodeType&&(a.style.display=e[b])});a.isPrinting=!1;t&&a.setSize.apply(a,d);D(a,"afterPrint")},1E3)}},contextMenu:function(a,c,e,b,f,m,g){var d=this,t=d.options.navigation,w=d.chartWidth,h=d.chartHeight,p="cache-"+a,
	l=d[p],x=Math.max(f,m),y,z;l||(d[p]=l=q("div",{className:a},{position:"absolute",zIndex:1E3,padding:x+"px"},d.container),y=q("div",{className:"highcharts-menu"},null,l),v(y,r({MozBoxShadow:"3px 3px 10px #888",WebkitBoxShadow:"3px 3px 10px #888",boxShadow:"3px 3px 10px #888"},t.menuStyle)),z=function(){v(l,{display:"none"});g&&g.setState(0);d.openMenu=!1},u(l,"mouseleave",function(){l.hideTimer=setTimeout(z,500)}),u(l,"mouseenter",function(){clearTimeout(l.hideTimer)}),p=u(n,"mouseup",function(b){d.pointer.inClass(b.target,
	a)||z()}),u(d,"destroy",p),k(c,function(a){if(a){var b;a.separator?b=q("hr",null,null,y):(b=q("div",{className:"highcharts-menu-item",onclick:function(b){b&&b.stopPropagation();z();a.onclick&&a.onclick.apply(d,arguments)},innerHTML:a.text||d.options.lang[a.textKey]},null,y),b.onmouseover=function(){v(this,t.menuItemHoverStyle)},b.onmouseout=function(){v(this,t.menuItemStyle)},v(b,r({cursor:"pointer"},t.menuItemStyle)));d.exportDivElements.push(b)}}),d.exportDivElements.push(y,l),d.exportMenuWidth=
	l.offsetWidth,d.exportMenuHeight=l.offsetHeight);c={display:"block"};e+d.exportMenuWidth>w?c.right=w-e-f-x+"px":c.left=e-x+"px";b+m+d.exportMenuHeight>h&&"top"!==g.alignOptions.verticalAlign?c.bottom=h-b-x+"px":c.top=b+m-x+"px";v(l,c);d.openMenu=!0},addButton:function(a){var c=this,e=c.renderer,b=p(c.options.navigation.buttonOptions,a),f=b.onclick,m=b.menuItems,g,d,h=b.symbolSize||12;c.btnCount||(c.btnCount=0);c.exportDivElements||(c.exportDivElements=[],c.exportSVGElements=[]);if(!1!==b.enabled){var k=
	b.theme,n=k.states,q=n&&n.hover,n=n&&n.select,l;delete k.states;f?l=function(a){a.stopPropagation();f.call(c,a)}:m&&(l=function(){c.contextMenu(d.menuClassName,m,d.translateX,d.translateY,d.width,d.height,d);d.setState(2)});b.text&&b.symbol?k.paddingLeft=C(k.paddingLeft,25):b.text||r(k,{width:b.width,height:b.height,padding:0});d=e.button(b.text,0,0,l,k,q,n).addClass(a.className).attr({"stroke-linecap":"round",title:c.options.lang[b._titleKey],zIndex:3});d.menuClassName=a.menuClassName||"highcharts-menu-"+
	c.btnCount++;b.symbol&&(g=e.symbol(b.symbol,b.symbolX-h/2,b.symbolY-h/2,h,h).addClass("highcharts-button-symbol").attr({zIndex:1}).add(d),g.attr({stroke:b.symbolStroke,fill:b.symbolFill,"stroke-width":b.symbolStrokeWidth||1}));d.add().align(r(b,{width:d.width,x:C(b.x,c.buttonOffset)}),!0,"spacingBox");c.buttonOffset+=(d.width+b.buttonSpacing)*("right"===b.align?-1:1);c.exportSVGElements.push(d,g)}},destroyExport:function(a){var c=a?a.target:this;a=c.exportSVGElements;var e=c.exportDivElements;a&&
	(k(a,function(a,e){a&&(a.onclick=a.ontouchstart=null,c.exportSVGElements[e]=a.destroy())}),a.length=0);e&&(k(e,function(a,e){clearTimeout(a.hideTimer);F(a,"mouseleave");c.exportDivElements[e]=a.onmouseout=a.onmouseover=a.ontouchstart=a.onclick=null;B(a)}),e.length=0)}});H.menu=function(a,c,e,b){return["M",a,c+2.5,"L",a+e,c+2.5,"M",a,c+b/2+.5,"L",a+e,c+b/2+.5,"M",a,c+b-1.5,"L",a+e,c+b-1.5]};A.prototype.renderExporting=function(){var a,c=this.options.exporting,e=c.buttons,b=this.isDirtyExporting||!this.exportSVGElements;
	this.buttonOffset=0;this.isDirtyExporting&&this.destroyExport();if(b&&!1!==c.enabled){for(a in e)this.addButton(e[a]);this.isDirtyExporting=!1}u(this,"destroy",this.destroyExport)};A.prototype.callbacks.push(function(a){a.renderExporting();u(a,"redraw",a.renderExporting);k(["exporting","navigation"],function(c){a[c]={update:function(e,b){a.isDirtyExporting=!0;p(!0,a.options[c],e);C(b,!0)&&a.redraw()}}})})})(h)});


/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Contract_Beta = __webpack_require__(451);
	var TickDisplay_Beta = __webpack_require__(456);
	var commonTrading = __webpack_require__(445);
	var Symbols = __webpack_require__(447);
	var Tick = __webpack_require__(448);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var elementInnerHtml = __webpack_require__(430).elementInnerHtml;
	var elementTextContent = __webpack_require__(430).elementTextContent;
	var isVisible = __webpack_require__(430).isVisible;
	var formatMoney = __webpack_require__(433).formatMoney;
	var toTitleCase = __webpack_require__(449).toTitleCase;

	/*
	 * Purchase object that handles all the functions related to
	 * contract purchase response
	 */

	var Purchase_Beta = function () {
	    'use strict';

	    var purchase_data = {};

	    var display = function display(details) {
	        purchase_data = details;

	        var receipt = details.buy;
	        var passthrough = details.echo_req.passthrough;
	        var container = document.getElementById('contract_confirmation_container');
	        var message_container = document.getElementById('confirmation_message');
	        var heading = document.getElementById('contract_purchase_heading');
	        var descr = document.getElementById('contract_purchase_descr');
	        var barrier_element = document.getElementById('contract_purchase_barrier');
	        var chart = document.getElementById('tick_chart');
	        var brief = document.getElementById('contract_purchase_brief');
	        var balance = document.getElementById('contract_purchase_balance');
	        var payout = document.getElementById('contract_purchase_payout');
	        var cost = document.getElementById('contract_purchase_cost');
	        var spots = document.getElementById('contract_purchase_spots');
	        var confirmation_error = document.getElementById('confirmation_error');
	        var confirmation_error_contents = document.getElementById('confirmation_error_contents');
	        var contracts_list = document.getElementById('contracts_list');
	        var button = document.getElementById('contract_purchase_button');

	        var error = details.error;
	        var show_chart = !error && passthrough.duration <= 10 && passthrough.duration_unit === 't' && (sessionStorage.formname === 'risefall' || sessionStorage.formname === 'higherlower' || sessionStorage.formname === 'asian');

	        contracts_list.style.display = 'none';

	        if (error) {
	            container.style.display = 'block';
	            message_container.hide();
	            confirmation_error.show();
	            elementInnerHtml(confirmation_error_contents, error.message);
	        } else {
	            var guide_btn = document.getElementById('guideBtn');
	            if (guide_btn) {
	                guide_btn.style.display = 'none';
	            }
	            container.style.display = 'block';
	            message_container.show();
	            confirmation_error.hide();

	            $('#contract-values').find('td').each(function () {
	                $(this).text('').removeAttr('class', '');
	            });
	            var purchase_passthrough = purchase_data.echo_req.passthrough;
	            elementTextContent(brief, $('#underlying').find('option:selected').text() + ' / ' + toTitleCase(Contract_Beta.contractType()[Contract_Beta.form()][purchase_passthrough.contract_type]) + (Contract_Beta.form() === 'digits' && !/(even|odd)/i.test(purchase_passthrough.contract_type) ? ' ' + purchase_passthrough.barrier : ''));

	            elementTextContent(heading, localize('Contract Confirmation'));
	            elementTextContent(descr, receipt.longcode);
	            if (barrier_element) commonTrading.labelValue(barrier_element, '', '', true);
	            [].forEach.call(document.getElementsByClassName('contract_purchase_reference'), function (ref) {
	                elementTextContent(ref, localize('Ref.') + ' ' + receipt.transaction_id);
	            });

	            var payout_value = void 0,
	                cost_value = void 0;

	            if (passthrough.basis === 'payout') {
	                payout_value = passthrough.amount;
	                cost_value = passthrough['ask-price'];
	            } else {
	                cost_value = passthrough.amount;
	                payout_value = receipt.payout;
	            }

	            chart.hide();
	            spots.hide();

	            var currency = Client.get('currency');

	            commonTrading.labelValue(payout, localize('Payout'), formatMoney(currency, payout_value, 1));
	            commonTrading.labelValue(cost, localize('Stake'), formatMoney(currency, cost_value, 1));

	            elementTextContent(balance, localize('Account balance:') + ' ' + formatMoney(currency, receipt.balance_after));

	            if (show_chart) {
	                chart.show();
	            }

	            if (Contract_Beta.form() === 'digits') {
	                [].forEach.call(spots.childNodes, function (child) {
	                    elementInnerHtml(child, '&nbsp;');
	                });
	                spots.show();
	            }

	            if (Contract_Beta.form() !== 'digits' && !show_chart) {
	                button.setAttribute('contract_id', receipt.contract_id);
	                descr.show();
	                button.show();
	                $('#confirmation_message').find('.open_contract_details').attr('contract_id', receipt.contract_id).setVisibility(1);
	            } else {
	                descr.hide();
	                button.hide();
	                $('#confirmation_message').find('.open_contract_details').setVisibility(0);
	            }
	        }

	        if (show_chart) {
	            var contract_sentiment = void 0;
	            if (passthrough.contract_type === 'CALL' || passthrough.contract_type === 'ASIANU') {
	                contract_sentiment = 'up';
	            } else {
	                contract_sentiment = 'down';
	            }

	            // calculate number of decimals needed to display tick-chart according to the spot
	            // value of the underlying
	            var decimal_points = 2;
	            var tick_spots = Tick.spots();
	            var tick_spot_epochs = Object.keys(tick_spots);
	            if (tick_spot_epochs.length > 0) {
	                var last_quote = tick_spots[tick_spot_epochs[0]].toString();

	                if (last_quote.indexOf('.') !== -1) {
	                    decimal_points = last_quote.split('.')[1].length;
	                }
	            }

	            var barrier = void 0;
	            if (sessionStorage.getItem('formname') === 'higherlower') {
	                barrier = passthrough.barrier;
	            }

	            TickDisplay_Beta.init({
	                symbol: passthrough.symbol,
	                barrier: barrier,
	                number_of_ticks: passthrough.duration,
	                previous_tick_epoch: receipt.start_time,
	                contract_category: sessionStorage.getItem('formname') === 'asian' ? 'asian' : 'callput',
	                display_symbol: Symbols.getName(passthrough.symbol),
	                contract_start: receipt.start_time,
	                display_decimals: decimal_points,
	                contract_sentiment: contract_sentiment,
	                price: passthrough['ask-price'],
	                payout: receipt.payout,
	                show_contract_result: 1,
	                width: $('#tick_chart').width(),
	                is_trading_page: true
	            });
	            TickDisplay_Beta.resetSpots();
	        }
	    };

	    var updateSpotList = function updateSpotList() {
	        if ($('#contract_purchase_spots:hidden').length) {
	            return;
	        }

	        var duration = purchase_data.echo_req && purchase_data.echo_req.passthrough ? purchase_data.echo_req.passthrough.duration : null;

	        if (!duration) {
	            return;
	        }

	        var container = document.getElementById('contract_purchase_spots');
	        var tick_elem = document.getElementById('current_tick_number');
	        var spot_elem = document.getElementById('current_tick_spot');
	        var list_elem = document.getElementById('last_digits_list');
	        if (container) {
	            tick_elem.innerHTML = spot_elem.innerHTML = list_elem.innerHTML = '&nbsp;';
	        }
	        for (var i = 1; i <= duration; i++) {
	            var fragment = document.createElement('div');
	            fragment.classList.add('gr-grow');

	            var digit_elem = document.createElement('div');
	            digit_elem.classList.add('digit');
	            digit_elem.id = 'tick_digit_' + i;
	            elementInnerHtml(digit_elem, '&nbsp;');
	            fragment.appendChild(digit_elem);

	            var number_elem = document.createElement('div');
	            number_elem.classList.add('number');
	            elementInnerHtml(number_elem, i);
	            fragment.appendChild(number_elem);

	            list_elem.appendChild(fragment);
	        }

	        var spots2 = Tick.spots();
	        var epoches = Object.keys(spots2).sort(function (a, b) {
	            return a - b;
	        });
	        var tick_number = 0;

	        var is_win = function is_win(last_digit) {
	            var contract_type = purchase_data.echo_req.passthrough.contract_type;
	            var barrier = purchase_data.echo_req.passthrough.barrier;
	            return contract_type === 'DIGITMATCH' && last_digit === barrier || contract_type === 'DIGITDIFF' && last_digit !== barrier || contract_type === 'DIGITEVEN' && last_digit % 2 === 0 || contract_type === 'DIGITODD' && last_digit % 2 || contract_type === 'DIGITOVER' && last_digit > barrier || contract_type === 'DIGITUNDER' && last_digit < barrier;
	        };
	        var last_digit = null;
	        var replace = function replace(d) {
	            last_digit = d;
	            return '<span class="' + (is_win(d) ? 'profit' : 'loss') + '">' + d + '</span>';
	        };
	        for (var s = 0; s < epoches.length; s++) {
	            var tick_d = {
	                epoch: epoches[s],
	                quote: spots2[epoches[s]]
	            };

	            if (isVisible(container) && tick_d.epoch && tick_d.epoch > purchase_data.buy.start_time) {
	                tick_number++;

	                elementTextContent(tick_elem, localize('Tick') + ' ' + tick_number);
	                elementInnerHtml(spot_elem, tick_d.quote.replace(/\d$/, replace));

	                var this_digit_elem = document.getElementById('tick_digit_' + tick_number);
	                this_digit_elem.classList.add(is_win(last_digit) ? 'profit' : 'loss');
	                elementTextContent(this_digit_elem, last_digit);

	                if (last_digit && duration === 1) {
	                    var contract_status = void 0,
	                        final_price = void 0,
	                        pnl = void 0;

	                    if (is_win(last_digit)) {
	                        final_price = $('#contract_purchase_payout_value').attr('value');
	                        pnl = $('#contract_purchase_cost_value').attr('value');
	                        contract_status = localize('This contract won');
	                    } else {
	                        final_price = 0;
	                        pnl = -$('#contract_purchase_cost_value').attr('value');
	                        contract_status = localize('This contract lost');
	                    }

	                    commonTrading.updatePurchaseStatus_Beta(final_price, pnl, contract_status);
	                }

	                duration--;
	                if (!duration) {
	                    purchase_data.echo_req.passthrough.duration = 0;
	                }
	            }
	        }
	    };

	    return {
	        display: display,
	        updateSpotList: updateSpotList
	    };
	}();

	module.exports = Purchase_Beta;

/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Highcharts = __webpack_require__(453);
	var moment = __webpack_require__(305);
	var commonTrading = __webpack_require__(445);
	var Tick = __webpack_require__(448);
	var BinarySocket = __webpack_require__(427);
	var ViewPopupUI = __webpack_require__(436);
	var localize = __webpack_require__(428).localize;
	var isVisible = __webpack_require__(430).isVisible;
	__webpack_require__(454)(Highcharts);

	var TickDisplay_Beta = function () {
	    'use strict';

	    var number_of_ticks = void 0,
	        display_symbol = void 0,
	        contract_start_ms = void 0,
	        contract_category = void 0,
	        set_barrier = void 0,
	        barrier = void 0,
	        abs_barrier = void 0,
	        display_decimals = void 0,
	        show_contract_result = void 0,
	        is_trading_page = void 0,
	        contract_sentiment = void 0,
	        price = void 0,
	        payout = void 0,
	        ticks_needed = void 0,
	        x_indicators = void 0,
	        chart = void 0,
	        applicable_ticks = void 0,
	        contract_barrier = void 0,
	        contract_start_moment = void 0,
	        counter = void 0,
	        spots_list = void 0;

	    var tick_underlying = void 0,
	        tick_count = void 0,
	        tick_longcode = void 0,
	        tick_display_name = void 0,
	        tick_date_start = void 0,
	        absolute_barrier = void 0,
	        tick_shortcode = void 0,
	        contract_type = void 0,
	        tick_init = void 0,
	        subscribe = void 0,
	        responseID = void 0;

	    var initialize = function initialize(data) {
	        // setting up globals
	        number_of_ticks = parseInt(data.number_of_ticks);
	        display_symbol = data.display_symbol;
	        contract_start_ms = parseInt(data.contract_start * 1000);
	        contract_category = data.contract_category;
	        set_barrier = !contract_category.match('digits');
	        barrier = data.barrier;
	        abs_barrier = data.abs_barrier;
	        display_decimals = data.display_decimals || 2;
	        show_contract_result = data.show_contract_result;
	        is_trading_page = data.is_trading_page;
	        contract_sentiment = data.contract_sentiment;

	        if (data.show_contract_result) {
	            price = parseFloat(data.price);
	            payout = parseFloat(data.payout);
	        }

	        var minimize = data.show_contract_result;

	        setXIndicators();
	        initializeChart({
	            plot_from: data.previous_tick_epoch * 1000,
	            plot_to: new Date((parseInt(data.contract_start) + parseInt((number_of_ticks + 2) * 5)) * 1000).getTime(),
	            minimize: minimize,
	            width: data.width ? data.width : undefined
	        });

	        // add tooltip events to highcharts
	        Highcharts.wrap(Highcharts.Tooltip.prototype, 'hide', function (proceed) {
	            var tooltip = this.chart.options.tooltip;

	            // Run the original proceed method
	            proceed.apply(this, Array.prototype.slice.call(arguments, 1));

	            if (!this.isHidden && tooltip.events && tooltip.events.hide) {
	                tooltip.events.hide();
	            }
	        });

	        Highcharts.wrap(Highcharts.Tooltip.prototype, 'refresh', function (proceed) {
	            var tooltip = this.chart.options.tooltip;

	            // Run the original proceed method
	            proceed.apply(this, Array.prototype.slice.call(arguments, 1));

	            if (tooltip.events && tooltip.events.show) {
	                tooltip.events.show(this.chart.hoverPoints);
	            }
	        });
	    };

	    var setXIndicators = function setXIndicators() {
	        var exit_tick_index = number_of_ticks - 1;
	        if (contract_category.match('asian')) {
	            ticks_needed = number_of_ticks;
	            x_indicators = {
	                _0: { label: 'Entry Spot', id: 'start_tick' }
	            };
	            x_indicators['_' + exit_tick_index] = {
	                label: 'Exit Spot',
	                id: 'exit_tick'
	            };
	        } else if (contract_category.match('callput')) {
	            ticks_needed = number_of_ticks + 1;
	            x_indicators = {
	                _0: { label: 'Entry Spot', id: 'entry_tick' }
	            };
	            x_indicators['_' + number_of_ticks] = {
	                label: 'Exit Spot',
	                id: 'exit_tick'
	            };
	        } else if (contract_category.match('digits')) {
	            ticks_needed = number_of_ticks;
	            x_indicators = {
	                _0: { label: 'Tick 1', id: 'start_tick' }
	            };
	            x_indicators['_' + exit_tick_index] = {
	                label: 'Tick ' + number_of_ticks,
	                id: 'last_tick'
	            };
	        } else {
	            x_indicators = {};
	        }
	    };

	    var initializeChart = function initializeChart(config) {
	        var is_start_on_first_tick = contract_category.match('digits|asian');

	        var chart_options = {
	            chart: {
	                type: 'line',
	                renderTo: 'tick_chart',
	                width: config.width ? config.width : config.minimize ? 394 : null,
	                height: config.minimize ? 120 : null,
	                backgroundColor: null,
	                events: { load: plot(config.plot_from, config.plot_to) },
	                marginLeft: 20
	            },
	            credits: { enabled: false },
	            tooltip: {
	                formatter: function formatter() {
	                    var new_y = this.y.toFixed(display_decimals);
	                    var mom = moment.utc(applicable_ticks[this.x].epoch * 1000).format('dddd, MMM D, HH:mm:ss');
	                    return mom + '<br/>' + display_symbol + ' ' + new_y;
	                },
	                crosshairs: [true]
	            },
	            xAxis: {
	                type: 'linear',
	                min: 0,
	                max: ticks_needed - 0.5,
	                tickInterval: 1,
	                showFirstLabel: !!is_start_on_first_tick,

	                labels: {
	                    autoRotation: false,
	                    formatter: function formatter() {
	                        return this.value + (is_start_on_first_tick ? 1 : 0);
	                    }
	                },
	                crosshair: {
	                    color: '#E98024',
	                    zIndex: 1
	                },
	                title: {
	                    text: localize('Tick')
	                }
	            },
	            yAxis: {
	                opposite: false,
	                title: '',

	                labels: {
	                    align: 'left',
	                    x: 0
	                }
	            },
	            series: [{
	                data: []
	            }],
	            title: '',
	            exporting: { enabled: false, enableImages: false },
	            legend: { enabled: false }
	        };
	        // Trading page's chart
	        var showValues = function showValues(tick, time, this_price) {
	            $('#contract_purchase_profit_list').find('#chart-values').css('display', 'flex').end().find('#contract-values').css('display', 'none');
	            $('#chart_values_tick_value').text(tick);
	            $('#chart_values_time_value').text(time);
	            $('#chart_values_price_value').text(this_price);
	        };
	        if (is_trading_page) {
	            $.extend(true, chart_options, {
	                chart: {
	                    marginBottom: 25
	                },
	                tooltip: {
	                    style: { display: 'none' },

	                    formatter: function formatter() {
	                        var time = moment.utc(applicable_ticks[this.x].epoch * 1000).format('HH:mm:ss');
	                        var this_price = this.y;
	                        showValues(+this.x + (is_start_on_first_tick ? 1 : 0), time, this_price);
	                    },
	                    events: {
	                        hide: function hide() {
	                            $('#contract_purchase_profit_list').find('#chart-values').hide().end().find(' #contract-values').show();
	                        }
	                    }
	                },
	                xAxis: {
	                    title: {
	                        text: ''
	                    },
	                    crosshair: {
	                        width: 30
	                    },
	                    tickWidth: 0
	                },
	                yAxis: {
	                    gridLineWidth: 0,
	                    labels: {
	                        enabled: false
	                    }
	                },
	                series: [{
	                    color: '#2a3052',
	                    lineWidth: 1
	                }]
	            });
	        }
	        chart = new Highcharts.Chart(chart_options);
	        Highcharts.setOptions({
	            lang: { thousandsSep: ',' }
	        });
	    };

	    var applyChartBackgroundColor = function applyChartBackgroundColor(tick) {
	        if (!show_contract_result) {
	            return;
	        }
	        var chart_container = $('#tick_chart');
	        if (contract_sentiment === 'up') {
	            if (tick.quote > contract_barrier) {
	                chart_container.css('background-color', 'rgba(46,136,54,0.198039)');
	            } else {
	                chart_container.css('background-color', 'rgba(204,0,0,0.098039)');
	            }
	        } else if (contract_sentiment === 'down') {
	            if (tick.quote < contract_barrier) {
	                chart_container.css('background-color', 'rgba(46,136,54,0.198039)');
	            } else {
	                chart_container.css('background-color', 'rgba(204,0,0,0.098039)');
	            }
	        }
	    };

	    var addBarrier = function addBarrier() {
	        if (!set_barrier) {
	            return;
	        }

	        var barrier_type = contract_category.match('asian') ? 'asian' : 'static';
	        var line_color = is_trading_page ? '#6b8fb9' : 'green';
	        var line_width = is_trading_page ? 1 : 2;

	        if (barrier_type === 'static') {
	            var barrier_tick = applicable_ticks[0];

	            if (barrier) {
	                var final_barrier = barrier_tick.quote + parseFloat(barrier);
	                // sometimes due to rounding issues, result is 1.009999 while it should
	                // be 1.01
	                final_barrier = Number(Math.round(final_barrier + 'e' + display_decimals) + 'e-' + display_decimals);

	                barrier_tick.quote = final_barrier;
	            } else if (abs_barrier) {
	                barrier_tick.quote = parseFloat(abs_barrier);
	            }

	            chart.yAxis[0].addPlotLine({
	                id: 'tick-barrier',
	                value: barrier_tick.quote,
	                color: line_color,
	                width: line_width,
	                zIndex: 2,
	                label: {
	                    text: is_trading_page ? '' : 'Barrier (' + barrier_tick.quote + ')',
	                    align: 'center'
	                }
	            });

	            contract_barrier = barrier_tick.quote;
	            set_barrier = false;
	        }

	        if (barrier_type === 'asian') {
	            var total = 0;
	            for (var i = 0; i < applicable_ticks.length; i++) {
	                total += parseFloat(applicable_ticks[i].quote);
	            }
	            var calc_barrier = total / applicable_ticks.length;
	            calc_barrier = calc_barrier.toFixed(parseInt(display_decimals) + 1); // round calculated barrier

	            chart.yAxis[0].removePlotLine('tick-barrier');
	            chart.yAxis[0].addPlotLine({
	                id: 'tick-barrier',
	                value: calc_barrier,
	                color: line_color,
	                width: line_width,
	                zIndex: 2,
	                label: {
	                    text: is_trading_page ? '' : 'Average (' + calc_barrier + ')',
	                    align: 'center'
	                }
	            });
	            contract_barrier = calc_barrier;
	        }
	        var purchase_barrier = document.getElementById('contract_purchase_barrier');
	        if (contract_barrier && purchase_barrier) {
	            commonTrading.labelValue(purchase_barrier, localize('Barrier'), contract_barrier, true);
	        }
	    };

	    var add = function add(indicator) {
	        chart.xAxis[0].addPlotLine({
	            value: indicator.index,
	            id: indicator.id,
	            label: { text: indicator.label, x: /start_tick|entry_tick/.test(indicator.id) ? -15 : 5 },
	            color: '#e98024',
	            width: 2,
	            zIndex: 2
	        });
	    };

	    var evaluateContractOutcome = function evaluateContractOutcome() {
	        if (!contract_barrier) {
	            return; // can't do anything without barrier
	        }

	        var exit_tick_index = applicable_ticks.length - 1;
	        var exit_spot = applicable_ticks[exit_tick_index].quote;

	        if (contract_sentiment === 'up') {
	            if (exit_spot > contract_barrier) {
	                win();
	            } else {
	                lose();
	            }
	        } else if (contract_sentiment === 'down') {
	            if (exit_spot < contract_barrier) {
	                win();
	            } else {
	                lose();
	            }
	        }
	    };

	    var win = function win() {
	        var profit = payout - price;
	        updateUI(payout, profit, localize('This contract won'));
	    };

	    var lose = function lose() {
	        updateUI(0, -price, localize('This contract lost'));
	    };

	    var plot = function plot() {
	        contract_start_moment = moment(contract_start_ms).utc();
	        counter = 0;
	        applicable_ticks = [];
	    };

	    var updateUI = function updateUI(final_price, pnl, contract_status) {
	        commonTrading.updatePurchaseStatus_Beta(final_price, final_price - pnl, contract_status);
	    };

	    var dispatch = function dispatch(data) {
	        var tick_chart = document.getElementById('tick_chart');

	        if (!tick_chart || !isVisible(tick_chart) || !data || !data.tick && !data.history) {
	            return;
	        }

	        if (subscribe && data.tick && document.getElementById('sell_content_wrapper')) {
	            responseID = data.tick.id;
	            ViewPopupUI.storeSubscriptionID(responseID);
	        }

	        var epoches = void 0,
	            spots2 = void 0,
	            chart_display_decimals = void 0;
	        if (document.getElementById('sell_content_wrapper')) {
	            if (data.tick && document.getElementById('sell_content_wrapper')) {
	                Tick.details(data);
	                if (!chart_display_decimals) {
	                    chart_display_decimals = data.tick.quote.split('.')[1].length || 2;
	                }
	            } else if (data.history && document.getElementById('sell_content_wrapper')) {
	                if (!chart_display_decimals) {
	                    chart_display_decimals = data.history.prices[0].split('.')[1].length || 2;
	                }
	            }
	            if (!tick_init || tick_init === '') {
	                initialize({
	                    symbol: tick_underlying,
	                    number_of_ticks: tick_count,
	                    contract_category: /asian/i.test(tick_shortcode) ? 'asian' : /digit/i.test(tick_shortcode) ? 'digits' : 'callput',
	                    longcode: tick_longcode,
	                    display_symbol: tick_display_name,
	                    contract_start: tick_date_start,
	                    abs_barrier: absolute_barrier,
	                    display_decimals: chart_display_decimals,
	                    contract_sentiment: contract_type === 'CALL' || contract_type === 'ASIANU' ? 'up' : 'down',
	                    show_contract_result: 0
	                });
	                spots_list = {};
	                tick_init = 'initialized';
	            }
	        }
	        if (data.tick) {
	            spots2 = Tick.spots();
	            epoches = Object.keys(spots2).sort(function (a, b) {
	                return a - b;
	            });
	        } else if (data.history) {
	            epoches = data.history.times;
	        }
	        if (applicable_ticks && ticks_needed && applicable_ticks.length >= ticks_needed) {
	            evaluateContractOutcome();
	            if (responseID) {
	                BinarySocket.send({ forget: responseID });
	            }
	        } else {
	            for (var d = 0; d < epoches.length; d++) {
	                var tick = void 0;
	                if (data.tick) {
	                    tick = {
	                        epoch: parseInt(epoches[d]),
	                        quote: parseFloat(spots2[epoches[d]])
	                    };
	                } else if (data.history) {
	                    tick = {
	                        epoch: parseInt(data.history.times[d]),
	                        quote: parseFloat(data.history.prices[d])
	                    };
	                }
	                if (tick.epoch > contract_start_moment.unix() && !spots_list[tick.epoch]) {
	                    if (!chart || !chart.series) return;
	                    chart.series[0].addPoint([counter, tick.quote], true, false);
	                    applicable_ticks.push(tick);
	                    spots_list[tick.epoch] = tick.quote;
	                    var indicator_key = '_' + counter;
	                    if (typeof x_indicators[indicator_key] !== 'undefined') {
	                        x_indicators[indicator_key].index = counter;
	                        add(x_indicators[indicator_key]);
	                    }
	                    addBarrier();
	                    applyChartBackgroundColor(tick);
	                    counter++;
	                }
	            }

	            if (is_trading_page) {
	                var is_up = contract_sentiment === 'up';
	                var min = chart.yAxis[0].getExtremes().min;
	                var max = chart.yAxis[0].getExtremes().max;
	                chart.yAxis[0].removePlotBand('win-area');
	                chart.yAxis[0].addPlotBand({
	                    id: 'win-area',
	                    from: is_up ? contract_barrier : min,
	                    to: is_up ? max : contract_barrier,
	                    color: '#f5f8fb'
	                });
	                chart.yAxis[0].removePlotBand('lose-area');
	                chart.yAxis[0].addPlotBand({
	                    id: 'lose-area',
	                    from: is_up ? min : contract_barrier,
	                    to: is_up ? contract_barrier : max,
	                    color: '#ffffff'
	                });
	            }
	        }
	    };

	    var updateChart = function updateChart(data, contract) {
	        subscribe = 'false';
	        if (contract) {
	            tick_underlying = contract.underlying;
	            tick_count = contract.tick_count;
	            tick_longcode = contract.longcode;
	            tick_display_name = contract.display_name;
	            tick_date_start = contract.date_start;
	            absolute_barrier = contract.barrier;
	            tick_shortcode = contract.shortcode;
	            contract_type = contract.contract_type;
	            tick_init = '';
	            var request = {
	                ticks_history: contract.underlying,
	                start: contract.date_start,
	                end: 'latest'
	            };
	            if (contract.current_spot_time < contract.date_expiry) {
	                request.subscribe = 1;
	                subscribe = 'true';
	            } else {
	                request.end = contract.date_expiry;
	            }
	            BinarySocket.send(request, { callback: dispatch });
	        } else {
	            dispatch(data);
	        }
	    };

	    return {
	        init: initialize,
	        updateChart: updateChart,
	        resetSpots: function resetSpots() {
	            spots_list = {};
	        }
	    };
	}();

	module.exports = TickDisplay_Beta;

/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var Highcharts = __webpack_require__(453);
	var Symbols = __webpack_require__(447);
	var BinarySocket = __webpack_require__(427);
	var localize = __webpack_require__(428).localize;
	__webpack_require__(454)(Highcharts);

	var DigitInfo = function () {
	    'use strict';

	    var spots = [],
	        stream_id = null,
	        chart = void 0,

	    // To avoid too many greens and reds
	    prev_min_index = -1,
	        prev_max_index = -1;

	    var chart_config = {
	        chart: {
	            renderTo: 'last_digit_histo',
	            defaultSeriesType: 'column',
	            backgroundColor: '#eee',
	            borderWidth: 1,
	            borderColor: '#ccc',
	            plotBackgroundColor: '#fff',
	            plotBorderWidth: 1,
	            plotBorderColor: '#ccc',
	            height: 225 },
	        title: { text: '' },
	        credits: { enabled: false },
	        exporting: { enabled: false },
	        legend: {
	            enabled: false
	        },
	        tooltip: {
	            borderWidth: 1,
	            formatter: function formatter() {
	                var total = $('#tick_count').val();
	                var percentage = this.y / total * 100;
	                return '<b>' + localize('Digit') + ':</b> ' + this.x + '<br/><b>' + localize('Percentage') + ':</b> ' + percentage.toFixed(1) + '%';
	            }
	        },
	        plotOptions: {
	            column: {
	                shadow: false,
	                borderWidth: 0.5,
	                borderColor: '#666',
	                pointPadding: 0,
	                groupPadding: 0.0,
	                color: '#e1f0fb'
	            },
	            series: {
	                dataLabels: {
	                    enabled: true,
	                    style: {
	                        textShadow: false
	                    },
	                    formatter: function formatter() {
	                        var total = $('#tick_count').val();
	                        var percentage = this.point.y / total * 100;
	                        return percentage.toFixed(2) + '%';
	                    }
	                }
	            }
	        },
	        xAxis: {
	            categories: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
	            lineWidth: 0,
	            lineColor: '#999',
	            tickLength: 10,
	            tickColor: '#ccc'
	        },
	        yAxis: {
	            title: { text: '' },
	            maxPadding: 0,
	            gridLineColor: '#e9e9e9',
	            tickWidth: 1,
	            tickLength: 3,
	            tickColor: '#ccc',
	            lineColor: '#ccc',
	            endOnTick: true,
	            opposite: false,
	            labels: {
	                align: 'left',
	                x: 0,
	                enabled: false,
	                formatter: function formatter() {
	                    var total = $('#tick_count').val();
	                    var percentage = parseInt(this.value / total * 100);
	                    return percentage + '%';
	                }
	            }
	        }
	    };

	    var addContent = function addContent(underlying) {
	        var domain = document.domain.split('.').slice(-2).join('.');
	        var underlyings = [];
	        var symbols = Symbols.getAllSymbols();
	        Object.keys(symbols).forEach(function (key) {
	            if (/^(R_|RD)/.test(key)) {
	                underlyings.push(key);
	            }
	        });
	        underlyings = underlyings.sort();
	        var elem = '';
	        for (var i = 0; i < underlyings.length; i++) {
	            elem += '<option value="' + underlyings[i] + '">' + localize(symbols[underlyings[i]]) + '</option>';
	        }
	        $('#digit_underlying').html($(elem)).val(underlying);
	        $('#digit_domain').text(domain.charAt(0).toUpperCase() + domain.slice(1));
	        $('#digit_info_underlying').text($('#digit_underlying option:selected').text());
	    };

	    var onLatest = function onLatest() {
	        var getLatest = function getLatest() {
	            var $digit_underlying_option = $('#digit_underlying option:selected');
	            var symbol = $digit_underlying_option.val();
	            var count = $('#tick_count').val();
	            $('#digit_info_underlying').text($digit_underlying_option.text());
	            $('#digit_info_count').text(count);
	            var request = {
	                ticks_history: symbol,
	                end: 'latest',
	                count: count
	            };
	            if (chart.series[0].name !== symbol) {
	                if ($('#underlying').find('option:selected').val() !== $('#digit_underlying').val()) {
	                    request.subscribe = 1;
	                    request.style = 'ticks';
	                }
	                if (stream_id !== null) {
	                    BinarySocket.send({ forget: stream_id });
	                    stream_id = null;
	                }
	            }
	            BinarySocket.send(request, {
	                callback: function callback(response) {
	                    var type = response.msg_type;
	                    if (type === 'tick') {
	                        updateChart(response);
	                    } else if (type === 'history') {
	                        showChart(response.echo_req.ticks_history, response.history.prices);
	                    }
	                }
	            });
	        };
	        $('#digit_underlying, #tick_count').off('change').on('change', getLatest);
	    };

	    var showChart = function showChart(underlying, underlying_spots) {
	        if (typeof underlying_spots === 'undefined' || underlying_spots.length <= 0) {
	            console.log('Unexpected error occured in the charts.');
	            return;
	        }
	        var dec = underlying_spots[0].split('.')[1].length;
	        for (var i = 0; i < underlying_spots.length; i++) {
	            var val = parseFloat(underlying_spots[i]).toFixed(dec);
	            underlying_spots[i] = val.substr(val.length - 1);
	        }

	        var getTitle = function getTitle() {
	            return {
	                text: localize($('#last_digit_title').html(), [underlying_spots.length, $('#digit_underlying option:selected').text()])
	            };
	        };

	        spots = underlying_spots;
	        if (chart && $('#last_digit_histo').html()) {
	            chart.xAxis[0].update({ title: getTitle() }, true);
	            chart.series[0].name = underlying;
	        } else {
	            addContent(underlying); // this creates #last_digit_title
	            chart_config.xAxis.title = getTitle();
	            chart = new Highcharts.Chart(chart_config);
	            chart.addSeries({ name: underlying, data: [] });
	            onLatest();
	            stream_id = null;
	        }
	        update();
	    };

	    var update = function update(symbol, latest_spot) {
	        if (typeof chart === 'undefined') {
	            return null;
	        }

	        var series = chart.series[0]; // Where we put the final data.
	        if (series.name !== symbol) {
	            latest_spot = undefined; // This simplifies the logic a bit later.
	        }

	        if (typeof latest_spot !== 'undefined') {
	            // This is a bit later. :D
	            spots.unshift(latest_spot.slice(-1)); // Only last digit matters
	            spots.pop();
	        }

	        // Always recompute and draw, even if theres no new data.
	        // This is especially useful on first reuqest, but maybe in other ways.
	        var filtered_spots = [];
	        var filterFunc = function filterFunc(el) {
	            return +el === digit;
	        };
	        var digit = 10;
	        var min_max_counter = [];
	        while (digit--) {
	            var val = spots.filter(filterFunc).length;
	            filtered_spots[digit] = val;
	            if (typeof min_max_counter[val] === 'undefined') {
	                min_max_counter[val] = 0;
	            }
	            min_max_counter[val]++;
	        }
	        var min = Math.min.apply(null, filtered_spots);
	        var max = Math.max.apply(null, filtered_spots);
	        var min_index = filtered_spots.indexOf(min);
	        var max_index = filtered_spots.indexOf(max);
	        // changing color
	        if (min_max_counter[min] >= 1) {
	            filtered_spots[min_index] = { y: min, color: '#CC0000' };
	            if (prev_min_index === -1) {
	                prev_min_index = min_index;
	            } else if (prev_min_index !== min_index) {
	                if (_typeof(filtered_spots[prev_min_index]) === 'object') {
	                    filtered_spots[prev_min_index] = { y: filtered_spots[prev_min_index].y, color: '#e1f0fb' };
	                } else {
	                    filtered_spots[prev_min_index] = { y: filtered_spots[prev_min_index], color: '#e1f0fb' };
	                }
	                prev_min_index = min_index;
	            }
	        }

	        if (min_max_counter[max] >= 1) {
	            filtered_spots[max_index] = { y: max, color: '#2E8836' };
	            if (prev_max_index === -1) {
	                prev_max_index = max_index;
	            } else if (prev_max_index !== max_index) {
	                if (_typeof(filtered_spots[prev_max_index]) === 'object') {
	                    filtered_spots[prev_max_index] = { y: filtered_spots[prev_max_index].y, color: '#e1f0fb' };
	                } else {
	                    filtered_spots[prev_max_index] = { y: filtered_spots[prev_max_index], color: '#e1f0fb' };
	                }
	                prev_max_index = max_index;
	            }
	        }
	        return series.setData(filtered_spots);
	    };

	    var updateChart = function updateChart(tick) {
	        if (stream_id) {
	            if (chart.series[0].name === tick.tick.symbol) {
	                stream_id = tick.tick.id || null;
	                update(tick.tick.symbol, tick.tick.quote);
	            } else {
	                BinarySocket.send({ forget: tick.tick.id.toString() });
	            }
	        } else {
	            update(tick.tick.symbol, tick.tick.quote);
	        }
	    };

	    return {
	        showChart: showChart,
	        updateChart: updateChart
	    };
	}();

	module.exports = DigitInfo;

/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);
	var State = __webpack_require__(421).State;

	/*
	 * get the current active tab if its visible i.e allowed for current parameters
	 */
	var getActiveTab = function getActiveTab(item) {
	    var tab = item || 'currentAnalysisTab';
	    var is_chart_allowed = State.get('is_chart_allowed');
	    var selected_tab = sessionStorage.getItem(tab) || (State.get('is_mb_trading') ? 'tab_portfolio' : is_chart_allowed ? 'tab_graph' : 'tab_explanation');
	    var selected_element = document.getElementById(selected_tab);

	    if (selected_element && selected_element.classList.contains('invisible') && (item || !(selected_tab === 'tab_portfolio' && !!(Client.isLoggedIn() && State.get('is_mb_trading'))))) {
	        selected_tab = is_chart_allowed ? 'tab_graph' : 'tab_explanation';
	        sessionStorage.setItem(tab, selected_tab);
	    }

	    return selected_tab;
	};

	module.exports = {
	    getActiveTab: getActiveTab,
	    getActiveTab_Beta: function getActiveTab_Beta() {
	        return getActiveTab('currentAnalysisTab_Beta');
	    }
	};

/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Contract = __webpack_require__(444);
	var Symbols = __webpack_require__(447);
	var Tick = __webpack_require__(448);
	var TickDisplay = __webpack_require__(460);
	var updateValues = __webpack_require__(461);
	var localize = __webpack_require__(428).localize;
	var elementInnerHtml = __webpack_require__(430).elementInnerHtml;
	var elementTextContent = __webpack_require__(430).elementTextContent;
	var isVisible = __webpack_require__(430).isVisible;
	var padLeft = __webpack_require__(449).padLeft;

	/*
	 * Purchase object that handles all the functions related to
	 * contract purchase response
	 */

	var Purchase = function () {
	    'use strict';

	    var purchase_data = {};

	    var display = function display(details) {
	        purchase_data = details;

	        var receipt = details.buy;
	        var passthrough = details.echo_req.passthrough;
	        var container = document.getElementById('contract_confirmation_container');
	        var message_container = document.getElementById('confirmation_message');
	        var heading = document.getElementById('contract_purchase_heading');
	        var descr = document.getElementById('contract_purchase_descr');
	        var barrier_element = document.getElementById('contract_purchase_barrier');
	        var reference = document.getElementById('contract_purchase_reference');
	        var chart = document.getElementById('tick_chart');
	        var payout = document.getElementById('contract_purchase_payout');
	        var cost = document.getElementById('contract_purchase_cost');
	        var profit = document.getElementById('contract_purchase_profit');
	        var spots = document.getElementById('contract_purchase_spots');
	        var confirmation_error = document.getElementById('confirmation_error');
	        var contracts_list = document.getElementById('contracts_list');
	        var button = document.getElementById('contract_purchase_button');

	        var error = details.error;
	        var show_chart = !error && passthrough.duration <= 10 && passthrough.duration_unit === 't' && (sessionStorage.formname === 'risefall' || sessionStorage.formname === 'higherlower' || sessionStorage.formname === 'asian');

	        contracts_list.style.display = 'none';

	        if (error) {
	            container.style.display = 'block';
	            message_container.hide();
	            confirmation_error.show();
	            elementInnerHtml(confirmation_error, error.message);
	        } else {
	            var guide_btn = document.getElementById('guideBtn');
	            if (guide_btn) {
	                guide_btn.style.display = 'none';
	            }
	            container.style.display = 'table-row';
	            message_container.show();
	            confirmation_error.hide();

	            elementTextContent(heading, localize('Contract Confirmation'));
	            elementTextContent(descr, receipt.longcode);
	            if (barrier_element) barrier_element.textContent = '';
	            elementTextContent(reference, localize('Your transaction reference is') + ' ' + receipt.transaction_id);

	            var payout_value = void 0,
	                cost_value = void 0;

	            if (passthrough.basis === 'payout') {
	                payout_value = passthrough.amount;
	                cost_value = passthrough['ask-price'];
	            } else {
	                cost_value = passthrough.amount;
	                payout_value = receipt.payout;
	            }
	            var profit_value = Math.round((payout_value - cost_value) * 100) / 100;

	            elementInnerHtml(payout, localize('Potential Payout') + ' <p>' + payout_value + '</p>');
	            elementInnerHtml(cost, localize('Total Cost') + ' <p>' + cost_value + '</p>');
	            elementInnerHtml(profit, localize('Potential Profit') + ' <p>' + profit_value + '</p>');

	            updateValues.updateContractBalance(receipt.balance_after);

	            if (show_chart) {
	                chart.show();
	            } else {
	                chart.hide();
	            }

	            if (Contract.form() === 'digits') {
	                elementTextContent(spots, '');
	                spots.className = '';
	                spots.show();
	            } else {
	                spots.hide();
	            }

	            if (Contract.form() !== 'digits' && !show_chart) {
	                elementTextContent(button, localize('View'));
	                button.setAttribute('contract_id', receipt.contract_id);
	                button.show();
	                $('.open_contract_details').attr('contract_id', receipt.contract_id).setVisibility(1);
	            } else {
	                button.hide();
	                $('.open_contract_details').setVisibility(0);
	            }
	        }

	        if (show_chart) {
	            var contract_sentiment = void 0;
	            if (passthrough.contract_type === 'CALL' || passthrough.contract_type === 'ASIANU') {
	                contract_sentiment = 'up';
	            } else {
	                contract_sentiment = 'down';
	            }

	            // calculate number of decimals needed to display tick-chart according to the spot
	            // value of the underlying
	            var decimal_points = 2;
	            var tick_spots = Tick.spots();
	            var tick_spot_epochs = Object.keys(tick_spots);
	            if (tick_spot_epochs.length > 0) {
	                var last_quote = tick_spots[tick_spot_epochs[0]].toString();

	                if (last_quote.indexOf('.') !== -1) {
	                    decimal_points = last_quote.split('.')[1].length;
	                }
	            }

	            var barrier = void 0;
	            if (sessionStorage.getItem('formname') === 'higherlower') {
	                barrier = passthrough.barrier;
	            }

	            TickDisplay.init({
	                symbol: passthrough.symbol,
	                barrier: barrier,
	                number_of_ticks: passthrough.duration,
	                previous_tick_epoch: receipt.start_time,
	                contract_category: sessionStorage.getItem('formname') === 'asian' ? 'asian' : 'callput',
	                display_symbol: Symbols.getName(passthrough.symbol),
	                contract_start: receipt.start_time,
	                display_decimals: decimal_points,
	                contract_sentiment: contract_sentiment,
	                price: passthrough['ask-price'],
	                payout: receipt.payout,
	                show_contract_result: 1,
	                width: $('#confirmation_message').width()
	            });
	            TickDisplay.resetSpots();
	        }
	    };

	    var updateSpotList = function updateSpotList() {
	        if ($('#contract_purchase_spots:hidden').length) {
	            return;
	        }

	        var duration = purchase_data.echo_req && purchase_data.echo_req.passthrough ? purchase_data.echo_req.passthrough.duration : null;

	        if (!duration) {
	            return;
	        }

	        var spots = document.getElementById('contract_purchase_spots');
	        var spots2 = Tick.spots();
	        var epoches = Object.keys(spots2).sort(function (a, b) {
	            return a - b;
	        });
	        if (spots) spots.textContent = '';

	        var last_digit = void 0;
	        var replace = function replace(d) {
	            last_digit = d;return '<b>' + d + '</b>';
	        };
	        for (var s = 0; s < epoches.length; s++) {
	            var tick_d = {
	                epoch: epoches[s],
	                quote: spots2[epoches[s]]
	            };

	            if (isVisible(spots) && tick_d.epoch && tick_d.epoch > purchase_data.buy.start_time) {
	                var fragment = document.createElement('div');
	                fragment.classList.add('row');

	                var el1 = document.createElement('div');
	                el1.classList.add('col');
	                elementTextContent(el1, localize('Tick') + ' ' + (spots.getElementsByClassName('row').length + 1));
	                fragment.appendChild(el1);

	                var el2 = document.createElement('div');
	                el2.classList.add('col');
	                var date = new Date(tick_d.epoch * 1000);
	                var hours = padLeft(date.getUTCHours(), 2, '0');
	                var minutes = padLeft(date.getUTCMinutes(), 2, '0');
	                var seconds = padLeft(date.getUTCSeconds(), 2, '0');
	                elementTextContent(el2, [hours, minutes, seconds].join(':'));
	                fragment.appendChild(el2);

	                var tick = tick_d.quote.replace(/\d$/, replace);
	                var el3 = document.createElement('div');
	                el3.classList.add('col');
	                elementInnerHtml(el3, tick);
	                fragment.appendChild(el3);

	                spots.appendChild(fragment);
	                spots.scrollTop = spots.scrollHeight;

	                if (last_digit && duration === 1) {
	                    var contract_status = void 0,
	                        final_price = void 0,
	                        pnl = void 0;
	                    var pass_contract_type = purchase_data.echo_req.passthrough.contract_type;
	                    var pass_barrier = purchase_data.echo_req.passthrough.barrier;

	                    if (pass_contract_type === 'DIGITMATCH' && +last_digit === +pass_barrier || pass_contract_type === 'DIGITDIFF' && +last_digit !== +pass_barrier || pass_contract_type === 'DIGITEVEN' && +last_digit % 2 === 0 || pass_contract_type === 'DIGITODD' && +last_digit % 2 || pass_contract_type === 'DIGITOVER' && +last_digit > pass_barrier || pass_contract_type === 'DIGITUNDER' && +last_digit < pass_barrier) {
	                        spots.className = 'won';
	                        final_price = $('#contract_purchase_payout').find('p').text();
	                        pnl = $('#contract_purchase_cost').find('p').text();
	                        contract_status = localize('This contract won');
	                    } else {
	                        spots.className = 'lost';
	                        final_price = 0;
	                        pnl = -$('#contract_purchase_cost').find('p').text();
	                        contract_status = localize('This contract lost');
	                    }

	                    updateValues.updatePurchaseStatus(final_price, pnl, contract_status);
	                }

	                duration--;
	                if (!duration) {
	                    purchase_data.echo_req.passthrough.duration = 0;
	                }
	            }
	        }
	    };

	    return {
	        display: display,
	        updateSpotList: updateSpotList
	    };
	}();

	module.exports = Purchase;

/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Highcharts = __webpack_require__(453);
	var moment = __webpack_require__(305);
	var Tick = __webpack_require__(448);
	var updatePurchaseStatus = __webpack_require__(461).updatePurchaseStatus;
	var BinarySocket = __webpack_require__(427);
	var ViewPopupUI = __webpack_require__(436);
	var localize = __webpack_require__(428).localize;
	var elementInnerHtml = __webpack_require__(430).elementInnerHtml;
	var isVisible = __webpack_require__(430).isVisible;
	__webpack_require__(454)(Highcharts);

	var TickDisplay = function () {
	    'use strict';

	    var number_of_ticks = void 0,
	        display_symbol = void 0,
	        contract_start_ms = void 0,
	        contract_category = void 0,
	        set_barrier = void 0,
	        barrier = void 0,
	        abs_barrier = void 0,
	        display_decimals = void 0,
	        show_contract_result = void 0,
	        contract_sentiment = void 0,
	        price = void 0,
	        payout = void 0,
	        ticks_needed = void 0,
	        x_indicators = void 0,
	        chart = void 0,
	        applicable_ticks = void 0,
	        contract_barrier = void 0,
	        contract_start_moment = void 0,
	        counter = void 0,
	        spots_list = void 0;

	    var tick_underlying = void 0,
	        tick_count = void 0,
	        tick_longcode = void 0,
	        tick_display_name = void 0,
	        tick_date_start = void 0,
	        absolute_barrier = void 0,
	        tick_shortcode = void 0,
	        tick_init = void 0,
	        subscribe = void 0,
	        responseID = void 0;

	    var initialize = function initialize(data) {
	        // setting up globals
	        number_of_ticks = parseInt(data.number_of_ticks);
	        display_symbol = data.display_symbol;
	        contract_start_ms = parseInt(data.contract_start) * 1000;
	        contract_category = data.contract_category;
	        set_barrier = !contract_category.match('digits');
	        barrier = data.barrier;
	        abs_barrier = data.abs_barrier;
	        display_decimals = data.display_decimals || 2;
	        show_contract_result = data.show_contract_result;

	        if (data.show_contract_result) {
	            contract_sentiment = data.contract_sentiment;
	            price = parseFloat(data.price);
	            payout = parseFloat(data.payout);
	        }

	        var minimize = data.show_contract_result;
	        var end_time = parseInt(data.contract_start) + parseInt((number_of_ticks + 2) * 5);

	        setXIndicators();
	        initializeChart({
	            plot_from: data.previous_tick_epoch * 1000,
	            plot_to: new Date(end_time * 1000).getTime(),
	            minimize: minimize,
	            width: data.width ? data.width : undefined
	        });
	    };

	    var setXIndicators = function setXIndicators() {
	        var exit_tick_index = number_of_ticks - 1;
	        if (contract_category.match('asian')) {
	            ticks_needed = number_of_ticks;
	            x_indicators = {
	                _0: { label: 'Entry Spot', id: 'start_tick' }
	            };
	            x_indicators['_' + exit_tick_index] = {
	                label: 'Exit Spot',
	                id: 'exit_tick'
	            };
	        } else if (contract_category.match('callput')) {
	            ticks_needed = number_of_ticks + 1;
	            x_indicators = {
	                _0: { label: 'Entry Spot', id: 'entry_tick' }
	            };
	            x_indicators['_' + number_of_ticks] = {
	                label: 'Exit Spot',
	                id: 'exit_tick'
	            };
	        } else if (contract_category.match('digits')) {
	            ticks_needed = number_of_ticks;
	            x_indicators = {
	                _0: { label: 'Tick 1', id: 'start_tick' }
	            };
	            x_indicators['_' + exit_tick_index] = {
	                label: 'Tick ' + number_of_ticks,
	                id: 'last_tick'
	            };
	        } else {
	            x_indicators = {};
	        }
	    };

	    var initializeChart = function initializeChart(config) {
	        chart = new Highcharts.Chart({
	            chart: {
	                type: 'line',
	                renderTo: 'tick_chart',
	                width: config.width ? config.width : config.minimize ? 394 : null,
	                height: config.minimize ? 143 : null,
	                backgroundColor: null,
	                events: { load: plot(config.plot_from, config.plot_to) },
	                marginLeft: 50
	            },
	            credits: { enabled: false },
	            tooltip: {
	                formatter: function formatter() {
	                    var new_y = this.y.toFixed(display_decimals);
	                    var mom = moment.utc(applicable_ticks[this.x].epoch * 1000).format('dddd, MMM D, HH:mm:ss');
	                    return mom + '<br/>' + display_symbol + ' ' + new_y;
	                }
	            },
	            xAxis: {
	                type: 'linear',
	                min: 0,
	                max: number_of_ticks + 1,
	                labels: { enabled: false }
	            },
	            yAxis: {
	                opposite: false,
	                labels: {
	                    align: 'left',
	                    x: 0
	                },
	                title: ''
	            },
	            series: [{
	                data: []
	            }],
	            title: '',
	            exporting: { enabled: false, enableImages: false },
	            legend: { enabled: false }
	        });
	        Highcharts.setOptions({
	            lang: { thousandsSep: ',' }
	        });
	    };

	    var applyChartBackgroundColor = function applyChartBackgroundColor(tick) {
	        if (!show_contract_result) {
	            return;
	        }
	        var chart_container = $('#tick_chart');
	        if (contract_sentiment === 'up') {
	            if (tick.quote > contract_barrier) {
	                chart_container.css('background-color', 'rgba(46,136,54,0.198039)');
	            } else {
	                chart_container.css('background-color', 'rgba(204,0,0,0.098039)');
	            }
	        } else if (contract_sentiment === 'down') {
	            if (tick.quote < contract_barrier) {
	                chart_container.css('background-color', 'rgba(46,136,54,0.198039)');
	            } else {
	                chart_container.css('background-color', 'rgba(204,0,0,0.098039)');
	            }
	        }
	    };

	    var addBarrier = function addBarrier() {
	        if (!set_barrier) {
	            return;
	        }

	        var barrier_type = contract_category.match('asian') ? 'asian' : 'static';

	        if (barrier_type === 'static') {
	            var barrier_tick = applicable_ticks[0];

	            if (barrier) {
	                var final_barrier = barrier_tick.quote + parseFloat(barrier);
	                // sometimes due to rounding issues, result is 1.009999 while it should
	                // be 1.01
	                final_barrier = Number(Math.round(final_barrier + 'e' + display_decimals) + 'e-' + display_decimals);

	                barrier_tick.quote = final_barrier;
	            } else if (abs_barrier) {
	                barrier_tick.quote = parseFloat(abs_barrier);
	            }

	            chart.yAxis[0].addPlotLine({
	                id: 'tick-barrier',
	                value: barrier_tick.quote,
	                label: { text: 'Barrier (' + barrier_tick.quote + ')', align: 'center' },
	                color: 'green',
	                width: 2,
	                zIndex: 2
	            });
	            contract_barrier = barrier_tick.quote;
	            set_barrier = false;
	        }

	        if (barrier_type === 'asian') {
	            var total = 0;
	            for (var i = 0; i < applicable_ticks.length; i++) {
	                total += parseFloat(applicable_ticks[i].quote);
	            }
	            var calc_barrier = total / applicable_ticks.length;
	            calc_barrier = calc_barrier.toFixed(parseInt(display_decimals) + 1); // round calculated barrier

	            chart.yAxis[0].removePlotLine('tick-barrier');
	            chart.yAxis[0].addPlotLine({
	                id: 'tick-barrier',
	                value: calc_barrier,
	                color: 'green',
	                label: {
	                    text: 'Average (' + calc_barrier + ')',
	                    align: 'center'
	                },
	                width: 2,
	                zIndex: 2
	            });
	            contract_barrier = calc_barrier;
	        }
	        var purchase_barrier = document.getElementById('contract_purchase_barrier');
	        if (contract_barrier && purchase_barrier) {
	            elementInnerHtml(purchase_barrier, localize('Barrier') + ': ' + contract_barrier);
	        }
	    };

	    var add = function add(indicator) {
	        chart.xAxis[0].addPlotLine({
	            value: indicator.index,
	            id: indicator.id,
	            label: { text: indicator.label, x: /start_tick|entry_tick/.test(indicator.id) ? -15 : 5 },
	            color: '#e98024',
	            width: 2,
	            zIndex: 2
	        });
	    };

	    var evaluateContractOutcome = function evaluateContractOutcome() {
	        if (!contract_barrier) {
	            return; // can't do anything without barrier
	        }

	        var exit_tick_index = applicable_ticks.length - 1;
	        var exit_spot = applicable_ticks[exit_tick_index].quote;

	        if (contract_sentiment === 'up') {
	            if (exit_spot > contract_barrier) {
	                win();
	            } else {
	                lose();
	            }
	        } else if (contract_sentiment === 'down') {
	            if (exit_spot < contract_barrier) {
	                win();
	            } else {
	                lose();
	            }
	        }
	    };

	    var win = function win() {
	        var profit = payout - price;
	        updateUI(payout, profit, localize('This contract won'));
	    };

	    var lose = function lose() {
	        updateUI(0, -price, localize('This contract lost'));
	    };

	    var plot = function plot() {
	        contract_start_moment = moment(contract_start_ms).utc();
	        counter = 0;
	        applicable_ticks = [];
	    };

	    var updateUI = function updateUI(final_price, pnl, contract_status) {
	        updatePurchaseStatus(final_price, final_price - pnl, contract_status);
	    };

	    var dispatch = function dispatch(data) {
	        var tick_chart = document.getElementById('tick_chart');

	        if (!tick_chart || !isVisible(tick_chart) || !data || !data.tick && !data.history) {
	            return;
	        }

	        if (subscribe && data.tick && document.getElementById('sell_content_wrapper')) {
	            responseID = data.tick.id;
	            ViewPopupUI.storeSubscriptionID(responseID);
	        }

	        var epoches = void 0,
	            spots2 = void 0,
	            chart_display_decimals = void 0;
	        if (document.getElementById('sell_content_wrapper')) {
	            if (data.tick && document.getElementById('sell_content_wrapper')) {
	                Tick.details(data);
	                if (!chart_display_decimals) {
	                    chart_display_decimals = data.tick.quote.split('.')[1].length || 2;
	                }
	            } else if (data.history && document.getElementById('sell_content_wrapper')) {
	                if (!chart_display_decimals) {
	                    chart_display_decimals = data.history.prices[0].split('.')[1].length || 2;
	                }
	            }
	            if (!tick_init) {
	                initialize({
	                    symbol: tick_underlying,
	                    number_of_ticks: tick_count,
	                    contract_category: /asian/i.test(tick_shortcode) ? 'asian' : /digit/i.test(tick_shortcode) ? 'digits' : 'callput',
	                    longcode: tick_longcode,
	                    display_symbol: tick_display_name,
	                    contract_start: tick_date_start,
	                    abs_barrier: absolute_barrier,
	                    display_decimals: chart_display_decimals,
	                    show_contract_result: 0
	                });
	                spots_list = {};
	                tick_init = 'initialized';
	            }
	        }
	        if (data.tick) {
	            spots2 = Tick.spots();
	            epoches = Object.keys(spots2).sort(function (a, b) {
	                return a - b;
	            });
	        } else if (data.history) {
	            epoches = data.history.times;
	        }

	        if (applicable_ticks && ticks_needed && applicable_ticks.length >= ticks_needed) {
	            evaluateContractOutcome();
	            if (responseID) {
	                BinarySocket.send({ forget: responseID });
	            }
	        } else {
	            for (var d = 0; d < epoches.length; d++) {
	                var tick = void 0;
	                if (data.tick) {
	                    tick = {
	                        epoch: parseInt(epoches[d]),
	                        quote: parseFloat(spots2[epoches[d]])
	                    };
	                } else if (data.history) {
	                    tick = {
	                        epoch: parseInt(data.history.times[d]),
	                        quote: parseFloat(data.history.prices[d])
	                    };
	                }

	                if (tick.epoch > contract_start_moment.unix() && !spots_list[tick.epoch]) {
	                    if (!chart || !chart.series) return;
	                    chart.series[0].addPoint([counter, tick.quote], true, false);
	                    applicable_ticks.push(tick);
	                    spots_list[tick.epoch] = tick.quote;
	                    var indicator_key = '_' + counter;
	                    if (typeof x_indicators[indicator_key] !== 'undefined') {
	                        x_indicators[indicator_key].index = counter;
	                        add(x_indicators[indicator_key]);
	                    }

	                    addBarrier();
	                    applyChartBackgroundColor(tick);
	                    counter++;
	                }
	            }
	        }
	    };

	    var updateChart = function updateChart(data, contract) {
	        subscribe = 'false';
	        if (contract) {
	            tick_underlying = contract.underlying;
	            tick_count = contract.tick_count;
	            tick_longcode = contract.longcode;
	            tick_display_name = contract.display_name;
	            tick_date_start = contract.date_start;
	            absolute_barrier = contract.barrier;
	            tick_shortcode = contract.shortcode;
	            tick_init = '';
	            var request = {
	                ticks_history: contract.underlying,
	                start: contract.date_start,
	                end: 'latest'
	            };
	            if (contract.current_spot_time < contract.date_expiry) {
	                request.subscribe = 1;
	                subscribe = 'true';
	            } else {
	                request.end = contract.date_expiry;
	            }
	            BinarySocket.send(request, { callback: dispatch });
	        } else {
	            dispatch(data);
	        }
	    };

	    return {
	        init: initialize,
	        updateChart: updateChart,
	        dispatch: dispatch,
	        resetSpots: function resetSpots() {
	            spots_list = {};
	        }
	    };
	}();

	module.exports = TickDisplay;

/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var formatMoney = __webpack_require__(433).formatMoney;

	var updatePurchaseStatus = function updatePurchaseStatus(final_price, pnl, contract_status) {
	    $('#contract_purchase_heading').text(localize(contract_status));
	    var $payout = $('#contract_purchase_payout');
	    var $cost = $('#contract_purchase_cost');
	    var $profit = $('#contract_purchase_profit');
	    var currency = Client.get('currency');

	    $payout.html($('<div/>', { text: localize('Buy price') }).append($('<p/>', { text: formatMoney(currency, Math.abs(pnl), 1) })));
	    $cost.html($('<div/>', { text: localize('Final price') }).append($('<p/>', { text: formatMoney(currency, final_price, 1) })));
	    if (!final_price) {
	        $profit.html($('<div/>', { text: localize('Loss') }).append($('<p/>', { text: formatMoney(currency, pnl, 1) })));
	    } else {
	        $profit.html($('<div/>', { text: localize('Profit') }).append($('<p/>', { text: formatMoney(currency, Math.round((final_price - pnl) * 100) / 100, 1) })));
	        updateContractBalance(Client.get('balance'));
	    }
	};

	var updateContractBalance = function updateContractBalance(balance) {
	    $('#contract_purchase_balance').text(localize('Account balance:') + ' ' + formatMoney(Client.get('currency'), balance));
	};

	module.exports = {
	    updatePurchaseStatus: updatePurchaseStatus,
	    updateContractBalance: updateContractBalance
	};

/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var MBDefaults = __webpack_require__(416);
	var MBNotifications = __webpack_require__(434);
	var BinarySocket = __webpack_require__(427);

	/*
	 * MBTick object handles all the process/display related to tick streaming
	 *
	 * We request tick stream for particular underlying to update current spot
	 *
	 *
	 * Usage:
	 * use `MBTick.detail` to populate this object
	 *
	 * then use
	 *
	 * `MBTick.quote()` to get current spot quote
	 * `MBTick.id()` to get the unique for current stream
	 * `MBTick.epoch()` to get the tick epoch time
	 * 'MBTick.display()` to display current spot
	 */

	var MBTick = function () {
	    'use strict';

	    var _quote = '',
	        _id = '',
	        _epoch = '',
	        _spots = {},
	        error_message = '';
	    var keep_number = 60;

	    var details = function details(data) {
	        error_message = '';

	        if (data) {
	            if (data.error) {
	                error_message = data.error.message;
	            } else {
	                var tick = data.tick;
	                _quote = tick.quote;
	                _id = tick.id;
	                _epoch = tick.epoch;

	                _spots[_epoch] = _quote;
	                var epoches = Object.keys(_spots).sort(function (a, b) {
	                    return a - b;
	                });
	                if (epoches.length > keep_number) {
	                    delete _spots[epoches[0]];
	                }
	            }
	        }
	    };

	    var display = function display() {
	        $('#spot').fadeIn(200);
	        var spot_element = document.getElementById('spot');
	        if (!spot_element) return;
	        var message = '';
	        if (error_message) {
	            message = error_message;
	        } else {
	            message = _quote;
	        }

	        if (parseFloat(message) !== +message) {
	            spot_element.className = 'error';
	        } else {
	            spot_element.classList.remove('error');
	            MBTick.displayPriceMovement(parseFloat(spot_element.textContent), parseFloat(message));
	        }

	        spot_element.textContent = message;
	    };

	    /*
	     * Display price/spot movement variation to depict price moved up or down
	     */
	    var displayPriceMovement = function displayPriceMovement(old_value, current_value) {
	        var class_name = current_value > old_value ? 'up' : current_value < old_value ? 'down' : 'still';
	        $('#spot-dyn').attr('class', 'dynamics ' + class_name);
	    };

	    var chart_config = {
	        type: 'line',
	        lineColor: '#606060',
	        fillColor: false,
	        spotColor: '#00f000',
	        minSpotColor: '#0000f0',
	        maxSpotColor: '#f00000',
	        highlightSpotColor: '#ffff00',
	        highlightLineColor: '#000000',
	        spotRadius: 2,
	        width: 200,
	        height: 25
	    };

	    var $chart = void 0;

	    var updateWarmChart = function updateWarmChart() {
	        $chart = $chart || $('#trading_worm_chart');
	        var spots_array = Object.keys(MBTick.spots()).sort(function (a, b) {
	            return a - b;
	        }).map(function (v) {
	            return MBTick.spots()[v];
	        });
	        if ($chart && typeof $chart.sparkline === 'function') {
	            $chart.sparkline(spots_array, chart_config);
	            if (spots_array.length) {
	                $chart.show();
	            } else {
	                $chart.hide();
	            }
	        }
	    };

	    var request = function request(symbol) {
	        BinarySocket.send({
	            ticks_history: symbol,
	            style: 'ticks',
	            end: 'latest',
	            count: keep_number,
	            subscribe: 1
	        }, { callback: processTickHistory });
	    };

	    var processTickHistory = function processTickHistory(response) {
	        if (response.msg_type === 'tick') {
	            if (response.hasOwnProperty('error')) {
	                MBNotifications.show({ text: response.error.message, uid: 'TICK_ERROR' });
	                return;
	            }
	            var symbol = MBDefaults.get('underlying');
	            if (response.echo_req.ticks === symbol || response.tick && response.tick.symbol === symbol) {
	                MBTick.details(response);
	                MBTick.display();
	                MBTick.updateWarmChart();
	            }
	        } else if (response.history && response.history.times && response.history.prices) {
	            for (var i = 0; i < response.history.times.length; i++) {
	                details({
	                    tick: {
	                        epoch: response.history.times[i],
	                        quote: response.history.prices[i]
	                    }
	                });
	            }
	        }
	    };

	    return {
	        details: details,
	        display: display,
	        updateWarmChart: updateWarmChart,
	        request: request,
	        quote: function quote() {
	            return _quote;
	        },
	        id: function id() {
	            return _id;
	        },
	        epoch: function epoch() {
	            return _epoch;
	        },
	        errorMessage: function errorMessage() {
	            return error_message;
	        },
	        spots: function spots() {
	            return _spots;
	        },
	        setQuote: function setQuote(q) {
	            _quote = q;
	        },
	        clean: function clean() {
	            _spots = {};
	            _quote = '';
	            $chart = null;
	            $('#spot').fadeOut(200, function () {
	                // resets spot movement coloring, will continue on the next tick responses
	                $('#spot-dyn').removeAttr('class').text('');
	            });
	        },
	        displayPriceMovement: displayPriceMovement,
	        processTickHistory: processTickHistory
	    };
	}();

	module.exports = MBTick;

/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var jpClient = __webpack_require__(425).jpClient;
	var BinarySocket = __webpack_require__(427);

	var Clock = function () {
	    'use strict';

	    var clock_started = false,
	        client_time = void 0,
	        timeout = void 0;

	    var showLocalTimeOnHover = function showLocalTimeOnHover(s) {
	        if (jpClient()) return;
	        $(s || '.date').each(function (idx, ele) {
	            var gmt_time_str = ele.textContent.replace('\n', ' ');
	            var local_time = moment.utc(gmt_time_str, 'YYYY-MM-DD HH:mm:ss').local();
	            if (local_time.isValid()) {
	                $(ele).attr('data-balloon', local_time.format('YYYY-MM-DD HH:mm:ss Z'));
	            }
	        });
	    };

	    var toJapanTimeIfNeeded = function toJapanTimeIfNeeded(gmt_time_str, show_time_zone, longcode, hide_seconds) {
	        var match = void 0;
	        if (longcode && longcode !== '') {
	            match = longcode.match(/((?:\d{4}-\d{2}-\d{2})\s?(\d{2}:\d{2}:\d{2})?(?:\sGMT)?)/);
	            if (!match) return longcode;
	        }

	        var time = void 0;
	        if (typeof gmt_time_str === 'number') {
	            time = moment.utc(gmt_time_str * 1000);
	        } else if (gmt_time_str) {
	            time = moment.utc(gmt_time_str, 'YYYY-MM-DD HH:mm:ss');
	        } else {
	            time = moment.utc(match[0], 'YYYY-MM-DD HH:mm:ss');
	        }

	        if (!time.isValid()) {
	            return null;
	        }

	        var jp_client = jpClient();
	        var time_str = time.utcOffset(jp_client ? '+09:00' : '+00:00').format((hide_seconds ? 'YYYY-MM-DD HH:mm' : 'YYYY-MM-DD HH:mm:ss') + (show_time_zone && show_time_zone !== '' ? jp_client ? ' zZ' : ' Z' : ''));

	        return longcode ? longcode.replace(match[0], time_str) : time_str;
	    };

	    var startClock = function startClock() {
	        if (!clock_started) {
	            var getTime = function getTime() {
	                clock_started = true;
	                client_time = moment().valueOf();
	                BinarySocket.send({ time: 1 }).then(function (response) {
	                    timeCounter(response);
	                });
	            };
	            setInterval(getTime, 30000);
	            getTime();
	        }
	    };

	    var timeCounter = function timeCounter(response) {
	        if (isNaN(client_time) || response.error) {
	            startClock();
	            return;
	        }
	        clearTimeout(timeout);
	        var $clock = $('#gmt-clock');
	        var start_timestamp = response.time;

	        var client_time_at_response = moment().valueOf();
	        var server_time_at_response = start_timestamp * 1000 + (client_time_at_response - client_time);

	        var updateTime = function updateTime() {
	            window.time = moment(server_time_at_response + moment().valueOf() - client_time_at_response).utc();
	            var time_str = window.time.format('YYYY-MM-DD HH:mm') + ' GMT';
	            if (jpClient()) {
	                $clock.html(toJapanTimeIfNeeded(time_str, 1, '', 1));
	            } else {
	                $clock.html(time_str);
	                showLocalTimeOnHover('#gmt-clock');
	            }
	            timeout = setTimeout(updateTime, 1000);
	        };
	        updateTime();
	    };

	    return {
	        startClock: startClock,
	        showLocalTimeOnHover: showLocalTimeOnHover,
	        toJapanTimeIfNeeded: toJapanTimeIfNeeded
	    };
	}();

	module.exports = Clock;

/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var moment = __webpack_require__(305);
	var Client = __webpack_require__(420);
	var getLanguage = __webpack_require__(424).get;
	var Login = __webpack_require__(465);
	var State = __webpack_require__(421).State;
	var isVisible = __webpack_require__(430).isVisible;
	var getAppId = __webpack_require__(431).getAppId;
	var Cookies = __webpack_require__(422);

	var GTM = function () {
	    'use strict';

	    var isGtmApplicable = function isGtmApplicable() {
	        return (/^(1|1098)$/.test(getAppId())
	        );
	    };

	    var gtmDataLayerInfo = function gtmDataLayerInfo(data) {
	        var data_layer_info = {
	            language: getLanguage(),
	            pageTitle: pageTitle(),
	            pjax: State.get('is_loaded_by_pjax'),
	            url: document.URL,
	            event: 'page_load'
	        };
	        if (Client.isLoggedIn()) {
	            data_layer_info.visitorId = Client.get('loginid');
	        }

	        $.extend(true, data_layer_info, data);

	        var event = data_layer_info.event;
	        delete data_layer_info.event;

	        return {
	            data: data_layer_info,
	            event: event
	        };
	    };

	    var pushDataLayer = function pushDataLayer(data) {
	        if (isGtmApplicable() && !Login.isLoginPages()) {
	            var info = gtmDataLayerInfo(data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' ? data : null);
	            dataLayer[0] = info.data;
	            dataLayer.push(info.data);
	            dataLayer.push({ event: info.event });
	        }
	    };

	    var pageTitle = function pageTitle() {
	        var t = /^.+[:-]\s*(.+)$/.exec(document.title);
	        return t && t[1] ? t[1] : document.title;
	    };

	    var eventHandler = function eventHandler(get_settings) {
	        if (!isGtmApplicable()) return;
	        var is_login = localStorage.getItem('GTM_login') === '1';
	        var is_new_account = localStorage.getItem('GTM_new_account') === '1';
	        if (!is_login && !is_new_account) return;

	        localStorage.removeItem('GTM_login');
	        localStorage.removeItem('GTM_new_account');

	        var affiliate_token = Cookies.getJSON('affiliate_tracking');
	        if (affiliate_token) {
	            pushDataLayer({ bom_affiliate_token: affiliate_token.t });
	        }

	        var data = {
	            visitorId: Client.get('loginid'),
	            bom_country: get_settings.country,
	            bom_email: get_settings.email,
	            url: window.location.href,
	            bom_today: Math.floor(Date.now() / 1000),
	            event: is_new_account ? 'new_account' : 'log_in'
	        };
	        if (is_new_account) {
	            data.bom_date_joined = data.bom_today;
	        }
	        if (!Client.get('is_virtual')) {
	            data.bom_age = parseInt((moment().unix() - get_settings.date_of_birth) / 31557600);
	            data.bom_firstname = get_settings.first_name;
	            data.bom_lastname = get_settings.last_name;
	            data.bom_phone = get_settings.phone;
	        }
	        pushDataLayer(data);
	    };

	    var pushPurchaseData = function pushPurchaseData(response) {
	        if (!isGtmApplicable() || Client.get('is_virtual')) return;
	        var buy = response.buy;
	        if (!buy) return;
	        var req = response.echo_req.passthrough;
	        var data = {
	            event: 'buy_contract',
	            visitorId: Client.get('loginid'),
	            bom_symbol: req.symbol,
	            bom_market: document.getElementById('contract_markets').value,
	            bom_currency: req.currency,
	            bom_contract_type: req.contract_type,
	            bom_contract_id: buy.contract_id,
	            bom_transaction_id: buy.transaction_id,
	            bom_buy_price: buy.buy_price,
	            bom_payout: buy.payout
	        };
	        $.extend(data, {
	            bom_amount: req.amount,
	            bom_basis: req.basis,
	            bom_expiry_type: document.getElementById('expiry_type').value
	        });
	        if (data.bom_expiry_type === 'duration') {
	            $.extend(data, {
	                bom_duration: req.duration,
	                bom_duration_unit: req.duration_unit
	            });
	        }
	        if (isVisible(document.getElementById('barrier'))) {
	            data.bom_barrier = req.barrier;
	        } else if (isVisible(document.getElementById('barrier_high'))) {
	            data.bom_barrier_high = req.barrier;
	            data.bom_barrier_low = req.barrier2;
	        }
	        if (isVisible(document.getElementById('prediction'))) {
	            data.bom_prediction = req.barrier;
	        }

	        pushDataLayer(data);
	    };

	    return {
	        pushDataLayer: pushDataLayer,
	        eventHandler: eventHandler,
	        pushPurchaseData: pushPurchaseData,
	        setLoginFlag: function setLoginFlag() {
	            if (isGtmApplicable()) localStorage.setItem('GTM_login', '1');
	        }
	    };
	}();

	module.exports = GTM;

/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);
	var getLanguage = __webpack_require__(424).get;
	var getAppId = __webpack_require__(431).getAppId;

	var Login = function () {
	    'use strict';

	    var redirectToLogin = function redirectToLogin() {
	        if (!Client.isLoggedIn() && !isLoginPages()) {
	            try {
	                sessionStorage.setItem('redirect_url', window.location.href);
	            } catch (e) {
	                window.alert('The website needs features which are not enabled on private mode browsing. Please use normal mode.');
	            }
	            window.location.href = loginUrl();
	        }
	    };

	    var loginUrl = function loginUrl() {
	        var server_url = localStorage.getItem('config.server_url');
	        var language = getLanguage();
	        return server_url && /qa/.test(server_url) ? 'https://www.' + server_url.split('.')[1] + '.com/oauth2/authorize?app_id=' + getAppId() + '&l=' + language : 'https://oauth.binary.com/oauth2/authorize?app_id=' + getAppId() + '&l=' + language;
	    };

	    var isLoginPages = function isLoginPages() {
	        return (/logged_inws/.test(document.URL)
	        );
	    };

	    return {
	        redirectToLogin: redirectToLogin,
	        isLoginPages: isLoginPages,
	        loginUrl: loginUrl
	    };
	}();

	module.exports = Login;

/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinaryPjax = __webpack_require__(467);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var defaultRedirectUrl = __webpack_require__(423).defaultRedirectUrl;
	var template = __webpack_require__(417).template;
	var jpClient = __webpack_require__(425).jpClient;
	var jpResidence = __webpack_require__(425).jpResidence;
	var BinarySocket = __webpack_require__(427);

	var CashierJP = function () {
	    'use strict';

	    var _onLoad = function _onLoad(action) {
	        if (jpClient() && !jpResidence()) BinaryPjax.load(defaultRedirectUrl());
	        var $container = $('#japan_cashier_container');
	        BinarySocket.wait('get_settings').then(function () {
	            $container.setVisibility(1);
	            if (action === 'deposit') {
	                $('#name_id').text((Client.get('loginid') || 'JP12345') + ' ' + (Client.get('first_name') || 'Joe Bloggs'));
	            } else if (action === 'withdraw') {
	                $('#id123-control22598118').val(Client.get('loginid'));
	                $('#id123-control22598060').val(Client.get('email'));
	            }
	        });
	    };

	    var errorHandler = function errorHandler() {
	        $('.error-msg').remove();
	        var $id = $('#id123-control22598145');
	        var withdrawal_amount = $id.val();

	        var showError = function showError(message) {
	            $id.parent().append($('<p/>', { class: 'error-msg', text: localize(message) }));
	        };

	        if (!/^([1-9][0-9]{0,5}|1000000)$/.test(withdrawal_amount)) {
	            showError(template('Please enter a number between [_1].', ['¥1 - ¥1,000,000']));
	            return false;
	        } else if (parseInt(Client.get('balance')) < withdrawal_amount) {
	            showError('Insufficient balance.');
	            return false;
	        }
	        return true;
	    };

	    return {
	        errorHandler: errorHandler,
	        Deposit: { onLoad: function onLoad() {
	                _onLoad('deposit');
	            } },
	        Withdraw: { onLoad: function onLoad() {
	                _onLoad('withdraw');
	            } }
	    };
	}();

	module.exports = CashierJP;

/***/ },
/* 467 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var getLanguage = __webpack_require__(424).get;
	var State = __webpack_require__(421).State;
	var urlFor = __webpack_require__(423).urlFor;

	var BinaryPjax = function () {
	    'use strict';

	    var xhr = void 0;
	    var params = {};
	    var defaults = {
	        type: 'GET',
	        dataType: 'html'
	    };
	    var cache = {};

	    var init = function init(container, content_selector) {
	        if (!(window.history && window.history.pushState && window.history.replaceState &&
	        // pushState isn't reliable on iOS until 5.
	        !navigator.userAgent.match(/((iPod|iPhone|iPad).+\bOS\s+[1-4]\D|WebApps\/.+CFNetwork)/))) {
	            console.error('Unable to initialize router');
	            return;
	        }

	        container = $(container);

	        if (!container.length) {
	            console.warn('Could not find container');
	            return;
	        }

	        if (!(content_selector && content_selector.length)) {
	            console.warn('No content selector provided');
	            return;
	        }

	        params.container = container;
	        params.content_selector = content_selector;

	        var url = window.location.href;
	        var title = document.title;
	        var content = container.find(content_selector);

	        // put current content to cache, so we won't need to load it again
	        if (title && content && content.length) {
	            window.history.replaceState({ url: url }, title, url);
	            setDataPage(content, url);
	            params.container.trigger('binarypjax:after', content);
	        }

	        $(document).find('#all-accounts a').on('click', handleClick);
	        $(document).on('click', 'a', handleClick);
	        $(window).on('popstate', handlePopstate);
	    };

	    var setDataPage = function setDataPage(content, url) {
	        content.attr('data-page', url.match('.+\/(.+)\.html.*')[1]);
	    };

	    var handleClick = function handleClick(event) {
	        var link = event.currentTarget;
	        var url = link.href;

	        if (url.length <= 0) {
	            return;
	        }

	        // Exclude links having 'no-ajax' class or target="_blank" or not html
	        if (link.classList.contains('no-ajax') || link.target === '_blank' || !/\.html/i.test(url)) {
	            return;
	        }

	        // Middle click, cmd click, and ctrl click should open links in a new tab as normal
	        if (event.which > 1 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) {
	            return;
	        }

	        // Ignore cross origin links
	        if (location.protocol !== link.protocol || location.hostname !== link.hostname) {
	            return;
	        }

	        // Ignore event with default prevented
	        if (event.isDefaultPrevented()) {
	            return;
	        }

	        event.preventDefault();
	        // check if url is not same as current
	        if (location.href !== url) {
	            processUrl(url);
	        }
	    };

	    var processUrl = function processUrl(url, replace) {
	        State.set('is_loaded_by_pjax', true);

	        if (!/^http/i.test(url)) {
	            url = urlFor(url);
	        }
	        var cached_content = cacheGet(url);
	        if (cached_content) {
	            replaceContent(url, cached_content, replace);
	        } else {
	            load(url, replace);
	        }
	    };

	    /**
	     * Load url from server
	     */
	    var load = function load(url, replace) {
	        var lang = getLanguage();
	        var options = $.extend(true, {}, $.ajaxSettings, defaults, {
	            url: url.replace(new RegExp('/' + lang + '/', 'i'), '/' + lang.toLowerCase() + '/pjax/') });

	        options.success = function (data) {
	            var result = {};

	            result.title = $(data).find('title').text().trim();
	            result.content = $('<div/>', { html: data }).find(params.content_selector);

	            // If failed to find title or content, load the page in traditional way
	            if (result.title.length === 0 || result.content.length === 0) {
	                locationReplace(url);
	                return;
	            }

	            setDataPage(result.content, url);
	            cachePut(url, result);
	            replaceContent(url, result, replace);
	        };

	        // Cancel the current request if we're already loading some page
	        abortXHR(xhr);

	        xhr = $.ajax(options);
	    };

	    var handlePopstate = function handlePopstate(e) {
	        var url = e.originalEvent.state ? e.originalEvent.state.url : window.location.href;
	        if (url) {
	            processUrl(url, true);
	        }
	        return false;
	    };

	    var replaceContent = function replaceContent(url, content, replace) {
	        window.history[replace ? 'replaceState' : 'pushState']({ url: url }, content.title, url);

	        params.container.trigger('binarypjax:before');

	        document.title = content.title;
	        params.container.find(params.content_selector).remove();
	        params.container.append(content.content.clone());

	        params.container.trigger('binarypjax:after', content.content);
	        $.scrollTo('body', 500);
	    };

	    var abortXHR = function abortXHR(xhr_obj) {
	        if (xhr_obj && xhr_obj.readyState < 4) {
	            xhr_obj.abort();
	        }
	    };

	    var cachePut = function cachePut(url, content) {
	        cache[cleanUrl(url)] = content;
	    };

	    var cacheGet = function cacheGet(url) {
	        return cache[cleanUrl(url)];
	    };

	    var cleanUrl = function cleanUrl(url) {
	        return url.replace(/(\?|#).*$/, '');
	    };

	    var locationReplace = function locationReplace(url) {
	        window.history.replaceState(null, '', url);
	        window.location.replace(url);
	    };

	    return {
	        init: init,
	        load: processUrl
	    };
	}();

	module.exports = BinaryPjax;

/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var urlForStatic = __webpack_require__(423).urlForStatic;

	var check_new_release = function check_new_release() {
	    // calling this method is handled by GTM tags
	    var last_reload = localStorage.getItem('new_release_reload_time');
	    // prevent reload in less than 10 minutes
	    if (last_reload && +last_reload + 10 * 60 * 1000 > moment().valueOf()) return;
	    localStorage.setItem('new_release_reload_time', moment().valueOf());
	    var currect_hash = ($('script[src*="binary.min.js"],script[src*="binary.js"]').attr('src') || '').split('?')[1];
	    var xhttp = new XMLHttpRequest();
	    xhttp.onreadystatechange = function () {
	        if (+xhttp.readyState === 4 && +xhttp.status === 200) {
	            var latest_hash = xhttp.responseText;
	            if (latest_hash && currect_hash && latest_hash !== currect_hash) {
	                window.location.reload(true);
	            }
	        }
	    };
	    xhttp.open('GET', urlForStatic() + 'version?' + Math.random().toString(36).slice(2), true);
	    xhttp.send();
	};

	module.exports = {
	    check_new_release: check_new_release
	};

/***/ },
/* 469 */
/***/ function(module, exports) {

	/** @license
	 * eventsource.js
	 * Available under MIT License (MIT)
	 * https://github.com/Yaffle/EventSource/
	 */

	/*jslint indent: 2, vars: true, plusplus: true */
	/*global setTimeout, clearTimeout */

	(function (global) {
	  "use strict";

	  var setTimeout = global.setTimeout;
	  var clearTimeout = global.clearTimeout;

	  function Map() {
	    this.data = {};
	  }

	  Map.prototype.get = function (key) {
	    return this.data[key + "~"];
	  };
	  Map.prototype.set = function (key, value) {
	    this.data[key + "~"] = value;
	  };
	  Map.prototype["delete"] = function (key) {
	    delete this.data[key + "~"];
	  };

	  function EventTarget() {
	    this.listeners = new Map();
	  }

	  function throwError(e) {
	    setTimeout(function () {
	      throw e;
	    }, 0);
	  }

	  EventTarget.prototype.dispatchEvent = function (event) {
	    event.target = this;
	    var type = event.type.toString();
	    var listeners = this.listeners;
	    var typeListeners = listeners.get(type);
	    if (typeListeners == undefined) {
	      return;
	    }
	    var length = typeListeners.length;
	    var i = -1;
	    var listener = undefined;
	    while (++i < length) {
	      listener = typeListeners[i];
	      try {
	        listener.call(this, event);
	      } catch (e) {
	        throwError(e);
	      }
	    }
	  };
	  EventTarget.prototype.addEventListener = function (type, callback) {
	    type = type.toString();
	    var listeners = this.listeners;
	    var typeListeners = listeners.get(type);
	    if (typeListeners == undefined) {
	      typeListeners = [];
	      listeners.set(type, typeListeners);
	    }
	    var i = typeListeners.length;
	    while (--i >= 0) {
	      if (typeListeners[i] === callback) {
	        return;
	      }
	    }
	    typeListeners.push(callback);
	  };
	  EventTarget.prototype.removeEventListener = function (type, callback) {
	    type = type.toString();
	    var listeners = this.listeners;
	    var typeListeners = listeners.get(type);
	    if (typeListeners == undefined) {
	      return;
	    }
	    var length = typeListeners.length;
	    var filtered = [];
	    var i = -1;
	    while (++i < length) {
	      if (typeListeners[i] !== callback) {
	        filtered.push(typeListeners[i]);
	      }
	    }
	    if (filtered.length === 0) {
	      listeners["delete"](type);
	    } else {
	      listeners.set(type, filtered);
	    }
	  };

	  function Event(type) {
	    this.type = type;
	    this.target = undefined;
	  }

	  function MessageEvent(type, options) {
	    Event.call(this, type);
	    this.data = options.data;
	    this.lastEventId = options.lastEventId;
	  }

	  MessageEvent.prototype = Event.prototype;

	  var XHR = global.XMLHttpRequest;
	  var XDR = global.XDomainRequest;
	  var isCORSSupported = XHR != undefined && (new XHR()).withCredentials != undefined;
	  var Transport = isCORSSupported || (XHR != undefined && XDR == undefined) ? XHR : XDR;

	  var WAITING = -1;
	  var CONNECTING = 0;
	  var OPEN = 1;
	  var CLOSED = 2;
	  var AFTER_CR = 3;
	  var FIELD_START = 4;
	  var FIELD = 5;
	  var VALUE_START = 6;
	  var VALUE = 7;
	  var contentTypeRegExp = /^text\/event\-stream;?(\s*charset\=utf\-8)?$/i;

	  var MINIMUM_DURATION = 1000;
	  var MAXIMUM_DURATION = 18000000;

	  function getDuration(value, def) {
	    var n = value;
	    if (n !== n) {
	      n = def;
	    }
	    return (n < MINIMUM_DURATION ? MINIMUM_DURATION : (n > MAXIMUM_DURATION ? MAXIMUM_DURATION : n));
	  }

	  function fire(that, f, event) {
	    try {
	      if (typeof f === "function") {
	        f.call(that, event);
	      }
	    } catch (e) {
	      throwError(e);
	    }
	  }

	  function EventSource(url, options) {
	    url = url.toString();

	    var withCredentials = isCORSSupported && options != undefined && Boolean(options.withCredentials);
	    var initialRetry = getDuration(1000, 0);
	    var heartbeatTimeout = getDuration(45000, 0);

	    var lastEventId = "";
	    var that = this;
	    var retry = initialRetry;
	    var wasActivity = false;
	    var CurrentTransport = options != undefined && options.Transport != undefined ? options.Transport : Transport;
	    var xhr = new CurrentTransport();
	    var timeout = 0;
	    var timeout0 = 0;
	    var charOffset = 0;
	    var currentState = WAITING;
	    var dataBuffer = [];
	    var lastEventIdBuffer = "";
	    var eventTypeBuffer = "";
	    var onTimeout = undefined;

	    var state = FIELD_START;
	    var field = "";
	    var value = "";

	    function close() {
	      currentState = CLOSED;
	      if (xhr != undefined) {
	        xhr.abort();
	        xhr = undefined;
	      }
	      if (timeout !== 0) {
	        clearTimeout(timeout);
	        timeout = 0;
	      }
	      if (timeout0 !== 0) {
	        clearTimeout(timeout0);
	        timeout0 = 0;
	      }
	      that.readyState = CLOSED;
	    }

	    function onEvent(type) {
	      var responseText = "";
	      if (currentState === OPEN || currentState === CONNECTING) {
	        try {
	          responseText = xhr.responseText;
	        } catch (error) {
	          // IE 8 - 9 with XMLHttpRequest
	        }
	      }
	      var event = undefined;
	      var isWrongStatusCodeOrContentType = false;

	      if (currentState === CONNECTING) {
	        var status = 0;
	        var statusText = "";
	        var contentType = undefined;
	        if (!("contentType" in xhr)) {
	          try {
	            status = xhr.status;
	            statusText = xhr.statusText;
	            contentType = xhr.getResponseHeader("Content-Type");
	          } catch (error) {
	            // https://bugs.webkit.org/show_bug.cgi?id=29121
	            status = 0;
	            statusText = "";
	            contentType = undefined;
	            // FF < 14, WebKit
	            // https://bugs.webkit.org/show_bug.cgi?id=29658
	            // https://bugs.webkit.org/show_bug.cgi?id=77854
	          }
	        } else if (type !== "" && type !== "error") {
	          status = 200;
	          statusText = "OK";
	          contentType = xhr.contentType;
	        }
	        if (contentType == undefined) {
	          contentType = "";
	        }
	        if (status === 0 && statusText === "" && type === "load" && responseText !== "") {
	          status = 200;
	          statusText = "OK";
	          if (contentType === "") { // Opera 12
	            var tmp = (/^data\:([^,]*?)(?:;base64)?,[\S]*$/).exec(url);
	            if (tmp != undefined) {
	              contentType = tmp[1];
	            }
	          }
	        }
	        if (status === 200 && contentTypeRegExp.test(contentType)) {
	          currentState = OPEN;
	          wasActivity = true;
	          retry = initialRetry;
	          that.readyState = OPEN;
	          event = new Event("open");
	          that.dispatchEvent(event);
	          fire(that, that.onopen, event);
	          if (currentState === CLOSED) {
	            return;
	          }
	        } else {
	          // Opera 12
	          if (status !== 0 && (status !== 200 || contentType !== "")) {
	            var message = "";
	            if (status !== 200) {
	              message = "EventSource's response has a status " + status + " " + statusText.replace(/\s+/g, " ") + " that is not 200. Aborting the connection.";
	            } else {
	              message = "EventSource's response has a Content-Type specifying an unsupported type: " + contentType.replace(/\s+/g, " ") + ". Aborting the connection.";
	            }
	            setTimeout(function () {
	              throw new Error(message);
	            }, 0);
	            isWrongStatusCodeOrContentType = true;
	          }
	        }
	      }

	      if (currentState === OPEN) {
	        if (responseText.length > charOffset) {
	          wasActivity = true;
	        }
	        var i = charOffset - 1;
	        var length = responseText.length;
	        var c = "\n";
	        while (++i < length) {
	          c = responseText.charAt(i);
	          if (state === AFTER_CR && c === "\n") {
	            state = FIELD_START;
	          } else {
	            if (state === AFTER_CR) {
	              state = FIELD_START;
	            }
	            if (c === "\r" || c === "\n") {
	              if (field === "data") {
	                dataBuffer.push(value);
	              } else if (field === "id") {
	                lastEventIdBuffer = value;
	              } else if (field === "event") {
	                eventTypeBuffer = value;
	              } else if (field === "retry") {
	                initialRetry = getDuration(Number(value), initialRetry);
	                retry = initialRetry;
	              } else if (field === "heartbeatTimeout") {
	                heartbeatTimeout = getDuration(Number(value), heartbeatTimeout);
	                if (timeout !== 0) {
	                  clearTimeout(timeout);
	                  timeout = setTimeout(onTimeout, heartbeatTimeout);
	                }
	              }
	              value = "";
	              field = "";
	              if (state === FIELD_START) {
	                if (dataBuffer.length !== 0) {
	                  lastEventId = lastEventIdBuffer;
	                  if (eventTypeBuffer === "") {
	                    eventTypeBuffer = "message";
	                  }
	                  event = new MessageEvent(eventTypeBuffer, {
	                    data: dataBuffer.join("\n"),
	                    lastEventId: lastEventIdBuffer
	                  });
	                  that.dispatchEvent(event);
	                  if (eventTypeBuffer === "message") {
	                    fire(that, that.onmessage, event);
	                  }
	                  if (currentState === CLOSED) {
	                    return;
	                  }
	                }
	                dataBuffer.length = 0;
	                eventTypeBuffer = "";
	              }
	              state = c === "\r" ? AFTER_CR : FIELD_START;
	            } else {
	              if (state === FIELD_START) {
	                state = FIELD;
	              }
	              if (state === FIELD) {
	                if (c === ":") {
	                  state = VALUE_START;
	                } else {
	                  field += c;
	                }
	              } else if (state === VALUE_START) {
	                if (c !== " ") {
	                  value += c;
	                }
	                state = VALUE;
	              } else if (state === VALUE) {
	                value += c;
	              }
	            }
	          }
	        }
	        charOffset = length;
	      }

	      if ((currentState === OPEN || currentState === CONNECTING) &&
	          (type === "load" || type === "error" || isWrongStatusCodeOrContentType || (charOffset > 1024 * 1024) || (timeout === 0 && !wasActivity))) {
	        if (isWrongStatusCodeOrContentType) {
	          close();
	        } else {
	          if (type === "" && timeout === 0 && !wasActivity) {
	            setTimeout(function () {
	              throw new Error("No activity within " + heartbeatTimeout + " milliseconds. Reconnecting.");
	            }, 0);
	          }
	          currentState = WAITING;
	          xhr.abort();
	          if (timeout !== 0) {
	            clearTimeout(timeout);
	            timeout = 0;
	          }
	          if (retry > initialRetry * 16) {
	            retry = initialRetry * 16;
	          }
	          if (retry > MAXIMUM_DURATION) {
	            retry = MAXIMUM_DURATION;
	          }
	          timeout = setTimeout(onTimeout, retry);
	          retry = retry * 2 + 1;

	          that.readyState = CONNECTING;
	        }
	        event = new Event("error");
	        that.dispatchEvent(event);
	        fire(that, that.onerror, event);
	      } else {
	        if (timeout === 0) {
	          wasActivity = false;
	          timeout = setTimeout(onTimeout, heartbeatTimeout);
	        }
	      }
	    }

	    function onProgress() {
	      onEvent("progress");
	    }

	    function onLoad() {
	      onEvent("load");
	    }

	    function onError() {
	      onEvent("error");
	    }

	    function onReadyStateChange() {
	      if (xhr.readyState === 4) {
	        if (xhr.status === 0) {
	          onEvent("error");
	        } else {
	          onEvent("load");
	        }
	      } else {
	        onEvent("progress");
	      }
	    }

	    if (("readyState" in xhr) && global.opera != undefined) {
	      // workaround for Opera issue with "progress" events
	      timeout0 = setTimeout(function f() {
	        if (xhr.readyState === 3) {
	          onEvent("progress");
	        }
	        timeout0 = setTimeout(f, 500);
	      }, 0);
	    }

	    onTimeout = function () {
	      timeout = 0;
	      if (currentState !== WAITING) {
	        onEvent("");
	        return;
	      }

	      // loading indicator in Safari, Chrome < 14
	      // loading indicator in Firefox
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=736723
	      if ((!("ontimeout" in xhr) || ("sendAsBinary" in xhr) || ("mozAnon" in xhr)) && global.document != undefined && global.document.readyState != undefined && global.document.readyState !== "complete") {
	        timeout = setTimeout(onTimeout, 4);
	        return;
	      }

	      // XDomainRequest#abort removes onprogress, onerror, onload
	      xhr.onload = onLoad;
	      xhr.onerror = onError;

	      if ("onabort" in xhr) {
	        // improper fix to match Firefox behaviour, but it is better than just ignore abort
	        // see https://bugzilla.mozilla.org/show_bug.cgi?id=768596
	        // https://bugzilla.mozilla.org/show_bug.cgi?id=880200
	        // https://code.google.com/p/chromium/issues/detail?id=153570
	        xhr.onabort = onError;
	      }

	      if ("onprogress" in xhr) {
	        xhr.onprogress = onProgress;
	      }
	      // IE 8-9 (XMLHTTPRequest)
	      // Firefox 3.5 - 3.6 - ? < 9.0
	      // onprogress is not fired sometimes or delayed
	      // see also #64
	      if ("onreadystatechange" in xhr) {
	        xhr.onreadystatechange = onReadyStateChange;
	      }

	      wasActivity = false;
	      timeout = setTimeout(onTimeout, heartbeatTimeout);

	      charOffset = 0;
	      currentState = CONNECTING;
	      dataBuffer.length = 0;
	      eventTypeBuffer = "";
	      lastEventIdBuffer = lastEventId;
	      value = "";
	      field = "";
	      state = FIELD_START;

	      var s = url.slice(0, 5);
	      if (s !== "data:" && s !== "blob:") {
	        s = url + ((url.indexOf("?", 0) === -1 ? "?" : "&") + "lastEventId=" + encodeURIComponent(lastEventId) + "&r=" + (Math.random() + 1).toString().slice(2));
	      } else {
	        s = url;
	      }
	      xhr.open("GET", s, true);

	      if ("withCredentials" in xhr) {
	        // withCredentials should be set after "open" for Safari and Chrome (< 19 ?)
	        xhr.withCredentials = withCredentials;
	      }

	      if ("responseType" in xhr) {
	        xhr.responseType = "text";
	      }

	      if ("setRequestHeader" in xhr) {
	        // Request header field Cache-Control is not allowed by Access-Control-Allow-Headers.
	        // "Cache-control: no-cache" are not honored in Chrome and Firefox
	        // https://bugzilla.mozilla.org/show_bug.cgi?id=428916
	        //xhr.setRequestHeader("Cache-Control", "no-cache");
	        xhr.setRequestHeader("Accept", "text/event-stream");
	        // Request header field Last-Event-ID is not allowed by Access-Control-Allow-Headers.
	        //xhr.setRequestHeader("Last-Event-ID", lastEventId);
	      }

	      xhr.send(undefined);
	    };

	    EventTarget.call(this);
	    this.close = close;
	    this.url = url;
	    this.readyState = CONNECTING;
	    this.withCredentials = withCredentials;

	    this.onopen = undefined;
	    this.onmessage = undefined;
	    this.onerror = undefined;

	    onTimeout();
	  }

	  function F() {
	    this.CONNECTING = CONNECTING;
	    this.OPEN = OPEN;
	    this.CLOSED = CLOSED;
	  }
	  F.prototype = EventTarget.prototype;

	  EventSource.prototype = new F();
	  F.call(EventSource);
	  if (isCORSSupported) {
	    EventSource.prototype.withCredentials = undefined;
	  }

	  var isEventSourceSupported = function () {
	    // Opera 12 fails this test, but this is fine.
	    return global.EventSource != undefined && ("withCredentials" in global.EventSource.prototype);
	  };

	  if (Transport != undefined && (global.EventSource == undefined || (isCORSSupported && !isEventSourceSupported()))) {
	    // Why replace a native EventSource ?
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=444328
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=831392
	    // https://code.google.com/p/chromium/issues/detail?id=260144
	    // https://code.google.com/p/chromium/issues/detail?id=225654
	    // ...
	    global.NativeEventSource = global.EventSource;
	    global.EventSource = EventSource;
	  }

	}(typeof window !== 'undefined' ? window : this));


/***/ },
/* 470 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	*
	* jquery.sparkline.js
	*
	* v@VERSION@
	* (c) Splunk, Inc
	* Contact: Gareth Watts (gareth@splunk.com)
	* http://omnipotent.net/jquery.sparkline/
	*
	* Generates inline sparkline charts from data supplied either to the method
	* or inline in HTML
	*
	* Compatible with Internet Explorer 6.0+ and modern browsers equipped with the canvas tag
	* (Firefox 2.0+, Safari, Opera, etc)
	*
	* License: New BSD License
	*
	* Copyright (c) 2012, Splunk Inc.
	* All rights reserved.
	*
	* Redistribution and use in source and binary forms, with or without modification,
	* are permitted provided that the following conditions are met:
	*
	*     * Redistributions of source code must retain the above copyright notice,
	*       this list of conditions and the following disclaimer.
	*     * Redistributions in binary form must reproduce the above copyright notice,
	*       this list of conditions and the following disclaimer in the documentation
	*       and/or other materials provided with the distribution.
	*     * Neither the name of Splunk Inc nor the names of its contributors may
	*       be used to endorse or promote products derived from this software without
	*       specific prior written permission.
	*
	* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
	* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
	* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
	* SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
	* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
	* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*
	*
	* Usage:
	*  $(selector).sparkline(values, options)
	*
	* If values is undefined or set to 'html' then the data values are read from the specified tag:
	*   <p>Sparkline: <span class="sparkline">1,4,6,6,8,5,3,5</span></p>
	*   $('.sparkline').sparkline();
	* There must be no spaces in the enclosed data set
	*
	* Otherwise values must be an array of numbers or null values
	*    <p>Sparkline: <span id="sparkline1">This text replaced if the browser is compatible</span></p>
	*    $('#sparkline1').sparkline([1,4,6,6,8,5,3,5])
	*    $('#sparkline2').sparkline([1,4,6,null,null,5,3,5])
	*
	* Values can also be specified in an HTML comment, or as a values attribute:
	*    <p>Sparkline: <span class="sparkline"><!--1,4,6,6,8,5,3,5 --></span></p>
	*    <p>Sparkline: <span class="sparkline" values="1,4,6,6,8,5,3,5"></span></p>
	*    $('.sparkline').sparkline();
	*
	* For line charts, x values can also be specified:
	*   <p>Sparkline: <span class="sparkline">1:1,2.7:4,3.4:6,5:6,6:8,8.7:5,9:3,10:5</span></p>
	*    $('#sparkline1').sparkline([ [1,1], [2.7,4], [3.4,6], [5,6], [6,8], [8.7,5], [9,3], [10,5] ])
	*
	* By default, options should be passed in as the second argument to the sparkline function:
	*   $('.sparkline').sparkline([1,2,3,4], {type: 'bar'})
	*
	* Options can also be set by passing them on the tag itself.  This feature is disabled by default though
	* as there's a slight performance overhead:
	*   $('.sparkline').sparkline([1,2,3,4], {enableTagOptions: true})
	*   <p>Sparkline: <span class="sparkline" sparkType="bar" sparkBarColor="red">loading</span></p>
	* Prefix all options supplied as tag attribute with "spark" (configurable by setting tagOptionsPrefix)
	*
	* Supported options:
	*   lineColor - Color of the line used for the chart
	*   fillColor - Color used to fill in the chart - Set to '' or false for a transparent chart
	*   width - Width of the chart - Defaults to 3 times the number of values in pixels
	*   height - Height of the chart - Defaults to the height of the containing element
	*   chartRangeMin - Specify the minimum value to use for the Y range of the chart - Defaults to the minimum value supplied
	*   chartRangeMax - Specify the maximum value to use for the Y range of the chart - Defaults to the maximum value supplied
	*   chartRangeClip - Clip out of range values to the max/min specified by chartRangeMin and chartRangeMax
	*   chartRangeMinX - Specify the minimum value to use for the X range of the chart - Defaults to the minimum value supplied
	*   chartRangeMaxX - Specify the maximum value to use for the X range of the chart - Defaults to the maximum value supplied
	*   composite - If true then don't erase any existing chart attached to the tag, but draw
	*           another chart over the top - Note that width and height are ignored if an
	*           existing chart is detected.
	*   tagValuesAttribute - Name of tag attribute to check for data values - Defaults to 'values'
	*   enableTagOptions - Whether to check tags for sparkline options
	*   tagOptionsPrefix - Prefix used for options supplied as tag attributes - Defaults to 'spark'
	*   disableHiddenCheck - If set to true, then the plugin will assume that charts will never be drawn into a
	*           hidden dom element, avoding a browser reflow
	*   disableInteraction - If set to true then all mouseover/click interaction behaviour will be disabled,
	*       making the plugin perform much like it did in 1.x
	*   disableTooltips - If set to true then tooltips will be disabled - Defaults to false (tooltips enabled)
	*   disableHighlight - If set to true then highlighting of selected chart elements on mouseover will be disabled
	*       defaults to false (highlights enabled)
	*   highlightLighten - Factor to lighten/darken highlighted chart values by - Defaults to 1.4 for a 40% increase
	*   tooltipContainer - Specify which DOM element the tooltip should be rendered into - defaults to document.body
	*   tooltipClassname - Optional CSS classname to apply to tooltips - If not specified then a default style will be applied
	*   tooltipOffsetX - How many pixels away from the mouse pointer to render the tooltip on the X axis
	*   tooltipOffsetY - How many pixels away from the mouse pointer to render the tooltip on the r axis
	*   tooltipFormatter  - Optional callback that allows you to override the HTML displayed in the tooltip
	*       callback is given arguments of (sparkline, options, fields)
	*   tooltipChartTitle - If specified then the tooltip uses the string specified by this setting as a title
	*   tooltipFormat - A format string or SPFormat object  (or an array thereof for multiple entries)
	*       to control the format of the tooltip
	*   tooltipPrefix - A string to prepend to each field displayed in a tooltip
	*   tooltipSuffix - A string to append to each field displayed in a tooltip
	*   tooltipSkipNull - If true then null values will not have a tooltip displayed (defaults to true)
	*   tooltipValueLookups - An object or range map to map field values to tooltip strings
	*       (eg. to map -1 to "Lost", 0 to "Draw", and 1 to "Win")
	*   numberFormatter - Optional callback for formatting numbers in tooltips
	*   numberDigitGroupSep - Character to use for group separator in numbers "1,234" - Defaults to ","
	*   numberDecimalMark - Character to use for the decimal point when formatting numbers - Defaults to "."
	*   numberDigitGroupCount - Number of digits between group separator - Defaults to 3
	*
	* There are 7 types of sparkline, selected by supplying a "type" option of 'line' (default),
	* 'bar', 'tristate', 'bullet', 'discrete', 'pie' or 'box'
	*    line - Line chart.  Options:
	*       spotColor - Set to '' to not end each line in a circular spot
	*       minSpotColor - If set, color of spot at minimum value
	*       maxSpotColor - If set, color of spot at maximum value
	*       spotRadius - Radius in pixels
	*       lineWidth - Width of line in pixels
	*       normalRangeMin
	*       normalRangeMax - If set draws a filled horizontal bar between these two values marking the "normal"
	*                      or expected range of values
	*       normalRangeColor - Color to use for the above bar
	*       drawNormalOnTop - Draw the normal range above the chart fill color if true
	*       defaultPixelsPerValue - Defaults to 3 pixels of width for each value in the chart
	*       highlightSpotColor - The color to use for drawing a highlight spot on mouseover - Set to null to disable
	*       highlightLineColor - The color to use for drawing a highlight line on mouseover - Set to null to disable
	*       valueSpots - Specify which points to draw spots on, and in which color.  Accepts a range map
	*
	*   bar - Bar chart.  Options:
	*       barColor - Color of bars for postive values
	*       negBarColor - Color of bars for negative values
	*       zeroColor - Color of bars with zero values
	*       nullColor - Color of bars with null values - Defaults to omitting the bar entirely
	*       barWidth - Width of bars in pixels
	*       colorMap - Optional mappnig of values to colors to override the *BarColor values above
	*                  can be an Array of values to control the color of individual bars or a range map
	*                  to specify colors for individual ranges of values
	*       barSpacing - Gap between bars in pixels
	*       zeroAxis - Centers the y-axis around zero if true
	*
	*   tristate - Charts values of win (>0), lose (<0) or draw (=0)
	*       posBarColor - Color of win values
	*       negBarColor - Color of lose values
	*       zeroBarColor - Color of draw values
	*       barWidth - Width of bars in pixels
	*       barSpacing - Gap between bars in pixels
	*       colorMap - Optional mappnig of values to colors to override the *BarColor values above
	*                  can be an Array of values to control the color of individual bars or a range map
	*                  to specify colors for individual ranges of values
	*
	*   discrete - Options:
	*       lineHeight - Height of each line in pixels - Defaults to 30% of the graph height
	*       thesholdValue - Values less than this value will be drawn using thresholdColor instead of lineColor
	*       thresholdColor
	*
	*   bullet - Values for bullet graphs msut be in the order: target, performance, range1, range2, range3, ...
	*       options:
	*       targetColor - The color of the vertical target marker
	*       targetWidth - The width of the target marker in pixels
	*       performanceColor - The color of the performance measure horizontal bar
	*       rangeColors - Colors to use for each qualitative range background color
	*
	*   pie - Pie chart. Options:
	*       sliceColors - An array of colors to use for pie slices
	*       offset - Angle in degrees to offset the first slice - Try -90 or +90
	*       borderWidth - Width of border to draw around the pie chart, in pixels - Defaults to 0 (no border)
	*       borderColor - Color to use for the pie chart border - Defaults to #000
	*
	*   box - Box plot. Options:
	*       raw - Set to true to supply pre-computed plot points as values
	*             values should be: low_outlier, low_whisker, q1, median, q3, high_whisker, high_outlier
	*             When set to false you can supply any number of values and the box plot will
	*             be computed for you.  Default is false.
	*       showOutliers - Set to true (default) to display outliers as circles
	*       outlierIQR - Interquartile range used to determine outliers.  Default 1.5
	*       boxLineColor - Outline color of the box
	*       boxFillColor - Fill color for the box
	*       whiskerColor - Line color used for whiskers
	*       outlierLineColor - Outline color of outlier circles
	*       outlierFillColor - Fill color of the outlier circles
	*       spotRadius - Radius of outlier circles
	*       medianColor - Line color of the median line
	*       target - Draw a target cross hair at the supplied value (default undefined)
	*
	*
	*
	*   Examples:
	*   $('#sparkline1').sparkline(myvalues, { lineColor: '#f00', fillColor: false });
	*   $('.barsparks').sparkline('html', { type:'bar', height:'40px', barWidth:5 });
	*   $('#tristate').sparkline([1,1,-1,1,0,0,-1], { type:'tristate' }):
	*   $('#discrete').sparkline([1,3,4,5,5,3,4,5], { type:'discrete' });
	*   $('#bullet').sparkline([10,12,12,9,7], { type:'bullet' });
	*   $('#pie').sparkline([1,1,2], { type:'pie' });
	*/

	/*jslint regexp: true, browser: true, jquery: true, white: true, nomen: false, plusplus: false, maxerr: 500, indent: 4 */

	(function (document, Math, undefined) {
	    // performance/minified-size optimization
	    (function (factory) {
	        if (true) {
	            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	        } else if (jQuery && !jQuery.fn.sparkline) {
	            factory(jQuery);
	        }
	    })(function ($) {
	        'use strict';

	        var UNSET_OPTION = {},
	            getDefaults,
	            createClass,
	            SPFormat,
	            clipval,
	            quartile,
	            normalizeValue,
	            normalizeValues,
	            remove,
	            isNumber,
	            all,
	            sum,
	            addCSS,
	            ensureArray,
	            formatNumber,
	            RangeMap,
	            MouseHandler,
	            Tooltip,
	            barHighlightMixin,
	            line,
	            bar,
	            tristate,
	            discrete,
	            bullet,
	            pie,
	            box,
	            defaultStyles,
	            initStyles,
	            VShape,
	            VCanvas_base,
	            VCanvas_canvas,
	            VCanvas_vml,
	            pending,
	            shapeCount = 0;

	        /**
	         * Default configuration settings
	         */
	        getDefaults = function getDefaults() {
	            return {
	                // Settings common to most/all chart types
	                common: {
	                    type: 'line',
	                    lineColor: '#00f',
	                    fillColor: '#cdf',
	                    defaultPixelsPerValue: 3,
	                    width: 'auto',
	                    height: 'auto',
	                    composite: false,
	                    tagValuesAttribute: 'values',
	                    tagOptionsPrefix: 'spark',
	                    enableTagOptions: false,
	                    enableHighlight: true,
	                    highlightLighten: 1.4,
	                    tooltipSkipNull: true,
	                    tooltipPrefix: '',
	                    tooltipSuffix: '',
	                    disableHiddenCheck: false,
	                    numberFormatter: false,
	                    numberDigitGroupCount: 3,
	                    numberDigitGroupSep: ',',
	                    numberDecimalMark: '.',
	                    disableTooltips: false,
	                    disableInteraction: false
	                },
	                // Defaults for line charts
	                line: {
	                    spotColor: '#f80',
	                    highlightSpotColor: '#5f5',
	                    highlightLineColor: '#f22',
	                    spotRadius: 1.5,
	                    minSpotColor: '#f80',
	                    maxSpotColor: '#f80',
	                    lineWidth: 1,
	                    normalRangeMin: undefined,
	                    normalRangeMax: undefined,
	                    normalRangeColor: '#ccc',
	                    drawNormalOnTop: false,
	                    chartRangeMin: undefined,
	                    chartRangeMax: undefined,
	                    chartRangeMinX: undefined,
	                    chartRangeMaxX: undefined,
	                    tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{y}}{{suffix}}')
	                },
	                // Defaults for bar charts
	                bar: {
	                    barColor: '#3366cc',
	                    negBarColor: '#f44',
	                    stackedBarColor: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00', '#dd4477', '#0099c6', '#990099'],
	                    zeroColor: undefined,
	                    nullColor: undefined,
	                    zeroAxis: true,
	                    barWidth: 4,
	                    barSpacing: 1,
	                    chartRangeMax: undefined,
	                    chartRangeMin: undefined,
	                    chartRangeClip: false,
	                    colorMap: undefined,
	                    tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{value}}{{suffix}}')
	                },
	                // Defaults for tristate charts
	                tristate: {
	                    barWidth: 4,
	                    barSpacing: 1,
	                    posBarColor: '#6f6',
	                    negBarColor: '#f44',
	                    zeroBarColor: '#999',
	                    colorMap: {},
	                    tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{value:map}}'),
	                    tooltipValueLookups: { map: { '-1': 'Loss', '0': 'Draw', '1': 'Win' } }
	                },
	                // Defaults for discrete charts
	                discrete: {
	                    lineHeight: 'auto',
	                    thresholdColor: undefined,
	                    thresholdValue: 0,
	                    chartRangeMax: undefined,
	                    chartRangeMin: undefined,
	                    chartRangeClip: false,
	                    tooltipFormat: new SPFormat('{{prefix}}{{value}}{{suffix}}')
	                },
	                // Defaults for bullet charts
	                bullet: {
	                    targetColor: '#f33',
	                    targetWidth: 3, // width of the target bar in pixels
	                    performanceColor: '#33f',
	                    rangeColors: ['#d3dafe', '#a8b6ff', '#7f94ff'],
	                    base: undefined, // set this to a number to change the base start number
	                    tooltipFormat: new SPFormat('{{fieldkey:fields}} - {{value}}'),
	                    tooltipValueLookups: { fields: { r: 'Range', p: 'Performance', t: 'Target' } }
	                },
	                // Defaults for pie charts
	                pie: {
	                    offset: 0,
	                    sliceColors: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00', '#dd4477', '#0099c6', '#990099'],
	                    borderWidth: 0,
	                    borderColor: '#000',
	                    tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{value}} ({{percent.1}}%)')
	                },
	                // Defaults for box plots
	                box: {
	                    raw: false,
	                    boxLineColor: '#000',
	                    boxFillColor: '#cdf',
	                    whiskerColor: '#000',
	                    outlierLineColor: '#333',
	                    outlierFillColor: '#fff',
	                    medianColor: '#f00',
	                    showOutliers: true,
	                    outlierIQR: 1.5,
	                    spotRadius: 1.5,
	                    target: undefined,
	                    targetColor: '#4a2',
	                    chartRangeMax: undefined,
	                    chartRangeMin: undefined,
	                    tooltipFormat: new SPFormat('{{field:fields}}: {{value}}'),
	                    tooltipFormatFieldlistKey: 'field',
	                    tooltipValueLookups: { fields: { lq: 'Lower Quartile', med: 'Median',
	                            uq: 'Upper Quartile', lo: 'Left Outlier', ro: 'Right Outlier',
	                            lw: 'Left Whisker', rw: 'Right Whisker' } }
	                }
	            };
	        };

	        // You can have tooltips use a css class other than jqstooltip by specifying tooltipClassname
	        defaultStyles = '.jqstooltip { ' + 'position: absolute;' + 'left: 0;' + 'top: 0;' + 'visibility: hidden;' + 'background: rgb(0, 0, 0) transparent;' + 'background-color: rgba(0,0,0,0.6);' + 'filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);' + '-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)";' + 'color: white;' + 'font: 10px arial, san serif;' + 'text-align: left;' + 'white-space: nowrap;' + 'padding: 5px;' + 'border: 1px solid white;' + 'box-sizing: content-box;' + 'z-index: 10000;' + '}' + '.jqsfield { ' + 'color: white;' + 'font: 10px arial, san serif;' + 'text-align: left;' + '}';

	        /**
	         * Utilities
	         */

	        createClass = function createClass() /* [baseclass, [mixin, ...]], definition */{
	            var Class, args;
	            Class = function Class() {
	                this.init.apply(this, arguments);
	            };
	            if (arguments.length > 1) {
	                if (arguments[0]) {
	                    Class.prototype = $.extend(new arguments[0](), arguments[arguments.length - 1]);
	                    Class._super = arguments[0].prototype;
	                } else {
	                    Class.prototype = arguments[arguments.length - 1];
	                }
	                if (arguments.length > 2) {
	                    args = Array.prototype.slice.call(arguments, 1, -1);
	                    args.unshift(Class.prototype);
	                    $.extend.apply($, args);
	                }
	            } else {
	                Class.prototype = arguments[0];
	            }
	            Class.prototype.cls = Class;
	            return Class;
	        };

	        /**
	         * Wraps a format string for tooltips
	         * {{x}}
	         * {{x.2}
	         * {{x:months}}
	         */
	        $.SPFormatClass = SPFormat = createClass({
	            fre: /\{\{([\w.]+?)(:(.+?))?\}\}/g,
	            precre: /(\w+)\.(\d+)/,

	            init: function init(format, fclass) {
	                this.format = format;
	                this.fclass = fclass;
	            },

	            render: function render(fieldset, lookups, options) {
	                var self = this,
	                    fields = fieldset,
	                    match,
	                    token,
	                    lookupkey,
	                    fieldvalue,
	                    prec;
	                return this.format.replace(this.fre, function () {
	                    var lookup;
	                    token = arguments[1];
	                    lookupkey = arguments[3];
	                    match = self.precre.exec(token);
	                    if (match) {
	                        prec = match[2];
	                        token = match[1];
	                    } else {
	                        prec = false;
	                    }
	                    fieldvalue = fields[token];
	                    if (fieldvalue === undefined) {
	                        return '';
	                    }
	                    if (lookupkey && lookups && lookups[lookupkey]) {
	                        lookup = lookups[lookupkey];
	                        if (lookup.get) {
	                            // RangeMap
	                            return lookups[lookupkey].get(fieldvalue) || fieldvalue;
	                        } else {
	                            return lookups[lookupkey][fieldvalue] || fieldvalue;
	                        }
	                    }
	                    if (isNumber(fieldvalue)) {
	                        if (options.get('numberFormatter')) {
	                            fieldvalue = options.get('numberFormatter')(fieldvalue);
	                        } else {
	                            fieldvalue = formatNumber(fieldvalue, prec, options.get('numberDigitGroupCount'), options.get('numberDigitGroupSep'), options.get('numberDecimalMark'));
	                        }
	                    }
	                    return fieldvalue;
	                });
	            }
	        });

	        // convience method to avoid needing the new operator
	        $.spformat = function (format, fclass) {
	            return new SPFormat(format, fclass);
	        };

	        clipval = function clipval(val, min, max) {
	            if (val < min) {
	                return min;
	            }
	            if (val > max) {
	                return max;
	            }
	            return val;
	        };

	        quartile = function quartile(values, q) {
	            var vl;
	            if (q === 2) {
	                vl = Math.floor(values.length / 2);
	                return values.length % 2 ? values[vl] : (values[vl - 1] + values[vl]) / 2;
	            } else {
	                if (values.length % 2) {
	                    // odd
	                    vl = (values.length * q + q) / 4;
	                    return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl - 1];
	                } else {
	                    //even
	                    vl = (values.length * q + 2) / 4;
	                    return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl - 1];
	                }
	            }
	        };

	        normalizeValue = function normalizeValue(val) {
	            var nf;
	            switch (val) {
	                case 'undefined':
	                    val = undefined;
	                    break;
	                case 'null':
	                    val = null;
	                    break;
	                case 'true':
	                    val = true;
	                    break;
	                case 'false':
	                    val = false;
	                    break;
	                default:
	                    nf = parseFloat(val);
	                    if (val == nf) {
	                        val = nf;
	                    }
	            }
	            return val;
	        };

	        normalizeValues = function normalizeValues(vals) {
	            var i,
	                result = [];
	            for (i = vals.length; i--;) {
	                result[i] = normalizeValue(vals[i]);
	            }
	            return result;
	        };

	        remove = function remove(vals, filter) {
	            var i,
	                vl,
	                result = [];
	            for (i = 0, vl = vals.length; i < vl; i++) {
	                if (vals[i] !== filter) {
	                    result.push(vals[i]);
	                }
	            }
	            return result;
	        };

	        isNumber = function isNumber(num) {
	            return !isNaN(parseFloat(num)) && isFinite(num);
	        };

	        formatNumber = function formatNumber(num, prec, groupsize, groupsep, decsep) {
	            var p, i;
	            num = (prec === false ? parseFloat(num).toString() : num.toFixed(prec)).split('');
	            p = (p = $.inArray('.', num)) < 0 ? num.length : p;
	            if (p < num.length) {
	                num[p] = decsep;
	            }
	            for (i = p - groupsize; i > 0; i -= groupsize) {
	                num.splice(i, 0, groupsep);
	            }
	            return num.join('');
	        };

	        // determine if all values of an array match a value
	        // returns true if the array is empty
	        all = function all(val, arr, ignoreNull) {
	            var i;
	            for (i = arr.length; i--;) {
	                if (ignoreNull && arr[i] === null) continue;
	                if (arr[i] !== val) {
	                    return false;
	                }
	            }
	            return true;
	        };

	        // sums the numeric values in an array, ignoring other values
	        sum = function sum(vals) {
	            var total = 0,
	                i;
	            for (i = vals.length; i--;) {
	                total += typeof vals[i] === 'number' ? vals[i] : 0;
	            }
	            return total;
	        };

	        ensureArray = function ensureArray(val) {
	            return $.isArray(val) ? val : [val];
	        };

	        // http://paulirish.com/2008/bookmarklet-inject-new-css-rules/
	        addCSS = function addCSS(css) {
	            var tag, iefail;
	            if (document.createStyleSheet) {
	                try {
	                    document.createStyleSheet().cssText = css;
	                    return;
	                } catch (e) {
	                    // IE <= 9 maxes out at 31 stylesheets; inject into page instead.
	                    iefail = true;
	                }
	            }
	            tag = document.createElement('style');
	            tag.type = 'text/css';
	            document.getElementsByTagName('head')[0].appendChild(tag);
	            if (iefail) {
	                document.styleSheets[document.styleSheets.length - 1].cssText = css;
	            } else {
	                tag[typeof document.body.style.WebkitAppearance == 'string' ? /* webkit only */'innerText' : 'innerHTML'] = css;
	            }
	        };

	        // Provide a cross-browser interface to a few simple drawing primitives
	        $.fn.simpledraw = function (width, height, useExisting, interact) {
	            var target, mhandler;
	            if (useExisting && (target = this.data('_jqs_vcanvas'))) {
	                return target;
	            }

	            if ($.fn.sparkline.canvas === false) {
	                // We've already determined that neither Canvas nor VML are available
	                return false;
	            } else if ($.fn.sparkline.canvas === undefined) {
	                // No function defined yet -- need to see if we support Canvas or VML
	                var el = document.createElement('canvas');
	                if (!!(el.getContext && el.getContext('2d'))) {
	                    // Canvas is available
	                    $.fn.sparkline.canvas = function (width, height, target, interact) {
	                        return new VCanvas_canvas(width, height, target, interact);
	                    };
	                } else if (document.namespaces && !document.namespaces.v) {
	                    // VML is available
	                    document.namespaces.add('v', 'urn:schemas-microsoft-com:vml', '#default#VML');
	                    $.fn.sparkline.canvas = function (width, height, target, interact) {
	                        return new VCanvas_vml(width, height, target);
	                    };
	                } else {
	                    // Neither Canvas nor VML are available
	                    $.fn.sparkline.canvas = false;
	                    return false;
	                }
	            }

	            if (width === undefined) {
	                width = $(this).innerWidth();
	            }
	            if (height === undefined) {
	                height = $(this).innerHeight();
	            }

	            target = $.fn.sparkline.canvas(width, height, this, interact);

	            mhandler = $(this).data('_jqs_mhandler');
	            if (mhandler) {
	                mhandler.registerCanvas(target);
	            }
	            return target;
	        };

	        $.fn.cleardraw = function () {
	            var target = this.data('_jqs_vcanvas');
	            if (target) {
	                target.reset();
	            }
	        };

	        $.RangeMapClass = RangeMap = createClass({
	            init: function init(map) {
	                var key,
	                    range,
	                    rangelist = [];
	                for (key in map) {
	                    if (map.hasOwnProperty(key) && typeof key === 'string' && key.indexOf(':') > -1) {
	                        range = key.split(':');
	                        range[0] = range[0].length === 0 ? -Infinity : parseFloat(range[0]);
	                        range[1] = range[1].length === 0 ? Infinity : parseFloat(range[1]);
	                        range[2] = map[key];
	                        rangelist.push(range);
	                    }
	                }
	                this.map = map;
	                this.rangelist = rangelist || false;
	            },

	            get: function get(value) {
	                var rangelist = this.rangelist,
	                    i,
	                    range,
	                    result;
	                if ((result = this.map[value]) !== undefined) {
	                    return result;
	                }
	                if (rangelist) {
	                    for (i = rangelist.length; i--;) {
	                        range = rangelist[i];
	                        if (range[0] <= value && range[1] >= value) {
	                            return range[2];
	                        }
	                    }
	                }
	                return undefined;
	            }
	        });

	        // Convenience function
	        $.range_map = function (map) {
	            return new RangeMap(map);
	        };

	        MouseHandler = createClass({
	            init: function init(el, options) {
	                var $el = $(el);
	                this.$el = $el;
	                this.options = options;
	                this.currentPageX = 0;
	                this.currentPageY = 0;
	                this.el = el;
	                this.splist = [];
	                this.tooltip = null;
	                this.over = false;
	                this.displayTooltips = !options.get('disableTooltips');
	                this.highlightEnabled = !options.get('disableHighlight');
	            },

	            registerSparkline: function registerSparkline(sp) {
	                this.splist.push(sp);
	                if (this.over) {
	                    this.updateDisplay();
	                }
	            },

	            registerCanvas: function registerCanvas(canvas) {
	                var $canvas = $(canvas.canvas);
	                this.canvas = canvas;
	                this.$canvas = $canvas;
	                $canvas.mouseenter($.proxy(this.mouseenter, this));
	                $canvas.mouseleave($.proxy(this.mouseleave, this));
	                $canvas.click($.proxy(this.mouseclick, this));
	            },

	            reset: function reset(removeTooltip) {
	                this.splist = [];
	                if (this.tooltip && removeTooltip) {
	                    this.tooltip.remove();
	                    this.tooltip = undefined;
	                }
	            },

	            mouseclick: function mouseclick(e) {
	                var clickEvent = $.Event('sparklineClick');
	                clickEvent.originalEvent = e;
	                clickEvent.sparklines = this.splist;
	                this.$el.trigger(clickEvent);
	            },

	            mouseenter: function mouseenter(e) {
	                $(document.body).unbind('mousemove.jqs');
	                $(document.body).bind('mousemove.jqs', $.proxy(this.mousemove, this));
	                this.over = true;
	                this.currentPageX = e.pageX;
	                this.currentPageY = e.pageY;
	                this.currentEl = e.target;
	                if (!this.tooltip && this.displayTooltips) {
	                    this.tooltip = new Tooltip(this.options);
	                    this.tooltip.updatePosition(e.pageX, e.pageY);
	                }
	                this.updateDisplay();
	            },

	            mouseleave: function mouseleave() {
	                $(document.body).unbind('mousemove.jqs');
	                var splist = this.splist,
	                    spcount = splist.length,
	                    needsRefresh = false,
	                    sp,
	                    i;
	                this.over = false;
	                this.currentEl = null;

	                if (this.tooltip) {
	                    this.tooltip.remove();
	                    this.tooltip = null;
	                }

	                for (i = 0; i < spcount; i++) {
	                    sp = splist[i];
	                    if (sp.clearRegionHighlight()) {
	                        needsRefresh = true;
	                    }
	                }

	                if (needsRefresh) {
	                    this.canvas.render();
	                }
	            },

	            mousemove: function mousemove(e) {
	                this.currentPageX = e.pageX;
	                this.currentPageY = e.pageY;
	                this.currentEl = e.target;
	                if (this.tooltip) {
	                    this.tooltip.updatePosition(e.pageX, e.pageY);
	                }
	                this.updateDisplay();
	            },

	            updateDisplay: function updateDisplay() {
	                var splist = this.splist,
	                    spcount = splist.length,
	                    needsRefresh = false,
	                    offset = this.$canvas.offset(),
	                    localX = this.currentPageX - offset.left,
	                    localY = this.currentPageY - offset.top,
	                    tooltiphtml,
	                    sp,
	                    i,
	                    result,
	                    changeEvent;
	                if (!this.over) {
	                    return;
	                }
	                for (i = 0; i < spcount; i++) {
	                    sp = splist[i];
	                    result = sp.setRegionHighlight(this.currentEl, localX, localY);
	                    if (result) {
	                        needsRefresh = true;
	                    }
	                }
	                if (needsRefresh) {
	                    changeEvent = $.Event('sparklineRegionChange');
	                    changeEvent.sparklines = this.splist;
	                    this.$el.trigger(changeEvent);
	                    if (this.tooltip) {
	                        tooltiphtml = '';
	                        for (i = 0; i < spcount; i++) {
	                            sp = splist[i];
	                            tooltiphtml += sp.getCurrentRegionTooltip();
	                        }
	                        this.tooltip.setContent(tooltiphtml);
	                    }
	                    if (!this.disableHighlight) {
	                        this.canvas.render();
	                    }
	                }
	                if (result === null) {
	                    this.mouseleave();
	                }
	            }
	        });

	        Tooltip = createClass({
	            sizeStyle: 'position: static !important;' + 'display: block !important;' + 'visibility: hidden !important;' + 'float: left !important;',

	            init: function init(options) {
	                var tooltipClassname = options.get('tooltipClassname', 'jqstooltip'),
	                    sizetipStyle = this.sizeStyle,
	                    offset;
	                this.container = options.get('tooltipContainer') || document.body;
	                this.tooltipOffsetX = options.get('tooltipOffsetX', 10);
	                this.tooltipOffsetY = options.get('tooltipOffsetY', 12);
	                // remove any previous lingering tooltip
	                $('#jqssizetip').remove();
	                $('#jqstooltip').remove();
	                this.sizetip = $('<div/>', {
	                    id: 'jqssizetip',
	                    style: sizetipStyle,
	                    'class': tooltipClassname
	                });
	                this.tooltip = $('<div/>', {
	                    id: 'jqstooltip',
	                    'class': tooltipClassname
	                }).appendTo(this.container);
	                // account for the container's location
	                offset = this.tooltip.offset();
	                this.offsetLeft = offset.left;
	                this.offsetTop = offset.top;
	                this.hidden = true;
	                $(window).unbind('resize.jqs scroll.jqs');
	                $(window).bind('resize.jqs scroll.jqs', $.proxy(this.updateWindowDims, this));
	                this.updateWindowDims();
	            },

	            updateWindowDims: function updateWindowDims() {
	                this.scrollTop = $(window).scrollTop();
	                this.scrollLeft = $(window).scrollLeft();
	                this.scrollRight = this.scrollLeft + $(window).width();
	                this.updatePosition();
	            },

	            getSize: function getSize(content) {
	                this.sizetip.html(content).appendTo(this.container);
	                this.width = this.sizetip.width() + 1;
	                this.height = this.sizetip.height();
	                this.sizetip.remove();
	            },

	            setContent: function setContent(content) {
	                if (!content) {
	                    this.tooltip.css('visibility', 'hidden');
	                    this.hidden = true;
	                    return;
	                }
	                this.getSize(content);
	                this.tooltip.html(content).css({
	                    'width': this.width,
	                    'height': this.height,
	                    'visibility': 'visible'
	                });
	                if (this.hidden) {
	                    this.hidden = false;
	                    this.updatePosition();
	                }
	            },

	            updatePosition: function updatePosition(x, y) {
	                if (x === undefined) {
	                    if (this.mousex === undefined) {
	                        return;
	                    }
	                    x = this.mousex - this.offsetLeft;
	                    y = this.mousey - this.offsetTop;
	                } else {
	                    this.mousex = x = x - this.offsetLeft;
	                    this.mousey = y = y - this.offsetTop;
	                }
	                if (!this.height || !this.width || this.hidden) {
	                    return;
	                }

	                y -= this.height + this.tooltipOffsetY;
	                x += this.tooltipOffsetX;

	                if (y < this.scrollTop) {
	                    y = this.scrollTop;
	                }
	                if (x < this.scrollLeft) {
	                    x = this.scrollLeft;
	                } else if (x + this.width > this.scrollRight) {
	                    x = this.scrollRight - this.width;
	                }

	                this.tooltip.css({
	                    'left': x,
	                    'top': y
	                });
	            },

	            remove: function remove() {
	                this.tooltip.remove();
	                this.sizetip.remove();
	                this.sizetip = this.tooltip = undefined;
	                $(window).unbind('resize.jqs scroll.jqs');
	            }
	        });

	        initStyles = function initStyles() {
	            addCSS(defaultStyles);
	        };

	        $(initStyles);

	        pending = [];
	        $.fn.sparkline = function (userValues, userOptions) {
	            return this.each(function () {
	                var options = new $.fn.sparkline.options(this, userOptions),
	                    $this = $(this),
	                    render,
	                    i;
	                render = function render() {
	                    var values, width, height, tmp, mhandler, sp, vals;
	                    if (userValues === 'html' || userValues === undefined) {
	                        vals = this.getAttribute(options.get('tagValuesAttribute'));
	                        if (vals === undefined || vals === null) {
	                            vals = $this.html();
	                        }
	                        values = vals.replace(/(^\s*<!--)|(-->\s*$)|\s+/g, '').split(',');
	                    } else {
	                        values = userValues;
	                    }

	                    width = options.get('width') === 'auto' ? values.length * options.get('defaultPixelsPerValue') : options.get('width');
	                    if (options.get('height') === 'auto') {
	                        if (!options.get('composite') || !$.data(this, '_jqs_vcanvas')) {
	                            // must be a better way to get the line height
	                            tmp = document.createElement('span');
	                            tmp.innerHTML = 'a';
	                            $this.html(tmp);
	                            height = $(tmp).innerHeight() || $(tmp).height();
	                            $(tmp).remove();
	                            tmp = null;
	                        }
	                    } else {
	                        height = options.get('height');
	                    }

	                    if (!options.get('disableInteraction')) {
	                        mhandler = $.data(this, '_jqs_mhandler');
	                        if (!mhandler) {
	                            mhandler = new MouseHandler(this, options);
	                            $.data(this, '_jqs_mhandler', mhandler);
	                        } else if (!options.get('composite')) {
	                            mhandler.reset();
	                        }
	                    } else {
	                        mhandler = false;
	                    }

	                    if (options.get('composite') && !$.data(this, '_jqs_vcanvas')) {
	                        if (!$.data(this, '_jqs_errnotify')) {
	                            window.alert('Attempted to attach a composite sparkline to an element with no existing sparkline');
	                            $.data(this, '_jqs_errnotify', true);
	                        }
	                        return;
	                    }

	                    sp = new $.fn.sparkline[options.get('type')](this, values, options, width, height);

	                    sp.render();

	                    if (mhandler) {
	                        mhandler.registerSparkline(sp);
	                    }
	                };
	                if ($(this).html() && !options.get('disableHiddenCheck') && $(this).is(':hidden') || !$(this).parents('body').length) {
	                    if (!options.get('composite') && $.data(this, '_jqs_pending')) {
	                        // remove any existing references to the element
	                        for (i = pending.length; i; i--) {
	                            if (pending[i - 1][0] == this) {
	                                pending.splice(i - 1, 1);
	                            }
	                        }
	                    }
	                    pending.push([this, render]);
	                    $.data(this, '_jqs_pending', true);
	                } else {
	                    render.call(this);
	                }
	            });
	        };

	        $.fn.sparkline.defaults = getDefaults();

	        $.sparkline_display_visible = function () {
	            var el, i, pl;
	            var done = [];
	            for (i = 0, pl = pending.length; i < pl; i++) {
	                el = pending[i][0];
	                if ($(el).is(':visible') && !$(el).parents().is(':hidden')) {
	                    pending[i][1].call(el);
	                    $.data(pending[i][0], '_jqs_pending', false);
	                    done.push(i);
	                } else if (!$(el).closest('html').length && !$.data(el, '_jqs_pending')) {
	                    // element has been inserted and removed from the DOM
	                    // If it was not yet inserted into the dom then the .data request
	                    // will return true.
	                    // removing from the dom causes the data to be removed.
	                    $.data(pending[i][0], '_jqs_pending', false);
	                    done.push(i);
	                }
	            }
	            for (i = done.length; i; i--) {
	                pending.splice(done[i - 1], 1);
	            }
	        };

	        /**
	         * User option handler
	         */
	        $.fn.sparkline.options = createClass({
	            init: function init(tag, userOptions) {
	                var extendedOptions, defaults, base, tagOptionType;
	                this.userOptions = userOptions = userOptions || {};
	                this.tag = tag;
	                this.tagValCache = {};
	                defaults = $.fn.sparkline.defaults;
	                base = defaults.common;
	                this.tagOptionsPrefix = userOptions.enableTagOptions && (userOptions.tagOptionsPrefix || base.tagOptionsPrefix);

	                tagOptionType = this.getTagSetting('type');
	                if (tagOptionType === UNSET_OPTION) {
	                    extendedOptions = defaults[userOptions.type || base.type];
	                } else {
	                    extendedOptions = defaults[tagOptionType];
	                }
	                this.mergedOptions = $.extend({}, base, extendedOptions, userOptions);
	            },

	            getTagSetting: function getTagSetting(key) {
	                var prefix = this.tagOptionsPrefix,
	                    val,
	                    i,
	                    pairs,
	                    keyval;
	                if (prefix === false || prefix === undefined) {
	                    return UNSET_OPTION;
	                }
	                if (this.tagValCache.hasOwnProperty(key)) {
	                    val = this.tagValCache.key;
	                } else {
	                    val = this.tag.getAttribute(prefix + key);
	                    if (val === undefined || val === null) {
	                        val = UNSET_OPTION;
	                    } else if (val.substr(0, 1) === '[') {
	                        val = val.substr(1, val.length - 2).split(',');
	                        for (i = val.length; i--;) {
	                            val[i] = normalizeValue(val[i].replace(/(^\s*)|(\s*$)/g, ''));
	                        }
	                    } else if (val.substr(0, 1) === '{') {
	                        pairs = val.substr(1, val.length - 2).split(',');
	                        val = {};
	                        for (i = pairs.length; i--;) {
	                            keyval = pairs[i].split(':', 2);
	                            val[keyval[0].replace(/(^\s*)|(\s*$)/g, '')] = normalizeValue(keyval[1].replace(/(^\s*)|(\s*$)/g, ''));
	                        }
	                    } else {
	                        val = normalizeValue(val);
	                    }
	                    this.tagValCache.key = val;
	                }
	                return val;
	            },

	            get: function get(key, defaultval) {
	                var tagOption = this.getTagSetting(key),
	                    result;
	                if (tagOption !== UNSET_OPTION) {
	                    return tagOption;
	                }
	                return (result = this.mergedOptions[key]) === undefined ? defaultval : result;
	            }
	        });

	        $.fn.sparkline._base = createClass({
	            disabled: false,

	            init: function init(el, values, options, width, height) {
	                this.el = el;
	                this.$el = $(el);
	                this.values = values;
	                this.options = options;
	                this.width = width;
	                this.height = height;
	                this.currentRegion = undefined;
	            },

	            /**
	             * Setup the canvas
	             */
	            initTarget: function initTarget() {
	                var interactive = !this.options.get('disableInteraction');
	                if (!(this.target = this.$el.simpledraw(this.width, this.height, this.options.get('composite'), interactive))) {
	                    this.disabled = true;
	                } else {
	                    this.canvasWidth = this.target.pixelWidth;
	                    this.canvasHeight = this.target.pixelHeight;
	                }
	            },

	            /**
	             * Actually render the chart to the canvas
	             */
	            render: function render() {
	                if (this.disabled) {
	                    this.el.innerHTML = '';
	                    return false;
	                }
	                return true;
	            },

	            /**
	             * Return a region id for a given x/y co-ordinate
	             */
	            getRegion: function getRegion(x, y) {},

	            /**
	             * Highlight an item based on the moused-over x,y co-ordinate
	             */
	            setRegionHighlight: function setRegionHighlight(el, x, y) {
	                var currentRegion = this.currentRegion,
	                    highlightEnabled = !this.options.get('disableHighlight'),
	                    newRegion;
	                if (x > this.canvasWidth || y > this.canvasHeight || x < 0 || y < 0) {
	                    return null;
	                }
	                newRegion = this.getRegion(el, x, y);
	                if (currentRegion !== newRegion) {
	                    if (currentRegion !== undefined && highlightEnabled) {
	                        this.removeHighlight();
	                    }
	                    this.currentRegion = newRegion;
	                    if (newRegion !== undefined && highlightEnabled) {
	                        this.renderHighlight();
	                    }
	                    return true;
	                }
	                return false;
	            },

	            /**
	             * Reset any currently highlighted item
	             */
	            clearRegionHighlight: function clearRegionHighlight() {
	                if (this.currentRegion !== undefined) {
	                    this.removeHighlight();
	                    this.currentRegion = undefined;
	                    return true;
	                }
	                return false;
	            },

	            renderHighlight: function renderHighlight() {
	                this.changeHighlight(true);
	            },

	            removeHighlight: function removeHighlight() {
	                this.changeHighlight(false);
	            },

	            changeHighlight: function changeHighlight(highlight) {},

	            /**
	             * Fetch the HTML to display as a tooltip
	             */
	            getCurrentRegionTooltip: function getCurrentRegionTooltip() {
	                var options = this.options,
	                    header = '',
	                    entries = [],
	                    fields,
	                    formats,
	                    formatlen,
	                    fclass,
	                    text,
	                    i,
	                    showFields,
	                    showFieldsKey,
	                    newFields,
	                    fv,
	                    formatter,
	                    format,
	                    fieldlen,
	                    j;
	                if (this.currentRegion === undefined) {
	                    return '';
	                }
	                fields = this.getCurrentRegionFields();
	                formatter = options.get('tooltipFormatter');
	                if (formatter) {
	                    return formatter(this, options, fields);
	                }
	                if (options.get('tooltipChartTitle')) {
	                    header += '<div class="jqs jqstitle">' + options.get('tooltipChartTitle') + '</div>\n';
	                }
	                formats = this.options.get('tooltipFormat');
	                if (!formats) {
	                    return '';
	                }
	                if (!$.isArray(formats)) {
	                    formats = [formats];
	                }
	                if (!$.isArray(fields)) {
	                    fields = [fields];
	                }
	                showFields = this.options.get('tooltipFormatFieldlist');
	                showFieldsKey = this.options.get('tooltipFormatFieldlistKey');
	                if (showFields && showFieldsKey) {
	                    // user-selected ordering of fields
	                    newFields = [];
	                    for (i = fields.length; i--;) {
	                        fv = fields[i][showFieldsKey];
	                        if ((j = $.inArray(fv, showFields)) != -1) {
	                            newFields[j] = fields[i];
	                        }
	                    }
	                    fields = newFields;
	                }
	                formatlen = formats.length;
	                fieldlen = fields.length;
	                for (i = 0; i < formatlen; i++) {
	                    format = formats[i];
	                    if (typeof format === 'string') {
	                        format = new SPFormat(format);
	                    }
	                    fclass = format.fclass || 'jqsfield';
	                    for (j = 0; j < fieldlen; j++) {
	                        if (!fields[j].isNull || !options.get('tooltipSkipNull')) {
	                            $.extend(fields[j], {
	                                prefix: options.get('tooltipPrefix'),
	                                suffix: options.get('tooltipSuffix')
	                            });
	                            text = format.render(fields[j], options.get('tooltipValueLookups'), options);
	                            entries.push('<div class="' + fclass + '">' + text + '</div>');
	                        }
	                    }
	                }
	                if (entries.length) {
	                    return header + entries.join('\n');
	                }
	                return '';
	            },

	            getCurrentRegionFields: function getCurrentRegionFields() {},

	            calcHighlightColor: function calcHighlightColor(color, options) {
	                var highlightColor = options.get('highlightColor'),
	                    lighten = options.get('highlightLighten'),
	                    parse,
	                    mult,
	                    rgbnew,
	                    i;
	                if (highlightColor) {
	                    return highlightColor;
	                }
	                if (lighten) {
	                    // extract RGB values
	                    parse = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(color) || /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color);
	                    if (parse) {
	                        rgbnew = [];
	                        mult = color.length === 4 ? 16 : 1;
	                        for (i = 0; i < 3; i++) {
	                            rgbnew[i] = clipval(Math.round(parseInt(parse[i + 1], 16) * mult * lighten), 0, 255);
	                        }
	                        return 'rgb(' + rgbnew.join(',') + ')';
	                    }
	                }
	                return color;
	            }

	        });

	        barHighlightMixin = {
	            changeHighlight: function changeHighlight(highlight) {
	                var currentRegion = this.currentRegion,
	                    target = this.target,
	                    shapeids = this.regionShapes[currentRegion],
	                    newShapes;
	                // will be null if the region value was null
	                if (shapeids) {
	                    newShapes = this.renderRegion(currentRegion, highlight);
	                    if ($.isArray(newShapes) || $.isArray(shapeids)) {
	                        target.replaceWithShapes(shapeids, newShapes);
	                        this.regionShapes[currentRegion] = $.map(newShapes, function (newShape) {
	                            return newShape.id;
	                        });
	                    } else {
	                        target.replaceWithShape(shapeids, newShapes);
	                        this.regionShapes[currentRegion] = newShapes.id;
	                    }
	                }
	            },

	            render: function render() {
	                var values = this.values,
	                    target = this.target,
	                    regionShapes = this.regionShapes,
	                    shapes,
	                    ids,
	                    i,
	                    j;

	                if (!this.cls._super.render.call(this)) {
	                    return;
	                }
	                for (i = values.length; i--;) {
	                    shapes = this.renderRegion(i);
	                    if (shapes) {
	                        if ($.isArray(shapes)) {
	                            ids = [];
	                            for (j = shapes.length; j--;) {
	                                shapes[j].append();
	                                ids.push(shapes[j].id);
	                            }
	                            regionShapes[i] = ids;
	                        } else {
	                            shapes.append();
	                            regionShapes[i] = shapes.id; // store just the shapeid
	                        }
	                    } else {
	                        // null value
	                        regionShapes[i] = null;
	                    }
	                }
	                target.render();
	            }
	        };

	        /**
	         * Line charts
	         */
	        $.fn.sparkline.line = line = createClass($.fn.sparkline._base, {
	            type: 'line',

	            init: function init(el, values, options, width, height) {
	                line._super.init.call(this, el, values, options, width, height);
	                this.vertices = [];
	                this.regionMap = [];
	                this.xvalues = [];
	                this.yvalues = [];
	                this.yminmax = [];
	                this.hightlightSpotId = null;
	                this.lastShapeId = null;
	                this.initTarget();
	            },

	            getRegion: function getRegion(el, x, y) {
	                var i,
	                    regionMap = this.regionMap; // maps regions to value positions
	                for (i = regionMap.length; i--;) {
	                    if (regionMap[i] !== null && x >= regionMap[i][0] && x <= regionMap[i][1]) {
	                        return regionMap[i][2];
	                    }
	                }
	                return undefined;
	            },

	            getCurrentRegionFields: function getCurrentRegionFields() {
	                var currentRegion = this.currentRegion;
	                return {
	                    isNull: this.yvalues[currentRegion] === null,
	                    x: this.xvalues[currentRegion],
	                    y: this.yvalues[currentRegion],
	                    color: this.options.get('lineColor'),
	                    fillColor: this.options.get('fillColor'),
	                    offset: currentRegion
	                };
	            },

	            renderHighlight: function renderHighlight() {
	                var currentRegion = this.currentRegion,
	                    target = this.target,
	                    vertex = this.vertices[currentRegion],
	                    options = this.options,
	                    spotRadius = options.get('spotRadius'),
	                    highlightSpotColor = options.get('highlightSpotColor'),
	                    highlightLineColor = options.get('highlightLineColor'),
	                    highlightSpot,
	                    highlightLine;

	                if (!vertex) {
	                    return;
	                }
	                if (spotRadius && highlightSpotColor) {
	                    highlightSpot = target.drawCircle(vertex[0], vertex[1], spotRadius, undefined, highlightSpotColor);
	                    this.highlightSpotId = highlightSpot.id;
	                    target.insertAfterShape(this.lastShapeId, highlightSpot);
	                }
	                if (highlightLineColor) {
	                    highlightLine = target.drawLine(vertex[0], this.canvasTop, vertex[0], this.canvasTop + this.canvasHeight, highlightLineColor);
	                    this.highlightLineId = highlightLine.id;
	                    target.insertAfterShape(this.lastShapeId, highlightLine);
	                }
	            },

	            removeHighlight: function removeHighlight() {
	                var target = this.target;
	                if (this.highlightSpotId) {
	                    target.removeShapeId(this.highlightSpotId);
	                    this.highlightSpotId = null;
	                }
	                if (this.highlightLineId) {
	                    target.removeShapeId(this.highlightLineId);
	                    this.highlightLineId = null;
	                }
	            },

	            scanValues: function scanValues() {
	                var values = this.values,
	                    valcount = values.length,
	                    xvalues = this.xvalues,
	                    yvalues = this.yvalues,
	                    yminmax = this.yminmax,
	                    i,
	                    val,
	                    isStr,
	                    isArray,
	                    sp;
	                for (i = 0; i < valcount; i++) {
	                    val = values[i];
	                    isStr = typeof values[i] === 'string';
	                    isArray = _typeof(values[i]) === 'object' && values[i] instanceof Array;
	                    sp = isStr && values[i].split(':');
	                    if (isStr && sp.length === 2) {
	                        // x:y
	                        xvalues.push(Number(sp[0]));
	                        yvalues.push(Number(sp[1]));
	                        yminmax.push(Number(sp[1]));
	                    } else if (isArray) {
	                        xvalues.push(val[0]);
	                        yvalues.push(val[1]);
	                        yminmax.push(val[1]);
	                    } else {
	                        xvalues.push(i);
	                        if (values[i] === null || values[i] === 'null') {
	                            yvalues.push(null);
	                        } else {
	                            yvalues.push(Number(val));
	                            yminmax.push(Number(val));
	                        }
	                    }
	                }
	                if (this.options.get('xvalues')) {
	                    xvalues = this.options.get('xvalues');
	                }

	                this.maxy = this.maxyorg = Math.max.apply(Math, yminmax);
	                this.miny = this.minyorg = Math.min.apply(Math, yminmax);

	                this.maxx = Math.max.apply(Math, xvalues);
	                this.minx = Math.min.apply(Math, xvalues);

	                this.xvalues = xvalues;
	                this.yvalues = yvalues;
	                this.yminmax = yminmax;
	            },

	            processRangeOptions: function processRangeOptions() {
	                var options = this.options,
	                    normalRangeMin = options.get('normalRangeMin'),
	                    normalRangeMax = options.get('normalRangeMax');

	                if (normalRangeMin !== undefined) {
	                    if (normalRangeMin < this.miny) {
	                        this.miny = normalRangeMin;
	                    }
	                    if (normalRangeMax > this.maxy) {
	                        this.maxy = normalRangeMax;
	                    }
	                }
	                if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.miny)) {
	                    this.miny = options.get('chartRangeMin');
	                }
	                if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.maxy)) {
	                    this.maxy = options.get('chartRangeMax');
	                }
	                if (options.get('chartRangeMinX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMinX') < this.minx)) {
	                    this.minx = options.get('chartRangeMinX');
	                }
	                if (options.get('chartRangeMaxX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMaxX') > this.maxx)) {
	                    this.maxx = options.get('chartRangeMaxX');
	                }
	            },

	            drawNormalRange: function drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey) {
	                var normalRangeMin = this.options.get('normalRangeMin'),
	                    normalRangeMax = this.options.get('normalRangeMax'),
	                    ytop = canvasTop + Math.round(canvasHeight - canvasHeight * ((normalRangeMax - this.miny) / rangey)),
	                    height = Math.round(canvasHeight * (normalRangeMax - normalRangeMin) / rangey);
	                this.target.drawRect(canvasLeft, ytop, canvasWidth, height, undefined, this.options.get('normalRangeColor')).append();
	            },

	            render: function render() {
	                var options = this.options,
	                    target = this.target,
	                    canvasWidth = this.canvasWidth,
	                    canvasHeight = this.canvasHeight,
	                    vertices = this.vertices,
	                    spotRadius = options.get('spotRadius'),
	                    regionMap = this.regionMap,
	                    rangex,
	                    rangey,
	                    yvallast,
	                    canvasTop,
	                    canvasLeft,
	                    vertex,
	                    path,
	                    paths,
	                    x,
	                    y,
	                    xnext,
	                    xpos,
	                    xposnext,
	                    last,
	                    next,
	                    yvalcount,
	                    lineShapes,
	                    fillShapes,
	                    plen,
	                    valueSpots,
	                    hlSpotsEnabled,
	                    color,
	                    xvalues,
	                    yvalues,
	                    i;

	                if (!line._super.render.call(this)) {
	                    return;
	                }

	                this.scanValues();
	                this.processRangeOptions();

	                xvalues = this.xvalues;
	                yvalues = this.yvalues;

	                if (!this.yminmax.length || this.yvalues.length < 2) {
	                    // empty or all null valuess
	                    return;
	                }

	                canvasTop = canvasLeft = 0;

	                rangex = this.maxx - this.minx === 0 ? 1 : this.maxx - this.minx;
	                rangey = this.maxy - this.miny === 0 ? 1 : this.maxy - this.miny;
	                yvallast = this.yvalues.length - 1;

	                if (spotRadius && (canvasWidth < spotRadius * 4 || canvasHeight < spotRadius * 4)) {
	                    spotRadius = 0;
	                }
	                if (spotRadius) {
	                    // adjust the canvas size as required so that spots will fit
	                    hlSpotsEnabled = options.get('highlightSpotColor') && !options.get('disableInteraction');
	                    if (hlSpotsEnabled || options.get('minSpotColor') || options.get('spotColor') && yvalues[yvallast] === this.miny) {
	                        canvasHeight -= Math.ceil(spotRadius);
	                    }
	                    if (hlSpotsEnabled || options.get('maxSpotColor') || options.get('spotColor') && yvalues[yvallast] === this.maxy) {
	                        canvasHeight -= Math.ceil(spotRadius);
	                        canvasTop += Math.ceil(spotRadius);
	                    }
	                    if (hlSpotsEnabled || (options.get('minSpotColor') || options.get('maxSpotColor')) && (yvalues[0] === this.miny || yvalues[0] === this.maxy)) {
	                        canvasLeft += Math.ceil(spotRadius);
	                        canvasWidth -= Math.ceil(spotRadius);
	                    }
	                    if (hlSpotsEnabled || options.get('spotColor') || options.get('minSpotColor') || options.get('maxSpotColor') && (yvalues[yvallast] === this.miny || yvalues[yvallast] === this.maxy)) {
	                        canvasWidth -= Math.ceil(spotRadius);
	                    }
	                }

	                canvasHeight--;

	                if (options.get('normalRangeMin') !== undefined && !options.get('drawNormalOnTop')) {
	                    this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);
	                }

	                path = [];
	                paths = [path];
	                last = next = null;
	                yvalcount = yvalues.length;
	                for (i = 0; i < yvalcount; i++) {
	                    x = xvalues[i];
	                    xnext = xvalues[i + 1];
	                    y = yvalues[i];
	                    xpos = canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex));
	                    xposnext = i < yvalcount - 1 ? canvasLeft + Math.round((xnext - this.minx) * (canvasWidth / rangex)) : canvasWidth;
	                    next = xpos + (xposnext - xpos) / 2;
	                    regionMap[i] = [last || 0, next, i];
	                    last = next;
	                    if (y === null) {
	                        if (i) {
	                            if (yvalues[i - 1] !== null) {
	                                path = [];
	                                paths.push(path);
	                            }
	                            vertices.push(null);
	                        }
	                    } else {
	                        if (y < this.miny) {
	                            y = this.miny;
	                        }
	                        if (y > this.maxy) {
	                            y = this.maxy;
	                        }
	                        if (!path.length) {
	                            // previous value was null
	                            path.push([xpos, canvasTop + canvasHeight]);
	                        }
	                        vertex = [xpos, canvasTop + Math.round(canvasHeight - canvasHeight * ((y - this.miny) / rangey))];
	                        path.push(vertex);
	                        vertices.push(vertex);
	                    }
	                }

	                lineShapes = [];
	                fillShapes = [];
	                plen = paths.length;
	                for (i = 0; i < plen; i++) {
	                    path = paths[i];
	                    if (path.length) {
	                        if (options.get('fillColor')) {
	                            path.push([path[path.length - 1][0], canvasTop + canvasHeight]);
	                            fillShapes.push(path.slice(0));
	                            path.pop();
	                        }
	                        // if there's only a single point in this path, then we want to display it
	                        // as a vertical line which means we keep path[0]  as is
	                        if (path.length > 2) {
	                            // else we want the first value
	                            path[0] = [path[0][0], path[1][1]];
	                        }
	                        lineShapes.push(path);
	                    }
	                }

	                // draw the fill first, then optionally the normal range, then the line on top of that
	                plen = fillShapes.length;
	                for (i = 0; i < plen; i++) {
	                    target.drawShape(fillShapes[i], options.get('fillColor'), options.get('fillColor')).append();
	                }

	                if (options.get('normalRangeMin') !== undefined && options.get('drawNormalOnTop')) {
	                    this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);
	                }

	                plen = lineShapes.length;
	                for (i = 0; i < plen; i++) {
	                    target.drawShape(lineShapes[i], options.get('lineColor'), undefined, options.get('lineWidth')).append();
	                }

	                if (spotRadius && options.get('valueSpots')) {
	                    valueSpots = options.get('valueSpots');
	                    if (valueSpots.get === undefined) {
	                        valueSpots = new RangeMap(valueSpots);
	                    }
	                    for (i = 0; i < yvalcount; i++) {
	                        color = valueSpots.get(yvalues[i]);
	                        if (color) {
	                            target.drawCircle(canvasLeft + Math.round((xvalues[i] - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((yvalues[i] - this.miny) / rangey)), spotRadius, undefined, color).append();
	                        }
	                    }
	                }
	                if (spotRadius && options.get('spotColor') && yvalues[yvallast] !== null) {
	                    target.drawCircle(canvasLeft + Math.round((xvalues[xvalues.length - 1] - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((yvalues[yvallast] - this.miny) / rangey)), spotRadius, undefined, options.get('spotColor')).append();
	                }
	                if (this.maxy !== this.minyorg) {
	                    if (spotRadius && options.get('minSpotColor')) {
	                        x = xvalues[$.inArray(this.minyorg, yvalues)];
	                        target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((this.minyorg - this.miny) / rangey)), spotRadius, undefined, options.get('minSpotColor')).append();
	                    }
	                    if (spotRadius && options.get('maxSpotColor')) {
	                        x = xvalues[$.inArray(this.maxyorg, yvalues)];
	                        target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((this.maxyorg - this.miny) / rangey)), spotRadius, undefined, options.get('maxSpotColor')).append();
	                    }
	                }

	                this.lastShapeId = target.getLastShapeId();
	                this.canvasTop = canvasTop;
	                target.render();
	            }
	        });

	        /**
	         * Bar charts
	         */
	        $.fn.sparkline.bar = bar = createClass($.fn.sparkline._base, barHighlightMixin, {
	            type: 'bar',

	            init: function init(el, values, options, width, height) {
	                var barWidth = parseInt(options.get('barWidth'), 10),
	                    barSpacing = parseInt(options.get('barSpacing'), 10),
	                    chartRangeMin = options.get('chartRangeMin'),
	                    chartRangeMax = options.get('chartRangeMax'),
	                    chartRangeClip = options.get('chartRangeClip'),
	                    stackMin = Infinity,
	                    stackMax = -Infinity,
	                    isStackString,
	                    groupMin,
	                    groupMax,
	                    stackRanges,
	                    numValues,
	                    i,
	                    vlen,
	                    range,
	                    zeroAxis,
	                    xaxisOffset,
	                    min,
	                    max,
	                    clipMin,
	                    clipMax,
	                    stacked,
	                    vlist,
	                    j,
	                    slen,
	                    svals,
	                    val,
	                    yoffset,
	                    yMaxCalc,
	                    canvasHeightEf;
	                bar._super.init.call(this, el, values, options, width, height);

	                // scan values to determine whether to stack bars
	                for (i = 0, vlen = values.length; i < vlen; i++) {
	                    val = values[i];
	                    isStackString = typeof val === 'string' && val.indexOf(':') > -1;
	                    if (isStackString || $.isArray(val)) {
	                        stacked = true;
	                        if (isStackString) {
	                            val = values[i] = normalizeValues(val.split(':'));
	                        }
	                        val = remove(val, null); // min/max will treat null as zero
	                        groupMin = Math.min.apply(Math, val);
	                        groupMax = Math.max.apply(Math, val);
	                        if (groupMin < stackMin) {
	                            stackMin = groupMin;
	                        }
	                        if (groupMax > stackMax) {
	                            stackMax = groupMax;
	                        }
	                    }
	                }

	                this.stacked = stacked;
	                this.regionShapes = {};
	                this.barWidth = barWidth;
	                this.barSpacing = barSpacing;
	                this.totalBarWidth = barWidth + barSpacing;
	                this.width = width = values.length * barWidth + (values.length - 1) * barSpacing;

	                this.initTarget();

	                if (chartRangeClip) {
	                    clipMin = chartRangeMin === undefined ? -Infinity : chartRangeMin;
	                    clipMax = chartRangeMax === undefined ? Infinity : chartRangeMax;
	                }

	                numValues = [];
	                stackRanges = stacked ? [] : numValues;
	                var stackTotals = [];
	                var stackRangesNeg = [];
	                for (i = 0, vlen = values.length; i < vlen; i++) {
	                    if (stacked) {
	                        vlist = values[i];
	                        values[i] = svals = [];
	                        stackTotals[i] = 0;
	                        stackRanges[i] = stackRangesNeg[i] = 0;
	                        for (j = 0, slen = vlist.length; j < slen; j++) {
	                            val = svals[j] = chartRangeClip ? clipval(vlist[j], clipMin, clipMax) : vlist[j];
	                            if (val !== null) {
	                                if (val > 0) {
	                                    stackTotals[i] += val;
	                                }
	                                if (stackMin < 0 && stackMax > 0) {
	                                    if (val < 0) {
	                                        stackRangesNeg[i] += Math.abs(val);
	                                    } else {
	                                        stackRanges[i] += val;
	                                    }
	                                } else {
	                                    stackRanges[i] += Math.abs(val - (val < 0 ? stackMax : stackMin));
	                                }
	                                numValues.push(val);
	                            }
	                        }
	                    } else {
	                        val = chartRangeClip ? clipval(values[i], clipMin, clipMax) : values[i];
	                        val = values[i] = normalizeValue(val);
	                        if (val !== null) {
	                            numValues.push(val);
	                        }
	                    }
	                }
	                this.max = max = Math.max.apply(Math, numValues);
	                this.min = min = Math.min.apply(Math, numValues);
	                this.stackMax = stackMax = stacked ? Math.max.apply(Math, stackTotals) : max;
	                this.stackMin = stackMin = stacked ? Math.min.apply(Math, numValues) : min;

	                if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < min)) {
	                    min = options.get('chartRangeMin');
	                }
	                if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > max)) {
	                    max = options.get('chartRangeMax');
	                }

	                this.zeroAxis = zeroAxis = options.get('zeroAxis', true);
	                if (min <= 0 && max >= 0 && zeroAxis) {
	                    xaxisOffset = 0;
	                } else if (zeroAxis == false) {
	                    xaxisOffset = min;
	                } else if (min > 0) {
	                    xaxisOffset = min;
	                } else {
	                    xaxisOffset = max;
	                }
	                this.xaxisOffset = xaxisOffset;

	                range = stacked ? Math.max.apply(Math, stackRanges) + Math.max.apply(Math, stackRangesNeg) : max - min;

	                // as we plot zero/min values a single pixel line, we add a pixel to all other
	                // values - Reduce the effective canvas size to suit
	                this.canvasHeightEf = zeroAxis && min < 0 ? this.canvasHeight - 2 : this.canvasHeight - 1;

	                if (min < xaxisOffset) {
	                    yMaxCalc = stacked && max >= 0 ? stackMax : max;
	                    yoffset = (yMaxCalc - xaxisOffset) / range * this.canvasHeight;
	                    if (yoffset !== Math.ceil(yoffset)) {
	                        this.canvasHeightEf -= 2;
	                        yoffset = Math.ceil(yoffset);
	                    }
	                } else {
	                    yoffset = this.canvasHeight;
	                }
	                this.yoffset = yoffset;

	                if ($.isArray(options.get('colorMap'))) {
	                    this.colorMapByIndex = options.get('colorMap');
	                    this.colorMapByValue = null;
	                } else {
	                    this.colorMapByIndex = null;
	                    this.colorMapByValue = options.get('colorMap');
	                    if (this.colorMapByValue && this.colorMapByValue.get === undefined) {
	                        this.colorMapByValue = new RangeMap(this.colorMapByValue);
	                    }
	                }

	                this.range = range;
	            },

	            getRegion: function getRegion(el, x, y) {
	                var result = Math.floor(x / this.totalBarWidth);
	                return result < 0 || result >= this.values.length ? undefined : result;
	            },

	            getCurrentRegionFields: function getCurrentRegionFields() {
	                var currentRegion = this.currentRegion,
	                    values = ensureArray(this.values[currentRegion]),
	                    result = [],
	                    value,
	                    i;
	                for (i = values.length; i--;) {
	                    value = values[i];
	                    result.push({
	                        isNull: value === null,
	                        value: value,
	                        color: this.calcColor(i, value, currentRegion),
	                        offset: currentRegion
	                    });
	                }
	                return result;
	            },

	            calcColor: function calcColor(stacknum, value, valuenum) {
	                var colorMapByIndex = this.colorMapByIndex,
	                    colorMapByValue = this.colorMapByValue,
	                    options = this.options,
	                    color,
	                    newColor;
	                if (this.stacked) {
	                    color = options.get('stackedBarColor');
	                } else {
	                    color = value < 0 ? options.get('negBarColor') : options.get('barColor');
	                }
	                if (value === 0 && options.get('zeroColor') !== undefined) {
	                    color = options.get('zeroColor');
	                }
	                if (colorMapByValue && (newColor = colorMapByValue.get(value))) {
	                    color = newColor;
	                } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {
	                    color = colorMapByIndex[valuenum];
	                }
	                return $.isArray(color) ? color[stacknum % color.length] : color;
	            },

	            /**
	             * Render bar(s) for a region
	             */
	            renderRegion: function renderRegion(valuenum, highlight) {
	                var vals = this.values[valuenum],
	                    options = this.options,
	                    xaxisOffset = this.xaxisOffset,
	                    result = [],
	                    range = this.range,
	                    stacked = this.stacked,
	                    target = this.target,
	                    x = valuenum * this.totalBarWidth,
	                    canvasHeightEf = this.canvasHeightEf,
	                    yoffset = this.yoffset,
	                    y,
	                    height,
	                    color,
	                    isNull,
	                    yoffsetNeg,
	                    i,
	                    valcount,
	                    val,
	                    minPlotted,
	                    allMin;

	                vals = $.isArray(vals) ? vals : [vals];
	                valcount = vals.length;
	                val = vals[0];
	                isNull = all(null, vals);
	                allMin = all(xaxisOffset, vals, true);

	                if (isNull) {
	                    if (options.get('nullColor')) {
	                        color = highlight ? options.get('nullColor') : this.calcHighlightColor(options.get('nullColor'), options);
	                        y = yoffset > 0 ? yoffset - 1 : yoffset;
	                        return target.drawRect(x, y, this.barWidth - 1, 0, color, color);
	                    } else {
	                        return undefined;
	                    }
	                }
	                yoffsetNeg = yoffset;
	                for (i = 0; i < valcount; i++) {
	                    val = vals[i];

	                    if (stacked && val === xaxisOffset) {
	                        if (!allMin || minPlotted) {
	                            continue;
	                        }
	                        minPlotted = true;
	                    }

	                    if (range > 0) {
	                        height = Math.floor(canvasHeightEf * (Math.abs(val - xaxisOffset) / range)) + 1;
	                    } else {
	                        height = 1;
	                    }
	                    if (val < xaxisOffset || val === xaxisOffset && yoffset === 0) {
	                        y = yoffsetNeg;
	                        yoffsetNeg += height;
	                    } else {
	                        y = yoffset - height;
	                        yoffset -= height;
	                    }
	                    color = this.calcColor(i, val, valuenum);
	                    if (highlight) {
	                        color = this.calcHighlightColor(color, options);
	                    }
	                    result.push(target.drawRect(x, y, this.barWidth - 1, height - 1, color, color));
	                }
	                if (result.length === 1) {
	                    return result[0];
	                }
	                return result;
	            }
	        });

	        /**
	         * Tristate charts
	         */
	        $.fn.sparkline.tristate = tristate = createClass($.fn.sparkline._base, barHighlightMixin, {
	            type: 'tristate',

	            init: function init(el, values, options, width, height) {
	                var barWidth = parseInt(options.get('barWidth'), 10),
	                    barSpacing = parseInt(options.get('barSpacing'), 10);
	                tristate._super.init.call(this, el, values, options, width, height);

	                this.regionShapes = {};
	                this.barWidth = barWidth;
	                this.barSpacing = barSpacing;
	                this.totalBarWidth = barWidth + barSpacing;
	                this.values = $.map(values, Number);
	                this.width = width = values.length * barWidth + (values.length - 1) * barSpacing;

	                if ($.isArray(options.get('colorMap'))) {
	                    this.colorMapByIndex = options.get('colorMap');
	                    this.colorMapByValue = null;
	                } else {
	                    this.colorMapByIndex = null;
	                    this.colorMapByValue = options.get('colorMap');
	                    if (this.colorMapByValue && this.colorMapByValue.get === undefined) {
	                        this.colorMapByValue = new RangeMap(this.colorMapByValue);
	                    }
	                }
	                this.initTarget();
	            },

	            getRegion: function getRegion(el, x, y) {
	                return Math.floor(x / this.totalBarWidth);
	            },

	            getCurrentRegionFields: function getCurrentRegionFields() {
	                var currentRegion = this.currentRegion;
	                return {
	                    isNull: this.values[currentRegion] === undefined,
	                    value: this.values[currentRegion],
	                    color: this.calcColor(this.values[currentRegion], currentRegion),
	                    offset: currentRegion
	                };
	            },

	            calcColor: function calcColor(value, valuenum) {
	                var values = this.values,
	                    options = this.options,
	                    colorMapByIndex = this.colorMapByIndex,
	                    colorMapByValue = this.colorMapByValue,
	                    color,
	                    newColor;

	                if (colorMapByValue && (newColor = colorMapByValue.get(value))) {
	                    color = newColor;
	                } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {
	                    color = colorMapByIndex[valuenum];
	                } else if (values[valuenum] < 0) {
	                    color = options.get('negBarColor');
	                } else if (values[valuenum] > 0) {
	                    color = options.get('posBarColor');
	                } else {
	                    color = options.get('zeroBarColor');
	                }
	                return color;
	            },

	            renderRegion: function renderRegion(valuenum, highlight) {
	                var values = this.values,
	                    options = this.options,
	                    target = this.target,
	                    canvasHeight,
	                    height,
	                    halfHeight,
	                    x,
	                    y,
	                    color;

	                canvasHeight = target.pixelHeight;
	                halfHeight = Math.round(canvasHeight / 2);

	                x = valuenum * this.totalBarWidth;
	                if (values[valuenum] < 0) {
	                    y = halfHeight;
	                    height = halfHeight - 1;
	                } else if (values[valuenum] > 0) {
	                    y = 0;
	                    height = halfHeight - 1;
	                } else {
	                    y = halfHeight - 1;
	                    height = 2;
	                }
	                color = this.calcColor(values[valuenum], valuenum);
	                if (color === null) {
	                    return;
	                }
	                if (highlight) {
	                    color = this.calcHighlightColor(color, options);
	                }
	                return target.drawRect(x, y, this.barWidth - 1, height - 1, color, color);
	            }
	        });

	        /**
	         * Discrete charts
	         */
	        $.fn.sparkline.discrete = discrete = createClass($.fn.sparkline._base, barHighlightMixin, {
	            type: 'discrete',

	            init: function init(el, values, options, width, height) {
	                discrete._super.init.call(this, el, values, options, width, height);

	                this.regionShapes = {};
	                this.values = values = $.map(values, Number);
	                this.min = Math.min.apply(Math, values);
	                this.max = Math.max.apply(Math, values);
	                this.range = this.max - this.min;
	                this.width = width = options.get('width') === 'auto' ? values.length * 2 : this.width;
	                this.interval = Math.floor(width / values.length);
	                this.itemWidth = width / values.length;
	                if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.min)) {
	                    this.min = options.get('chartRangeMin');
	                }
	                if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.max)) {
	                    this.max = options.get('chartRangeMax');
	                }
	                this.initTarget();
	                if (this.target) {
	                    this.lineHeight = options.get('lineHeight') === 'auto' ? Math.round(this.canvasHeight * 0.3) : options.get('lineHeight');
	                }
	            },

	            getRegion: function getRegion(el, x, y) {
	                return Math.floor(x / this.itemWidth);
	            },

	            getCurrentRegionFields: function getCurrentRegionFields() {
	                var currentRegion = this.currentRegion;
	                return {
	                    isNull: this.values[currentRegion] === undefined,
	                    value: this.values[currentRegion],
	                    offset: currentRegion
	                };
	            },

	            renderRegion: function renderRegion(valuenum, highlight) {
	                var values = this.values,
	                    options = this.options,
	                    min = this.min,
	                    max = this.max,
	                    range = this.range,
	                    interval = this.interval,
	                    target = this.target,
	                    canvasHeight = this.canvasHeight,
	                    lineHeight = this.lineHeight,
	                    pheight = canvasHeight - lineHeight,
	                    ytop,
	                    val,
	                    color,
	                    x;

	                val = clipval(values[valuenum], min, max);
	                x = valuenum * interval;
	                ytop = Math.round(pheight - pheight * ((val - min) / range));
	                color = options.get('thresholdColor') && val < options.get('thresholdValue') ? options.get('thresholdColor') : options.get('lineColor');
	                if (highlight) {
	                    color = this.calcHighlightColor(color, options);
	                }
	                return target.drawLine(x, ytop, x, ytop + lineHeight, color);
	            }
	        });

	        /**
	         * Bullet charts
	         */
	        $.fn.sparkline.bullet = bullet = createClass($.fn.sparkline._base, {
	            type: 'bullet',

	            init: function init(el, values, options, width, height) {
	                var min, max, vals;
	                bullet._super.init.call(this, el, values, options, width, height);

	                // values: target, performance, range1, range2, range3
	                this.values = values = normalizeValues(values);
	                // target or performance could be null
	                vals = values.slice();
	                vals[0] = vals[0] === null ? vals[2] : vals[0];
	                vals[1] = values[1] === null ? vals[2] : vals[1];
	                min = Math.min.apply(Math, values);
	                max = Math.max.apply(Math, values);
	                if (options.get('base') === undefined) {
	                    min = min < 0 ? min : 0;
	                } else {
	                    min = options.get('base');
	                }
	                this.min = min;
	                this.max = max;
	                this.range = max - min;
	                this.shapes = {};
	                this.valueShapes = {};
	                this.regiondata = {};
	                this.width = width = options.get('width') === 'auto' ? '4.0em' : width;
	                this.target = this.$el.simpledraw(width, height, options.get('composite'));
	                if (!values.length) {
	                    this.disabled = true;
	                }
	                this.initTarget();
	            },

	            getRegion: function getRegion(el, x, y) {
	                var shapeid = this.target.getShapeAt(el, x, y);
	                return shapeid !== undefined && this.shapes[shapeid] !== undefined ? this.shapes[shapeid] : undefined;
	            },

	            getCurrentRegionFields: function getCurrentRegionFields() {
	                var currentRegion = this.currentRegion;
	                return {
	                    fieldkey: currentRegion.substr(0, 1),
	                    value: this.values[currentRegion.substr(1)],
	                    region: currentRegion
	                };
	            },

	            changeHighlight: function changeHighlight(highlight) {
	                var currentRegion = this.currentRegion,
	                    shapeid = this.valueShapes[currentRegion],
	                    shape;
	                delete this.shapes[shapeid];
	                switch (currentRegion.substr(0, 1)) {
	                    case 'r':
	                        shape = this.renderRange(currentRegion.substr(1), highlight);
	                        break;
	                    case 'p':
	                        shape = this.renderPerformance(highlight);
	                        break;
	                    case 't':
	                        shape = this.renderTarget(highlight);
	                        break;
	                }
	                this.valueShapes[currentRegion] = shape.id;
	                this.shapes[shape.id] = currentRegion;
	                this.target.replaceWithShape(shapeid, shape);
	            },

	            renderRange: function renderRange(rn, highlight) {
	                var rangeval = this.values[rn],
	                    rangewidth = Math.round(this.canvasWidth * ((rangeval - this.min) / this.range)),
	                    color = this.options.get('rangeColors')[rn - 2];
	                if (highlight) {
	                    color = this.calcHighlightColor(color, this.options);
	                }
	                return this.target.drawRect(0, 0, rangewidth - 1, this.canvasHeight - 1, color, color);
	            },

	            renderPerformance: function renderPerformance(highlight) {
	                var perfval = this.values[1],
	                    perfwidth = Math.round(this.canvasWidth * ((perfval - this.min) / this.range)),
	                    color = this.options.get('performanceColor');
	                if (highlight) {
	                    color = this.calcHighlightColor(color, this.options);
	                }
	                return this.target.drawRect(0, Math.round(this.canvasHeight * 0.3), perfwidth - 1, Math.round(this.canvasHeight * 0.4) - 1, color, color);
	            },

	            renderTarget: function renderTarget(highlight) {
	                var targetval = this.values[0],
	                    x = Math.round(this.canvasWidth * ((targetval - this.min) / this.range) - this.options.get('targetWidth') / 2),
	                    targettop = Math.round(this.canvasHeight * 0.10),
	                    targetheight = this.canvasHeight - targettop * 2,
	                    color = this.options.get('targetColor');
	                if (highlight) {
	                    color = this.calcHighlightColor(color, this.options);
	                }
	                return this.target.drawRect(x, targettop, this.options.get('targetWidth') - 1, targetheight - 1, color, color);
	            },

	            render: function render() {
	                var vlen = this.values.length,
	                    target = this.target,
	                    i,
	                    shape;
	                if (!bullet._super.render.call(this)) {
	                    return;
	                }
	                for (i = 2; i < vlen; i++) {
	                    shape = this.renderRange(i).append();
	                    this.shapes[shape.id] = 'r' + i;
	                    this.valueShapes['r' + i] = shape.id;
	                }
	                if (this.values[1] !== null) {
	                    shape = this.renderPerformance().append();
	                    this.shapes[shape.id] = 'p1';
	                    this.valueShapes.p1 = shape.id;
	                }
	                if (this.values[0] !== null) {
	                    shape = this.renderTarget().append();
	                    this.shapes[shape.id] = 't0';
	                    this.valueShapes.t0 = shape.id;
	                }
	                target.render();
	            }
	        });

	        /**
	         * Pie charts
	         */
	        $.fn.sparkline.pie = pie = createClass($.fn.sparkline._base, {
	            type: 'pie',

	            init: function init(el, values, options, width, height) {
	                var total = 0,
	                    i;

	                pie._super.init.call(this, el, values, options, width, height);

	                this.shapes = {}; // map shape ids to value offsets
	                this.valueShapes = {}; // maps value offsets to shape ids
	                this.values = values = $.map(values, Number);

	                if (options.get('width') === 'auto') {
	                    this.width = this.height;
	                }

	                if (values.length > 0) {
	                    for (i = values.length; i--;) {
	                        total += values[i];
	                    }
	                }
	                this.total = total;
	                this.initTarget();
	                this.radius = Math.floor(Math.min(this.canvasWidth, this.canvasHeight) / 2);
	            },

	            getRegion: function getRegion(el, x, y) {
	                var shapeid = this.target.getShapeAt(el, x, y);
	                return shapeid !== undefined && this.shapes[shapeid] !== undefined ? this.shapes[shapeid] : undefined;
	            },

	            getCurrentRegionFields: function getCurrentRegionFields() {
	                var currentRegion = this.currentRegion;
	                return {
	                    isNull: this.values[currentRegion] === undefined,
	                    value: this.values[currentRegion],
	                    percent: this.values[currentRegion] / this.total * 100,
	                    color: this.options.get('sliceColors')[currentRegion % this.options.get('sliceColors').length],
	                    offset: currentRegion
	                };
	            },

	            changeHighlight: function changeHighlight(highlight) {
	                var currentRegion = this.currentRegion,
	                    newslice = this.renderSlice(currentRegion, highlight),
	                    shapeid = this.valueShapes[currentRegion];
	                delete this.shapes[shapeid];
	                this.target.replaceWithShape(shapeid, newslice);
	                this.valueShapes[currentRegion] = newslice.id;
	                this.shapes[newslice.id] = currentRegion;
	            },

	            renderSlice: function renderSlice(valuenum, highlight) {
	                var target = this.target,
	                    options = this.options,
	                    radius = this.radius,
	                    borderWidth = options.get('borderWidth'),
	                    offset = options.get('offset'),
	                    circle = 2 * Math.PI,
	                    values = this.values,
	                    total = this.total,
	                    next = offset ? 2 * Math.PI * (offset / 360) : 0,
	                    start,
	                    end,
	                    i,
	                    vlen,
	                    color;

	                vlen = values.length;
	                for (i = 0; i < vlen; i++) {
	                    start = next;
	                    end = next;
	                    if (total > 0) {
	                        // avoid divide by zero
	                        end = next + circle * (values[i] / total);
	                    }
	                    if (valuenum === i) {
	                        color = options.get('sliceColors')[i % options.get('sliceColors').length];
	                        if (highlight) {
	                            color = this.calcHighlightColor(color, options);
	                        }

	                        return target.drawPieSlice(radius, radius, radius - borderWidth, start, end, undefined, color);
	                    }
	                    next = end;
	                }
	            },

	            render: function render() {
	                var target = this.target,
	                    values = this.values,
	                    options = this.options,
	                    radius = this.radius,
	                    borderWidth = options.get('borderWidth'),
	                    shape,
	                    i;

	                if (!pie._super.render.call(this)) {
	                    return;
	                }
	                if (borderWidth) {
	                    target.drawCircle(radius, radius, Math.floor(radius - borderWidth / 2), options.get('borderColor'), undefined, borderWidth).append();
	                }
	                for (i = values.length; i--;) {
	                    if (values[i]) {
	                        // don't render zero values
	                        shape = this.renderSlice(i).append();
	                        this.valueShapes[i] = shape.id; // store just the shapeid
	                        this.shapes[shape.id] = i;
	                    }
	                }
	                target.render();
	            }
	        });

	        /**
	         * Box plots
	         */
	        $.fn.sparkline.box = box = createClass($.fn.sparkline._base, {
	            type: 'box',

	            init: function init(el, values, options, width, height) {
	                box._super.init.call(this, el, values, options, width, height);
	                this.values = $.map(values, Number);
	                this.width = options.get('width') === 'auto' ? '4.0em' : width;
	                this.initTarget();
	                if (!this.values.length) {
	                    this.disabled = 1;
	                }
	            },

	            /**
	             * Simulate a single region
	             */
	            getRegion: function getRegion() {
	                return 1;
	            },

	            getCurrentRegionFields: function getCurrentRegionFields() {
	                var result = [{ field: 'lq', value: this.quartiles[0] }, { field: 'med', value: this.quartiles[1] }, { field: 'uq', value: this.quartiles[2] }];
	                if (this.loutlier !== undefined) {
	                    result.push({ field: 'lo', value: this.loutlier });
	                }
	                if (this.routlier !== undefined) {
	                    result.push({ field: 'ro', value: this.routlier });
	                }
	                if (this.lwhisker !== undefined) {
	                    result.push({ field: 'lw', value: this.lwhisker });
	                }
	                if (this.rwhisker !== undefined) {
	                    result.push({ field: 'rw', value: this.rwhisker });
	                }
	                return result;
	            },

	            render: function render() {
	                var target = this.target,
	                    values = this.values,
	                    vlen = values.length,
	                    options = this.options,
	                    canvasWidth = this.canvasWidth,
	                    canvasHeight = this.canvasHeight,
	                    minValue = options.get('chartRangeMin') === undefined ? Math.min.apply(Math, values) : options.get('chartRangeMin'),
	                    maxValue = options.get('chartRangeMax') === undefined ? Math.max.apply(Math, values) : options.get('chartRangeMax'),
	                    canvasLeft = 0,
	                    lwhisker,
	                    loutlier,
	                    iqr,
	                    q1,
	                    q2,
	                    q3,
	                    rwhisker,
	                    routlier,
	                    i,
	                    size,
	                    unitSize;

	                if (!box._super.render.call(this)) {
	                    return;
	                }

	                if (options.get('raw')) {
	                    if (options.get('showOutliers') && values.length > 5) {
	                        loutlier = values[0];
	                        lwhisker = values[1];
	                        q1 = values[2];
	                        q2 = values[3];
	                        q3 = values[4];
	                        rwhisker = values[5];
	                        routlier = values[6];
	                    } else {
	                        lwhisker = values[0];
	                        q1 = values[1];
	                        q2 = values[2];
	                        q3 = values[3];
	                        rwhisker = values[4];
	                    }
	                } else {
	                    values.sort(function (a, b) {
	                        return a - b;
	                    });
	                    q1 = quartile(values, 1);
	                    q2 = quartile(values, 2);
	                    q3 = quartile(values, 3);
	                    iqr = q3 - q1;
	                    if (options.get('showOutliers')) {
	                        lwhisker = rwhisker = undefined;
	                        for (i = 0; i < vlen; i++) {
	                            if (lwhisker === undefined && values[i] > q1 - iqr * options.get('outlierIQR')) {
	                                lwhisker = values[i];
	                            }
	                            if (values[i] < q3 + iqr * options.get('outlierIQR')) {
	                                rwhisker = values[i];
	                            }
	                        }
	                        loutlier = values[0];
	                        routlier = values[vlen - 1];
	                    } else {
	                        lwhisker = values[0];
	                        rwhisker = values[vlen - 1];
	                    }
	                }
	                this.quartiles = [q1, q2, q3];
	                this.lwhisker = lwhisker;
	                this.rwhisker = rwhisker;
	                this.loutlier = loutlier;
	                this.routlier = routlier;

	                unitSize = canvasWidth / (maxValue - minValue + 1);
	                if (options.get('showOutliers')) {
	                    canvasLeft = Math.ceil(options.get('spotRadius'));
	                    canvasWidth -= 2 * Math.ceil(options.get('spotRadius'));
	                    unitSize = canvasWidth / (maxValue - minValue + 1);
	                    if (loutlier < lwhisker) {
	                        target.drawCircle((loutlier - minValue) * unitSize + canvasLeft, canvasHeight / 2, options.get('spotRadius'), options.get('outlierLineColor'), options.get('outlierFillColor')).append();
	                    }
	                    if (routlier > rwhisker) {
	                        target.drawCircle((routlier - minValue) * unitSize + canvasLeft, canvasHeight / 2, options.get('spotRadius'), options.get('outlierLineColor'), options.get('outlierFillColor')).append();
	                    }
	                }

	                // box
	                target.drawRect(Math.round((q1 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.1), Math.round((q3 - q1) * unitSize), Math.round(canvasHeight * 0.8), options.get('boxLineColor'), options.get('boxFillColor')).append();
	                // left whisker
	                target.drawLine(Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), Math.round((q1 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), options.get('lineColor')).append();
	                target.drawLine(Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 4), Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight - canvasHeight / 4), options.get('whiskerColor')).append();
	                // right whisker
	                target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), Math.round((q3 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), options.get('lineColor')).append();
	                target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 4), Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight - canvasHeight / 4), options.get('whiskerColor')).append();
	                // median line
	                target.drawLine(Math.round((q2 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.1), Math.round((q2 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.9), options.get('medianColor')).append();
	                if (options.get('target')) {
	                    size = Math.ceil(options.get('spotRadius'));
	                    target.drawLine(Math.round((options.get('target') - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2 - size), Math.round((options.get('target') - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2 + size), options.get('targetColor')).append();
	                    target.drawLine(Math.round((options.get('target') - minValue) * unitSize + canvasLeft - size), Math.round(canvasHeight / 2), Math.round((options.get('target') - minValue) * unitSize + canvasLeft + size), Math.round(canvasHeight / 2), options.get('targetColor')).append();
	                }
	                target.render();
	            }
	        });

	        // Setup a very simple "virtual canvas" to make drawing the few shapes we need easier
	        // This is accessible as $(foo).simpledraw()

	        VShape = createClass({
	            init: function init(target, id, type, args) {
	                this.target = target;
	                this.id = id;
	                this.type = type;
	                this.args = args;
	            },
	            append: function append() {
	                this.target.appendShape(this);
	                return this;
	            }
	        });

	        VCanvas_base = createClass({
	            _pxregex: /(\d+)(px)?\s*$/i,

	            init: function init(width, height, target) {
	                if (!width) {
	                    return;
	                }
	                this.width = width;
	                this.height = height;
	                this.target = target;
	                this.lastShapeId = null;
	                if (target[0]) {
	                    target = target[0];
	                }
	                $.data(target, '_jqs_vcanvas', this);
	            },

	            drawLine: function drawLine(x1, y1, x2, y2, lineColor, lineWidth) {
	                return this.drawShape([[x1, y1], [x2, y2]], lineColor, lineWidth);
	            },

	            drawShape: function drawShape(path, lineColor, fillColor, lineWidth) {
	                return this._genShape('Shape', [path, lineColor, fillColor, lineWidth]);
	            },

	            drawCircle: function drawCircle(x, y, radius, lineColor, fillColor, lineWidth) {
	                return this._genShape('Circle', [x, y, radius, lineColor, fillColor, lineWidth]);
	            },

	            drawPieSlice: function drawPieSlice(x, y, radius, startAngle, endAngle, lineColor, fillColor) {
	                return this._genShape('PieSlice', [x, y, radius, startAngle, endAngle, lineColor, fillColor]);
	            },

	            drawRect: function drawRect(x, y, width, height, lineColor, fillColor) {
	                return this._genShape('Rect', [x, y, width, height, lineColor, fillColor]);
	            },

	            getElement: function getElement() {
	                return this.canvas;
	            },

	            /**
	             * Return the most recently inserted shape id
	             */
	            getLastShapeId: function getLastShapeId() {
	                return this.lastShapeId;
	            },

	            /**
	             * Clear and reset the canvas
	             */
	            reset: function reset() {
	                window.alert('reset not implemented');
	            },

	            _insert: function _insert(el, target) {
	                $(target).html(el);
	            },

	            /**
	             * Calculate the pixel dimensions of the canvas
	             */
	            _calculatePixelDims: function _calculatePixelDims(width, height, canvas) {
	                // XXX This should probably be a configurable option
	                var match;
	                match = this._pxregex.exec(height);
	                if (match) {
	                    this.pixelHeight = match[1];
	                } else {
	                    this.pixelHeight = $(canvas).height();
	                }
	                match = this._pxregex.exec(width);
	                if (match) {
	                    this.pixelWidth = match[1];
	                } else {
	                    this.pixelWidth = $(canvas).width();
	                }
	            },

	            /**
	             * Generate a shape object and id for later rendering
	             */
	            _genShape: function _genShape(shapetype, shapeargs) {
	                var id = shapeCount++;
	                shapeargs.unshift(id);
	                return new VShape(this, id, shapetype, shapeargs);
	            },

	            /**
	             * Add a shape to the end of the render queue
	             */
	            appendShape: function appendShape(shape) {
	                window.alert('appendShape not implemented');
	            },

	            /**
	             * Replace one shape with another
	             */
	            replaceWithShape: function replaceWithShape(shapeid, shape) {
	                window.alert('replaceWithShape not implemented');
	            },

	            /**
	             * Insert one shape after another in the render queue
	             */
	            insertAfterShape: function insertAfterShape(shapeid, shape) {
	                window.alert('insertAfterShape not implemented');
	            },

	            /**
	             * Remove a shape from the queue
	             */
	            removeShapeId: function removeShapeId(shapeid) {
	                window.alert('removeShapeId not implemented');
	            },

	            /**
	             * Find a shape at the specified x/y co-ordinates
	             */
	            getShapeAt: function getShapeAt(el, x, y) {
	                window.alert('getShapeAt not implemented');
	            },

	            /**
	             * Render all queued shapes onto the canvas
	             */
	            render: function render() {
	                window.alert('render not implemented');
	            }
	        });

	        VCanvas_canvas = createClass(VCanvas_base, {
	            init: function init(width, height, target, interact) {
	                VCanvas_canvas._super.init.call(this, width, height, target);
	                this.canvas = document.createElement('canvas');
	                if (target[0]) {
	                    target = target[0];
	                }
	                this.context = this.canvas.getContext('2d');
	                var devicePixelRatio = window.devicePixelRatio || 1,
	                    backingStoreRatio = this.context.webkitBackingStorePixelRatio || this.context.mozBackingStorePixelRatio || this.context.msBackingStorePixelRatio || this.context.oBackingStorePixelRatio || this.context.backingStorePixelRatio || 1,
	                    ratio = devicePixelRatio / backingStoreRatio;
	                $.data(target, '_jqs_vcanvas', this);
	                $(this.canvas).css({ display: 'inline-block', width: width, height: height, verticalAlign: 'top' });
	                this._insert(this.canvas, target);
	                this._calculatePixelDims(width, height, this.canvas);
	                this.canvas.width = this.pixelWidth * ratio;
	                this.canvas.height = this.pixelHeight * ratio;
	                this.context.scale(ratio, ratio);
	                this.interact = interact;
	                this.shapes = {};
	                this.shapeseq = [];
	                this.currentTargetShapeId = undefined;
	                $(this.canvas).css({ width: this.pixelWidth, height: this.pixelHeight });
	            },

	            _getContext: function _getContext(lineColor, fillColor, lineWidth) {
	                var context = this.canvas.getContext('2d');
	                if (lineColor !== undefined) {
	                    context.strokeStyle = lineColor;
	                }
	                context.lineWidth = lineWidth === undefined ? 1 : lineWidth;
	                if (fillColor !== undefined) {
	                    context.fillStyle = fillColor;
	                }
	                return context;
	            },

	            reset: function reset() {
	                var context = this._getContext();
	                context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
	                this.shapes = {};
	                this.shapeseq = [];
	                this.currentTargetShapeId = undefined;
	            },

	            _drawShape: function _drawShape(shapeid, path, lineColor, fillColor, lineWidth) {
	                var context = this._getContext(lineColor, fillColor, lineWidth),
	                    i,
	                    plen;
	                context.beginPath();
	                context.moveTo(path[0][0] + 0.5, path[0][1] + 0.5);
	                for (i = 1, plen = path.length; i < plen; i++) {
	                    context.lineTo(path[i][0] + 0.5, path[i][1] + 0.5); // the 0.5 offset gives us crisp pixel-width lines
	                }
	                if (lineColor !== undefined) {
	                    context.stroke();
	                }
	                if (fillColor !== undefined) {
	                    context.fill();
	                }
	                if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {
	                    this.currentTargetShapeId = shapeid;
	                }
	            },

	            _drawCircle: function _drawCircle(shapeid, x, y, radius, lineColor, fillColor, lineWidth) {
	                var context = this._getContext(lineColor, fillColor, lineWidth);
	                context.beginPath();
	                context.arc(x, y, radius, 0, 2 * Math.PI, false);
	                if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {
	                    this.currentTargetShapeId = shapeid;
	                }
	                if (lineColor !== undefined) {
	                    context.stroke();
	                }
	                if (fillColor !== undefined) {
	                    context.fill();
	                }
	            },

	            _drawPieSlice: function _drawPieSlice(shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {
	                var context = this._getContext(lineColor, fillColor);
	                context.beginPath();
	                context.moveTo(x, y);
	                context.arc(x, y, radius, startAngle, endAngle, false);
	                context.lineTo(x, y);
	                context.closePath();
	                if (lineColor !== undefined) {
	                    context.stroke();
	                }
	                if (fillColor) {
	                    context.fill();
	                }
	                if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {
	                    this.currentTargetShapeId = shapeid;
	                }
	            },

	            _drawRect: function _drawRect(shapeid, x, y, width, height, lineColor, fillColor) {
	                return this._drawShape(shapeid, [[x, y], [x + width, y], [x + width, y + height], [x, y + height], [x, y]], lineColor, fillColor);
	            },

	            appendShape: function appendShape(shape) {
	                this.shapes[shape.id] = shape;
	                this.shapeseq.push(shape.id);
	                this.lastShapeId = shape.id;
	                return shape.id;
	            },

	            replaceWithShape: function replaceWithShape(shapeid, shape) {
	                var shapeseq = this.shapeseq,
	                    i;
	                this.shapes[shape.id] = shape;
	                for (i = shapeseq.length; i--;) {
	                    if (shapeseq[i] == shapeid) {
	                        shapeseq[i] = shape.id;
	                    }
	                }
	                delete this.shapes[shapeid];
	            },

	            replaceWithShapes: function replaceWithShapes(shapeids, shapes) {
	                var shapeseq = this.shapeseq,
	                    shapemap = {},
	                    sid,
	                    i,
	                    first;

	                for (i = shapeids.length; i--;) {
	                    shapemap[shapeids[i]] = true;
	                }
	                for (i = shapeseq.length; i--;) {
	                    sid = shapeseq[i];
	                    if (shapemap[sid]) {
	                        shapeseq.splice(i, 1);
	                        delete this.shapes[sid];
	                        first = i;
	                    }
	                }
	                for (i = shapes.length; i--;) {
	                    shapeseq.splice(first, 0, shapes[i].id);
	                    this.shapes[shapes[i].id] = shapes[i];
	                }
	            },

	            insertAfterShape: function insertAfterShape(shapeid, shape) {
	                var shapeseq = this.shapeseq,
	                    i;
	                for (i = shapeseq.length; i--;) {
	                    if (shapeseq[i] === shapeid) {
	                        shapeseq.splice(i + 1, 0, shape.id);
	                        this.shapes[shape.id] = shape;
	                        return;
	                    }
	                }
	            },

	            removeShapeId: function removeShapeId(shapeid) {
	                var shapeseq = this.shapeseq,
	                    i;
	                for (i = shapeseq.length; i--;) {
	                    if (shapeseq[i] === shapeid) {
	                        shapeseq.splice(i, 1);
	                        break;
	                    }
	                }
	                delete this.shapes[shapeid];
	            },

	            getShapeAt: function getShapeAt(el, x, y) {
	                this.targetX = x;
	                this.targetY = y;
	                this.render();
	                return this.currentTargetShapeId;
	            },

	            render: function render() {
	                var shapeseq = this.shapeseq,
	                    shapes = this.shapes,
	                    shapeCount = shapeseq.length,
	                    context = this._getContext(),
	                    shapeid,
	                    shape,
	                    i;
	                context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
	                for (i = 0; i < shapeCount; i++) {
	                    shapeid = shapeseq[i];
	                    shape = shapes[shapeid];
	                    this['_draw' + shape.type].apply(this, shape.args);
	                }
	                if (!this.interact) {
	                    // not interactive so no need to keep the shapes array
	                    this.shapes = {};
	                    this.shapeseq = [];
	                }
	            }

	        });

	        VCanvas_vml = createClass(VCanvas_base, {
	            init: function init(width, height, target) {
	                var groupel;
	                VCanvas_vml._super.init.call(this, width, height, target);
	                if (target[0]) {
	                    target = target[0];
	                }
	                $.data(target, '_jqs_vcanvas', this);
	                this.canvas = document.createElement('span');
	                $(this.canvas).css({ display: 'inline-block', position: 'relative', overflow: 'hidden', width: width, height: height, margin: '0', padding: '0', verticalAlign: 'top' });
	                this._insert(this.canvas, target);
	                this._calculatePixelDims(width, height, this.canvas);
	                this.canvas.width = this.pixelWidth;
	                this.canvas.height = this.pixelHeight;
	                groupel = '<v:group coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '"' + ' style="position:absolute;top:0;left:0;width:' + this.pixelWidth + 'px;height=' + this.pixelHeight + 'px;"></v:group>';
	                this.canvas.insertAdjacentHTML('beforeEnd', groupel);
	                this.group = $(this.canvas).children()[0];
	                this.rendered = false;
	                this.prerender = '';
	            },

	            _drawShape: function _drawShape(shapeid, path, lineColor, fillColor, lineWidth) {
	                var vpath = [],
	                    initial,
	                    stroke,
	                    fill,
	                    closed,
	                    vel,
	                    plen,
	                    i;
	                for (i = 0, plen = path.length; i < plen; i++) {
	                    vpath[i] = '' + path[i][0] + ',' + path[i][1];
	                }
	                initial = vpath.splice(0, 1);
	                lineWidth = lineWidth === undefined ? 1 : lineWidth;
	                stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="' + lineWidth + 'px" strokeColor="' + lineColor + '" ';
	                fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
	                closed = vpath[0] === vpath[vpath.length - 1] ? 'x ' : '';
	                vel = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '" ' + ' id="jqsshape' + shapeid + '" ' + stroke + fill + ' style="position:absolute;left:0;top:0;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0;margin:0;" ' + ' path="m ' + initial + ' l ' + vpath.join(', ') + ' ' + closed + 'e">' + ' </v:shape>';
	                return vel;
	            },

	            _drawCircle: function _drawCircle(shapeid, x, y, radius, lineColor, fillColor, lineWidth) {
	                var stroke, fill, vel;
	                x -= radius;
	                y -= radius;
	                stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="' + lineWidth + 'px" strokeColor="' + lineColor + '" ';
	                fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
	                vel = '<v:oval ' + ' id="jqsshape' + shapeid + '" ' + stroke + fill + ' style="position:absolute;top:' + y + 'px; left:' + x + 'px; width:' + radius * 2 + 'px; height:' + radius * 2 + 'px"></v:oval>';
	                return vel;
	            },

	            _drawPieSlice: function _drawPieSlice(shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {
	                var vpath, startx, starty, endx, endy, stroke, fill, vel;
	                if (startAngle === endAngle) {
	                    return ''; // VML seems to have problem when start angle equals end angle.
	                }
	                if (endAngle - startAngle === 2 * Math.PI) {
	                    startAngle = 0.0; // VML seems to have a problem when drawing a full circle that doesn't start 0
	                    endAngle = 2 * Math.PI;
	                }

	                startx = x + Math.round(Math.cos(startAngle) * radius);
	                starty = y + Math.round(Math.sin(startAngle) * radius);
	                endx = x + Math.round(Math.cos(endAngle) * radius);
	                endy = y + Math.round(Math.sin(endAngle) * radius);

	                if (startx === endx && starty === endy) {
	                    if (endAngle - startAngle < Math.PI) {
	                        // Prevent very small slices from being mistaken as a whole pie
	                        return '';
	                    }
	                    // essentially going to be the entire circle, so ignore startAngle
	                    startx = endx = x + radius;
	                    starty = endy = y;
	                }

	                if (startx === endx && starty === endy && endAngle - startAngle < Math.PI) {
	                    return '';
	                }

	                vpath = [x - radius, y - radius, x + radius, y + radius, startx, starty, endx, endy];
	                stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="1px" strokeColor="' + lineColor + '" ';
	                fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
	                vel = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '" ' + ' id="jqsshape' + shapeid + '" ' + stroke + fill + ' style="position:absolute;left:0;top:0;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0;margin:0;" ' + ' path="m ' + x + ',' + y + ' wa ' + vpath.join(', ') + ' x e">' + ' </v:shape>';
	                return vel;
	            },

	            _drawRect: function _drawRect(shapeid, x, y, width, height, lineColor, fillColor) {
	                return this._drawShape(shapeid, [[x, y], [x, y + height], [x + width, y + height], [x + width, y], [x, y]], lineColor, fillColor);
	            },

	            reset: function reset() {
	                this.group.innerHTML = '';
	            },

	            appendShape: function appendShape(shape) {
	                var vel = this['_draw' + shape.type].apply(this, shape.args);
	                if (this.rendered) {
	                    this.group.insertAdjacentHTML('beforeEnd', vel);
	                } else {
	                    this.prerender += vel;
	                }
	                this.lastShapeId = shape.id;
	                return shape.id;
	            },

	            replaceWithShape: function replaceWithShape(shapeid, shape) {
	                var existing = $('#jqsshape' + shapeid),
	                    vel = this['_draw' + shape.type].apply(this, shape.args);
	                existing[0].outerHTML = vel;
	            },

	            replaceWithShapes: function replaceWithShapes(shapeids, shapes) {
	                // replace the first shapeid with all the new shapes then toast the remaining old shapes
	                var existing = $('#jqsshape' + shapeids[0]),
	                    replace = '',
	                    slen = shapes.length,
	                    i;
	                for (i = 0; i < slen; i++) {
	                    replace += this['_draw' + shapes[i].type].apply(this, shapes[i].args);
	                }
	                existing[0].outerHTML = replace;
	                for (i = 1; i < shapeids.length; i++) {
	                    $('#jqsshape' + shapeids[i]).remove();
	                }
	            },

	            insertAfterShape: function insertAfterShape(shapeid, shape) {
	                var existing = $('#jqsshape' + shapeid),
	                    vel = this['_draw' + shape.type].apply(this, shape.args);
	                existing[0].insertAdjacentHTML('afterEnd', vel);
	            },

	            removeShapeId: function removeShapeId(shapeid) {
	                var existing = $('#jqsshape' + shapeid);
	                this.group.removeChild(existing[0]);
	            },

	            getShapeAt: function getShapeAt(el, x, y) {
	                var shapeid = el.id.substr(8);
	                return shapeid;
	            },

	            render: function render() {
	                if (!this.rendered) {
	                    // batch the intial render into a single repaint
	                    this.group.innerHTML = this.prerender;
	                    this.rendered = true;
	                }
	            }
	        });
	    });
	})(document, Math);

/***/ },
/* 471 */
/***/ function(module, exports) {

	'use strict';

	Element.prototype.hide = function () {
	    this.style.display = 'none';
	};

	Element.prototype.show = function () {
	    this.style.display = '';
	};

	if (!('remove' in Element.prototype)) {
	    Element.prototype.remove = function () {
	        if (this.parentNode) {
	            this.parentNode.removeChild(this);
	        }
	    };
	}

	(function ($) {
	    $.fn.setVisibility = function (make_visible) {
	        if (make_visible) {
	            this.removeClass('invisible');
	        } else {
	            this.addClass('invisible');
	        }
	        return this;
	    };
	})(jQuery);

/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery.scrollTo
	 * Copyright (c) 2007-2015 Ariel Flesler - aflesler<a>gmail<d>com | http://flesler.blogspot.com
	 * Licensed under MIT
	 * http://flesler.blogspot.com/2007/10/jqueryscrollto.html
	 * @projectDescription Lightweight, cross-browser and highly customizable animated scrolling with jQuery
	 * @author Ariel Flesler
	 * @version 2.1.2
	 */
	;(function(factory) {
		'use strict';
		if (true) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof module !== 'undefined' && module.exports) {
			// CommonJS
			module.exports = factory(require('jquery'));
		} else {
			// Global
			factory(jQuery);
		}
	})(function($) {
		'use strict';

		var $scrollTo = $.scrollTo = function(target, duration, settings) {
			return $(window).scrollTo(target, duration, settings);
		};

		$scrollTo.defaults = {
			axis:'xy',
			duration: 0,
			limit:true
		};

		function isWin(elem) {
			return !elem.nodeName ||
				$.inArray(elem.nodeName.toLowerCase(), ['iframe','#document','html','body']) !== -1;
		}		

		$.fn.scrollTo = function(target, duration, settings) {
			if (typeof duration === 'object') {
				settings = duration;
				duration = 0;
			}
			if (typeof settings === 'function') {
				settings = { onAfter:settings };
			}
			if (target === 'max') {
				target = 9e9;
			}

			settings = $.extend({}, $scrollTo.defaults, settings);
			// Speed is still recognized for backwards compatibility
			duration = duration || settings.duration;
			// Make sure the settings are given right
			var queue = settings.queue && settings.axis.length > 1;
			if (queue) {
				// Let's keep the overall duration
				duration /= 2;
			}
			settings.offset = both(settings.offset);
			settings.over = both(settings.over);

			return this.each(function() {
				// Null target yields nothing, just like jQuery does
				if (target === null) return;

				var win = isWin(this),
					elem = win ? this.contentWindow || window : this,
					$elem = $(elem),
					targ = target, 
					attr = {},
					toff;

				switch (typeof targ) {
					// A number will pass the regex
					case 'number':
					case 'string':
						if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ)) {
							targ = both(targ);
							// We are done
							break;
						}
						// Relative/Absolute selector
						targ = win ? $(targ) : $(targ, elem);
						/* falls through */
					case 'object':
						if (targ.length === 0) return;
						// DOMElement / jQuery
						if (targ.is || targ.style) {
							// Get the real position of the target
							toff = (targ = $(targ)).offset();
						}
				}

				var offset = $.isFunction(settings.offset) && settings.offset(elem, targ) || settings.offset;

				$.each(settings.axis.split(''), function(i, axis) {
					var Pos	= axis === 'x' ? 'Left' : 'Top',
						pos = Pos.toLowerCase(),
						key = 'scroll' + Pos,
						prev = $elem[key](),
						max = $scrollTo.max(elem, axis);

					if (toff) {// jQuery / DOMElement
						attr[key] = toff[pos] + (win ? 0 : prev - $elem.offset()[pos]);

						// If it's a dom element, reduce the margin
						if (settings.margin) {
							attr[key] -= parseInt(targ.css('margin'+Pos), 10) || 0;
							attr[key] -= parseInt(targ.css('border'+Pos+'Width'), 10) || 0;
						}

						attr[key] += offset[pos] || 0;

						if (settings.over[pos]) {
							// Scroll to a fraction of its width/height
							attr[key] += targ[axis === 'x'?'width':'height']() * settings.over[pos];
						}
					} else {
						var val = targ[pos];
						// Handle percentage values
						attr[key] = val.slice && val.slice(-1) === '%' ?
							parseFloat(val) / 100 * max
							: val;
					}

					// Number or 'number'
					if (settings.limit && /^\d+$/.test(attr[key])) {
						// Check the limits
						attr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max);
					}

					// Don't waste time animating, if there's no need.
					if (!i && settings.axis.length > 1) {
						if (prev === attr[key]) {
							// No animation needed
							attr = {};
						} else if (queue) {
							// Intermediate animation
							animate(settings.onAfterFirst);
							// Don't animate this axis again in the next iteration.
							attr = {};
						}
					}
				});

				animate(settings.onAfter);

				function animate(callback) {
					var opts = $.extend({}, settings, {
						// The queue setting conflicts with animate()
						// Force it to always be true
						queue: true,
						duration: duration,
						complete: callback && function() {
							callback.call(elem, targ, settings);
						}
					});
					$elem.animate(attr, opts);
				}
			});
		};

		// Max scrolling position, works on quirks mode
		// It only fails (not too badly) on IE, quirks mode.
		$scrollTo.max = function(elem, axis) {
			var Dim = axis === 'x' ? 'Width' : 'Height',
				scroll = 'scroll'+Dim;

			if (!isWin(elem))
				return elem[scroll] - $(elem)[Dim.toLowerCase()]();

			var size = 'client' + Dim,
				doc = elem.ownerDocument || elem.document,
				html = doc.documentElement,
				body = doc.body;

			return Math.max(html[scroll], body[scroll]) - Math.min(html[size], body[size]);
		};

		function both(val) {
			return $.isFunction(val) || $.isPlainObject(val) ? val : { top:val, left:val };
		}

		// Add special hooks so that window scroll properties can be animated
		$.Tween.propHooks.scrollLeft = 
		$.Tween.propHooks.scrollTop = {
			get: function(t) {
				return $(t.elem)[t.prop]();
			},
			set: function(t) {
				var curr = this.get(t);
				// If interrupt is true and user scrolled, stop animating
				if (t.options.interrupt && t._last && t._last !== curr) {
					return $(t.elem).stop();
				}
				var next = Math.round(t.now);
				// Don't waste CPU
				// Browsers don't render floating point scroll
				if (curr !== next) {
					$(t.elem)[t.prop](next);
					t._last = this.get(t);
				}
			}
		};

		// AMD requirement
		return $scrollTo;
	});


/***/ },
/* 473 */
/***/ function(module, exports) {

	'use strict';

	window._trackJs = {
	    onError: function onError(payload) {
	        var itemExistInList = function itemExistInList(item, list) {
	            for (var i = 0; i < list.length; i++) {
	                if (item.indexOf(list[i]) > -1) {
	                    return true;
	                }
	            }
	            return false;
	        };

	        var ignorable_errors = [
	        // General script error, not actionable
	        '[object Event]',
	        // General script error, not actionable
	        'Script error.',
	        // error when user  interrupts script loading, nothing to fix
	        'Error loading script',
	        // an error caused by DealPly (http://www.dealply.com/) chrome extension
	        'DealPly',
	        // this error is reported when a post request returns error, i.e. html body
	        // the details provided in this case are completely useless, thus discarded
	        'Unexpected token <'];

	        if (itemExistInList(payload.message, ignorable_errors)) {
	            return false;
	        }

	        payload.network = payload.network.filter(function (item) {
	            return (
	                // ignore random errors from Intercom
	                !(item.statusCode === 403 && payload.message.indexOf('intercom') > -1)
	            );
	        });

	        return true;
	    }
	};

	// if Track:js is already loaded, we need to initialize it
	if (typeof trackJs !== 'undefined') trackJs.configure(window._trackJs);

/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinaryPjax = __webpack_require__(467);
	var pages_config = __webpack_require__(475);
	var Client = __webpack_require__(420);
	var GTM = __webpack_require__(464);
	var localize = __webpack_require__(428).localize;
	var Login = __webpack_require__(465);
	var Page = __webpack_require__(583);
	var defaultRedirectUrl = __webpack_require__(423).defaultRedirectUrl;
	var BinarySocket = __webpack_require__(427);
	var BinarySocketGeneral = __webpack_require__(606);

	var BinaryLoader = function () {
	    'use strict';

	    var container = void 0,
	        active_script = null;

	    var init = function init() {
	        Client.init();
	        BinarySocket.init(BinarySocketGeneral.initOptions());

	        container = $('#content-holder');
	        container.on('binarypjax:before', beforeContentChange);
	        container.on('binarypjax:after', afterContentChange);
	        BinaryPjax.init(container, '#content');
	    };

	    var beforeContentChange = function beforeContentChange() {
	        if (active_script) {
	            Page.onUnload();
	            BinarySocket.removeOnDisconnect();
	            if (typeof active_script.onUnload === 'function') {
	                active_script.onUnload();
	            }
	            active_script = null;
	        }
	    };

	    var afterContentChange = function afterContentChange(e, content) {
	        Page.onLoad();
	        GTM.pushDataLayer();
	        var this_page = content.getAttribute('data-page');
	        if (this_page in pages_config) {
	            loadHandler(pages_config[this_page]);
	        } else if (/\/get-started\//i.test(window.location.pathname)) {
	            loadHandler(pages_config['get-started']);
	        }
	    };

	    var error_messages = {
	        login: function login() {
	            return localize('Please <a href="[_1]">log in</a> to view this page.', [Login.loginUrl()]);
	        },
	        only_virtual: 'Sorry, this feature is available to virtual accounts only.',
	        only_real: 'This feature is not relevant to virtual-money accounts.'
	    };

	    var loadHandler = function loadHandler(config) {
	        active_script = config.module;
	        if (config.is_authenticated) {
	            if (!Client.isLoggedIn()) {
	                displayMessage(error_messages.login());
	            } else {
	                BinarySocket.wait('authorize').then(function (response) {
	                    if (response.error) {
	                        displayMessage(error_messages.login());
	                    } else if (config.only_virtual && !Client.get('is_virtual')) {
	                        displayMessage(error_messages.only_virtual);
	                    } else if (config.only_real && Client.get('is_virtual')) {
	                        displayMessage(error_messages.only_real);
	                    } else {
	                        active_script.onLoad();
	                    }
	                });
	            }
	        } else if (config.not_authenticated && Client.isLoggedIn()) {
	            BinaryPjax.load(defaultRedirectUrl(), true);
	        } else {
	            active_script.onLoad();
	        }
	        BinarySocket.setOnDisconnect(active_script.onDisconnect);
	    };

	    var displayMessage = function displayMessage(message) {
	        var $content = container.find('#content .container');
	        $content.html($('<div/>', { class: 'logged_out_title_container', html: $content.find('h1') })).append($('<p/>', { class: 'center-text notice-msg', html: localize(message) }));
	    };

	    return {
	        init: init
	    };
	}();

	module.exports = BinaryLoader;

/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var LoggedInHandler = __webpack_require__(476);

	var Charity = __webpack_require__(477);
	var Contact = __webpack_require__(478);
	var Endpoint = __webpack_require__(481);
	var Home = __webpack_require__(482);
	var GetStarted = __webpack_require__(485);
	var GetStartedJP = __webpack_require__(486);
	var JobDetails = __webpack_require__(487);
	var Platforms = __webpack_require__(488);
	var Regulation = __webpack_require__(489);
	var StaticPages = __webpack_require__(490);
	var TermsAndConditions = __webpack_require__(492);
	var WhyUs = __webpack_require__(498);

	var AccountTransfer = __webpack_require__(499);
	var Cashier = __webpack_require__(500);
	var DepositWithdraw = __webpack_require__(501);
	var PaymentAgentList = __webpack_require__(502);
	var PaymentAgentWithdraw = __webpack_require__(503);
	var MBTradePage = __webpack_require__(504);
	var AssetIndexUI = __webpack_require__(514);
	var TradingTimesUI = __webpack_require__(517);
	var TradePage_Beta = __webpack_require__(520);
	var TradePage = __webpack_require__(536);
	var Authenticate = __webpack_require__(542);
	var ChangePassword = __webpack_require__(543);
	var PaymentAgentTransfer = __webpack_require__(544);
	var Portfolio = __webpack_require__(511);
	var ProfitTable = __webpack_require__(546);
	var APIToken = __webpack_require__(549);
	var AuthorisedApps = __webpack_require__(551);
	var CashierPassword = __webpack_require__(555);
	var FinancialAssessment = __webpack_require__(556);
	var IPHistory = __webpack_require__(557);
	var Limits = __webpack_require__(561);
	var Settings = __webpack_require__(564);
	var SelfExclusion = __webpack_require__(565);
	var PersonalDetails = __webpack_require__(566);
	var Statement = __webpack_require__(568);
	var TopUpVirtual = __webpack_require__(571);
	var LostPassword = __webpack_require__(572);
	var MetaTrader = __webpack_require__(495);
	var FinancialAccOpening = __webpack_require__(573);
	var JapanAccOpening = __webpack_require__(576);
	var RealAccOpening = __webpack_require__(577);
	var VirtualAccOpening = __webpack_require__(578);
	var ResetPassword = __webpack_require__(580);
	var TNCApproval = __webpack_require__(493);

	var CashierJP = __webpack_require__(466);
	var KnowledgeTest = __webpack_require__(581);

	var pages_config = {
	    account_transfer: { module: AccountTransfer, is_authenticated: true, only_real: true },
	    api_tokenws: { module: APIToken, is_authenticated: true },
	    assessmentws: { module: FinancialAssessment, is_authenticated: true, only_real: true },
	    asset_indexws: { module: AssetIndexUI },
	    authenticate: { module: Authenticate, is_authenticated: true, only_real: true },
	    authorised_appsws: { module: AuthorisedApps, is_authenticated: true },
	    cashier: { module: Cashier },
	    cashier_passwordws: { module: CashierPassword, is_authenticated: true, only_real: true },
	    change_passwordws: { module: ChangePassword, is_authenticated: true },
	    charity: { module: Charity },
	    contact: { module: Contact },
	    detailsws: { module: PersonalDetails, is_authenticated: true },
	    endpoint: { module: Endpoint },
	    epg_forwardws: { module: DepositWithdraw, is_authenticated: true, only_real: true },
	    forwardws: { module: DepositWithdraw, is_authenticated: true, only_real: true },
	    home: { module: Home, not_authenticated: true },
	    iphistoryws: { module: IPHistory, is_authenticated: true },
	    japanws: { module: JapanAccOpening, is_authenticated: true, only_virtual: true },
	    knowledge_testws: { module: KnowledgeTest, is_authenticated: true, only_virtual: true },
	    limitsws: { module: Limits, is_authenticated: true, only_real: true },
	    logged_inws: { module: LoggedInHandler },
	    lost_passwordws: { module: LostPassword, not_authenticated: true },
	    maltainvestws: { module: FinancialAccOpening, is_authenticated: true },
	    market_timesws: { module: TradingTimesUI },
	    metatrader: { module: MetaTrader, is_authenticated: true },
	    multi_barriers_trading: { module: MBTradePage },
	    payment_agent_listws: { module: PaymentAgentList },
	    payment_methods: { module: Cashier.PaymentMethods },
	    platforms: { module: Platforms },
	    portfoliows: { module: Portfolio, is_authenticated: true },
	    profit_tablews: { module: ProfitTable, is_authenticated: true },
	    realws: { module: RealAccOpening, is_authenticated: true, only_virtual: true },
	    regulation: { module: Regulation },
	    reset_passwordws: { module: ResetPassword, not_authenticated: true },
	    securityws: { module: Settings, is_authenticated: true },
	    self_exclusionws: { module: SelfExclusion, is_authenticated: true, only_real: true },
	    settingsws: { module: Settings, is_authenticated: true },
	    signup: { module: StaticPages.AffiliateSignup },
	    statementws: { module: Statement, is_authenticated: true },
	    tnc_approvalws: { module: TNCApproval, is_authenticated: true, only_real: true },
	    top_up_virtualws: { module: TopUpVirtual, is_authenticated: true, only_virtual: true },
	    trading: { module: TradePage },
	    trading_beta: { module: TradePage_Beta },
	    transferws: { module: PaymentAgentTransfer, is_authenticated: true, only_real: true },
	    virtualws: { module: VirtualAccOpening, not_authenticated: true },
	    withdrawws: { module: PaymentAgentWithdraw, is_authenticated: true, only_real: true },
	    'deposit-jp': { module: CashierJP.Deposit, is_authenticated: true, only_real: true },
	    'get-started': { module: GetStarted },
	    'get-started-jp': { module: GetStartedJP },
	    'home-jp': { module: Home, not_authenticated: true },
	    'job-details': { module: JobDetails },
	    'open-positions': { module: StaticPages.OpenPositions },
	    'open-source-projects': { module: StaticPages.OpenSourceProjects },
	    'payment-agent': { module: StaticPages.PaymentAgent },
	    'terms-and-conditions': { module: TermsAndConditions },
	    'terms-and-conditions-jp': { module: TermsAndConditions },
	    'volidx-markets': { module: StaticPages.VolidxMarkets },
	    'why-us': { module: WhyUs },
	    'why-us-jp': { module: WhyUs },
	    'withdraw-jp': { module: CashierJP.Withdraw, is_authenticated: true, only_real: true }
	};

	module.exports = pages_config;

/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);
	var GTM = __webpack_require__(464);
	var getLanguage = __webpack_require__(424).get;
	var defaultRedirectUrl = __webpack_require__(423).defaultRedirectUrl;
	var urlFor = __webpack_require__(423).urlFor;
	var isEmptyObject = __webpack_require__(417).isEmptyObject;
	var Cookies = __webpack_require__(422);

	var LoggedInHandler = function () {
	    'use strict';

	    var onLoad = function onLoad() {
	        parent.window.is_logging_in = 1; // this flag is used in base.js to prevent auto-reloading this page
	        var redirect_url = void 0;
	        try {
	            var tokens = storeTokens();
	            var loginid = Cookies.get('loginid');

	            if (!loginid) {
	                // redirected to another domain (e.g. github.io) so those cookie are not accessible here
	                var loginids = Object.keys(tokens);
	                var loginid_list = '';
	                loginids.map(function (id) {
	                    loginid_list += '' + (loginid_list ? '+' : '') + id + ':' + (/^V/i.test(id) ? 'V' : 'R') + ':E'; // since there is not any data source to check, so assume all are enabled, disabled accounts will be handled on authorize
	                });
	                loginid = loginids[0];
	                // set cookies
	                Client.setCookie('loginid', loginid);
	                Client.setCookie('loginid_list', loginid_list);
	            }
	            Client.setCookie('login', tokens[loginid]);

	            // set flags
	            GTM.setLoginFlag();

	            // redirect url
	            redirect_url = sessionStorage.getItem('redirect_url');
	            sessionStorage.removeItem('redirect_url');
	        } catch (e) {
	            console.log('storage is not supported');
	        }

	        // redirect back
	        var set_default = true;
	        if (redirect_url) {
	            var do_not_redirect = ['reset_passwordws', 'lost_passwordws', 'change_passwordws', 'home', 'home-jp'];
	            var reg = new RegExp(do_not_redirect.join('|'), 'i');
	            if (!reg.test(redirect_url) && urlFor('') !== redirect_url) {
	                set_default = false;
	            }
	        }
	        if (set_default) {
	            redirect_url = defaultRedirectUrl();
	            var lang_cookie = Cookies.get('language');
	            var language = getLanguage();
	            if (lang_cookie && lang_cookie !== language) {
	                redirect_url = redirect_url.replace(new RegExp('/' + language + '/', 'i'), '/' + lang_cookie.toLowerCase() + '/');
	            }
	        }
	        document.getElementById('loading_link').setAttribute('href', redirect_url);
	        window.location.href = redirect_url; // need to redirect not using pjax
	    };

	    var storeTokens = function storeTokens() {
	        // Parse hash for loginids and tokens returned by OAuth
	        var hash = (/acct1/i.test(window.location.hash) ? window.location.hash : window.location.search).substr(1).split('&'); // to maintain compatibility till backend change released
	        var tokens = {};
	        for (var i = 0; i < hash.length; i += 2) {
	            var loginid = getHashValue(hash[i], 'acct');
	            var token = getHashValue(hash[i + 1], 'token');
	            if (loginid && token) {
	                tokens[loginid] = token;
	            }
	        }
	        if (!isEmptyObject(tokens)) {
	            Client.set('tokens', JSON.stringify(tokens));
	        }
	        return tokens;
	    };

	    var getHashValue = function getHashValue(source, key) {
	        return source && source.length > 0 ? new RegExp('^' + key).test(source.split('=')[0]) ? source.split('=')[1] : '' : '';
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = LoggedInHandler;

/***/ },
/* 477 */
/***/ function(module, exports) {

	'use strict';

	var Charity = function () {
	    'use strict';

	    var interval = null;

	    var onLoad = function onLoad() {
	        var $gallery = $('.gallery');
	        var images = void 0;
	        var switchPicture = function switchPicture() {
	            images = $gallery.find('img');
	            if (images.length > 1) {
	                images.eq(images.length - 1).prependTo($gallery);
	            }
	        };
	        interval = setInterval(switchPicture, 5000);
	    };

	    var onUnload = function onUnload() {
	        if (interval) {
	            clearInterval(interval);
	            interval = null;
	        }
	    };

	    return {
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = Charity;

/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var urlForStatic = __webpack_require__(423).urlForStatic;
	var loadCSS = __webpack_require__(479).loadCSS;
	var loadJS = __webpack_require__(480).loadJS;

	var Contact = function () {
	    'use strict';

	    var onLoad = function onLoad() {
	        displayCsContacts();
	        showLiveChatIcon();
	    };

	    var displayCsContacts = function displayCsContacts() {
	        $('.contact-content').on('change', '#cs_telephone_number', function () {
	            var val = $(this).val().split(',');
	            $('#display_cs_telephone').html(val[0] + (val.length > 1 ? '<br />' + val[1] : ''));
	        });
	    };

	    var showLiveChatIcon = function showLiveChatIcon() {
	        if (typeof DESK === 'undefined') {
	            loadCSS('https://d3jyn100am7dxp.cloudfront.net/assets/widget_embed_191.cssgz?1367387331');
	            loadJS('https://d3jyn100am7dxp.cloudfront.net/assets/widget_embed_libraries_191.jsgz?1367387332');
	        }

	        var desk_load = setInterval(function () {
	            if (typeof DESK !== 'undefined') {
	                renderDeskWidget();
	                changeChatIcon();
	                clearInterval(desk_load);
	            }
	        }, 80);
	    };

	    var renderDeskWidget = function renderDeskWidget() {
	        new DESK.Widget({
	            version: 1,
	            site: 'binary.desk.com',
	            port: '80',
	            type: 'chat',
	            id: 'live-chat-icon',
	            displayMode: 0, // 0 for popup, 1 for lightbox
	            features: {
	                offerAlways: true,
	                offerAgentsOnline: false,
	                offerRoutingAgentsAvailable: false,
	                offerEmailIfChatUnavailable: false
	            },
	            fields: {
	                ticket: {
	                    // desc: &#x27;&#x27;,
	                    // labels_new: &#x27;&#x27;,
	                    // priority: &#x27;&#x27;,
	                    // subject: &#x27;&#x27;,
	                    // custom_loginid: &#x27;&#x27;
	                },
	                interaction: {
	                    // email: &#x27;&#x27;,
	                    // name: &#x27;&#x27;
	                },
	                chat: {
	                    // subject: ''
	                },
	                customer: {
	                    // company: &#x27;&#x27;,
	                    // desc: &#x27;&#x27;,
	                    // first_name: &#x27;&#x27;,
	                    // last_name: &#x27;&#x27;,
	                    // locale_code: &#x27;&#x27;,
	                    // title: &#x27;&#x27;,
	                    // custom_loginid: &#x27;&#x27;
	                }
	            }
	        }).render();
	    };

	    var changeChatIcon = function changeChatIcon() {
	        // desk.com change icon - crude way
	        if ($('#live-chat-icon').length > 0) {
	            var timer = null;
	            var image_url = urlForStatic('images/pages/contact/chat-icon.svg');
	            var updateIcon = function updateIcon() {
	                var desk_widget = $('.a-desk-widget');
	                var image_str = desk_widget.css('background-image');
	                if (image_str) {
	                    desk_widget.css({
	                        'background-image': 'url("' + image_url + '")',
	                        'background-size': 'contain',
	                        'min-width': 50,
	                        'min-height': 50,
	                        width: 'auto'
	                    });

	                    if (image_str.match(/live-chat-icon/g)) {
	                        clearInterval(timer);
	                    }
	                }
	                desk_widget.removeAttr('onmouseover onmouseout');
	            };
	            timer = setInterval(updateIcon, 500);
	        }
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = Contact;

/***/ },
/* 479 */
/***/ function(module, exports) {

	"use strict";

	/*!
	loadCSS: load a CSS file asynchronously.
	[c]2014 @scottjehl, Filament Group, Inc.
	Licensed MIT
	*/
	function loadCSS(href, before, media) {
		"use strict";
		// Arguments explained:
		// `href` is the URL for your CSS file.
		// `before` optionally defines the element we'll use as a reference for injecting our <link>
		// By default, `before` uses the first <script> element in the page.
		// However, since the order in which stylesheets are referenced matters, you might need a more specific location in your document.
		// If so, pass a different reference element to the `before` argument and it'll insert before that instead
		// note: `insertBefore` is used instead of `appendChild`, for safety re: http://www.paulirish.com/2011/surefire-dom-element-insertion/

		var ss = window.document.createElement("link");
		var ref = before || window.document.getElementsByTagName("script")[0];
		ss.rel = "stylesheet";
		ss.href = href;
		// temporarily, set media to something non-matching to ensure it'll fetch without blocking render
		ss.media = "only x";
		// inject link
		ref.parentNode.insertBefore(ss, ref);
		// set media back to `all` so that the styleshet applies once it loads
		setTimeout(function () {
			ss.media = media || "all";
		});
		return ss;
	}

	module.exports = {
		loadCSS: loadCSS
	};

/***/ },
/* 480 */
/***/ function(module, exports) {

	"use strict";

	/*! loadJS: load a JS file asynchronously. [c]2014 @scottjehl, Filament Group, Inc. (Based on http://goo.gl/REQGQ by Paul Irish). Licensed MIT */
	function loadJS(src) {
		"use strict";

		var ref = window.document.getElementsByTagName("script")[0];
		var script = window.document.createElement("script");
		script.src = src;
		ref.parentNode.insertBefore(script, ref);
		return script;
	}

	module.exports = {
		loadJS: loadJS
	};

/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var getAppId = __webpack_require__(431).getAppId;
	var getSocketURL = __webpack_require__(431).getSocketURL;

	var Endpoint = function () {
	    'use strict';

	    var onLoad = function onLoad() {
	        var $server_url = $('#server_url');
	        var $app_id = $('#app_id');
	        $server_url.val(getSocketURL().split('/')[2]);
	        $app_id.val(getAppId());

	        $('#frm_endpoint').on('submit', function (e) {
	            e.preventDefault();
	            var server_url = $server_url.val().trim().toLowerCase();
	            var app_id = $app_id.val().trim();
	            if (server_url) localStorage.setItem('config.server_url', server_url);
	            if (app_id && !isNaN(app_id)) localStorage.setItem('config.app_id', parseInt(app_id));
	            window.location.reload();
	        });

	        $('#reset_endpoint').on('click', function () {
	            localStorage.removeItem('config.server_url');
	            localStorage.removeItem('config.app_id');
	            window.location.reload();
	        });
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = Endpoint;

/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinaryPjax = __webpack_require__(467);
	var getLanguage = __webpack_require__(424).get;
	var localize = __webpack_require__(428).localize;
	var urlFor = __webpack_require__(423).urlFor;
	var FormManager = __webpack_require__(483);
	var BinarySocket = __webpack_require__(427);

	var Home = function () {
	    'use strict';

	    var clients_country = void 0;

	    var onLoad = function onLoad() {
	        if (getLanguage() === 'JA' && !/home-jp/.test(window.location.pathname)) {
	            BinaryPjax.load('home-jp');
	            return;
	        }
	        BinarySocket.wait('website_status').then(function (response) {
	            clients_country = response.website_status.clients_country;
	            var form_id = '#frm_verify_email';

	            $('#start_now').click(function () {
	                $.scrollTo($(form_id), 500, { offset: -10 });
	            });

	            FormManager.init(form_id, [{ selector: '#email', validations: ['req', 'email'], request_field: 'verify_email' }, { request_field: 'type', value: 'account_opening' }]);
	            FormManager.handleSubmit({
	                form_selector: form_id,
	                fnc_response_handler: handler,
	                fnc_additional_check: checkCountry
	            });
	        });
	    };

	    var checkCountry = function checkCountry(req) {
	        if (clients_country !== 'my' || /@binary\.com$/.test(req.verify_email)) {
	            return true;
	        }
	        $('#frm_verify_email').find('div').html($('<p/>', { class: 'notice-msg center-text', html: localize('Sorry, account signup is not available in your country. Please contact <a href="[_1]">customer support</a> for more information.', [urlFor('contact')]) }));
	        return false;
	    };

	    var handler = function handler(response) {
	        var error = response.error;
	        if (!error) {
	            BinaryPjax.load('new_account/virtualws');
	        } else {
	            $('#signup_error').setVisibility(1).text(error.message);
	        }
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = Home;

/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Validation = __webpack_require__(484);
	var isEmptyObject = __webpack_require__(417).isEmptyObject;
	var showLoadingImage = __webpack_require__(417).showLoadingImage;
	var BinarySocket = __webpack_require__(427);

	var FormManager = function () {
	    'use strict';

	    var forms = {};

	    var initForm = function initForm(form_selector, fields) {
	        var $form = $(form_selector + ':visible');
	        var $btn = $form.find('button[type="submit"]');
	        if ($form.length) {
	            forms[form_selector] = {
	                $btn_submit: $btn,
	                can_submit: true
	            };
	            if (Array.isArray(fields) && fields.length) {
	                forms[form_selector].fields = fields;

	                fields.forEach(function (field) {
	                    if (field.selector) {
	                        field.$ = $form.find(field.selector);
	                        if (!field.$.length) return;
	                    }

	                    field.form = form_selector;
	                });
	            }
	        }
	        // handle firefox
	        $btn.removeAttr('disabled');
	        Validation.init(form_selector, fields);
	    };

	    var getFormData = function getFormData(form_selector) {
	        var data = {};
	        var fields = forms[form_selector].fields;
	        if (!fields) return data;
	        var key = void 0,
	            $selector = void 0,
	            val = void 0,
	            value = void 0,
	            native = void 0;

	        fields.forEach(function (field) {
	            if (!field.exclude_request) {
	                $selector = $(field.form).find(field.selector);
	                if ($selector.is(':visible') || field.value) {
	                    val = $selector.val();
	                    key = field.request_field || field.selector;
	                    native = $selector.attr('data-picker') === 'native';

	                    // prioritise data-value
	                    // if label, take the text
	                    // if checkbox, take checked value
	                    // otherwise take the value
	                    value = field.value ? typeof field.value === 'function' ? field.value() : field.value : native ? val : $selector.attr('data-value') || (/lbl_/.test(key) ? field.value || $selector.text() : $selector.is(':checkbox') ? $selector.is(':checked') ? 1 : 0 : Array.isArray(val) ? val.join(',') : val || '');

	                    if (!(field.exclude_if_empty && val.length === 0)) {
	                        key = key.replace(/lbl_|#|\./g, '');
	                        if (field.parent_node) {
	                            if (!data[field.parent_node]) {
	                                data[field.parent_node] = {};
	                            }
	                            data[field.parent_node][key] = value;
	                        } else {
	                            data[key] = value;
	                        }
	                    }
	                }
	            }
	        });
	        return data;
	    };

	    var disableButton = function disableButton($btn) {
	        if ($btn.length && !$btn.find('.barspinner').length) {
	            $btn.attr('disabled', 'disabled');
	            var $btn_text = $('<span/>', { text: $btn.text(), class: 'invisible' });
	            showLoadingImage($btn, 'white');
	            $btn.append($btn_text);
	        }
	    };

	    var enableButton = function enableButton($btn) {
	        if ($btn.length && $btn.find('.barspinner').length) {
	            $btn.removeAttr('disabled').html($btn.find('span').text());
	        }
	    };

	    var handleSubmit = function handleSubmit(options) {
	        var form = void 0,
	            $btn_submit = void 0,
	            can_submit = void 0;

	        var onSuccess = function onSuccess() {
	            var response = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	            if (typeof options.fnc_response_handler === 'function') {
	                if (options.enable_button || 'error' in response) {
	                    enableButton($btn_submit);
	                    form.can_submit = true;
	                }
	                options.fnc_response_handler(response);
	            }
	        };

	        $(options.form_selector).off('submit').on('submit', function (evt) {
	            evt.preventDefault();
	            form = forms[options.form_selector];
	            $btn_submit = form.$btn_submit;
	            can_submit = form.can_submit;
	            if (!can_submit) return;
	            if (Validation.validate(options.form_selector)) {
	                var req = $.extend({}, options.obj_request, getFormData(options.form_selector));
	                if (typeof options.fnc_additional_check === 'function' && !options.fnc_additional_check(req)) {
	                    return;
	                }
	                disableButton($btn_submit);
	                form.can_submit = false;
	                if (isEmptyObject(req)) {
	                    onSuccess();
	                } else {
	                    BinarySocket.send(req).then(function (response) {
	                        onSuccess(response);
	                    });
	                }
	            }
	        });
	    };

	    return {
	        init: initForm,
	        handleSubmit: handleSubmit
	    };
	}();

	module.exports = FormManager;

/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var localize = __webpack_require__(428).localize;
	var compareBigUnsignedInt = __webpack_require__(449).compareBigUnsignedInt;

	var Validation = function () {
	    'use strict';

	    var forms = {};
	    var error_class = 'error-msg';
	    var hidden_class = 'invisible';

	    var events_map = {
	        input: 'input change',
	        select: 'change',
	        checkbox: 'change'
	    };

	    var getFieldType = function getFieldType($field) {
	        return $field.length ? $field.attr('type') === 'checkbox' ? 'checkbox' : $field.get(0).localName : null;
	    };

	    var getFieldValue = function getFieldValue(field) {
	        return (field.type === 'checkbox' ? field.$.is(':checked') ? '1' : '' : field.$.val()) || '';
	    };

	    var initForm = function initForm(form_selector, fields) {
	        var $form = $(form_selector + ':visible');
	        if ($form.length) {
	            forms[form_selector] = { $form: $form };
	            if (Array.isArray(fields) && fields.length) {
	                forms[form_selector].fields = fields;

	                fields.forEach(function (field) {
	                    field.$ = $form.find(field.selector);
	                    if (!field.$.length || !field.validations) return;

	                    field.type = getFieldType($(field.$[0])); // also handles multiple results
	                    field.form = form_selector;
	                    if (field.msg_element) {
	                        field.$error = $form.find(field.msg_element);
	                    } else {
	                        var $parent = field.$.parent();
	                        // Add indicator to required fields
	                        if (field.validations.indexOf('req') >= 0) {
	                            var $label = $parent.parent().find('label');
	                            if (!$label.length) $label = $parent.find('label');
	                            if ($label.find('span.required_field_asterisk').length === 0) {
	                                $label.append($('<span/>', { class: 'required_field_asterisk', text: '*' }));
	                            }
	                        }
	                        if ($parent.find('div.' + error_class).length === 0) {
	                            $parent.append($('<div/>', { class: error_class + ' ' + hidden_class }));
	                        }
	                        field.$error = $parent.find('.' + error_class);
	                    }

	                    var event = events_map[field.type];
	                    if (event) {
	                        field.$.unbind(event).on(event, function () {
	                            checkField(field);
	                            if (field.re_check_field) {
	                                checkField(forms[form_selector].fields.find(function (fld) {
	                                    return fld.selector === field.re_check_field;
	                                }));
	                            }
	                        });
	                    }
	                });
	            }
	        }
	    };

	    // ------------------------------
	    // ----- Validation Methods -----
	    // ------------------------------
	    var validRequired = function validRequired(value, options, field) {
	        if ((typeof value === 'string' ? value.trim() : value).length) return true;
	        // else
	        validators_map.req.message = field.type === 'checkbox' ? 'Please select the checkbox.' : 'This field is required.';
	        return false;
	    };
	    var validEmail = function validEmail(value) {
	        return (/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}$/.test(value)
	        );
	    };
	    var validPassword = function validPassword(value) {
	        return (/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]+/.test(value)
	        );
	    };
	    var validLetterSymbol = function validLetterSymbol(value) {
	        return !/[`~!@#$%^&*)(_=+\[}{\]\\\/";:\?><,|\d]+/.test(value);
	    };
	    var validGeneral = function validGeneral(value) {
	        return !/[`~!@#$%^&*)(_=+\[}{\]\\\/";:\?><|]+/.test(value);
	    };
	    var validAddress = function validAddress(value) {
	        return !/[`~!#$%^&*)(_=+\[}{\]\\";:\?><|]+/.test(value);
	    };
	    var validPostCode = function validPostCode(value) {
	        return (/^[a-zA-Z\d-\s]*$/.test(value)
	        );
	    };
	    var validPhone = function validPhone(value) {
	        return (/^\+?[0-9\s]*$/.test(value)
	        );
	    };
	    var validRegular = function validRegular(value, options) {
	        return options.regex.test(value);
	    };
	    var validEmailToken = function validEmailToken(value) {
	        return value.trim().length === 8;
	    };

	    var validCompare = function validCompare(value, options) {
	        return value === $(options.to).val();
	    };
	    var validNotEqual = function validNotEqual(value, options) {
	        return value !== $(options.to).val();
	    };
	    var validMin = function validMin(value, options) {
	        return options.min ? value.trim().length >= options.min : true;
	    };
	    var validLength = function validLength(value, options) {
	        return (options.min ? value.trim().length >= options.min : true) && (options.max ? value.trim().length <= options.max : true);
	    };

	    var validNumber = function validNumber(value, options) {
	        if (options.allow_empty && value.length === 0) {
	            return true;
	        }

	        var is_ok = true,
	            message = '';

	        if (!(options.type === 'float' ? /^\d+(\.\d+)?$/ : /^\d+$/).test(value) || !$.isNumeric(value)) {
	            is_ok = false;
	            message = localize('Should be a valid number');
	        } else if (options.type === 'float' && options.decimals && !new RegExp('^\\d+(\\.\\d{' + options.decimals.replace(/ /g, '') + '})?$').test(value)) {
	            is_ok = false;
	            message = localize('Only [_1] decimal points are allowed.', [options.decimals]);
	        } else if ('min' in options && 'max' in options && (+value < +options.min || isMoreThanMax(value, options))) {
	            is_ok = false;
	            message = localize('Should be between [_1] and [_2]', [options.min, options.max]);
	        } else if ('min' in options && +value < +options.min) {
	            is_ok = false;
	            message = localize('Should be more than [_1]', [options.min]);
	        } else if ('max' in options && isMoreThanMax(value, options)) {
	            is_ok = false;
	            message = localize('Should be less than [_1]', [options.max]);
	        }

	        validators_map.number.message = message;
	        return is_ok;
	    };

	    var isMoreThanMax = function isMoreThanMax(value, options) {
	        return options.type === 'float' ? +value > +options.max : compareBigUnsignedInt(value, options.max) === 1;
	    };

	    var validators_map = {
	        req: { func: validRequired, message: '' },
	        email: { func: validEmail, message: 'Invalid email address' },
	        password: { func: validPassword, message: 'Password should have lower and uppercase letters with numbers.' },
	        general: { func: validGeneral, message: 'Only letters, numbers, space, hyphen, period, and apostrophe are allowed.' },
	        address: { func: validAddress, message: 'Only letters, numbers, space, hyphen, period, and apostrophe are allowed.' },
	        letter_symbol: { func: validLetterSymbol, message: 'Only letters, space, hyphen, period, and apostrophe are allowed.' },
	        postcode: { func: validPostCode, message: 'Only letters, numbers, space, and hyphen are allowed.' },
	        phone: { func: validPhone, message: 'Only numbers and spaces are allowed.' },
	        email_token: { func: validEmailToken, message: 'Please submit a valid verification token.' },
	        compare: { func: validCompare, message: 'The two passwords that you entered do not match.' },
	        not_equal: { func: validNotEqual, message: '[_1] and [_2] cannot be the same.' },
	        min: { func: validMin, message: 'Minimum of [_1] characters required.' },
	        length: { func: validLength, message: 'You should enter [_1] characters.' },
	        number: { func: validNumber, message: '' },
	        regular: { func: validRegular, message: '' }
	    };

	    var pass_length = { min: 6, max: 25 };

	    // --------------------
	    // ----- Validate -----
	    // --------------------
	    var checkField = function checkField(field) {
	        if (!field.$.is(':visible') || !field.validations) return true;
	        var all_is_ok = true,
	            message = void 0;

	        field.validations.some(function (valid) {
	            if (!valid) return false; // check next validation
	            var type = void 0,
	                options = {};

	            if (typeof valid === 'string') {
	                type = valid;
	            } else {
	                type = valid[0];
	                options = valid[1];
	            }

	            if (type === 'password' && !validLength(getFieldValue(field), pass_length)) {
	                field.is_ok = false;
	                type = 'length';
	                options = pass_length;
	            } else {
	                var validator = type === 'custom' ? options.func : validators_map[type].func;
	                field.is_ok = validator(getFieldValue(field), options, field);
	            }

	            if (!field.is_ok) {
	                message = options.message || validators_map[type].message;
	                if (type === 'length') {
	                    message = localize(message, [options.min === options.max ? options.min : options.min + '-' + options.max]);
	                } else if (type === 'min') {
	                    message = localize(message, [options.min]);
	                } else if (type === 'not_equal') {
	                    message = localize(message, [localize(options.name1), localize(options.name2)]);
	                }
	                all_is_ok = false;
	                return true; // break on the first error found
	            }
	            return false; // check next validation
	        });

	        if (!all_is_ok) {
	            showError(field, message);
	        } else {
	            clearError(field);
	        }

	        return all_is_ok;
	    };

	    var clearError = function clearError(field) {
	        if (field.$error && field.$error.length) {
	            field.$error.setVisibility(0);
	        }
	    };

	    var showError = function showError(field, message) {
	        clearError(field);
	        field.$error.text(localize(message)).setVisibility(1);
	    };

	    var validate = function validate(form_selector) {
	        var form = forms[form_selector];
	        if (!form.fields) return true;
	        form.is_ok = true;
	        form.fields.forEach(function (field) {
	            if (!checkField(field)) {
	                if (form.is_ok && !field.no_scroll) {
	                    // first error
	                    $.scrollTo(field.$, 500, { offset: -10 });
	                }
	                form.is_ok = false;
	            }
	        });
	        return form.is_ok;
	    };

	    return {
	        init: initForm,
	        validate: validate
	    };
	}();

	module.exports = Validation;

/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);

	var GetStarted = function () {
	    'use strict';

	    var selectNavElement = function selectNavElement() {
	        $('.nav li').removeClass('selected').find('a[href="' + window.location.pathname + '"]').parent('li').addClass('selected');
	    };

	    var updateActiveSubsection = function updateActiveSubsection($nav, $to_show) {
	        $('.subsection').setVisibility(0);
	        $to_show.setVisibility(1);
	        var $nav_back = $nav.find('.back');
	        var $nav_next = $nav.find('.next');

	        if ($to_show.hasClass('first')) {
	            $nav_back.addClass('button-disabled');
	            $nav_next.removeClass('button-disabled');
	        } else if ($to_show.hasClass('last')) {
	            $nav_back.removeClass('button-disabled');
	            $nav_next.addClass('button-disabled');
	        } else {
	            $nav_back.removeClass('button-disabled');
	            $nav_next.removeClass('button-disabled');
	        }

	        var new_hash = $to_show.find('a[name]').attr('name').slice(0, -8);
	        if (window.location.hash !== '#' + new_hash) {
	            window.location.hash = new_hash;
	        }

	        return false;
	    };

	    var onLoad = function onLoad() {
	        Client.activateByClientType();

	        var $nav = $('.get-started').find('.subsection-navigation');

	        if ($nav.length) {
	            $nav.on('click', 'a', function () {
	                var $button = $(this);
	                if ($button.hasClass('button-disabled')) {
	                    return false;
	                }
	                var $now_showing = $('.subsection:not(.invisible)');
	                var $to_show = $button.hasClass('next') ? $now_showing.next('.subsection') : $now_showing.prev('.subsection');
	                return updateActiveSubsection($nav, $to_show);
	            });

	            var fragment = location.href.split('#')[1];
	            var $to_show = fragment ? $('a[name=' + fragment + '-section]').parent('.subsection') : $('.subsection.first');
	            updateActiveSubsection($nav, $to_show);
	        }
	        selectNavElement();
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = GetStarted;

/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);
	var BinaryPjax = __webpack_require__(467);
	var jpClient = __webpack_require__(425).jpClient;

	var GetStartedJP = function () {
	    'use strict';

	    var $contents = void 0,
	        $sidebar_li = void 0,
	        $index = void 0;

	    var showSelectedTab = function showSelectedTab() {
	        var updated_tab = window.location.hash;
	        $contents.find('div').hide();
	        $sidebar_li.removeClass('selected');
	        if (updated_tab) {
	            $index.hide();
	            $contents.find('div[id=content-' + updated_tab.slice(1, updated_tab.length) + ']').show().find('div').show();
	            $sidebar_li.filter('.' + updated_tab.slice(1, updated_tab.length)).addClass('selected');
	            $contents.show();
	        } else {
	            $contents.hide();
	            $index.show();
	        }
	    };

	    var onLoad = function onLoad() {
	        if (!jpClient()) {
	            BinaryPjax.load('get-started');
	        }

	        Client.activateByClientType();
	        $contents = $('.contents');
	        $sidebar_li = $('.sidebar ul li');
	        $index = $('#index');

	        var tab = window.location.hash;
	        if (tab && tab !== '') {
	            $index.hide();
	            $('.sidebar ul li.' + tab.slice(1, tab.length)).addClass('selected');
	            showSelectedTab();
	        }

	        $(window).on('hashchange', function () {
	            showSelectedTab();
	        });

	        $sidebar_li.click(function () {
	            $('.sidebar ul li').removeClass('selected');
	            $(this).addClass('selected');
	        });
	    };

	    var onUnload = function onUnload() {
	        $(window).off('hashchange');
	    };

	    return {
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = GetStartedJP;

/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var urlParam = __webpack_require__(423).param;
	var urlFor = __webpack_require__(423).urlFor;

	var JobDetails = function () {
	    'use strict';

	    var dept = void 0;

	    var $sections_div = void 0,
	        dept_class = void 0,
	        $senior_perl_message = void 0,
	        $sidebar = void 0,
	        $sidebar_dept = void 0;

	    var showSelectedDiv = function showSelectedDiv() {
	        var section = window.location.hash;
	        $sections_div.setVisibility(0).filter(section).setVisibility(1);
	        if (dept === 'Information_Technology' && /senior_perl_developer/.test(section)) {
	            $senior_perl_message.setVisibility(1);
	        } else {
	            $senior_perl_message.setVisibility(0);
	        }
	    };

	    var onLoad = function onLoad() {
	        dept = urlParam('dept');
	        dept_class = '.' + dept;
	        $sidebar = $('.sidebar');
	        $sidebar_dept = $sidebar.filter(dept_class);
	        $sections_div = $('.sections > div > div');
	        $senior_perl_message = $('.senior_perl_message');
	        // hide all first (to handle pjaxload)
	        $sidebar.setVisibility(0);
	        $('#title').find('h1').setVisibility(0);
	        $('#image').find('img').setVisibility(0);
	        // show section
	        $(dept_class).setVisibility(1);
	        $sidebar_dept.setVisibility(1).find('a[href="' + window.location.hash + '"]').parent('li').addClass('selected');
	        showSelectedDiv();
	        $('#back-button').attr('href', urlFor('open-positions') + '#' + dept);
	        addEventListeners();
	    };

	    var addEventListeners = function addEventListeners() {
	        var $sidebar_list_item = $sidebar_dept.find('#sidebar-nav li');
	        $sidebar_list_item.click(function () {
	            $sidebar_list_item.removeClass('selected');
	            $(this).addClass('selected');
	        });

	        $(window).on('hashchange', function () {
	            showSelectedDiv();
	        });
	    };

	    var onUnload = function onUnload() {
	        $(window).off('hashchange');
	    };

	    return {
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = JobDetails;

/***/ },
/* 488 */
/***/ function(module, exports) {

	'use strict';

	var Platforms = function () {
	    'use strict';

	    var sections = [];

	    var onLoad = function onLoad() {
	        sections = ['more-tools', 'trading-platforms'];

	        var sidebar_list_item = $('.sidebar-nav li');
	        sidebar_list_item.click(function () {
	            sidebar_list_item.removeClass('selected');
	            $(this).addClass('selected');
	        });

	        $(window).on('hashchange', function () {
	            showSelectedDiv();
	        });

	        checkWidth();
	        $(window).resize(checkWidth);
	        // $('.inner').scroll(checkScroll);
	        // setHeights();
	    };

	    // const setHeights = () => {
	    //     let $this;
	    //     $('.inner tr').each(function() {
	    //         $this = $(this);
	    //         const $td = $this.find('td:first');
	    //         const $th = $this.find('th');
	    //         if ($th.height() > $td.height()) {
	    //             $this.find('td').height($th.height());
	    //         }
	    //     });
	    // };

	    // const checkScroll = () => {
	    //     const $elem = $('.inner');
	    //     const $fade_left = $('.fade-to-left');
	    //     const $fade_right = $('.fade-to-right');
	    //     const new_scroll_left = $elem.scrollLeft();
	    //     $fade_left.css('opacity', new_scroll_left === 0 ? '0' : '100');
	    //     $fade_right.css('opacity', $elem.get(0).scrollWidth === new_scroll_left + $elem.width() ? '0' : '100');
	    // };

	    var checkWidth = function checkWidth() {
	        if ($('.sidebar').is(':visible')) {
	            showSelectedDiv();
	        } else {
	            $('.sections').setVisibility(1);
	        }
	        // $('.inner th').hide().fadeIn(1); // force to refresh in order to maintain correct positions
	    };

	    var getHash = function getHash() {
	        var hash = window.location.hash;
	        return hash && $.inArray(hash.substring(1), sections) !== -1 ? hash : '#trading-platforms';
	    };

	    var showSelectedDiv = function showSelectedDiv() {
	        var $sections_with_hash = $('.sections[id="' + getHash().substring(1) + '"]');
	        if ($sections_with_hash.is(':visible') && $('.sections:visible').length === 1) {
	            return;
	        }
	        $('.sections').setVisibility(0);
	        $sections_with_hash.setVisibility(1);
	        $('.sidebar-nav a[href="' + getHash() + '"]').parent().addClass('selected');
	    };

	    var onUnload = function onUnload() {
	        $(window).off('resize hashchange');
	    };

	    return {
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = Platforms;

/***/ },
/* 489 */
/***/ function(module, exports) {

	'use strict';

	var Regulation = function () {
	    'use strict';

	    var onLoad = function onLoad() {
	        $(function () {
	            $('#accordion').accordion({
	                heightStyle: 'content',
	                collapsible: true,
	                active: 0
	            });
	        });

	        var coords = [];
	        var $map_area = $('#planetmap').find('area');
	        var $selector = $('img[usemap="#planetmap"]');
	        $map_area.each(function () {
	            coords.push($(this).attr('coords'));
	        });
	        var relocateLinks = function relocateLinks() {
	            $map_area.each(function (index) {
	                var c = '';
	                var new_width = $selector[0].getBoundingClientRect().width.toFixed(2);
	                coords[index].split(',').map(function (v) {
	                    c += (c ? ',' : '') + (v * new_width / 900).toFixed(2);
	                });
	                $(this).attr('coords', c);
	            });
	        };
	        $(document).ready(relocateLinks);
	        $(window).resize(relocateLinks);
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = Regulation;

/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var GetStarted = __webpack_require__(485);
	var handleHash = __webpack_require__(417).handleHash;
	var Scroll = __webpack_require__(491);

	module.exports = {
	    OpenPositions: {
	        onLoad: function onLoad() {
	            Scroll.scrollToHashSection();
	        }
	    },
	    VolidxMarkets: {
	        onLoad: function onLoad() {
	            Scroll.goToHashSection();GetStarted.onLoad();
	        },
	        onUnload: function onUnload() {
	            Scroll.offScroll();
	        }
	    },
	    OpenSourceProjects: {
	        onLoad: function onLoad() {
	            Scroll.sidebarScroll($('.open-source-projects'));
	        },
	        onUnload: function onUnload() {
	            Scroll.offScroll();
	        }
	    },
	    PaymentAgent: {
	        onLoad: function onLoad() {
	            Scroll.sidebarScroll($('.payment-agent'));
	        },
	        onUnload: function onUnload() {
	            Scroll.offScroll();
	        }
	    },
	    AffiliateSignup: {
	        onLoad: function onLoad() {
	            tabListener();handleHash();
	        }
	    }
	};

/***/ },
/* 491 */
/***/ function(module, exports) {

	'use strict';

	var Scroll = function () {
	    'use strict';

	    var $main_container = void 0;

	    var sidebarScroll = function sidebarScroll($container) {
	        $main_container = $container;

	        $container.on('click', '#sidebar-nav li', function () {
	            var clicked_li = $(this);
	            $.scrollTo($('.section:eq(' + clicked_li.index() + ')'), 500);
	            return false;
	        });

	        if ($container.length) {
	            // grab the initial top offset of the navigation
	            var $sidebar = $container.find('.sidebar');
	            var $sidebar_container = $container.find('.sidebar-container');
	            var width = $sidebar.width();
	            var sticky_navigation_offset_top = $sidebar.offset().top;

	            // With thanks:
	            // http://www.backslash.gr/content/blog/webdevelopment/6-navigation-menu-that-stays-on-top-with-jquery

	            // our function that decides weather the navigation bar should have "fixed" css position or not.
	            var sticky_navigation = function sticky_navigation() {
	                if (!$sidebar.is(':visible')) return;
	                if (!width) {
	                    width = $sidebar.width();
	                    sticky_navigation_offset_top = $sidebar.offset().top;
	                }
	                var scroll_top = $(window).scrollTop(); // our current vertical position from the top

	                // if we've scrolled more than the navigation, change its position to fixed to stick to top,
	                // otherwise change it back to relative
	                if (scroll_top + $sidebar[0].offsetHeight > $sidebar_container[0].offsetHeight + $sidebar_container.offset().top) {
	                    $sidebar.css({ position: 'absolute', bottom: 0, top: '', width: width });
	                } else if (scroll_top > sticky_navigation_offset_top) {
	                    $sidebar.css({ position: 'fixed', top: 0, bottom: '', width: width });
	                } else {
	                    $sidebar.css({ position: 'relative' });
	                }
	            };

	            // run our function on load
	            sticky_navigation();

	            var sidebar_nav = $sidebar.find('#sidebar-nav');
	            var length = $container.find('.section').length;
	            $(window).on('scroll', function () {
	                if (!sidebar_nav.is(':visible')) return;
	                // and run it again every time you scroll
	                sticky_navigation();

	                for (var i = 0; i < length; i++) {
	                    var section = $('.section:eq(' + i + ')');
	                    var section_offset = section.offset();
	                    var is_offset_top = section_offset && $(this).scrollTop() >= section_offset.top - 5;
	                    if (($(window).scrollTop() === 0 || is_offset_top) && section.css('display') !== 'none') {
	                        // ignore hidden elements
	                        sidebar_nav.find('li').removeClass('selected');

	                        if ($(window).scrollTop() === 0 || sidebar_nav.width() === 0) {
	                            // We're at the top of the screen, so highlight first nav item
	                            sidebar_nav.find('li:first-child').addClass('selected');
	                        } else if ($(window).scrollTop() + $(window).height() >= $(document).height()) {
	                            // We're at bottom of screen so highlight last nav item.
	                            sidebar_nav.find('li:last-child').addClass('selected');
	                        } else {
	                            sidebar_nav.find('li:eq(' + i + ')').addClass('selected');
	                        }
	                    }
	                }
	            });
	        }
	    };

	    var scrollToTop = function scrollToTop() {
	        var is_displaying = false;
	        var $scrollup = $('#scrollup');
	        $(document).scroll(function () {
	            if ($(this).scrollTop() > 100) {
	                if (is_displaying) return;
	                $scrollup.fadeIn();
	                is_displaying = true;
	            } else if (is_displaying) {
	                $scrollup.fadeOut();
	                is_displaying = false;
	            }
	        });

	        $scrollup.click(function () {
	            $.scrollTo(0, 500);
	        });
	    };

	    return {
	        sidebarScroll: sidebarScroll,
	        scrollToTop: scrollToTop,
	        offScroll: function offScroll() {
	            $(window).off('scroll');
	            if ($main_container) {
	                $main_container.find('#sidebar-nav li').off('click');
	                $main_container = '';
	            }
	        },
	        goToHashSection: function goToHashSection() {
	            var hash = window.location.hash;
	            if (hash) $('a[href="' + hash + '"]').click();
	        },
	        scrollToHashSection: function scrollToHashSection() {
	            var hash = window.location.hash;
	            if (hash) $.scrollTo($(hash));
	        }
	    };
	}();

	module.exports = Scroll;

/***/ },
/* 492 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var localize = __webpack_require__(428).localize;
	var urlParam = __webpack_require__(423).param;
	var Scroll = __webpack_require__(491);
	var TNCApproval = __webpack_require__(493);

	var TermsAndConditions = function () {
	    'use strict';

	    var onLoad = function onLoad() {
	        handleActiveTab();
	        TNCApproval.requiresTNCApproval($('#btn_accept'), function () {
	            $('.tnc_accept').setVisibility(1);
	        }, function () {
	            $('#tnc_accept').html(localize('Your settings have been updated successfully.'));
	        });
	        Scroll.sidebarScroll($('.tac-binary'));
	        tabListener();

	        $('.currentYear').text(new Date().getFullYear());
	    };

	    var handleActiveTab = function handleActiveTab() {
	        var hash = window.location.hash || '#legal';
	        var menu = '.tab-menu-wrap';
	        var content = '.tab-content-wrapper';

	        var parent_active = 'active';
	        var child_active = 'a-active';

	        $(menu).find('li').removeClass(parent_active).find('span').removeClass(child_active);

	        var $tab_to_show = $(hash);
	        // if hash is a subtab or has subtabs
	        if ($tab_to_show.find('.tm-li-2').length > 0 || /tm-li-2/.test($(hash).attr('class'))) {
	            $tab_to_show = $tab_to_show.find('.tm-a-2').first().addClass(child_active).closest('.tm-li');
	        }
	        $tab_to_show.addClass(parent_active);

	        var content_to_show = 'div' + hash + '-content';
	        if ($(content_to_show).length === 0) {
	            content_to_show = 'div#' + $(hash).find('.tm-li-2').first().attr('id') + '-content';
	        }
	        $(content).find('> div').setVisibility(0).end().find(content_to_show).setVisibility(1);

	        var section = urlParam('section');
	        var $content = $('#content');
	        if (section) {
	            var $section = $content.find('a#' + section);
	            if ($section.length) setTimeout(function () {
	                $.scrollTo($section, 0, { offset: -10 });
	            }, 500);
	        } else if (window.location.hash) {
	            setTimeout(function () {
	                $.scrollTo($content.find('.tab-menu'), 0, { offset: -10 });
	            }, 500);
	        }
	    };

	    var onUnload = function onUnload() {
	        Scroll.offScroll();
	    };

	    return {
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = TermsAndConditions;

/***/ },
/* 493 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var BinaryPjax = __webpack_require__(467);
	var Client = __webpack_require__(420);
	var Header = __webpack_require__(494);
	var defaultRedirectUrl = __webpack_require__(423).defaultRedirectUrl;
	var urlFor = __webpack_require__(423).urlFor;
	var template = __webpack_require__(417).template;

	var TNCApproval = function () {
	    'use strict';

	    var onLoad = function onLoad() {
	        requiresTNCApproval($('#btn_accept'), display, null, true);
	    };

	    var display = function display() {
	        var landing_company = Client.get('landing_company_fullname');
	        if (!landing_company) return;

	        var $container = $('#tnc_container');
	        var $tnc_msg = $container.find('#tnc_message');
	        $tnc_msg.html(template($tnc_msg.html(), [landing_company, urlFor(Client.get('residence') === 'jp' ? 'terms-and-conditions-jp' : 'terms-and-conditions')]));
	        $container.find('#tnc_loading').remove();
	        $container.find('#tnc_approval').setVisibility(1);
	    };

	    var requiresTNCApproval = function requiresTNCApproval($btn, funcDisplay, onSuccess, redirect_anyway) {
	        BinarySocket.wait('website_status', 'get_settings').then(function () {
	            if (!Client.shouldAcceptTnc()) {
	                redirectBack(redirect_anyway);
	                return;
	            }

	            funcDisplay();

	            $btn.click(function (e) {
	                e.preventDefault();
	                e.stopPropagation();
	                BinarySocket.send({ tnc_approval: '1' }, { forced: true }).then(function (response) {
	                    if (response.error) {
	                        $('#err_message').html(response.error.message).setVisibility(1);
	                    } else {
	                        BinarySocket.send({ get_settings: 1 }, { forced: true }).then(function () {
	                            Header.displayAccountStatus();
	                        });
	                        redirectBack(redirect_anyway);
	                        if (typeof onSuccess === 'function') {
	                            onSuccess();
	                        }
	                    }
	                });
	            });
	        });
	    };

	    var redirectBack = function redirectBack(redirect_anyway) {
	        if (redirect_anyway) {
	            setTimeout(function () {
	                BinaryPjax.load(defaultRedirectUrl());
	            }, 500);
	        }
	    };

	    return {
	        onLoad: onLoad,
	        requiresTNCApproval: requiresTNCApproval
	    };
	}();

	module.exports = TNCApproval;

/***/ },
/* 494 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinaryPjax = __webpack_require__(467);
	var Client = __webpack_require__(420);
	var GTM = __webpack_require__(464);
	var localize = __webpack_require__(428).localize;
	var Login = __webpack_require__(465);
	var State = __webpack_require__(421).State;
	var urlFor = __webpack_require__(423).urlFor;
	var isEmptyObject = __webpack_require__(417).isEmptyObject;
	var checkClientsCountry = __webpack_require__(425).checkClientsCountry;
	var jpClient = __webpack_require__(425).jpClient;
	var BinarySocket = __webpack_require__(427);
	var MetaTrader = __webpack_require__(495);

	var Header = function () {
	    'use strict';

	    var onLoad = function onLoad() {
	        showOrHideLoginForm();
	        bindClick();
	        if (!Login.isLoginPages()) {
	            checkClientsCountry();
	        }
	        if (Client.isLoggedIn()) {
	            $('ul#menu-top').addClass('smaller-font');
	            displayAccountStatus();
	        }
	    };

	    var bindClick = function bindClick() {
	        $('#logo').off('click').on('click', function () {
	            BinaryPjax.load(urlFor(Client.isLoggedIn() ? jpClient() ? 'multi_barriers_trading' : 'trading' : ''));
	        });
	        $('#btn_login').off('click').on('click', function (e) {
	            e.preventDefault();
	            Login.redirectToLogin();
	        });
	        $('a.logout').off('click').on('click', function () {
	            Client.sendLogoutRequest();
	        });
	    };

	    var showOrHideLoginForm = function showOrHideLoginForm() {
	        if (!Client.isLoggedIn()) return;
	        var loginid_select = $('<div/>');
	        var loginid_array = Client.get('loginid_array');
	        loginid_array.forEach(function (client) {
	            if (!client.disabled) {
	                var type = 'Virtual';
	                if (client.real) {
	                    if (client.financial) type = 'Investment';else if (client.non_financial) type = 'Gaming';else type = 'Real';
	                }
	                type += ' Account';

	                var curr_id = client.id;
	                var localized_type = localize(type);
	                if (curr_id === Client.get('loginid')) {
	                    // default account
	                    $('.account-type').html(localized_type);
	                    $('.account-id').html(curr_id);
	                } else {
	                    loginid_select.append($('<a/>', { href: 'java' + 'script:;', 'data-value': curr_id }).append($('<li/>', { text: localized_type }).append($('<div/>', { text: curr_id })))).append($('<div/>', { class: 'separator-line-thin-gray' }));
	                }
	            }
	        });
	        var $this = void 0;
	        $('.login-id-list').html(loginid_select).find('a').off('click').on('click', function (e) {
	            e.preventDefault();
	            $this = $(this);
	            $this.attr('disabled', 'disabled');
	            switchLoginid($this.attr('data-value'));
	        });
	    };

	    var metatraderMenuItemVisibility = function metatraderMenuItemVisibility(landing_company_response) {
	        if (MetaTrader.isEligible(landing_company_response)) {
	            $('#all-accounts').find('#user_menu_metatrader').setVisibility(1);
	        }
	    };

	    var switchLoginid = function switchLoginid(loginid) {
	        if (!loginid || loginid.length === 0) return;
	        var token = Client.getToken(loginid);
	        if (!token || token.length === 0) {
	            Client.sendLogoutRequest(true);
	            return;
	        }

	        // cleaning the previous values
	        Client.clear();
	        sessionStorage.setItem('active_tab', '1');
	        // set cookies: loginid, login
	        Client.setCookie('loginid', loginid);
	        Client.setCookie('login', token);
	        // set local storage
	        GTM.setLoginFlag();
	        localStorage.setItem('active_loginid', loginid);
	        $('.login-id-list a').removeAttr('disabled');
	        window.location.reload();
	    };

	    var upgradeMessageVisibility = function upgradeMessageVisibility() {
	        BinarySocket.wait('authorize', 'landing_company', 'get_settings').then(function () {
	            var landing_company = State.get(['response', 'landing_company', 'landing_company']);
	            var loginid_array = Client.get('loginid_array');

	            var $upgrade_msg = $('.upgrademessage');

	            var showUpgrade = function showUpgrade(url, msg) {
	                $upgrade_msg.setVisibility(1).find('a').setVisibility(1).attr('href', urlFor(url)).html($('<span/>', { text: localize(msg) }));
	            };

	            if (Client.get('is_virtual')) {
	                var show_upgrade_msg = !loginid_array.some(function (client) {
	                    return client.real;
	                });

	                $upgrade_msg.setVisibility(1).find('> span').setVisibility(1).end().find('a').setVisibility(0);

	                var jp_account_status = (State.get(['response', 'get_settings', 'get_settings', 'jp_account_status']) || {}).status;
	                if (jp_account_status && show_upgrade_msg) {
	                    if (/jp_knowledge_test_(pending|fail)/.test(jp_account_status)) {
	                        // do not show upgrade for user that filled up form
	                        showUpgrade('/new_account/knowledge_testws', '{JAPAN ONLY}Take knowledge test');
	                    } else {
	                        $upgrade_msg.setVisibility(1);
	                        if (jp_account_status === 'jp_activation_pending') {
	                            if ($('.activation-message').length === 0) {
	                                $('#virtual-text').append($('<div/>', { class: 'activation-message', text: ' ' + localize('Your Application is Being Processed.') }));
	                            }
	                        } else if (jp_account_status === 'activated') {
	                            if ($('.activated-message').length === 0) {
	                                $('#virtual-text').append($('<div/>', { class: 'activated-message', text: ' ' + localize('{JAPAN ONLY}Your Application has Been Processed. Please Re-Login to Access Your Real-Money Account.') }));
	                            }
	                        }
	                    }
	                } else if (show_upgrade_msg) {
	                    $upgrade_msg.find('> span').setVisibility(1);
	                    if (Client.canUpgradeVirtualToFinancial(landing_company)) {
	                        showUpgrade('new_account/maltainvestws', 'Upgrade to a Financial Account');
	                    } else if (Client.canUpgradeVirtualToJapan(landing_company)) {
	                        showUpgrade('new_account/japanws', 'Upgrade to a Real Account');
	                    } else {
	                        showUpgrade('new_account/realws', 'Upgrade to a Real Account');
	                    }
	                } else {
	                    $upgrade_msg.find('a').setVisibility(0).html('');
	                }
	            } else {
	                var show_financial = false;
	                // also allow UK MLT client to open MF account
	                if (Client.canUpgradeGamingToFinancial(landing_company) || Client.get('residence') === 'gb' && /^MLT/.test(Client.get('loginid'))) {
	                    show_financial = !loginid_array.some(function (client) {
	                        return client.financial;
	                    });
	                }
	                if (show_financial) {
	                    $('#virtual-text').parent().setVisibility(0);
	                    showUpgrade('new_account/maltainvestws', 'Open a Financial Account');
	                } else {
	                    $upgrade_msg.setVisibility(0);
	                }
	            }
	        });
	    };

	    var displayNotification = function displayNotification(message, is_error) {
	        var $msg_notification = $('#msg_notification');
	        $msg_notification.html(message).attr('data-message', message);
	        if ($msg_notification.is(':hidden')) $msg_notification.removeClass('error').slideDown(500, function () {
	            if (is_error) $msg_notification.addClass('error');
	        });
	    };

	    var hideNotification = function hideNotification() {
	        var $msg_notification = $('#msg_notification');
	        if ($msg_notification.is(':visible')) $msg_notification.removeClass('error').slideUp(500, function () {
	            $msg_notification.html('').removeAttr('data-message');
	        });
	    };

	    var displayAccountStatus = function displayAccountStatus() {
	        BinarySocket.wait('authorize').then(function () {
	            var get_account_status = void 0,
	                status = void 0,
	                should_authenticate = false;

	            var riskAssessment = function riskAssessment() {
	                if (get_account_status.risk_classification === 'high') {
	                    return isEmptyObject(State.get(['response', 'get_financial_assessment', 'get_financial_assessment']));
	                }
	                return false;
	            };

	            var buildMessage = function buildMessage(string, path) {
	                var hash = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
	                return localize(string, ['<a href="' + urlFor(path) + hash + '">', '</a>']);
	            };

	            var messages = {
	                authenticate: function authenticate() {
	                    return buildMessage('[_1]Authenticate your account[_2] now to take full advantage of all withdrawal options available.', 'user/authenticate');
	                },
	                financial_limit: function financial_limit() {
	                    return buildMessage('Please set your 30-day turnover limit in our [_1]self-exclusion facilities[_2] to remove deposit limits.', 'user/security/self_exclusionws', '#max_30day_turnover');
	                },
	                residence: function residence() {
	                    return buildMessage('Please set [_1]country of residence[_2] before upgrading to a real-money account.', 'user/settings/detailsws');
	                },
	                risk: function risk() {
	                    return buildMessage('Please complete the [_1]financial assessment form[_2] to lift your withdrawal and trading limits.', 'user/settings/assessmentws');
	                },
	                tax: function tax() {
	                    return buildMessage('Please [_1]complete your account profile[_2] to lift your withdrawal and trading limits.', 'user/settings/detailsws');
	                },
	                tnc: function tnc() {
	                    return buildMessage('Please [_1]accept the updated Terms and Conditions[_2] to lift your withdrawal and trading limits.', 'user/tnc_approvalws');
	                },
	                unwelcome: function unwelcome() {
	                    return buildMessage('Your account is restricted. Kindly [_1]contact customer support[_2] for assistance.', 'contact');
	                }
	            };

	            var validations = {
	                authenticate: function authenticate() {
	                    return (!/authenticated/.test(status) || !/age_verification/.test(status)) && !jpClient() && should_authenticate;
	                },
	                financial_limit: function financial_limit() {
	                    return (/ukrts_max_turnover_limit_not_set/.test(status)
	                    );
	                },
	                residence: function residence() {
	                    return !Client.get('residence');
	                },
	                risk: function risk() {
	                    return riskAssessment();
	                },
	                tax: function tax() {
	                    return Client.shouldCompleteTax();
	                },
	                tnc: function tnc() {
	                    return Client.shouldAcceptTnc();
	                },
	                unwelcome: function unwelcome() {
	                    return (/(unwelcome|(cashier|withdrawal)_locked)/.test(status)
	                    );
	                }
	            };

	            // real account checks in order
	            var check_statuses_real = ['tnc', 'financial_limit', 'risk', 'tax', 'authenticate', 'unwelcome'];

	            // virtual checks
	            var check_statuses_virtual = ['residence'];

	            var checkStatus = function checkStatus(check_statuses) {
	                var notified = check_statuses.some(function (check_type) {
	                    if (validations[check_type]()) {
	                        displayNotification(messages[check_type]());
	                        return true;
	                    }
	                    return false;
	                });
	                if (!notified) hideNotification();
	            };

	            if (Client.get('is_virtual')) {
	                checkStatus(check_statuses_virtual);
	            } else {
	                BinarySocket.wait('website_status', 'get_account_status', 'get_settings', 'get_financial_assessment', 'balance').then(function () {
	                    get_account_status = State.get(['response', 'get_account_status', 'get_account_status']) || {};
	                    status = get_account_status.status;
	                    if (/costarica/.test(Client.get('landing_company_name')) && +Client.get('balance') < 200) {
	                        BinarySocket.send({ mt5_login_list: 1 }).then(function (response) {
	                            if (response.mt5_login_list.length) {
	                                should_authenticate = true;
	                            }
	                            checkStatus(check_statuses_real);
	                        });
	                    } else {
	                        should_authenticate = true;
	                        checkStatus(check_statuses_real);
	                    }
	                });
	            }
	        });
	    };

	    return {
	        onLoad: onLoad,

	        upgradeMessageVisibility: upgradeMessageVisibility,
	        metatraderMenuItemVisibility: metatraderMenuItemVisibility,
	        displayNotification: displayNotification,
	        hideNotification: hideNotification,
	        displayAccountStatus: displayAccountStatus
	    };
	}();

	module.exports = Header;

/***/ },
/* 495 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var MetaTraderConfig = __webpack_require__(496);
	var MetaTraderUI = __webpack_require__(497);
	var BinarySocket = __webpack_require__(427);
	var localize = __webpack_require__(428).localize;
	var Validation = __webpack_require__(484);

	var MetaTrader = function () {
	    'use strict';

	    var types_info = MetaTraderConfig.types_info;
	    var actions_info = MetaTraderConfig.actions_info;
	    var fields = MetaTraderConfig.fields;

	    var has_financial_company = void 0,
	        has_gaming_company = void 0;

	    var onLoad = function onLoad() {
	        BinarySocket.wait('landing_company').then(function (response) {
	            if (isEligible(response)) {
	                updateEnabledStatus('gaming', has_gaming_company);
	                updateEnabledStatus('financial', has_financial_company);
	                getAllAccountsInfo();
	                MetaTraderUI.init(submit);
	            } else {
	                MetaTraderUI.displayPageError(localize('Sorry, this feature is not available.'));
	            }
	        });
	    };

	    var isEligible = function isEligible(landing_company_response) {
	        var is_eligible = false;
	        if (!landing_company_response.error) {
	            var lc = landing_company_response.landing_company;
	            has_financial_company = lc.hasOwnProperty('mt_financial_company') && lc.mt_financial_company.shortcode === 'vanuatu';
	            has_gaming_company = lc.hasOwnProperty('mt_gaming_company') && lc.mt_gaming_company.shortcode === 'costarica';
	            if (lc.hasOwnProperty('financial_company') && lc.financial_company.shortcode === 'costarica' && (has_financial_company || has_gaming_company)) {
	                is_eligible = true;
	            }
	        }
	        return is_eligible;
	    };

	    var updateEnabledStatus = function updateEnabledStatus(account_type, is_enabled) {
	        Object.keys(types_info).forEach(function (acc_type) {
	            if (types_info[acc_type].account_type === account_type) {
	                types_info[acc_type].is_enabled = is_enabled;
	            }
	        });
	    };

	    var getAllAccountsInfo = function getAllAccountsInfo() {
	        BinarySocket.send({ mt5_login_list: 1 }).then(function (response) {
	            if (response.mt5_login_list && response.mt5_login_list.length > 0) {
	                response.mt5_login_list.map(function (obj) {
	                    var acc_type = getAccountType(obj.group);
	                    if (acc_type) {
	                        // ignore old accounts which are not linked to any group
	                        types_info[acc_type].account_info = { login: obj.login };
	                        getAccountDetails(obj.login, acc_type);
	                    }
	                });
	            }
	            // Update types with no account
	            Object.keys(types_info).forEach(function (acc_type) {
	                if (!types_info[acc_type].account_info) {
	                    MetaTraderUI.updateAccount(acc_type);
	                }
	            });
	        });
	    };

	    var getAccountDetails = function getAccountDetails(login, acc_type) {
	        MetaTraderUI.displayLoadingAccount(acc_type);
	        BinarySocket.send({
	            mt5_get_settings: 1,
	            login: login
	        }).then(function (response) {
	            if (response.mt5_get_settings) {
	                types_info[acc_type].account_info = response.mt5_get_settings;
	                MetaTraderUI.updateAccount(acc_type);
	            }
	        });
	    };

	    var getAccountType = function getAccountType(group) {
	        return group ? /demo/.test(group) ? 'demo' : group.split('\\')[1] || '' : '';
	    };

	    var makeRequestObject = function makeRequestObject(acc_type, action) {
	        var req = {};

	        Object.keys(fields[action]).forEach(function (field) {
	            var field_obj = fields[action][field];
	            if (field_obj.request_field) {
	                req[field_obj.request_field] = MetaTraderUI.$form().find(field_obj.id).val();
	            }
	        });

	        // set main command
	        req['mt5_' + action] = 1;

	        // add additional fields
	        $.extend(req, fields[action].additional_fields(acc_type));

	        return req;
	    };

	    var submit = function submit(e) {
	        e.preventDefault();
	        MetaTraderUI.hideFormMessage();
	        var $btn_submit = $(e.target);
	        var acc_type = $btn_submit.attr('acc_type');
	        var action = $btn_submit.attr('action');
	        if (Validation.validate('#frm_' + action)) {
	            MetaTraderUI.disableButton();
	            // further validations before submit (password_check)
	            MetaTraderUI.postValidate(acc_type, action).then(function (is_ok) {
	                if (!is_ok) {
	                    MetaTraderUI.enableButton();
	                    return;
	                }

	                var req = makeRequestObject(acc_type, action);
	                BinarySocket.send(req).then(function (response) {
	                    if (response.error) {
	                        MetaTraderUI.displayFormMessage(response.error.message);
	                        MetaTraderUI.enableButton();
	                    } else {
	                        MetaTraderUI.closeForm();
	                        MetaTraderUI.displayMainMessage(actions_info[action].success_msg(response));
	                        getAccountDetails(actions_info[action].login ? actions_info[action].login(response) : types_info[acc_type].account_info.login, acc_type);
	                    }
	                });
	            });
	        }
	    };

	    return {
	        onLoad: onLoad,
	        isEligible: isEligible
	    };
	}();

	module.exports = MetaTrader;

/***/ },
/* 496 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var urlFor = __webpack_require__(423).urlFor;
	var isEmptyObject = __webpack_require__(417).isEmptyObject;
	var formatMoney = __webpack_require__(433).formatMoney;

	var MetaTraderConfig = function () {
	    'use strict';

	    var currency = 'USD';

	    var types_info = {
	        demo: { account_type: 'demo', mt5_account_type: '', title: localize('Demo'), max_leverage: 1000, is_demo: true },
	        vanuatu_cent: { account_type: 'financial', mt5_account_type: 'cent', title: localize('Real Cent'), max_leverage: 1000 },
	        vanuatu_standard: { account_type: 'financial', mt5_account_type: 'standard', title: localize('Real Standard'), max_leverage: 300 },
	        vanuatu_stp: { account_type: 'financial', mt5_account_type: 'stp', title: localize('Real STP'), max_leverage: 100 },
	        costarica: { account_type: 'gaming', mt5_account_type: '', title: localize('Real Volatility'), max_leverage: 100 }
	    };

	    var needsRealMessage = function needsRealMessage() {
	        return $('#msg_' + (Client.get('has_real') ? 'switch' : 'upgrade')).html();
	    };

	    var actions_info = {
	        new_account: {
	            title: localize('Create Account'),
	            success_msg: function success_msg(response) {
	                var acc_type = response.mt5_new_account.account_type;
	                switch (acc_type) {
	                    case 'financial':
	                        acc_type = 'vanuatu_' + response.mt5_new_account.mt5_account_type;break;
	                    case 'gaming':
	                        acc_type = 'costarica';break;
	                    // no default
	                }
	                return localize('Congratulations! Your [_1] Account has been created.', [types_info[acc_type].title]);
	            },
	            login: function login(response) {
	                return response.mt5_new_account.login;
	            },
	            prerequisites: function prerequisites(acc_type) {
	                return new Promise(function (resolve) {
	                    if (types_info[acc_type].is_demo) {
	                        resolve();
	                    } else if (Client.get('is_virtual')) {
	                        resolve(needsRealMessage());
	                    } else if (types_info[acc_type].account_type === 'financial') {
	                        BinarySocket.send({ get_financial_assessment: 1 }).then(function (response_financial) {
	                            resolve(isEmptyObject(response_financial.get_financial_assessment) ? $('#msg_assessment').find('a').attr('onclick', 'localStorage.setItem(\'financial_assessment_redirect\', \'' + urlFor('user/metatrader') + '\')').end().html() : '');
	                        });
	                    } else {
	                        resolve();
	                    }
	                });
	            },
	            formValues: function formValues($form, acc_type, action) {
	                // Account type, Sub account type
	                $form.find(fields[action].lbl_account_type.id).text(types_info[acc_type].title);
	                // Email
	                $form.find(fields[action].lbl_email.id).text(fields[action].additional_fields(acc_type).email);
	                // Max leverage
	                $form.find(fields[action].ddl_leverage.id + ' option').each(function () {
	                    if (+$(this).val() > types_info[acc_type].max_leverage) {
	                        $(this).remove();
	                    }
	                });
	            }
	        },
	        password_change: {
	            title: localize('Change Password'),
	            success_msg: function success_msg(response) {
	                return localize('The main password of account number [_1] has been changed.', [response.echo_req.login]);
	            },
	            prerequisites: function prerequisites() {
	                return new Promise(function (resolve) {
	                    return resolve('');
	                });
	            },
	            formValues: function formValues($form, acc_type, action) {
	                // Login ID
	                $form.find(fields[action].lbl_login.id).text(fields[action].additional_fields(acc_type).login);
	            }
	        },
	        deposit: {
	            title: localize('Deposit'),
	            success_msg: function success_msg(response) {
	                return localize('[_1] deposit from [_2] to account number [_3] is done. Transaction ID: [_4]', [formatMoney(currency, response.echo_req.amount), response.echo_req.from_binary, response.echo_req.to_mt5, response.binary_transaction_id]);
	            },
	            prerequisites: function prerequisites() {
	                return new Promise(function (resolve) {
	                    if (Client.get('is_virtual')) {
	                        resolve(needsRealMessage());
	                    } else {
	                        BinarySocket.send({ cashier_password: 1 }).then(function (response) {
	                            if (!response.error && response.cashier_password === 1) {
	                                resolve(localize('Your cashier is locked as per your request - to unlock it, please click <a href="[_1]">here</a>.', [urlFor('user/security/cashier_passwordws')]));
	                            } else {
	                                resolve();
	                            }
	                        });
	                    }
	                });
	            },
	            formValues: function formValues($form, acc_type, action) {
	                // From, To
	                $form.find(fields[action].lbl_from.id).text(fields[action].additional_fields(acc_type).from_binary);
	                $form.find(fields[action].lbl_to.id).text(fields[action].additional_fields(acc_type).to_mt5);
	            }
	        },
	        withdrawal: {
	            title: localize('Withdraw'),
	            success_msg: function success_msg(response) {
	                return localize('[_1] withdrawal from account number [_2] to [_3] is done. Transaction ID: [_4]', [formatMoney(currency, response.echo_req.amount), response.echo_req.from_mt5, response.echo_req.to_binary, response.binary_transaction_id]);
	            },
	            prerequisites: function prerequisites(acc_type) {
	                return new Promise(function (resolve) {
	                    if (Client.get('is_virtual')) {
	                        resolve(needsRealMessage());
	                    } else if (types_info[acc_type].account_type === 'financial') {
	                        BinarySocket.send({ get_account_status: 1 }).then(function (response_status) {
	                            resolve($.inArray('authenticated', response_status.get_account_status.status) === -1 ? $('#msg_authenticate').find('.show_for_mt5').setVisibility(1).end().html() : '');
	                        });
	                    } else {
	                        resolve();
	                    }
	                });
	            },
	            pre_submit: function pre_submit($form, acc_type, displayFormMessage) {
	                return BinarySocket.send({
	                    mt5_password_check: 1,
	                    login: types_info[acc_type].account_info.login,
	                    password: $form.find(fields.withdrawal.txt_main_pass.id).val()
	                }).then(function (response) {
	                    if (+response.mt5_password_check === 1) {
	                        return true;
	                    } else if (response.error) {
	                        displayFormMessage(response.error.message);
	                    }
	                    return false;
	                });
	            },
	            formValues: function formValues($form, acc_type, action) {
	                // From, To
	                $form.find(fields[action].lbl_from.id).text(fields[action].additional_fields(acc_type).from_mt5);
	                $form.find(fields[action].lbl_to.id).text(fields[action].additional_fields(acc_type).to_binary);
	            }
	        }
	    };

	    var fields = {
	        new_account: {
	            lbl_account_type: { id: '#lbl_account_type' },
	            lbl_email: { id: '#lbl_email' },
	            txt_name: { id: '#txt_name', request_field: 'name' },
	            ddl_leverage: { id: '#ddl_leverage', request_field: 'leverage' },
	            txt_main_pass: { id: '#txt_main_pass', request_field: 'mainPassword' },
	            txt_re_main_pass: { id: '#txt_re_main_pass' },
	            txt_investor_pass: { id: '#txt_investor_pass', request_field: 'investPassword' },
	            chk_tnc: { id: '#chk_tnc' },
	            additional_fields: function additional_fields(acc_type) {
	                return $.extend({
	                    account_type: types_info[acc_type].account_type,
	                    email: Client.get('email')
	                }, types_info[acc_type].mt5_account_type ? {
	                    mt5_account_type: types_info[acc_type].mt5_account_type
	                } : {});
	            }
	        },
	        password_change: {
	            lbl_login: { id: '#lbl_login' },
	            txt_old_password: { id: '#txt_old_password', request_field: 'old_password' },
	            txt_new_password: { id: '#txt_new_password', request_field: 'new_password' },
	            txt_re_new_password: { id: '#txt_re_new_password' },
	            additional_fields: function additional_fields(acc_type) {
	                return {
	                    login: types_info[acc_type].account_info.login
	                };
	            }
	        },
	        deposit: {
	            lbl_from: { id: '#lbl_from' },
	            lbl_to: { id: '#lbl_to' },
	            txt_amount: { id: '#txt_amount', request_field: 'amount' },
	            additional_fields: function additional_fields(acc_type) {
	                return {
	                    from_binary: Client.get('loginid'),
	                    to_mt5: types_info[acc_type].account_info.login
	                };
	            }
	        },
	        withdrawal: {
	            lbl_from: { id: '#lbl_from' },
	            lbl_to: { id: '#lbl_to' },
	            txt_amount: { id: '#txt_amount', request_field: 'amount' },
	            txt_main_pass: { id: '#txt_main_pass' },
	            additional_fields: function additional_fields(acc_type) {
	                return {
	                    from_mt5: types_info[acc_type].account_info.login,
	                    to_binary: Client.get('loginid')
	                };
	            }
	        }
	    };

	    var validations = {
	        new_account: [{ selector: fields.new_account.txt_name.id, validations: ['req', 'letter_symbol', ['length', { min: 2, max: 30 }]] }, { selector: fields.new_account.txt_main_pass.id, validations: ['req', 'password'] }, { selector: fields.new_account.txt_re_main_pass.id, validations: ['req', ['compare', { to: fields.new_account.txt_main_pass.id }]] }, { selector: fields.new_account.txt_investor_pass.id, validations: ['req', 'password', ['not_equal', { to: fields.new_account.txt_main_pass.id, name1: 'Main password', name2: 'Investor password' }]] }, { selector: fields.new_account.ddl_leverage.id, validations: ['req'] }, { selector: fields.new_account.chk_tnc.id, validations: [['req', { message: 'Please accept the terms and conditions.' }]] }],
	        password_change: [{ selector: fields.password_change.txt_old_password.id, validations: ['req'] }, { selector: fields.password_change.txt_new_password.id, validations: ['req', 'password', ['not_equal', { to: fields.password_change.txt_old_password.id, name1: 'Current password', name2: 'New password' }]], re_check_field: fields.password_change.txt_re_new_password.id }, { selector: fields.password_change.txt_re_new_password.id, validations: ['req', ['compare', { to: fields.password_change.txt_new_password.id }]] }],
	        deposit: [{ selector: fields.deposit.txt_amount.id, validations: ['req', ['number', { type: 'float', min: 1, max: 20000 }]] }],
	        withdrawal: [{ selector: fields.withdrawal.txt_main_pass.id, validations: ['req'] }, { selector: fields.withdrawal.txt_amount.id, validations: ['req', ['number', { type: 'float', min: 1, max: 20000 }]] }]
	    };

	    return {
	        types_info: types_info,
	        actions_info: actions_info,
	        fields: fields,
	        validations: validations
	    };
	}();

	module.exports = MetaTraderConfig;

/***/ },
/* 497 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var showLoadingImage = __webpack_require__(417).showLoadingImage;
	var formatMoney = __webpack_require__(433).formatMoney;
	var Validation = __webpack_require__(484);
	var MetaTraderConfig = __webpack_require__(496);

	var MetaTraderUI = function () {
	    'use strict';

	    var $container = void 0,
	        $list = void 0,
	        $action = void 0,
	        $templates = void 0,
	        _$form = void 0,
	        $main_msg = void 0,
	        submit = void 0;

	    var types_info = MetaTraderConfig.types_info;
	    var actions_info = MetaTraderConfig.actions_info;
	    var validations = MetaTraderConfig.validations;

	    var init = function init(submit_func) {
	        submit = submit_func;
	        $container = $('#mt_account_management');
	        $list = $container.find('#accounts_list');
	        $action = $container.find('#fst_action');
	        $templates = $container.find('#templates');
	        $main_msg = $container.find('#main_msg');
	        $container.find('#mt_loading').remove();

	        populateAccountList();
	    };

	    var populateAccountList = function populateAccountList() {
	        var $acc_box = $templates.find('> .acc-box');
	        Object.keys(types_info).forEach(function (acc_type) {
	            if ($list.find('#' + acc_type).length === 0 && (types_info[acc_type].is_enabled || types_info[acc_type].is_demo)) {
	                var $acc_item = $acc_box.clone();

	                // set values
	                $acc_item.attr('id', acc_type);
	                $acc_item.find('.title').text(types_info[acc_type].title);

	                // exceptions for demo account
	                if (types_info[acc_type].is_demo) {
	                    $acc_item.find('.act_deposit, .act_withdrawal').remove();
	                }
	                $list.append($acc_item);
	            }
	        });
	        $list.find('[class*="act_"]').click(populateForm);
	        $action.find('.close').click(function () {
	            closeForm(true);
	        });
	    };

	    var displayLoadingAccount = function displayLoadingAccount(acc_type) {
	        var $acc_item = $list.find('#' + acc_type);
	        $acc_item.find('> div > div[class!="title"]').setVisibility(0);
	        $acc_item.find('.loading').setVisibility(1);
	    };

	    var updateAccount = function updateAccount(acc_type) {
	        var $acc_item = $list.find('#' + acc_type);
	        $acc_item.find('.loading').setVisibility(0);
	        if (types_info[acc_type].account_info) {
	            // Update account info
	            $acc_item.find('.acc-info div[data]').map(function () {
	                var key = $(this).attr('data');
	                var info = types_info[acc_type].account_info[key];
	                $(this).text(key === 'balance' ? formatMoney('USD', +info) : key === 'leverage' ? '1:' + info : info);
	            });
	            $acc_item.find('.has-account').setVisibility(1);
	        } else {
	            $acc_item.find('.no-account').setVisibility(1).find('.info').html($templates.find('#' + acc_type));
	        }
	    };

	    var populateForm = function populateForm(e) {
	        closeForm();
	        var $target = $(e.target);
	        if ($target.prop('tagName').toLowerCase() === 'img') {
	            $target = $target.parents('a');
	        }
	        var acc_type = $target.parents('.acc-box').attr('id');
	        var action = $target.attr('class').match(/act_(.*)/)[1];

	        // set active
	        $list.find('.acc-box[id!="' + acc_type + '"] > div').removeClass('active');
	        $list.find('#' + acc_type + ' > div').addClass('active');

	        actions_info[action].prerequisites(acc_type).then(function (error_msg) {
	            if (error_msg) {
	                // does not meet one of prerequisites
	                displayMainMessage(error_msg);
	                return;
	            }

	            // clone form, event listener
	            _$form = $templates.find('#frm_' + action).clone();
	            var formValues = actions_info[action].formValues;
	            if (formValues) formValues(_$form, acc_type, action);
	            _$form.find('#btn_submit').attr({ acc_type: acc_type, action: action }).on('click dblclick', submit);

	            // update legend, append form
	            $action.find('legend').text(types_info[acc_type].title + ': ' + actions_info[action].title).end().find('#frm_action').html(_$form).end().setVisibility(1);
	            $.scrollTo($action, 500, { offset: -7 });
	            Validation.init('#frm_' + action, validations[action]);
	        });
	    };

	    var closeForm = function closeForm(should_scroll) {
	        if (_$form && _$form.length) {
	            _$form.find('#btn_submit').off('click dblclick', submit);
	            _$form.empty();
	            _$form = undefined;
	            $action.setVisibility(0);
	            $list.find('.acc-box > div').removeClass('active');
	            if (should_scroll) {
	                $.scrollTo($list, 500, { offset: -10 });
	            }
	        }
	        $main_msg.empty().setVisibility(0);
	    };

	    var postValidate = function postValidate(acc_type, action) {
	        var validate = actions_info[action].pre_submit;
	        return validate ? validate(_$form, acc_type, displayFormMessage) : new Promise(function (resolve) {
	            return resolve(true);
	        });
	    };

	    var hideFormMessage = function hideFormMessage() {
	        _$form.find('#msg_form').html('').setVisibility(0);
	    };

	    var displayFormMessage = function displayFormMessage(message) {
	        _$form.find('#msg_form').text(message).setVisibility(1);
	    };

	    var displayMainMessage = function displayMainMessage(message) {
	        $main_msg.html(message).setVisibility(1);
	        $.scrollTo($main_msg, 500, { offset: -10 });
	    };

	    var displayPageError = function displayPageError(message) {
	        $('#mt_account_management').find('#page_msg').html(message).setVisibility(1).end().find('#mt_loading').remove();
	    };

	    var disableButton = function disableButton() {
	        var $btn = _$form.find('button');
	        if ($btn.length && !$btn.find('.barspinner').length) {
	            $btn.attr('disabled', 'disabled');
	            var $btn_text = $('<span/>', { text: $btn.text(), class: 'invisible' });
	            showLoadingImage($btn, 'white');
	            $btn.append($btn_text);
	        }
	    };

	    var enableButton = function enableButton() {
	        var $btn = _$form.find('button');
	        if ($btn.length && $btn.find('.barspinner').length) {
	            $btn.removeAttr('disabled').html($btn.find('span').text());
	        }
	    };

	    return {
	        init: init,
	        $form: function $form() {
	            return _$form;
	        },
	        displayLoadingAccount: displayLoadingAccount,
	        updateAccount: updateAccount,
	        closeForm: closeForm,
	        postValidate: postValidate,
	        hideFormMessage: hideFormMessage,
	        displayFormMessage: displayFormMessage,
	        displayMainMessage: displayMainMessage,
	        displayPageError: displayPageError,
	        disableButton: disableButton,
	        enableButton: enableButton
	    };
	}();

	module.exports = MetaTraderUI;

/***/ },
/* 498 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);
	var Scroll = __webpack_require__(491);

	var WhyUs = function () {
	    'use strict';

	    var onLoad = function onLoad() {
	        Scroll.sidebarScroll($('.why-us'));
	        Client.activateByClientType();
	    };

	    var onUnload = function onUnload() {
	        Scroll.offScroll();
	    };

	    return {
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = WhyUs;

/***/ },
/* 499 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var FormManager = __webpack_require__(483);

	var AccountTransfer = function () {
	    'use strict';

	    var form_id = '#frm_account_transfer';

	    var accounts = void 0,
	        $transfer = void 0;

	    var populateAccounts = function populateAccounts(response) {
	        if (response.error) {
	            $('#error_message').find('p').text(response.error.message).end().setVisibility(1);
	            return;
	        }
	        accounts = response.accounts;
	        var $form = $(form_id);
	        $transfer = $form.find('#transfer');
	        var text = void 0,
	            from_loginid = void 0,
	            to_loginid = void 0;

	        accounts.forEach(function (account, idx) {
	            if (+account.balance) {
	                from_loginid = accounts[idx].loginid;
	                to_loginid = accounts[1 - idx].loginid;
	                text = localize('from [_1] to [_2]', [from_loginid, to_loginid]);
	                $transfer.append($('<option/>', {
	                    text: text,
	                    'data-from': from_loginid,
	                    'data-to': to_loginid,
	                    'data-currency': accounts[idx].currency,
	                    'data-balance': accounts[idx].balance
	                }));
	            }
	        });

	        // show client's login id on top
	        var $client_option = $transfer.find('option[data-from="' + Client.get('loginid') + '"]');
	        if ($client_option.length !== 0) {
	            $client_option.insertBefore($transfer.find('option:eq(0)')).attr('selected', 'selected');
	        }

	        if (from_loginid) {
	            showForm($form);
	        } else {
	            $('#client_message').setVisibility(1);
	        }
	    };

	    var showForm = function showForm($form) {
	        var $currency = $form.find('#currency');
	        $transfer.on('change', function () {
	            updateCurrency($currency, $(this));
	            bindValidation();
	        });
	        updateCurrency($currency);
	        $form.setVisibility(1);
	        bindValidation();
	        FormManager.handleSubmit({
	            form_selector: form_id,
	            fnc_response_handler: responseHandler
	        });
	    };

	    var updateCurrency = function updateCurrency($currency) {
	        $currency.text(getTransferAttr('data-currency'));
	    };

	    var getTransferAttr = function getTransferAttr(attribute) {
	        return $transfer.find('option:selected').attr(attribute);
	    };

	    var bindValidation = function bindValidation() {
	        FormManager.init(form_id, [{ selector: '#amount', validations: ['req', ['number', { type: 'float', decimals: '1, 2', min: 0.1, max: getTransferAttr('data-balance') }]] }, { request_field: 'transfer_between_accounts', value: 1 }, { request_field: 'account_from', value: function value() {
	                return getTransferAttr('data-from');
	            } }, { request_field: 'account_to', value: function value() {
	                return getTransferAttr('data-to');
	            } }, { request_field: 'currency', value: function value() {
	                return getTransferAttr('data-currency');
	            } }]);
	    };

	    var responseHandler = function responseHandler(response) {
	        if (response.error) {
	            $('#form_error').text(response.error.message).setVisibility(1);
	        } else {
	            BinarySocket.send({ transfer_between_accounts: 1 }).then(function (data) {
	                return populateReceipt(data);
	            });
	        }
	    };

	    var populateReceipt = function populateReceipt(response) {
	        $(form_id).setVisibility(0);
	        accounts = response.accounts;
	        accounts.forEach(function (account, idx) {
	            $('#loginid_' + (idx + 1)).text(account.loginid);
	            $('#balance_' + (idx + 1)).text(account.currency + ' ' + account.balance);
	        });
	        $('#success_form').setVisibility(1);
	    };

	    var onLoad = function onLoad() {
	        BinarySocket.send({ transfer_between_accounts: 1 }).then(function (response) {
	            return populateAccounts(response);
	        });
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = AccountTransfer;

/***/ },
/* 500 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var BinaryPjax = __webpack_require__(467);
	var Client = __webpack_require__(420);
	var Header = __webpack_require__(494);
	var defaultRedirectUrl = __webpack_require__(423).defaultRedirectUrl;
	var urlFor = __webpack_require__(423).urlFor;
	var jpClient = __webpack_require__(425).jpClient;
	var jpResidence = __webpack_require__(425).jpResidence;

	var Cashier = function () {
	    'use strict';

	    var href = '';

	    var showContent = function showContent() {
	        Client.activateByClientType();
	    };

	    var displayTopUpButton = function displayTopUpButton() {
	        BinarySocket.wait('balance').then(function (response) {
	            var currency = response.balance.currency;
	            var balance = +response.balance.balance;
	            var can_topup = currency !== 'JPY' && balance <= 1000 || currency === 'JPY' && balance <= 100000;
	            var top_up_id = '#VRT_topup_link';
	            var $a = $(top_up_id);
	            var classes = ['toggle', 'button-disabled'];
	            var new_el = { class: $a.attr('class').replace(classes[+can_topup], classes[1 - +can_topup]), html: $a.html(), id: $a.attr('id') };
	            if (can_topup) {
	                href = href || urlFor('/cashier/top_up_virtualws');
	                new_el.href = href;
	            }
	            $a.replaceWith($('<a/>', new_el));
	            $(top_up_id).parent().setVisibility(1);
	        });
	    };

	    var onLoad = function onLoad() {
	        if (jpClient() && !jpResidence()) {
	            BinaryPjax.load(defaultRedirectUrl());
	        }
	        if (Client.isLoggedIn()) {
	            BinarySocket.wait('authorize').then(function () {
	                Header.upgradeMessageVisibility(); // To handle the upgrade buttons visibility
	                var is_virtual = Client.get('is_virtual');
	                if (is_virtual) {
	                    displayTopUpButton();
	                }
	                if (is_virtual || /CR/.test(Client.get('loginid'))) {
	                    $('#payment-agent-section').setVisibility(1);
	                }
	                if (Client.hasGamingFinancialEnabled()) {
	                    $('#account-transfer-section').setVisibility(1);
	                }
	            });
	        }
	        showContent();
	    };

	    return {
	        onLoad: onLoad,
	        PaymentMethods: { onLoad: function onLoad() {
	                showContent();
	            } }
	    };
	}();

	module.exports = Cashier;

/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var template = __webpack_require__(417).template;
	var appendTextValueChild = __webpack_require__(430).appendTextValueChild;
	var FormManager = __webpack_require__(483);

	var DepositWithdraw = function () {
	    'use strict';

	    var cashier_type = void 0;
	    var container = '#deposit_withdraw';
	    var verification_code = void 0;

	    var init = function init(cashier_password) {
	        if (cashier_password) {
	            showMessage('cashier_locked_message');
	            sessionStorage.setItem('cashier_lock_redirect', window.location.href);
	            return;
	        }
	        if (!Client.get('currency')) {
	            showCurrency();
	        } else {
	            initDepositWithdraw();
	        }
	    };

	    var initDepositWithdraw = function initDepositWithdraw(response) {
	        if (response && response.error) {
	            showError('custom_error', response.error.message);
	        } else if (cashier_type === 'deposit') {
	            getCashierURL();
	        } else if (cashier_type === 'withdraw') {
	            hideAll('#messages');
	            initWithdrawForm();
	        }
	    };

	    var initWithdrawForm = function initWithdrawForm() {
	        BinarySocket.send({
	            verify_email: Client.get('email'),
	            type: 'payment_withdraw'
	        }).then(function (response) {
	            if ('error' in response) {
	                showError('custom_error', response.error.message);
	            } else {
	                showMessage('check_email_message');
	                var withdraw_form_id = '#frm_withdraw';
	                $(withdraw_form_id).setVisibility(1);
	                FormManager.init(withdraw_form_id, [{ selector: '#verification_code', validations: ['req', 'email_token'] }]);
	                var req = populateReq();
	                FormManager.handleSubmit({
	                    form_selector: withdraw_form_id,
	                    obj_request: req,
	                    fnc_response_handler: handleCashierResponse
	                });
	            }
	        });
	    };

	    var showCurrency = function showCurrency() {
	        var currencies = Client.get('currencies').split(',');
	        currencies.forEach(function (c) {
	            appendTextValueChild('select_currency', c, c);
	        });
	        showMessage('choose_currency_message');
	        var currency_form_id = '#frm_currency';
	        $(currency_form_id).setVisibility(1);
	        FormManager.init(currency_form_id, [{ selector: '#select_currency', request_field: 'set_account_currency' }]);
	        FormManager.handleSubmit({
	            form_selector: currency_form_id,
	            fnc_response_handler: initDepositWithdraw
	        });
	    };

	    var getCashierType = function getCashierType() {
	        var $heading = $(container).find('#heading');
	        var hash_value = window.location.hash;
	        if (/withdraw/.test(hash_value)) {
	            cashier_type = 'withdraw';
	            $heading.text(localize('Withdraw'));
	        } else if (/deposit/.test(hash_value)) {
	            cashier_type = 'deposit';
	            $heading.text(localize('Deposit'));
	        }
	    };

	    var populateReq = function populateReq(send_verification) {
	        var req = { cashier: cashier_type };
	        var verification_code_val = $('#verification_code').val();
	        if (verification_code_val) verification_code = verification_code_val;
	        if (send_verification && verification_code) req.verification_code = verification_code;
	        if (/epg/.test(window.location.pathname)) req.provider = 'epg';
	        return req;
	    };

	    var getCashierURL = function getCashierURL() {
	        BinarySocket.send(populateReq(1)).then(function (response) {
	            return handleCashierResponse(response);
	        });
	    };

	    var hideAll = function hideAll(option) {
	        $('#frm_withdraw, #frm_currency, #frm_ukgc, #errors').setVisibility(0);
	        if (option) {
	            $(option).setVisibility(0);
	        }
	    };

	    var showError = function showError(id, error) {
	        hideAll();
	        if (error) $('#' + id).text(error);
	        showMessage(id, 'errors');
	    };

	    var showMessage = function showMessage(id) {
	        var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'messages';

	        $('#' + id).siblings().setVisibility(0).end().setVisibility(1);
	        $(container).find('#' + parent).setVisibility(1);
	    };

	    var showPersonalDetailsError = function showPersonalDetailsError(details) {
	        var msg_id = 'personal_details_message';
	        var error_fields = void 0;
	        if (details) {
	            error_fields = {
	                province: 'State/Province',
	                country: 'Country',
	                city: 'Town/City',
	                street: 'First line of home address',
	                pcode: 'Postal Code / ZIP',
	                phone: 'Telephone',
	                email: 'Email address'
	            };
	        }
	        var $el = $('#' + msg_id);
	        var err_msg = template($el.html(), [localize(details ? error_fields[details] : 'details')]);
	        $el.html(err_msg);
	        showMessage(msg_id);
	    };

	    var ukgcResponseHandler = function ukgcResponseHandler(response) {
	        if ('error' in response) {
	            showError('custom_error', response.error.message);
	        } else {
	            getCashierURL();
	        }
	    };

	    var initUKGC = function initUKGC() {
	        var ukgc_form_id = '#frm_ukgc';
	        $(ukgc_form_id).setVisibility(1);
	        FormManager.init(ukgc_form_id, [{ request_field: 'ukgc_funds_protection', value: 1 }, { request_field: 'tnc_approval', value: 1 }]);
	        FormManager.handleSubmit({
	            form_selector: ukgc_form_id,
	            fnc_response_handler: ukgcResponseHandler
	        });
	    };

	    var handleCashierResponse = function handleCashierResponse(response) {
	        hideAll('#messages');
	        var error = response.error;
	        if (error) {
	            switch (error.code) {
	                case 'ASK_TNC_APPROVAL':
	                    showError('tnc_error');
	                    break;
	                case 'ASK_FIX_DETAILS':
	                    showPersonalDetailsError(error.details);
	                    break;
	                case 'ASK_UK_FUNDS_PROTECTION':
	                    initUKGC();
	                    break;
	                case 'ASK_AUTHENTICATE':
	                    showMessage('not_authenticated_message');
	                    break;
	                case 'ASK_FINANCIAL_RISK_APPROVAL':
	                    showError('financial_risk_error');
	                    break;
	                case 'ASK_JP_KNOWLEDGE_TEST':
	                    showError('knowledge_test_error');
	                    break;
	                case 'JP_NOT_ACTIVATION':
	                    showError('activation_error');
	                    break;
	                case 'ASK_AGE_VERIFICATION':
	                    showError('age_error');
	                    break;
	                case 'ASK_SELF_EXCLUSION_MAX_TURNOVER_SET':
	                    showError('limits_error');
	                    break;
	                default:
	                    showError('custom_error', error.message);
	            }
	        } else {
	            $(container).find('iframe').attr('src', response.cashier).parent().setVisibility(1);
	        }
	    };

	    var onLoad = function onLoad() {
	        getCashierType();
	        BinarySocket.send({ cashier_password: 1 }).then(function (data) {
	            if ('error' in data) {
	                showError('custom_error', data.error.message);
	            } else {
	                init(data.cashier_password);
	            }
	        });
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = DepositWithdraw;

/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var urlForStatic = __webpack_require__(423).urlForStatic;
	var Cookies = __webpack_require__(422);

	var PaymentAgentList = function () {
	    'use strict';

	    var $pa_list_container = void 0,
	        $agent_template = void 0;

	    var ddl_countries_id = '#target_country';

	    var onLoad = function onLoad() {
	        $(function () {
	            $('#accordion').accordion({
	                heightStyle: 'content',
	                collapsible: true,
	                active: false
	            });
	        });

	        $pa_list_container = $('#pa_list');
	        $agent_template = $pa_list_container.find('#accordion').html();

	        var residence = Cookies.get('residence');
	        if (!residence || residence.length === 0) {
	            residence = '00'; // just to get a list of payment agent Countries
	        }

	        sendRequest(residence, true);
	    };

	    var sendRequest = function sendRequest(country, is_list) {
	        BinarySocket.send({
	            paymentagent_list: country || $(ddl_countries_id).val()
	        }).then(function (response) {
	            if (is_list) {
	                populateCountriesList(response);
	            } else {
	                populateAgentsList(response.paymentagent_list.list);
	            }
	        });
	    };

	    // --------------------------
	    // ----- Countries List -----
	    // --------------------------
	    var populateCountriesList = function populateCountriesList(response) {
	        var $ddl_countries = $(ddl_countries_id);
	        $ddl_countries.empty();

	        var countries = response.paymentagent_list.available_countries;
	        if (countries.length === 0) {
	            $ddl_countries.parent().setVisibility(0);
	            showEmptyListMsg();
	            return;
	        }

	        var requested_country = response.echo_req.paymentagent_list;
	        var found = false;
	        countries.map(function (country) {
	            if (country === requested_country) {
	                found = true;
	            }
	            insertListOption($ddl_countries, country[1], country[0]);
	        });
	        $('#target_country').setVisibility(1);
	        $('.barspinner').setVisibility(0);

	        if (found) {
	            $ddl_countries.val(requested_country);
	            populateAgentsList(response.paymentagent_list.list);
	        } else {
	            sendRequest();
	        }

	        $ddl_countries.change(function () {
	            sendRequest();
	        });
	    };

	    var insertListOption = function insertListOption($ddl_object, item_text, item_value) {
	        $ddl_object.append($('<option/>', { value: item_value, text: item_text }));
	    };

	    // -----------------------
	    // ----- Agents List -----
	    // -----------------------
	    var populateAgentsList = function populateAgentsList(list) {
	        if (!list || list.length === 0) {
	            showEmptyListMsg();
	            return;
	        }

	        var $accordion = $('<div/>', { id: 'accordion' });

	        list.map(function (agent) {
	            var supported_banks = '';
	            if (agent.supported_banks && agent.supported_banks.length > 0) {
	                var banks = agent.supported_banks.split(',');
	                banks.map(function (bank) {
	                    supported_banks += bank.length === 0 ? '' : '<img src="' + urlForStatic('images/pages/payment_agent/banks/' + bank.toLowerCase() + '.png') + '" alt="' + bank + '" title="' + bank + '" />';
	                });
	            }

	            $accordion.append($agent_template.replace(/%name/g, agent.name).replace(/%summary/g, agent.summary).replace(/%deposit_commission/g, agent.deposit_commission).replace(/%withdrawal_commission/g, agent.withdrawal_commission).replace(/%url/g, agent.url).replace(/%email/g, agent.email).replace(/%telephone/g, agent.telephone).replace(/%further_information/g, agent.further_information).replace(/%supported_banks/g, supported_banks));
	        });

	        $pa_list_container.empty().append($accordion);

	        $('#accordion').accordion({
	            heightStyle: 'content',
	            collapsible: true,
	            active: false
	        });
	    };

	    var showEmptyListMsg = function showEmptyListMsg() {
	        $('.barspinner').setVisibility(0);
	        $('#no_paymentagent').setVisibility(1);
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = PaymentAgentList;

/***/ },
/* 503 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var FormManager = __webpack_require__(483);
	var Cookies = __webpack_require__(422);

	var PaymentAgentWithdraw = function () {
	    'use strict';

	    var view_ids = {
	        error: '#viewError',
	        success: '#viewSuccess',
	        confirm: '#viewConfirm',
	        form: '#viewForm'
	    };
	    var field_ids = {
	        verification_code: '#verification_code',
	        ddl_agents: '#ddlAgents',
	        txt_amount: '#txtAmount',
	        txt_desc: '#txtDescription'
	    };

	    var $views = void 0,
	        agent_name = void 0;

	    // -----------------------
	    // ----- Agents List -----
	    // -----------------------
	    var populateAgentsList = function populateAgentsList(response) {
	        var $ddl_agents = $(field_ids.ddl_agents);
	        $ddl_agents.empty();
	        var pa_list = (response.paymentagent_list || {}).list;
	        if (pa_list.length > 0) {
	            BinarySocket.send({ verify_email: Client.get('email'), type: 'paymentagent_withdraw' });
	            insertListOption($ddl_agents, localize('Please select a payment agent'), '');
	            for (var i = 0; i < pa_list.length; i++) {
	                insertListOption($ddl_agents, pa_list[i].name, pa_list[i].paymentagent_loginid);
	            }
	            setActiveView(view_ids.form);
	            var form_id = '#' + $(view_ids.form).find('form').attr('id');
	            FormManager.init(form_id, [{ selector: field_ids.ddl_agents, validations: ['req'], request_field: 'paymentagent_loginid' }, { selector: field_ids.txt_amount, validations: ['req', ['number', { type: 'float', decimals: '1, 2', min: 10, max: 2000 }]], request_field: 'amount' }, { selector: field_ids.txt_desc, validations: ['general'], request_field: 'description' }, { selector: field_ids.verification_code, validations: ['req', 'email_token'] }, { request_field: 'currency', value: 'USD' }, { request_field: 'paymentagent_withdraw', value: 1 }, { request_field: 'dry_run', value: 1 }]);

	            FormManager.handleSubmit({
	                form_selector: form_id,
	                fnc_response_handler: withdrawResponse,
	                fnc_additional_check: setAgentName
	            });
	        } else {
	            showPageError(localize('The Payment Agent facility is currently not available in your country.'));
	        }
	    };

	    var insertListOption = function insertListOption($ddl_object, item_text, item_value) {
	        $ddl_object.append($('<option/>', { value: item_value, text: item_text }));
	    };

	    // ----------------------------
	    // ----- Withdraw Process -----
	    // ----------------------------
	    var withdrawResponse = function withdrawResponse(response) {
	        var request = response.echo_req;
	        switch (response.paymentagent_withdraw) {
	            case 2:
	                {
	                    // dry_run success: showing the confirmation page
	                    setActiveView(view_ids.confirm);

	                    $('#lblAgentName').text(agent_name);
	                    $('#lblCurrency').text(request.currency);
	                    $('#lblAmount').text(request.amount);

	                    FormManager.init(view_ids.confirm, [{ request_field: 'paymentagent_loginid', value: request.paymentagent_loginid }, { request_field: 'amount', value: request.amount }, { request_field: 'description', value: request.description }, { request_field: 'verification_code', value: request.verification_code }, { request_field: 'currency', value: request.currency }, { request_field: 'paymentagent_withdraw', value: 1 }]);

	                    FormManager.handleSubmit({
	                        form_selector: view_ids.confirm,
	                        fnc_response_handler: withdrawResponse
	                    });

	                    $(view_ids.confirm + ' #btnBack').click(function () {
	                        setActiveView(view_ids.form);
	                    });
	                    break;
	                }
	            case 1:
	                // withdrawal success
	                setActiveView(view_ids.success);
	                $('#successMessage').css('display', '').attr('class', 'success-msg').html($('<ul/>', { class: 'checked' }).append($('<li/>', { text: localize('Your request to withdraw [_1] [_2] from your account [_3] to Payment Agent [_4] account has been successfully processed.', [request.currency, request.amount, Cookies.get('loginid'), agent_name]) })));
	                break;

	            default:
	                // error
	                if (response.echo_req.dry_run === 1) {
	                    setActiveView(view_ids.form);
	                    $('#formMessage').setVisibility(1).html(response.error.message);
	                } else if (response.error.code === 'InvalidToken') {
	                    showPageError(localize('Your token has expired. Please click [_1]here[_2] to restart the verification process.', ['<a href="javascript:;" onclick="window.location.reload();">', '</a>']));
	                } else {
	                    showPageError(response.error.message);
	                }
	                break;
	        }
	    };

	    // -----------------------------
	    // ----- Message Functions -----
	    // -----------------------------
	    var showPageError = function showPageError(err_msg, id) {
	        var $error = $(view_ids.error);
	        $error.find(' > p').setVisibility(0);
	        if (id) {
	            $error.find('#' + id).setVisibility(1);
	        } else {
	            $error.find('#custom-error').html(err_msg).setVisibility(1);
	        }
	        setActiveView(view_ids.error);
	    };

	    // ----- View Control -----
	    var setActiveView = function setActiveView(view_id) {
	        $views.setVisibility(0);
	        $(view_id).setVisibility(1);
	    };

	    var onLoad = function onLoad() {
	        BinarySocket.wait('get_account_status').then(function (data) {
	            $views = $('#paymentagent_withdrawal').find('.viewItem');
	            $views.setVisibility(0);

	            if (/(withdrawal|cashier)_locked/.test(data.get_account_status.status)) {
	                showPageError('', 'withdrawal-locked-error');
	            } else {
	                BinarySocket.send({ paymentagent_list: Cookies.get('residence') }).then(function (response) {
	                    return populateAgentsList(response);
	                });
	            }
	        });
	    };

	    var setAgentName = function setAgentName() {
	        agent_name = $(field_ids.ddl_agents).find('option:selected').text();
	        return true;
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = PaymentAgentWithdraw;

/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var MBContract = __webpack_require__(304);
	var MBDisplayCurrencies = __webpack_require__(505);
	var MBTradingEvents = __webpack_require__(506);
	var MBPrice = __webpack_require__(303);
	var MBProcess = __webpack_require__(507);
	var BinarySocket = __webpack_require__(427);
	var TradingAnalysis = __webpack_require__(508);
	var chartFrameCleanup = __webpack_require__(509).chartFrameCleanup;
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var JapanPortfolio = __webpack_require__(510);

	var MBTradePage = function () {
	    'use strict';

	    var events_initialized = 0;
	    State.remove('is_mb_trading');

	    var onLoad = function onLoad() {
	        State.set('is_mb_trading', true);

	        if (events_initialized === 0) {
	            events_initialized = 1;
	            MBTradingEvents.init();
	        }

	        BinarySocket.send({ payout_currencies: 1 }).then(function () {
	            MBDisplayCurrencies('', false);
	            MBProcess.getSymbols();
	        });

	        TradingAnalysis.bindAnalysisTabEvent();
	        $('#tab_portfolio').find('a').text(localize('Portfolio'));
	        $('#tab_graph').find('a').text(localize('Chart'));
	        $('#tab_explanation').find('a').text(localize('Explanation'));
	        $('#remaining-time-label').text(localize('Remaining time'));
	        State.set('is_chart_allowed', true);
	        State.set('ViewPopup.onDisplayed', MBPrice.hidePriceOverlay);
	    };

	    var reload = function reload() {
	        window.location.reload();
	    };

	    var onUnload = function onUnload() {
	        chartFrameCleanup();
	        State.set('is_chart_allowed', false);
	        JapanPortfolio.hide();
	        State.remove('is_mb_trading');
	        events_initialized = 0;
	        MBContract.onUnload();
	        MBPrice.onUnload();
	        MBProcess.onUnload();
	        BinarySocket.clear('active_symbols');
	        State.remove('ViewPopup.onDisplayed');
	    };

	    var onDisconnect = function onDisconnect() {
	        MBPrice.showPriceOverlay();
	        chartFrameCleanup();
	        onLoad();
	    };

	    return {
	        onLoad: onLoad,
	        reload: reload,
	        onUnload: onUnload,
	        onDisconnect: onDisconnect
	    };
	}();

	module.exports = MBTradePage;

/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var MBDefaults = __webpack_require__(416);
	var Client = __webpack_require__(420);
	var State = __webpack_require__(421).State;
	var jpClient = __webpack_require__(425).jpClient;
	var formatCurrency = __webpack_require__(433).formatCurrency;

	/*
	 * Handles currency display
	 *
	 * It process 'socket.send({payout_currencies:1})` response
	 * and display them
	 */
	var MBDisplayCurrencies = function MBDisplayCurrencies(selected, show_class) {
	    'use strict';

	    var target = document.getElementById('currency');
	    var fragment = document.createDocumentFragment();
	    var currencies = Client.get('currencies').split(',');

	    if (!target) {
	        return;
	    }

	    while (target && target.firstChild) {
	        target.removeChild(target.firstChild);
	    }

	    if (currencies.length > 1 && !jpClient()) {
	        currencies.forEach(function (currency) {
	            var option = document.createElement('option');
	            var content = document.createTextNode(currency);

	            option.setAttribute('value', currency);
	            /* if (selected && selected == key) {
	                option.setAttribute('selected', 'selected');
	            }*/

	            option.appendChild(content);
	            fragment.appendChild(option);
	        });

	        target.appendChild(fragment);
	        MBDefaults.set('currency', target.value);
	    } else {
	        var class_value = show_class ? target.getAttribute('class') : '';
	        var text_value = State.get('is_mb_trading') && jpClient() ? '✕' : formatCurrency(currencies[0]);
	        $('#currency').replaceWith($('<span/>', { id: target.getAttribute('id'), class: class_value, value: currencies[0], text: text_value }));
	        if ($('.payout-mult:visible').length === 0) $('#payout').width(40); // wider when there is free space
	        MBDefaults.set('currency', currencies[0]);
	    }
	};

	module.exports = MBDisplayCurrencies;

/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var MBContract = __webpack_require__(304);
	var MBDefaults = __webpack_require__(416);
	var MBNotifications = __webpack_require__(434);
	var MBProcess = __webpack_require__(507);
	var MBTick = __webpack_require__(462);
	var TradingAnalysis = __webpack_require__(508);
	var debounce = __webpack_require__(445).debounce;
	var jpClient = __webpack_require__(425).jpClient;
	var formatMoney = __webpack_require__(433).formatMoney;

	/*
	 * TradingEvents object contains all the event handler function required for
	 * websocket trading page
	 *
	 * We need it as object so that we can call TradingEvent.init() only on trading
	 * page for pjax to work else it will fire on all pages
	 *
	 */
	var MBTradingEvents = function () {
	    'use strict';

	    var initiate = function initiate() {
	        /*
	         * attach event to underlying change, event need to request new contract details and price
	         */
	        var underlying_element = document.getElementById('underlying');
	        if (underlying_element) {
	            underlying_element.addEventListener('change', function (e) {
	                if (e.target) {
	                    // chartFrameSource();
	                    // showFormOverlay();
	                    // showPriceOverlay();
	                    if (e.target.selectedIndex < 0) {
	                        e.target.selectedIndex = 0;
	                    }
	                    var underlying = e.target.value;
	                    MBDefaults.set('underlying', underlying);
	                    MBNotifications.hide('SYMBOL_INACTIVE');

	                    MBTick.clean();

	                    MBTick.updateWarmChart();

	                    MBProcess.getContracts(underlying);

	                    // forget the old tick id i.e. close the old tick stream
	                    MBProcess.processForgetTicks();
	                    // get ticks for current underlying
	                    MBTick.request(underlying);
	                    MBContract.displayDescriptions();
	                }
	            });
	        }

	        var category_element = document.getElementById('category');
	        if (category_element) {
	            category_element.addEventListener('change', function (e) {
	                MBDefaults.set('category', e.target.value);
	                MBContract.populatePeriods('rebuild');
	                MBProcess.processPriceRequest();
	                TradingAnalysis.request();
	            });
	        }

	        var period_element = document.getElementById('period');
	        if (period_element) {
	            period_element.addEventListener('change', function (e) {
	                MBDefaults.set('period', e.target.value);
	                MBProcess.processPriceRequest();
	                $('.countdown-timer').removeClass('alert');
	                MBContract.displayRemainingTime('recalculate');
	                MBContract.displayDescriptions();
	            });
	        }

	        var payout_element = document.getElementById('payout');
	        var payoutOnKeypress = function payoutOnKeypress(ev) {
	            var key = ev.keyCode;
	            var char = String.fromCharCode(ev.which);
	            var is_ok = true;
	            if (char === '.' && ev.target.value.indexOf(char) >= 0 || !/[0-9\.]/.test(char) && [8, 37, 39, 46].indexOf(key) < 0 || // delete, backspace, arrow keys
	            /['%]/.test(char)) {
	                // similarity to arrows key code in some browsers
	                is_ok = false;
	            }
	            var result = payout_element.value.substring(0, ev.target.selectionStart) + char + payout_element.value.substring(ev.target.selectionEnd);

	            if (jpClient() && char === '.' || result[0] === '0' || !validatePayout(+result)) {
	                is_ok = false;
	            }

	            if (!is_ok) {
	                ev.returnValue = false;
	                ev.preventDefault();
	            }
	        };

	        var validatePayout = function validatePayout(payout_amount) {
	            var is_ok = true;
	            var contract = MBContract.getCurrentContracts();
	            var max_amount = Array.isArray(contract) && contract[0].expiry_type !== 'intraday' ? 20000 : 5000;
	            if (!payout_amount || isNaN(payout_amount) || jpClient() && (payout_amount < 1 || payout_amount > 100) || payout_amount <= 0 || payout_amount > max_amount) {
	                is_ok = false;
	            }

	            return is_ok;
	        };

	        if (payout_element) {
	            if (!payout_element.value) {
	                var payout_def = MBDefaults.get('payout') || (jpClient() ? 1 : 10);
	                payout_element.value = payout_def;
	                MBDefaults.set('payout', payout_def);
	            }
	            payout_element.addEventListener('keypress', payoutOnKeypress);
	            payout_element.addEventListener('input', debounce(function (e) {
	                var payout = e.target.value;

	                if (!jpClient()) {
	                    payout = payout.replace(/[^0-9.]/g, '');
	                    if (isStandardFloat(payout)) {
	                        payout = formatMoney(MBDefaults.get('currency'), parseFloat(payout), 1);
	                    }
	                    e.target.value = payout;
	                }

	                var $payout_element = $('#payout');
	                var $table_element = $('.japan-table');
	                if (!validatePayout(payout)) {
	                    $payout_element.addClass('error-field');
	                    $table_element.setVisibility(0);
	                    return false;
	                }
	                // else
	                $payout_element.removeClass('error-field');
	                $table_element.setVisibility(1);

	                MBDefaults.set('payout', payout);
	                MBProcess.processPriceRequest();
	                MBContract.displayDescriptions();
	                return true;
	            }));
	            payout_element.addEventListener('click', function () {
	                this.select();
	            });
	        }

	        // For verifying there are 2 digits after decimal
	        var isStandardFloat = function isStandardFloat(value) {
	            return !isNaN(value) && value % 1 !== 0 && (+parseFloat(value)).toFixed(10).replace(/^-?\d*\.?|0+$/g, '').length > 2;
	        };

	        var currency_element = document.getElementById('currency');
	        if (currency_element) {
	            currency_element.addEventListener('change', function () {
	                MBProcess.processPriceRequest();
	                MBContract.displayDescriptions();
	            });
	        }
	    };

	    return {
	        init: initiate
	    };
	}();

	module.exports = MBTradingEvents;

/***/ },
/* 507 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var MBContract = __webpack_require__(304);
	var MBDefaults = __webpack_require__(416);
	var MBNotifications = __webpack_require__(434);
	var MBPrice = __webpack_require__(303);
	var MBSymbols = __webpack_require__(418);
	var MBTick = __webpack_require__(462);
	var BinarySocket = __webpack_require__(427);
	var TradingAnalysis = __webpack_require__(508);
	var commonTrading = __webpack_require__(445);
	var BinaryPjax = __webpack_require__(467);
	var Client = __webpack_require__(420);
	var getLanguage = __webpack_require__(424).get;
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var jpClient = __webpack_require__(425).jpClient;

	var MBProcess = function () {
	    'use strict';

	    var market_status = '',
	        symbols_timeout = void 0;

	    var getSymbols = function getSymbols() {
	        BinarySocket.wait('website_status').then(function (website_status) {
	            var landing_company_obj = State.get(['response', 'landing_company', 'landing_company']);
	            var allowed_markets = Client.currentLandingCompany().legal_allowed_markets;
	            if (Client.isLoggedIn() && allowed_markets && allowed_markets.indexOf('forex') === -1) {
	                BinaryPjax.load('trading');
	                return;
	            }
	            var req = {
	                active_symbols: 'brief',
	                product_type: 'multi_barrier'
	            };
	            if (landing_company_obj) {
	                req.landing_company = landing_company_obj.financial_company ? landing_company_obj.financial_company.shortcode : 'japan';
	            } else if (website_status.website_status.clients_country === 'jp' || getLanguage() === 'JA') {
	                req.landing_company = 'japan';
	            }
	            BinarySocket.send(req, { msg_type: 'active_symbols' }).then(function (response) {
	                processActiveSymbols(response);
	            });
	        });
	    };

	    /*
	     * This function processes the active symbols to get markets
	     * and underlying list
	     */
	    var processActiveSymbols = function processActiveSymbols(data) {
	        if (data.hasOwnProperty('error')) {
	            MBNotifications.show({ text: data.error.message, uid: 'ACTIVE_SYMBOLS' });
	            return;
	        }

	        // populate the Symbols object
	        MBSymbols.details(data);

	        var is_show_all = Client.isLoggedIn() && !jpClient();
	        var symbols_list = is_show_all ? MBSymbols.getAllSymbols() : MBSymbols.underlyings().major_pairs;
	        var symbol = MBDefaults.get('underlying');

	        if (!symbol || !symbols_list[symbol]) {
	            symbol = undefined;
	            MBDefaults.remove('underlying');
	        }
	        // check if all symbols are inactive
	        var is_market_closed = true;
	        Object.keys(symbols_list).forEach(function (s) {
	            if (symbols_list[s].is_active) {
	                is_market_closed = false;
	            }
	        });
	        clearSymbolTimeout();
	        if (is_market_closed) {
	            handleMarketClosed();
	        } else {
	            handleMarketOpen();
	            if (is_show_all) populateUnderlyingGroups(symbol);else commonTrading.displayUnderlyings('underlying', symbols_list, symbol);

	            if (symbol && !symbols_list[symbol].is_active) {
	                MBNotifications.show({ text: localize('This symbol is not active. Please try another symbol.'), uid: 'SYMBOL_INACTIVE' });
	            } else {
	                MBProcess.processMarketUnderlying();
	            }
	        }
	    };

	    var populateUnderlyingGroups = function populateUnderlyingGroups(selected) {
	        var $underlyings = $('#underlying');
	        var all_symbols = MBSymbols.underlyings();
	        var markets = MBSymbols.markets();

	        $underlyings.empty();

	        Object.keys(markets).sort(function (a, b) {
	            return markets[a].name.localeCompare(markets[b].name);
	        }).forEach(function (market) {
	            $underlyings.append($('<optgroup/>', { label: markets[market].name }).append($(commonTrading.generateUnderlyingOptions(all_symbols[market], selected))));
	        });
	    };

	    var handleMarketClosed = function handleMarketClosed() {
	        $('.japan-form, .japan-table, #trading_bottom_content').setVisibility(0);
	        MBNotifications.show({ text: localize('Market is closed. Please try again later.'), uid: 'MARKET_CLOSED' });
	        symbols_timeout = setTimeout(function () {
	            getSymbols();
	        }, 30000);
	    };

	    var handleMarketOpen = function handleMarketOpen() {
	        $('.japan-form, .japan-table, #trading_bottom_content').setVisibility(1);
	        MBNotifications.hide('MARKET_CLOSED');
	    };

	    var clearSymbolTimeout = function clearSymbolTimeout() {
	        clearTimeout(symbols_timeout);
	    };

	    /*
	     * Function to call when underlying has changed
	     */
	    var processMarketUnderlying = function processMarketUnderlying() {
	        var underlying_element = document.getElementById('underlying');
	        if (!underlying_element) {
	            return;
	        }

	        if (underlying_element.selectedIndex < 0) {
	            underlying_element.selectedIndex = 0;
	        }
	        var underlying = underlying_element.value;
	        MBDefaults.set('underlying', underlying);

	        commonTrading.showFormOverlay();

	        // forget the old tick id i.e. close the old tick stream
	        processForgetTicks();
	        // get ticks for current underlying
	        MBTick.request(underlying);

	        MBTick.clean();

	        MBTick.updateWarmChart();

	        BinarySocket.clearTimeouts();

	        getContracts(underlying);
	    };

	    var contract_timeout = void 0;
	    var getContracts = function getContracts(underlying) {
	        var req = {
	            contracts_for: underlying || MBDefaults.get('underlying'),
	            currency: MBContract.getCurrency(),
	            product_type: 'multi_barrier'
	        };
	        if (!underlying) {
	            req.passthrough = { action: 'no-proposal' };
	        }
	        BinarySocket.send(req).then(function (response) {
	            MBNotifications.hide('CONNECTION_ERROR');
	            MBContract.setContractsResponse(response);
	            processContract(response);
	        });
	        if (contract_timeout) clearContractTimeout();
	        contract_timeout = setTimeout(getContracts, 15000);
	    };

	    var clearContractTimeout = function clearContractTimeout() {
	        clearTimeout(contract_timeout);
	    };

	    /*
	     * Function to display contract form for current underlying
	     */
	    var processContract = function processContract(contracts) {
	        if (contracts.hasOwnProperty('error')) {
	            MBNotifications.show({ text: contracts.error.message, uid: contracts.error.code });
	            return;
	        }

	        State.set('is_chart_allowed', !(contracts.contracts_for && contracts.contracts_for.feed_license && contracts.contracts_for.feed_license === 'chartonly'));

	        checkMarketStatus(contracts.contracts_for.close);

	        var no_rebuild = contracts.hasOwnProperty('passthrough') && contracts.passthrough.hasOwnProperty('action') && contracts.passthrough.action === 'no-proposal';
	        MBContract.populateOptions(no_rebuild ? null : 'rebuild');
	        if (no_rebuild) {
	            processExpiredBarriers();
	            return;
	        }
	        processPriceRequest();
	        TradingAnalysis.request();
	    };

	    var checkMarketStatus = function checkMarketStatus(close) {
	        var now = window.time.unix();

	        // if market is closed, else if market is open
	        if (now > close) {
	            if (market_status === 'open') {
	                handleMarketClosed();
	            }
	            market_status = 'closed';
	        } else {
	            if (market_status === 'closed') {
	                getSymbols();
	                handleMarketOpen();
	            }
	            market_status = 'open';
	        }
	    };

	    var processPriceRequest = function processPriceRequest() {
	        MBPrice.increaseReqId();
	        processForgetProposals();
	        MBPrice.showPriceOverlay();
	        var available_contracts = MBContract.getCurrentContracts();
	        var durations = MBDefaults.get('period').split('_');
	        var req = {
	            proposal_array: 1,
	            subscribe: 1,
	            basis: 'payout',
	            amount: jpClient() ? (parseInt(MBDefaults.get('payout')) || 1) * 1000 : MBDefaults.get('payout'),
	            currency: MBContract.getCurrency(),
	            symbol: MBDefaults.get('underlying'),
	            passthrough: { req_id: MBPrice.getReqId() },
	            date_expiry: durations[1],
	            contract_type: [],
	            barriers: [],

	            trading_period_start: durations[0]
	        };

	        // contract_type
	        available_contracts.forEach(function (c) {
	            return req.contract_type.push(c.contract_type);
	        });

	        // barriers
	        var all_expired = true;
	        var contract = available_contracts[0];
	        contract.available_barriers.forEach(function (barrier) {
	            var barrier_item = {};
	            if (+contract.barriers === 2) {
	                barrier_item.barrier = barrier[1];
	                barrier_item.barrier2 = barrier[0];
	            } else {
	                barrier_item.barrier = barrier;
	            }
	            if (!barrierHasExpired(contract.expired_barriers, barrier_item.barrier, barrier_item.barrier2)) {
	                all_expired = false;
	                req.barriers.push(barrier_item);
	            }
	        });

	        // send request
	        if (req.barriers.length) {
	            MBPrice.addPriceObj(req);
	            BinarySocket.send(req, { callback: processProposal });
	        }

	        // all barriers expired
	        if (all_expired) {
	            MBNotifications.show({ text: localize('All barriers in this trading window are expired') + '.', uid: 'ALL_EXPIRED' });
	            MBPrice.hidePriceOverlay();
	        } else {
	            MBNotifications.hide('ALL_EXPIRED');
	        }
	    };

	    var processProposal = function processProposal(response) {
	        var req_id = MBPrice.getReqId();
	        if (response.passthrough.req_id === req_id) {
	            if (response.error) {
	                MBNotifications.show({ text: response.error.message, uid: 'PROPOSAL', dismissible: false });
	                return;
	            }
	            MBNotifications.hide('PROPOSAL');
	            MBPrice.display(response);
	        }
	    };

	    var processExpiredBarriers = function processExpiredBarriers() {
	        var contracts = MBContract.getCurrentContracts();
	        var expired_barrier = void 0,
	            $expired_barrier_element = void 0;
	        contracts.forEach(function (c) {
	            var expired_barriers = c.expired_barriers;
	            for (var i = 0; i < expired_barriers.length; i++) {
	                if (+c.barriers === 2) {
	                    expired_barrier = [expired_barriers[i][0], expired_barriers[i][1]].join('_');
	                } else {
	                    expired_barrier = expired_barriers[i];
	                }
	                $expired_barrier_element = $('div [data-barrier="' + expired_barrier + '"]');
	                if ($expired_barrier_element.length > 0) {
	                    processForgetProposal(expired_barrier);
	                    $expired_barrier_element.remove();
	                }
	            }
	        });
	    };

	    var barrierHasExpired = function barrierHasExpired(expired_barriers, barrier, barrier2) {
	        if (barrier2) {
	            return containsArray(expired_barriers, [[barrier2, barrier]]);
	        }
	        return expired_barriers.indexOf(barrier.toString()) > -1;
	    };

	    var processForgetProposal = function processForgetProposal(expired_barrier) {
	        var prices = MBPrice.getPrices();
	        Object.keys(prices[expired_barrier]).forEach(function (c) {
	            if (!prices[expired_barrier][c].hasOwnProperty('error')) {
	                BinarySocket.send({ forget: prices[expired_barrier][c].proposal.id });
	            }
	        });
	    };

	    var processForgetProposals = function processForgetProposals() {
	        MBPrice.showPriceOverlay();
	        BinarySocket.send({
	            forget_all: 'proposal_array'
	        });
	        MBPrice.cleanup();
	    };

	    var processForgetTicks = function processForgetTicks() {
	        BinarySocket.send({
	            forget_all: 'ticks'
	        });
	    };

	    var forgetTradingStreams = function forgetTradingStreams() {
	        processForgetProposals();
	        processForgetTicks();
	    };

	    var containsArray = function containsArray(array, val) {
	        var hash = {};
	        for (var i = 0; i < array.length; i++) {
	            hash[array[i]] = i;
	        }
	        return hash.hasOwnProperty(val);
	    };

	    var onUnload = function onUnload() {
	        forgetTradingStreams();
	        clearSymbolTimeout();
	        clearContractTimeout();
	        MBSymbols.clearData();
	        MBTick.clean();
	    };

	    return {
	        getSymbols: getSymbols,
	        processActiveSymbols: processActiveSymbols,
	        processMarketUnderlying: processMarketUnderlying,
	        getContracts: getContracts,
	        processContract: processContract,
	        processPriceRequest: processPriceRequest,
	        processProposal: processProposal,
	        processForgetTicks: processForgetTicks,
	        forgetTradingStreams: forgetTradingStreams,
	        onUnload: onUnload
	    };
	}();

	module.exports = MBProcess;

/***/ },
/* 508 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var showHighchart = __webpack_require__(509).showHighchart;
	var Defaults = __webpack_require__(437);
	var getActiveTab = __webpack_require__(458).getActiveTab;
	var GetTicks = __webpack_require__(441);
	var MBDefaults = __webpack_require__(416);
	var getLanguage = __webpack_require__(424).get;
	var State = __webpack_require__(421).State;
	var Url = __webpack_require__(423);
	var JapanPortfolio = __webpack_require__(510);

	/*
	 * This file contains the code related to loading of trading page bottom analysis
	 * content. It will contain jquery so as to compatible with old code and less rewrite
	 *
	 * Please note that this will be removed in near future
	 */

	/*
	 * This function is called whenever we change market, form
	 * or underlying to load bet analysis for that particular event
	 */

	var TradingAnalysis = function () {
	    'use strict';

	    var hidden_class = 'invisible';
	    var form_name = void 0;

	    var requestTradeAnalysis = function requestTradeAnalysis() {
	        form_name = (State.get('is_mb_trading') ? MBDefaults.get('category') : Defaults.get('formname')) || 'risefall';

	        var map_obj = { matchdiff: 'digits', callput: 'higherlower' };
	        var regex = new RegExp(Object.keys(map_obj).join('|'), 'gi');
	        form_name = form_name.replace(regex, function (matched) {
	            return map_obj[matched];
	        });

	        $('#tab_last_digit').setVisibility(/(digits|overunder|evenodd)/.test(form_name));
	        sessionStorage.setItem('currentAnalysisTab', getActiveTab());
	        loadAnalysisTab();
	    };

	    /*
	     * This function bind event to link elements of bottom content
	     * navigation
	     */
	    var bindAnalysisTabEvent = function bindAnalysisTabEvent() {
	        $('#betsBottomPage').find('li a').on('click', function (e) {
	            e.preventDefault();
	            var li = e.target.parentElement;
	            sessionStorage.setItem('currentAnalysisTab', li.id);
	            if (!li.classList.contains('active')) {
	                loadAnalysisTab(li.id);
	            }
	        });
	    };

	    /*
	     * This function handles all the functionality on how to load
	     * tab according to current paramerted
	     */
	    var loadAnalysisTab = function loadAnalysisTab(tab) {
	        var current_tab = tab || getActiveTab();

	        $('#betsBottomPage').find('li').removeClass('active');
	        $('#' + current_tab).addClass('active');
	        toggleActiveAnalysisTabs();

	        JapanPortfolio.init();
	        if (current_tab === 'tab_portfolio') {
	            JapanPortfolio.show();
	        } else {
	            JapanPortfolio.hide();
	            if (current_tab === 'tab_graph') {
	                showHighchart();
	            } else if (current_tab === 'tab_last_digit') {
	                var underlying = $('#digit_underlying option:selected').val() || $('#underlying').find('option:selected').val();
	                var tick = $('#tick_count').val() || 100;
	                GetTicks.request('', {
	                    ticks_history: underlying,
	                    count: tick.toString(),
	                    end: 'latest'
	                });
	            } else if (current_tab === 'tab_explanation') {
	                showExplanation();
	            }
	        }
	    };

	    /*
	     * function to toggle the active element for analysis menu
	     */
	    var toggleActiveAnalysisTabs = function toggleActiveAnalysisTabs() {
	        var current_tab = getActiveTab();
	        var analysis_container = document.getElementById('bet_bottom_content');

	        if (analysis_container) {
	            var child_elements = analysis_container.children;
	            var current_tab_element = document.getElementById(current_tab + '-content');
	            var classes = current_tab_element.classList;

	            for (var i = 0, len = child_elements.length; i < len; i++) {
	                child_elements[i].classList.remove('selectedTab');
	                child_elements[i].classList.add(hidden_class);
	            }

	            classes.add('selectedTab');
	            classes.remove(hidden_class);
	        }
	    };

	    /*
	     * handle the display of proper explanation based on parameters
	     */
	    var showExplanation = function showExplanation() {
	        var $container = $('#tab_explanation-content');

	        $container.find('#explanation_winning > div, #explanation_explain > div, #explanation_image').setVisibility(0);
	        $container.find('#explanation_winning, #winning_' + form_name + ', #explanation_explain, #explain_' + form_name).setVisibility(1);

	        var images = {
	            risefall: {
	                image1: 'rise-fall-1.svg',
	                image2: 'rise-fall-2.svg'
	            },
	            higherlower: {
	                image1: 'higher-lower-1.svg',
	                image2: 'higher-lower-2.svg'
	            },
	            touchnotouch: {
	                image1: 'touch-notouch-1.svg',
	                image2: 'touch-notouch-2.svg'
	            },
	            endsinout: {
	                image1: 'in-out-1.svg',
	                image2: 'in-out-2.svg'
	            },
	            staysinout: {
	                image1: 'in-out-3.svg',
	                image2: 'in-out-4.svg'
	            },
	            updown: {
	                image1: 'up-down-1.svg',
	                image2: 'up-down-2.svg'
	            },
	            evenodd: {
	                image1: 'evenodd-1.svg',
	                image2: 'evenodd-2.svg'
	            },
	            overunder: {
	                image1: 'overunder-1.svg',
	                image2: 'overunder-2.svg'
	            }
	        };

	        if (images[form_name]) {
	            var image_path = Url.urlForStatic('images/pages/trade-explanation/' + (getLanguage() === 'JA' ? 'ja/' : ''));
	            $container.find('#explanation_image_1').attr('src', image_path + images[form_name].image1);
	            $container.find('#explanation_image_2').attr('src', image_path + images[form_name].image2);
	            $container.find('#explanation_image').setVisibility(1);
	        }
	    };

	    return {
	        request: requestTradeAnalysis,
	        bindAnalysisTabEvent: bindAnalysisTabEvent
	    };
	}();

	module.exports = TradingAnalysis;

/***/ },
/* 509 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var getLanguage = __webpack_require__(424).get;
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var Url = __webpack_require__(423);
	var jpClient = __webpack_require__(425).jpClient;

	var ChartFrame = function () {
	    var showHighchart = function showHighchart() {
	        if (State.get('is_chart_allowed')) {
	            chartFrameSource();
	        } else {
	            chartFrameCleanup();
	            $('#trade_live_chart').hide();
	            $('#chart-error').text(localize('Chart is not available for this underlying.')).show();
	        }
	    };

	    var chartFrameCleanup = function chartFrameCleanup() {
	        /*
	         * Prevent IE memory leak (http://stackoverflow.com/questions/8407946).
	         */
	        var chart_frame = document.getElementById('chart_frame');
	        if (chart_frame) {
	            chart_frame.src = 'about:blank';
	        }
	    };

	    var chartFrameSource = function chartFrameSource() {
	        var new_underlying = document.getElementById('underlying').value;
	        var chart_source = $('#chart_frame').attr('src');
	        if ($('#tab_graph').hasClass('active') && (Url.paramsHash(chart_source).instrument !== new_underlying || /^(|about:blank)$/.test(chart_source))) {
	            chartFrameCleanup();
	            setChartSource();
	        }
	        $('#chart-error').hide();
	        $('#trade_live_chart').show();
	    };

	    var setChartSource = function setChartSource() {
	        var is_ja = !!jpClient();
	        document.getElementById('chart_frame').src = 'https://webtrader.binary.com?affiliates=true&instrument=' + document.getElementById('underlying').value + '&timePeriod=1t&gtm=true&lang=' + getLanguage().toLowerCase() + '&hideOverlay=' + is_ja + '&hideShare=' + is_ja + '&timezone=GMT+' + (is_ja ? '9' : '0');
	    };

	    return {
	        showHighchart: showHighchart,
	        chartFrameCleanup: chartFrameCleanup,
	        chartFrameSource: chartFrameSource
	    };
	}();

	module.exports = ChartFrame;

/***/ },
/* 510 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);
	var State = __webpack_require__(421).State;
	var PortfolioInit = __webpack_require__(511);

	var JapanPortfolio = function () {
	    var $portfolio = void 0,
	        is_portfolio_active = false;

	    var init = function init() {
	        if (isActive()) {
	            $('#tab_portfolio').setVisibility(1);
	        }

	        var $container = $('#tab_portfolio-content');
	        $portfolio = $portfolio || $('#portfolio');

	        if ($portfolio && (!$portfolio.parent().length || $portfolio.parent().get(0).id !== 'tab_portfolio-content')) {
	            $portfolio.detach();
	            $container.append($portfolio);
	        }
	    };

	    var show = function show() {
	        if (isTradePage() && !is_portfolio_active) {
	            PortfolioInit.onLoad();
	            is_portfolio_active = true;
	        }
	    };

	    var isActive = function isActive() {
	        return !!(Client.isLoggedIn() && isTradePage());
	    };

	    var hide = function hide() {
	        if (isTradePage() && is_portfolio_active) {
	            PortfolioInit.onUnload();
	            is_portfolio_active = false;
	            $portfolio = undefined;
	        }
	    };

	    var isTradePage = function isTradePage() {
	        return State.get('is_mb_trading');
	    };

	    return {
	        init: init,
	        show: show,
	        hide: hide,
	        isActive: isActive
	    };
	}();

	module.exports = JapanPortfolio;

/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Portfolio = __webpack_require__(512).Portfolio;
	var ViewPopup = __webpack_require__(435);
	var BinarySocket = __webpack_require__(427);
	var Client = __webpack_require__(420);
	var toJapanTimeIfNeeded = __webpack_require__(463).toJapanTimeIfNeeded;
	var localize = __webpack_require__(428).localize;
	var urlParam = __webpack_require__(423).param;
	var showLoadingImage = __webpack_require__(417).showLoadingImage;
	var jpClient = __webpack_require__(425).jpClient;
	var formatMoney = __webpack_require__(433).formatMoney;
	var GetAppDetails = __webpack_require__(513);

	var PortfolioInit = function () {
	    'use strict';

	    var values = void 0,
	        currency = void 0,
	        oauth_apps = void 0,
	        is_initialized = void 0,
	        is_first_response = void 0;

	    var init = function init() {
	        updateBalance();

	        if (is_initialized) return;

	        values = {};
	        currency = '';
	        oauth_apps = {};
	        var $portfolio_loading = $('#portfolio-loading');
	        $portfolio_loading.show();
	        showLoadingImage($portfolio_loading);
	        is_first_response = true;
	        BinarySocket.send({ portfolio: 1 }).then(function (response) {
	            updatePortfolio(response);
	        });
	        // Subscribe to transactions to auto update new purchases
	        BinarySocket.send({ transaction: 1, subscribe: 1 }, { callback: transactionResponseHandler });
	        BinarySocket.send({ oauth_apps: 1 }).then(function (response) {
	            updateOAuthApps(response);
	        });
	        is_initialized = true;

	        // Display ViewPopup according to contract_id in query string
	        var contract_id = urlParam('contract_id');
	        if (contract_id) {
	            ViewPopup.init($('<div />', { contract_id: contract_id }).get(0));
	        }
	    };

	    var createPortfolioRow = function createPortfolioRow(data, is_first) {
	        var long_code =  true ? data.longcode : jpClient() ? toJapanTimeIfNeeded(undefined, undefined, data.longcode) : data.longcode;

	        var new_class = is_first ? '' : 'new';
	        var $div = $('<div/>');
	        $div.append($('<tr/>', { class: 'tr-first ' + new_class + ' ' + data.contract_id, id: data.contract_id }).append($('<td/>', { class: 'ref' }).append($('<span ' + GetAppDetails.showTooltip(data.app_id, oauth_apps[data.app_id]) + ' data-balloon-position="right">' + data.transaction_id + '</span>'))).append($('<td/>', { class: 'payout' }).append($('<strong/>', { text: formatMoney(data.currency, data.payout) }))).append($('<td/>', { class: 'details', text: long_code })).append($('<td/>', { class: 'purchase' }).append($('<strong/>', { text: formatMoney(data.currency, data.buy_price) }))).append($('<td/>', { class: 'indicative' }).append($('<strong/>', { class: 'indicative_price', text: '--.--' }))).append($('<td/>', { class: 'button' }).append($('<button/>', { class: 'button open_contract_details nowrap', contract_id: data.contract_id, text: localize('View') })))).append($('<tr/>', { class: 'tr-desc ' + new_class + ' ' + data.contract_id }).append($('<td/>', { colspan: '6', text: long_code })));
	        $('#portfolio-body').prepend($div.html());
	    };

	    var updateBalance = function updateBalance() {
	        var $portfolio_balance = $('#portfolio-balance');
	        if ($portfolio_balance.length === 0) return;
	        $portfolio_balance.text(Portfolio.getBalance(Client.get('balance'), Client.get('currency')));
	        var $if_balance_zero = $('#if-balance-zero');
	        if (Client.get('balance') > 0 || Client.get('is_virtual')) {
	            $if_balance_zero.setVisibility(0);
	        } else {
	            $if_balance_zero.setVisibility(1);
	        }
	    };

	    var updatePortfolio = function updatePortfolio(data) {
	        if (data.hasOwnProperty('error')) {
	            errorMessage(data.error.message);
	            return;
	        }

	        // no open contracts
	        if (data.portfolio.contracts.length === 0) {
	            $('#portfolio-no-contract').show();
	            $('#portfolio-table').setVisibility(0);
	        } else {
	            /**
	             * User has at least one contract
	             **/
	            $('#portfolio-no-contract').hide();
	            var portfolio_data = void 0;
	            $.each(data.portfolio.contracts, function (ci, c) {
	                if (!values.hasOwnProperty(c.contract_id)) {
	                    values[c.contract_id] = {};
	                    values[c.contract_id].buy_price = c.buy_price;
	                    portfolio_data = Portfolio.getPortfolioData(c);
	                    currency = portfolio_data.currency;
	                    createPortfolioRow(portfolio_data, is_first_response);
	                    setTimeout(function () {
	                        $('tr.' + c.contract_id).removeClass('new');
	                    }, 1000);
	                }
	            });
	            $('#portfolio-table').setVisibility(1);

	            // update footer area data
	            updateFooter();

	            // request "proposal_open_contract"
	            BinarySocket.send({ proposal_open_contract: 1, subscribe: 1 }, { callback: updateIndicative });
	        }
	        // ready to show portfolio table
	        $('#portfolio-loading').hide();
	        $('#portfolio-content').setVisibility(1);
	        is_first_response = false;
	    };

	    var transactionResponseHandler = function transactionResponseHandler(response) {
	        if (response.hasOwnProperty('error')) {
	            errorMessage(response.error.message);
	        } else if (response.transaction.action === 'buy') {
	            BinarySocket.send({ portfolio: 1 }).then(function (res) {
	                updatePortfolio(res);
	            });
	        } else if (response.transaction.action === 'sell') {
	            removeContract(response.transaction.contract_id);
	        }
	    };

	    var updateIndicative = function updateIndicative(data) {
	        if (data.hasOwnProperty('error') || !values) {
	            return;
	        }

	        var proposal = Portfolio.getProposalOpenContract(data.proposal_open_contract);
	        // avoid updating 'values' before the new contract row added to the table
	        if (!values.hasOwnProperty(proposal.contract_id)) {
	            return;
	        }

	        // force to sell the expired contract, in order to remove from portfolio
	        if (+proposal.is_settleable === 1 && !proposal.is_sold) {
	            BinarySocket.send({ sell_expired: 1 });
	        }
	        var $td = $('#' + proposal.contract_id).find('td.indicative');

	        var old_indicative = values[proposal.contract_id].indicative || 0.00;
	        values[proposal.contract_id].indicative = proposal.bid_price;

	        var status_class = '',
	            no_resale_html = '';
	        if (+proposal.is_sold === 1) {
	            removeContract(proposal.contract_id);
	        } else {
	            if (+proposal.is_valid_to_sell !== 1) {
	                no_resale_html = $('<span/>', { text: localize('Resale not offered') });
	                $td.addClass('no_resale');
	            } else {
	                status_class = values[proposal.contract_id].indicative < old_indicative ? ' price_moved_down' : values[proposal.contract_id].indicative > old_indicative ? ' price_moved_up' : '';
	                $td.removeClass('no_resale');
	            }
	            $td.html($('<strong/>', { class: 'indicative_price ' + status_class, text: formatMoney(proposal.currency, values[proposal.contract_id].indicative) }).append(no_resale_html));
	        }

	        updateFooter();
	    };

	    var updateOAuthApps = function updateOAuthApps(response) {
	        oauth_apps = GetAppDetails.buildOauthApps(response);
	        GetAppDetails.addTooltip(oauth_apps);
	    };

	    var removeContract = function removeContract(contract_id) {
	        delete values[contract_id];
	        $('tr.' + contract_id).removeClass('new').css('opacity', '0.5').fadeOut(1000, function () {
	            $(this).remove();
	            if ($('#portfolio-body').find('tr').length === 0) {
	                $('#portfolio-table').setVisibility(0);
	                $('#cost-of-open-positions, #value-of-open-positions').text('');
	                $('#portfolio-no-contract').show();
	            }
	        });
	        updateFooter();
	    };

	    var updateFooter = function updateFooter() {
	        $('#cost-of-open-positions').text(formatMoney(currency, Portfolio.getSumPurchase(values)));
	        $('#value-of-open-positions').text(formatMoney(currency, Portfolio.getIndicativeSum(values)));
	    };

	    var errorMessage = function errorMessage(msg) {
	        var $err = $('#portfolio').find('#error-msg');
	        if (msg) {
	            $err.setVisibility(1).text(msg);
	        } else {
	            $err.setVisibility(0).text('');
	        }
	    };

	    var onLoad = function onLoad() {
	        init();
	        ViewPopup.viewButtonOnClick('#portfolio-table');
	    };

	    var onUnload = function onUnload() {
	        BinarySocket.send({ forget_all: 'proposal_open_contract' });
	        BinarySocket.send({ forget_all: 'transaction' });
	        $('#portfolio-body').empty();
	        $('#portfolio-content').setVisibility(0);
	        is_initialized = false;
	    };

	    return {
	        updateBalance: updateBalance,
	        updatePortfolio: updatePortfolio,
	        updateIndicative: updateIndicative,
	        updateOAuthApps: updateOAuthApps,
	        transactionResponseHandler: transactionResponseHandler,
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = PortfolioInit;

/***/ },
/* 512 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);
	var toJapanTimeIfNeeded = __webpack_require__(463).toJapanTimeIfNeeded;
	var formatMoney = __webpack_require__(433).formatMoney;
	var jpClient = __webpack_require__(425).jpClient;

	var Portfolio = function () {
	    'use strict';

	    var getBalance = function getBalance(balance, currency) {
	        balance = parseFloat(balance);
	        return currency ? formatMoney(currency, balance) : balance;
	    };

	    var getPortfolioData = function getPortfolioData(c) {
	        return {
	            transaction_id: c.transaction_id,
	            contract_id: c.contract_id,
	            payout: formatMoney(c.currency, parseFloat(c.payout), 1),
	            longcode:  true ? c.longcode : jpClient() ? toJapanTimeIfNeeded(undefined, undefined, c.longcode) : c.longcode,
	            currency: c.currency,
	            buy_price: c.buy_price,
	            app_id: c.app_id
	        };
	    };

	    var getProposalOpenContract = function getProposalOpenContract(proposal) {
	        return {
	            contract_id: proposal.contract_id,
	            bid_price: formatMoney(proposal.currency, parseFloat(proposal.bid_price || 0), 1),
	            is_sold: proposal.is_sold,
	            is_valid_to_sell: proposal.is_valid_to_sell,
	            currency: proposal.currency
	        };
	    };

	    var getSum = function getSum(values, value_type) {
	        // value_type is: indicative or buy_price
	        var sum = 0;
	        var keys = Object.keys(values);
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (values[key] && !isNaN(values[key][value_type])) {
	                sum += parseFloat(values[key][value_type]);
	            }
	        }

	        return formatMoney(Client.get('currency'), sum, 1);
	    };

	    return {
	        getBalance: getBalance,
	        getPortfolioData: getPortfolioData,
	        getProposalOpenContract: getProposalOpenContract,
	        getIndicativeSum: function getIndicativeSum(values) {
	            return getSum(values, 'indicative');
	        },
	        getSumPurchase: function getSumPurchase(values) {
	            return getSum(values, 'buy_price');
	        }
	    };
	}();

	module.exports = {
	    Portfolio: Portfolio
	};

/***/ },
/* 513 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var localize = __webpack_require__(428).localize;

	var buildOauthApps = function buildOauthApps(response) {
	    if (!response || !response.oauth_apps) return {};
	    var obj_oauth_apps = {};
	    response.oauth_apps.forEach(function (app) {
	        obj_oauth_apps[app.app_id] = app.name;
	    });
	    obj_oauth_apps[2] = 'Binary.com Autoexpiry';
	    return obj_oauth_apps;
	};

	var addTooltip = function addTooltip(oauth_apps) {
	    Object.keys(oauth_apps).forEach(function (key) {
	        $('.' + key).attr('data-balloon', addAppIdName(key, oauth_apps[key]));
	    });
	};

	var addAppIdName = function addAppIdName(app_id, app_name) {
	    return app_id ? localize('Transaction performed by [_1] (App ID: [_2])', [app_name || '', app_id]) : '';
	};

	var showTooltip = function showTooltip(app_id, oauth_app_id) {
	    return app_id ? ' class="' + app_id + '" data-balloon="' + addAppIdName(app_id, oauth_app_id) + '"' : '';
	};

	module.exports = {
	    buildOauthApps: buildOauthApps,
	    addTooltip: addTooltip,
	    showTooltip: showTooltip
	};

/***/ },
/* 514 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var AssetIndex = __webpack_require__(515);
	var BinarySocket = __webpack_require__(427);
	var BinaryPjax = __webpack_require__(467);
	var State = __webpack_require__(421).State;
	var showLoadingImage = __webpack_require__(417).showLoadingImage;
	var Table = __webpack_require__(516);
	var jqueryuiTabsToDropdown = __webpack_require__(430).jqueryuiTabsToDropdown;
	var jpClient = __webpack_require__(425).jpClient;

	var AssetIndexUI = function () {
	    'use strict';

	    var $container = void 0,
	        $tabs = void 0,
	        $contents = void 0,
	        active_symbols = void 0,
	        asset_index = void 0,
	        market_columns = void 0,
	        is_framed = void 0;

	    var onLoad = function onLoad(config) {
	        if (jpClient()) {
	            if (!State.get('is_beta_trading')) {
	                BinaryPjax.load('resources');
	            }
	            return;
	        }

	        $container = $('#asset-index');
	        asset_index = market_columns = undefined;
	        if (!State.get('is_beta_trading')) active_symbols = undefined;

	        if ($container.contents().length) return;

	        showLoadingImage($container);

	        is_framed = config && config.framed;
	        if (!asset_index) {
	            sendRequest();
	        }
	        $container.tabs();
	    };

	    var populateTable = function populateTable() {
	        if (!active_symbols || !asset_index) return;

	        $('#errorMsg').setVisibility(0);
	        asset_index = AssetIndex.getAssetIndexData(asset_index, active_symbols);
	        market_columns = AssetIndex.getMarketColumns();
	        $tabs = $('<ul/>');
	        $contents = $('<div/>');

	        for (var i = 0; i < asset_index.length; i++) {
	            var asset_item = asset_index[i];
	            var symbol_info = asset_item[3];
	            if (symbol_info) {
	                var $submarket_table = getSubmarketTable(asset_item, symbol_info);
	                $submarket_table.find('tbody').append(createSubmarketTableRow(asset_item, symbol_info));
	            }
	        }

	        $container.empty().append($tabs).append($contents.children());

	        $container.tabs('destroy').tabs();

	        if (is_framed) {
	            $container.find('ul').hide();
	            $('<div/>', { class: 'center-text' }).append(jqueryuiTabsToDropdown($container)).prependTo($container);
	        }
	    };

	    var getSubmarketTable = function getSubmarketTable(asset_item, symbol_info) {
	        var market_id = 'market-' + symbol_info.market;
	        var submarket_id = 'submarket-' + symbol_info.submarket;

	        var $table = $contents.find('#' + submarket_id);
	        if ($table.length === 0) {
	            // Create the table for this submarket
	            var $market = $contents.find('#' + market_id);
	            if ($market.length === 0) {
	                // Create the market and tab elements
	                $market = $('<div/>', { id: market_id });
	                $tabs.append($('<li/>').append($('<a/>', { href: '#' + market_id, text: symbol_info.market_display_name, id: 'outline' })));
	            }
	            $table = createEmptyTable(asset_item, symbol_info, submarket_id);
	            $market.append($table);
	            $contents.append($market);
	        }

	        return $table;
	    };

	    var createSubmarketTableRow = function createSubmarketTableRow(asset_item, symbol_info) {
	        var cells = [symbol_info.display_name];
	        var columns = ['asset'];

	        var market_cols = market_columns[symbol_info.market];
	        var asset_cells = asset_item[4];
	        for (var i = 1; i < market_cols.columns.length; i++) {
	            var prop = market_cols.columns[i];
	            if (prop.length > 0) {
	                cells.push(prop in asset_cells ? asset_cells[prop] : '--');
	                columns.push(prop);
	            }
	        }

	        return Table.createFlexTableRow(cells, columns, 'data');
	    };

	    var createEmptyTable = function createEmptyTable(asset_item, symbol_info, submarket_id) {
	        var market = symbol_info.market;

	        var metadata = {
	            id: submarket_id,
	            cols: market_columns[market].columns
	        };

	        var $submarket_table = Table.createFlexTable([], metadata, market_columns[market].header);

	        var $submarket_header = $('<tr/>', { class: 'flex-tr' }).append($('<th/>', { class: 'flex-tr-child submarket-name', colspan: market_columns[market].columns.length, text: symbol_info.submarket_display_name }));
	        $submarket_table.find('thead').prepend($submarket_header);

	        return $submarket_table;
	    };

	    var sendRequest = function sendRequest() {
	        if (!active_symbols) {
	            BinarySocket.send({ active_symbols: 'brief' }).then(function (response) {
	                AssetIndexUI.setActiveSymbols(response);
	            });
	        }
	        BinarySocket.send({ asset_index: 1 }).then(function (response) {
	            asset_index = response.asset_index;
	            if (active_symbols) populateTable();
	        });
	    };

	    return {
	        onLoad: onLoad,
	        setActiveSymbols: function setActiveSymbols(response) {
	            active_symbols = response.active_symbols.slice(0); // clone
	            if (asset_index) populateTable();
	        }
	    };
	}();

	module.exports = AssetIndexUI;

/***/ },
/* 515 */
/***/ function(module, exports) {

	'use strict';

	var AssetIndex = function () {
	    'use strict';

	    var market_columns = void 0;

	    // Search and Remove (to decrease the next search count)
	    var getSymbolInfo = function getSymbolInfo(q_symbol, active_symbols) {
	        return active_symbols.filter(function (sy, id) {
	            if (sy.symbol === q_symbol) {
	                active_symbols.splice(id, 1);
	                return true;
	            }
	            return false;
	        });
	    };

	    /*
	     * This method generates headers for all tables of each market
	     * should include headers existed in all assets of each market and its submarkets
	     */
	    var getAssetIndexData = function getAssetIndexData(asset_index, active_symbols) {
	        if (!asset_index || !active_symbols) return null;

	        market_columns = {};

	        // index of items in asset_index response
	        var idx = {
	            symbol: 0,
	            display_name: 1,
	            cells: 2,
	            sym_info: 3,
	            values: 4,
	            cell_props: {
	                cell_name: 0,
	                cell_display_name: 1,
	                cell_from: 2,
	                cell_to: 3
	            }
	        };

	        for (var i = 0; i < asset_index.length; i++) {
	            var asset_item = asset_index[i];
	            var symbol_info = getSymbolInfo(asset_item[idx.symbol], active_symbols)[0];
	            if (symbol_info) {
	                var market = symbol_info.market;

	                asset_item.push(symbol_info);

	                // Generate market columns to use in all this market's submarket tables
	                if (!(market in market_columns)) {
	                    market_columns[market] = {
	                        header: [''],
	                        columns: ['']
	                    };
	                }

	                var asset_cells = asset_item[idx.cells];
	                var values = {};
	                for (var j = 0; j < asset_cells.length; j++) {
	                    var col = asset_cells[j][idx.cell_props.cell_name];

	                    values[col] = [asset_cells[j][idx.cell_props.cell_from], asset_cells[j][idx.cell_props.cell_to]].join(' - ');

	                    var market_cols = market_columns[market];
	                    if (market_cols.columns.indexOf(col) === -1) {
	                        market_cols.header.push(asset_cells[j][idx.cell_props.cell_display_name]);
	                        market_cols.columns.push(col);
	                    }
	                }
	                asset_item.push(values);
	            }
	        }
	        return asset_index;
	    };

	    return {
	        getAssetIndexData: getAssetIndexData,
	        getMarketColumns: function getMarketColumns() {
	            return market_columns;
	        }
	    };
	}();

	module.exports = AssetIndex;

/***/ },
/* 516 */
/***/ function(module, exports) {

	'use strict';

	var Table = function () {
	    'use strict';

	    /**
	     *
	     * @param {Array[]} body ordered data to pump into table body
	     * @param {Object} metadata object containing metadata of table
	     * @param {String[]} metadata.cols cols of table
	     * @param {String} metadata.id table id
	     * @param {String[]} [metadata.tableClass] class used in html
	     * @param {String[]} [header] string to be used as Header in table, if not stated then table will not have Header
	     * @param {String[]} [footer] string to be used as footer, to have empty footer, use an empty element in array
	     * eg. ["", "halo", ""] will have 3 elements in footer, 2 of them being empty
	     */

	    var createFlexTable = function createFlexTable(body, metadata, header, footer) {
	        var $table_container = $('<div></div>', { class: 'table-container' });
	        var $table = $('<table></table>', { class: metadata.tableClass || '', id: metadata.id });
	        var $body = createFlexTableTopGroup(body, metadata.cols, 'body');

	        if (header) {
	            var $header = createFlexTableTopGroup([header], metadata.cols, 'header');
	            $header.appendTo($table);
	        }

	        $body.appendTo($table);

	        if (footer) {
	            var $footer = createFlexTableTopGroup([footer], metadata.cols, 'footer');
	            $footer.appendTo($table);
	        }

	        $table.appendTo($table_container);

	        return $table_container;
	    };

	    /**
	     *
	     * @param {object[][]} data header strings
	     * @param {String[]} metadata cols name
	     * @param {'header'|'footer'|'body'} opt optional arg, specifies type of element to create. default to header
	     */
	    var createFlexTableTopGroup = function createFlexTableTopGroup(data, metadata, opt) {
	        var $outer = function () {
	            switch (opt) {
	                case 'body':
	                    return $('<tbody></tbody>');
	                case 'footer':
	                    return $('<tfoot></tfoot>');
	                default:
	                    return $('<thead></thead>');
	            }
	        }();

	        for (var i = 0; i < data.length; i++) {
	            var inner_type = opt === 'body' ? 'data' : 'header';
	            var $tr = createFlexTableRow(data[i], metadata, inner_type);
	            $tr.appendTo($outer);
	        }

	        return $outer;
	    };

	    /**
	     *
	     * @param {object[]} data
	     * @param {String[]} metadata cols name
	     * @param {'header'|'data'} opt optional, default to "header"
	     */
	    var createFlexTableRow = function createFlexTableRow(data, metadata, opt) {
	        if (data.length !== metadata.length) {
	            throw new Error('metadata and data does not match');
	        }

	        var is_data = opt === 'data';

	        var $tr = $('<tr></tr>');
	        for (var i = 0; i < data.length; i++) {
	            var class_name = metadata[i].toLowerCase().replace(/\s/g, '-');
	            var row_element = is_data ? $('<td></td>', { class: class_name, html: data[i] }) : $('<th></th>', { class: class_name, html: data[i] });
	            row_element.appendTo($tr);
	        }

	        return $tr;
	    };

	    var clearTableBody = function clearTableBody(id) {
	        var tbody = document.querySelector('#' + id + ' > tbody');
	        while (tbody && tbody.firstElementChild) {
	            tbody.removeChild(tbody.firstElementChild);
	        }
	    };

	    /**
	     *
	     * @param {String} id table id
	     * @param {Object[]} data array of data to be transform to row
	     * @param {Function} rowGenerator takes in one arg, and convert it into row to be append to table body
	     */
	    var appendTableBody = function appendTableBody(id, data, rowGenerator) {
	        var tbody = document.querySelector('#' + id + ' > tbody');
	        if (!tbody) return;
	        var doc_frag = document.createDocumentFragment();
	        data.map(function (ele) {
	            var row = rowGenerator(ele);
	            doc_frag.appendChild(row);
	        });

	        tbody.appendChild(doc_frag);
	    };

	    return {
	        createFlexTable: createFlexTable,
	        createFlexTableRow: createFlexTableRow,
	        clearTableBody: clearTableBody,
	        appendTableBody: appendTableBody
	    };
	}();

	module.exports = Table;

/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var TradingTimes = __webpack_require__(518);
	var BinarySocket = __webpack_require__(427);
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var showLoadingImage = __webpack_require__(417).showLoadingImage;
	var Table = __webpack_require__(516);
	var dateValueChanged = __webpack_require__(430).dateValueChanged;
	var jqueryuiTabsToDropdown = __webpack_require__(430).jqueryuiTabsToDropdown;
	var jpClient = __webpack_require__(425).jpClient;
	var toISOFormat = __webpack_require__(449).toISOFormat;
	var toReadableFormat = __webpack_require__(449).toReadableFormat;
	var DatePicker = __webpack_require__(519);

	var TradingTimesUI = function () {
	    'use strict';

	    var $date = void 0,
	        $container = void 0,
	        columns = void 0,
	        active_symbols = void 0,
	        trading_times = void 0,
	        is_framed = void 0;

	    var onLoad = function onLoad(config) {
	        $date = $('#trading-date');
	        $container = $('#trading-times');
	        columns = ['Asset', 'Opens', 'Closes', 'Settles', 'UpcomingEvents'];
	        if (!State.get('is_beta_trading')) active_symbols = trading_times = undefined;

	        if ($container.contents().length) return;

	        showLoadingImage($container);

	        is_framed = config && config.framed;
	        if (!trading_times) {
	            sendRequest('today', !(active_symbols && active_symbols.length));
	        }

	        var date = moment.utc();
	        $date.val(toReadableFormat(date)).attr('data-value', toISOFormat(date));
	        DatePicker.init({
	            selector: '#trading-date',
	            minDate: 0,
	            maxDate: 364
	        });
	        $date.change(function () {
	            if (!dateValueChanged(this, 'date')) {
	                return false;
	            }
	            $container.empty();
	            showLoadingImage($container);
	            trading_times = null;
	            sendRequest($date.attr('data-value'), !active_symbols);
	            return true;
	        });

	        $container.tabs();
	    };

	    var populateTable = function populateTable() {
	        if (!active_symbols || !trading_times) return;

	        $('#errorMsg').setVisibility(0);

	        var is_japan_trading = jpClient();

	        var markets = trading_times.markets;

	        var $ul = $('<ul/>', { class: is_japan_trading ? 'invisible' : '' });
	        var $contents = $('<div/>');

	        for (var m = 0; m < markets.length; m++) {
	            var tab_id = 'market_' + (m + 1);

	            // contents
	            var $market = $('<div/>', { id: tab_id });
	            $market.append(createMarketTables(markets[m], is_japan_trading));
	            if ($market.find('table tr').length) {
	                $contents.append($market);

	                // tabs
	                if (!is_japan_trading) {
	                    $ul.append($('<li/>').append($('<a/>', { href: '#' + tab_id, text: markets[m].name, id: 'outline' })));
	                }
	            }
	        }

	        $container.empty().append($ul).append($contents.children());

	        $container.tabs('destroy').tabs();

	        if (is_framed) {
	            $container.find('ul').hide();
	            $('<div/>', { class: 'center-text' }).append(jqueryuiTabsToDropdown($container)).prependTo($container);
	        }
	    };

	    var createMarketTables = function createMarketTables(market, is_japan_trading) {
	        var $market_tables = $('<div/>');

	        // submarkets of this market
	        var submarkets = market.submarkets;
	        var should_populate = void 0;
	        for (var s = 0; s < submarkets.length; s++) {
	            should_populate = true;
	            // display only "Major Pairs" for Japan
	            if (is_japan_trading) {
	                var submarket_info = TradingTimes.getSubmarketInfo(active_symbols, submarkets[s].name);
	                if (submarket_info.length === 0 || submarket_info[0].submarket !== 'major_pairs') {
	                    should_populate = false;
	                }
	            }

	            if (should_populate) {
	                // submarket table
	                var $submarket_table = createEmptyTable(market.name + '-' + s);

	                // submarket name
	                $submarket_table.find('thead').prepend(createSubmarketHeader(submarkets[s].name)).find('th.opens, th.closes').addClass('nowrap');

	                // symbols of this submarket
	                var symbols = submarkets[s].symbols;
	                for (var sy = 0; sy < symbols.length; sy++) {
	                    if (Object.keys(TradingTimes.getSymbolInfo(symbols[sy].symbol, active_symbols)).length !== 0) {
	                        $submarket_table.find('tbody').append(createSubmarketTableRow(market.name, submarkets[s].name, symbols[sy]));
	                    }
	                }

	                if ($submarket_table.find('tbody tr').length) {
	                    $market_tables.append($submarket_table);
	                }
	            }
	        }

	        return $market_tables;
	    };

	    var createSubmarketHeader = function createSubmarketHeader(submarket_name) {
	        return $('<tr/>', { class: 'flex-tr' }).append($('<th/>', { class: 'flex-tr-child submarket-name', colspan: columns.length, text: submarket_name }));
	    };

	    var createSubmarketTableRow = function createSubmarketTableRow(market_name, submarket_name, symbol) {
	        var $table_row = Table.createFlexTableRow([symbol.name, '', // Opens
	        '', // Closes
	        symbol.times.settlement, ''], columns, 'data');
	        $table_row.children('.opens').html(symbol.times.open.join('<br />'));
	        $table_row.children('.closes').html(symbol.times.close.join('<br />'));
	        $table_row.children('.upcomingevents').html(createEventsText(symbol.events));

	        return $table_row;
	    };

	    var createEventsText = function createEventsText(events) {
	        var result = '';
	        for (var i = 0; i < events.length; i++) {
	            result += '' + (i > 0 ? '<br />' : '') + localize(events[i].descrip) + ': ' + localize(events[i].dates);
	        }
	        return result.length > 0 ? result : '--';
	    };

	    var createEmptyTable = function createEmptyTable(table_id) {
	        var header = [localize('Asset'), localize('Opens'), localize('Closes'), localize('Settles'), localize('Upcoming Events')];

	        var metadata = {
	            id: table_id,
	            cols: columns
	        };

	        return Table.createFlexTable([], metadata, header);
	    };

	    var sendRequest = function sendRequest(date, should_request_active_symbols) {
	        var req = { active_symbols: 'brief' };
	        if (jpClient()) {
	            req.landing_company = 'japan';
	        }
	        if (should_request_active_symbols) {
	            BinarySocket.send(req, { msg_type: 'active_symbols' }).then(function (response) {
	                TradingTimesUI.setActiveSymbols(response);
	            });
	        }
	        BinarySocket.send({ trading_times: date || 'today' }).then(function (response) {
	            trading_times = response.trading_times;
	            if (active_symbols) populateTable();
	        });
	    };

	    return {
	        onLoad: onLoad,
	        setActiveSymbols: function setActiveSymbols(response) {
	            active_symbols = response.active_symbols.slice(0); // clone
	            if (trading_times) populateTable();
	        }
	    };
	}();

	module.exports = TradingTimesUI;

/***/ },
/* 518 */
/***/ function(module, exports) {

	'use strict';

	var TradingTimes = function () {
	    'use strict';

	    var getSubmarketInfo = function getSubmarketInfo(active_symbols, submarket_display_name) {
	        return active_symbols.filter(function (sy) {
	            return sy.submarket_display_name === submarket_display_name;
	        });
	    };

	    var getSymbolInfo = function getSymbolInfo(q_symbol, active_symbols) {
	        return active_symbols.filter(function (sy) {
	            return sy.symbol === q_symbol;
	        });
	    };

	    return {
	        getSubmarketInfo: getSubmarketInfo,
	        getSymbolInfo: getSymbolInfo
	    };
	}();

	module.exports = TradingTimes;

/***/ },
/* 519 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var localize = __webpack_require__(428).localize;
	var isEmptyObject = __webpack_require__(417).isEmptyObject;
	var clearable = __webpack_require__(417).clearable;
	var checkInput = __webpack_require__(430).checkInput;
	var toReadableFormat = __webpack_require__(449).toReadableFormat;
	var padLeft = __webpack_require__(449).padLeft;

	var DatePicker = function () {
	    'use strict';

	    var date_pickers = {};
	    var localizations = {};

	    var init = function init(options) {
	        hide(options.selector);
	        date_pickers[options.selector] = {};

	        if (isEmptyObject(localizations)) {
	            localizations = {
	                monthNames: localize(['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']),
	                monthNamesShort: localize(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']),
	                dayNames: localize(['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']),
	                dayNamesMin: localize(['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']),
	                nextText: localize('Next'),
	                prevText: localize('Previous')
	            };
	        }

	        config(options);
	        $(window).resize(function () {
	            checkWidth(options.selector);
	        });
	    };

	    var hide = function hide(selector) {
	        $(selector).datepicker('destroy').removeAttr('data-picker').off('keydown');
	    };

	    var create = function create(selector) {
	        var $this = void 0;
	        var date_picker = date_pickers[selector];
	        $(selector).keydown(function (e) {
	            if (e.which === 13) {
	                $this = $(this);
	                e.preventDefault();
	                e.stopPropagation();
	                if (date_picker.config_data.type === 'date') {
	                    $this.datepicker('setDate', $this.val());
	                }
	                $this.datepicker('hide');
	                $this.blur();
	                return false;
	            }
	            return true;
	        }).datepicker(date_picker.config_data);

	        // Not possible to tell datepicker where to put it's
	        // trigger calendar icon on the page, so we remove it
	        // from the DOM and use our own one.
	        $('button.ui-datepicker-trigger').remove();
	    };

	    var config = function config(options) {
	        var selector = options.selector;

	        var obj_config = {
	            dateFormat: 'dd M, yy',
	            changeMonth: true,
	            changeYear: true,
	            native: true, // custom variable to handle showing of native datepicker for field; true by default
	            type: 'date' };

	        Object.keys(localizations).forEach(function (localization) {
	            obj_config[localization] = localizations[localization];
	        });

	        $.extend(obj_config, options);

	        var setDate = function setDate(date) {
	            obj_config[date] = typeof options[date] === 'number' ? moment().add(Number(options[date]), 'day').toDate() : options[date];
	        };

	        if (options.minDate !== undefined) {
	            setDate('minDate');
	        }

	        if (options.maxDate !== undefined) {
	            setDate('maxDate');
	        }

	        var $this = void 0;
	        obj_config.onSelect = function (date_text) {
	            var year = $('.ui-datepicker-year').val();
	            var month = formatDate(Number($('.ui-datepicker-month').val()), 1);
	            var day = date_text.split(' ')[0];
	            var date = [year, month, day].join('-');
	            $this = $(this);
	            var old_value = $this.attr('data-value');
	            var this_selector = '#' + $this.attr('id');

	            $this.attr('data-value', date);

	            var duration = date_pickers[selector].config_data.type === 'diff' ? moment.utc(date + ' 23:59:59').diff(moment.utc(), 'days') : null;
	            $this.val(duration || date_text);
	            if (old_value === date) return false;
	            $(this_selector).trigger('change', [duration || date_text]);

	            if ($this.hasClass('clearable')) {
	                clearable($this);
	            }

	            return true;
	        };

	        date_pickers[selector].config_data = $.extend({}, obj_config);

	        checkWidth(selector);
	    };

	    var formatDate = function formatDate(date, add) {
	        return padLeft(date + (add || 0), 2, '0');
	    };

	    var toDate = function toDate(date) {
	        return [date.getFullYear(), formatDate(date.getMonth(), 1), formatDate(date.getDate())].join('-');
	    };

	    var checkWidth = function checkWidth(selector) {
	        var $selector = $(selector);
	        var date_picker_conf = date_pickers[selector].config_data;
	        if ($(window).width() < 770) {
	            if (!date_picker_conf.native) {
	                hide(selector);
	                $selector.attr('type', 'number');
	                return;
	            }
	            if (checkInput('date', 'not-a-date') && $selector.attr('data-picker') !== 'native') {
	                hide(selector);
	                $selector.attr({ type: 'date', 'data-picker': 'native' }).val($selector.attr('data-value'));
	                if ($selector.attr('readonly')) $selector.attr('data-readonly', 'readonly').removeAttr('readonly');
	                if (date_picker_conf.minDate !== undefined) $selector.attr('min', toDate(date_picker_conf.minDate));
	                if (date_picker_conf.maxDate !== undefined) $selector.attr('max', toDate(date_picker_conf.maxDate));
	                return;
	            }
	        }
	        if ($(window).width() > 769 && $selector.attr('data-picker') !== 'jquery' || $(window).width() < 770 && !checkInput('date', 'not-a-date')) {
	            var value = $selector.attr('data-value') || $selector.val();
	            var format_value = value && date_picker_conf.type !== 'diff' ? toReadableFormat(moment(value)) : $selector.val();
	            $selector.attr({ type: 'text', 'data-picker': 'jquery', 'data-value': value }).removeAttr('min max').val(format_value);
	            if ($selector.attr('data-readonly')) $selector.attr('readonly', 'readonly').removeAttr('data-readonly');
	            create(selector);
	        }
	    };

	    return {
	        init: init,
	        hide: hide
	    };
	}();

	module.exports = DatePicker;

/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var TradingAnalysis_Beta = __webpack_require__(521);
	var TradingEvents_Beta = __webpack_require__(522);
	var Price_Beta = __webpack_require__(524);
	var Process_Beta = __webpack_require__(525);
	var commonTrading = __webpack_require__(445);
	var chartFrameCleanup = __webpack_require__(509).chartFrameCleanup;
	var displayCurrencies = __webpack_require__(529);
	var Defaults = __webpack_require__(437);
	var BinarySocket = __webpack_require__(427);
	var PortfolioInit = __webpack_require__(511);
	var ViewPopup = __webpack_require__(435);
	var BinaryPjax = __webpack_require__(467);
	var State = __webpack_require__(421).State;
	var jpClient = __webpack_require__(425).jpClient;
	var Guide = __webpack_require__(530);
	var ResizeSensor = __webpack_require__(535);

	var TradePage_Beta = function () {
	    'use strict';

	    var events_initialized = 0;
	    State.remove('is_beta_trading');

	    var onLoad = function onLoad() {
	        var is_jp_client = jpClient();
	        if (is_jp_client) {
	            BinaryPjax.load('multi_barriers_trading');
	            return;
	        }
	        State.set('is_beta_trading', true);
	        Price_Beta.clearFormId();
	        if (events_initialized === 0) {
	            events_initialized = 1;
	            TradingEvents_Beta.init();
	        }

	        BinarySocket.send({ payout_currencies: 1 }).then(function () {
	            displayCurrencies();
	            Process_Beta.processActiveSymbols_Beta();
	        });

	        if (document.getElementById('websocket_form')) {
	            commonTrading.addEventListenerForm();
	            if (!is_jp_client) {
	                new ResizeSensor($('.col-left .content-tab-container, #contract_prices_container'), adjustAnalysisColumnHeight);
	                new ResizeSensor($('.col-right'), moreTabsHandler);
	            }
	        }

	        // Walktrough Guide
	        Guide.init({
	            script: 'trading'
	        });
	        TradingAnalysis_Beta.bindAnalysisTabEvent();

	        ViewPopup.viewButtonOnClick('#contract_confirmation_container');
	    };

	    var adjustAnalysisColumnHeight = function adjustAnalysisColumnHeight() {
	        var sum_height = 0;
	        if (window.innerWidth > 767) {
	            $('.col-left').children().each(function () {
	                if ($(this).is(':visible')) sum_height += $(this).outerHeight(true);
	            });
	        } else {
	            sum_height = 'auto';
	        }
	        $('#trading_analysis_content').height(sum_height);
	    };

	    var moreTabsHandler = function moreTabsHandler($ul) {
	        if (!$ul) $ul = $('#analysis_tabs');
	        var see_more_class = 'see-more';
	        var more_tabs_class = 'more-tabs';
	        var max_width = $ul.outerWidth();
	        var total_width = 0;

	        // add seeMore tab
	        var $see_more = $ul.find('li.' + see_more_class);
	        if ($see_more.length === 0) {
	            $see_more = $('<li/>', { class: 'tm-li ' + see_more_class }).append($('<a/>', { class: 'tm-a', href: 'java' + 'script:;' }).append($('<span/>', { class: 'caret-down' })));
	            $ul.append($see_more);
	        }
	        $see_more.removeClass('active');

	        // add moreTabs container
	        var $more_tabs = $ul.find('.' + more_tabs_class);
	        if ($more_tabs.length === 0) {
	            $more_tabs = $('<div/>', { class: more_tabs_class }).appendTo($see_more);
	        } else {
	            $more_tabs.find('>li').each(function (index, tab) {
	                $(tab).insertBefore($see_more);
	            });
	        }
	        $more_tabs.css('top', $ul.find('li:visible').outerHeight() - 1).unbind('click').click(function () {
	            hideDropDown('fast');
	        });

	        // move additional tabs to moreTabs
	        var $visible_tabs = $ul.find('>li:visible');
	        $visible_tabs.each(function (index, tab) {
	            total_width += $(tab).outerWidth(true);
	        });
	        var result_width = total_width;
	        while (result_width >= max_width) {
	            var $thisTab = $ul.find('>li:not(.' + see_more_class + '):visible').last();
	            result_width -= $thisTab.outerWidth(true);
	            $thisTab.prependTo($more_tabs);
	        }

	        if ($more_tabs.children().length === 0) {
	            $see_more.hide();
	            return;
	        }

	        $see_more.show();
	        if ($more_tabs.find('>li.active').length > 0) {
	            $see_more.addClass('active');
	        }

	        // drop down behaviour
	        var showDropDown = function showDropDown() {
	            $more_tabs.slideDown();
	            if ($see_more.find('.over').length === 0) {
	                $('<div/>', { class: 'over' }).insertBefore($see_more.find('>a'));
	                $see_more.find('.over').width($see_more.width());
	            }
	            $see_more.addClass('open');
	        };
	        var hideDropDown = function hideDropDown(duration) {
	            $more_tabs.slideUp(duration || 400, function () {
	                $see_more.removeClass('open');
	            });
	        };
	        var timeout = void 0;
	        $see_more.find('> a').unbind('click').on('click', function (e) {
	            e.stopPropagation();
	            if ($more_tabs.is(':visible')) {
	                hideDropDown();
	                clearTimeout(timeout);
	            } else {
	                clearTimeout(timeout);
	                showDropDown();
	                timeout = setTimeout(function () {
	                    hideDropDown();
	                    clearTimeout(timeout);
	                }, 3000);
	            }
	        });
	        $(document).unbind('click').on('click', function () {
	            hideDropDown();
	        });

	        $more_tabs.mouseenter(function () {
	            clearTimeout(timeout);
	        });

	        $more_tabs.mouseleave(function () {
	            clearTimeout(timeout);
	            timeout = setTimeout(function () {
	                hideDropDown();
	            }, 1000);
	        });
	    };

	    var reload = function reload() {
	        sessionStorage.removeItem('underlying');
	        window.location.reload();
	    };

	    var onUnload = function onUnload() {
	        State.remove('is_beta_trading');
	        events_initialized = 0;
	        Process_Beta.forgetTradingStreams_Beta();
	        BinarySocket.clear();
	        Defaults.clear();
	        PortfolioInit.onUnload();
	        chartFrameCleanup();
	        commonTrading.clean();
	        BinarySocket.clear('active_symbols');
	    };

	    var onDisconnect = function onDisconnect() {
	        commonTrading.showPriceOverlay();
	        commonTrading.showFormOverlay();
	        chartFrameCleanup();
	        onLoad();
	    };

	    return {
	        onLoad: onLoad,
	        reload: reload,
	        onUnload: onUnload,
	        onDisconnect: onDisconnect
	    };
	}();

	module.exports = TradePage_Beta;

/***/ },
/* 521 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Defaults = __webpack_require__(437);
	var showHighchart = __webpack_require__(509).showHighchart;
	var getActiveTab = __webpack_require__(458).getActiveTab_Beta;
	var GetTicks = __webpack_require__(441);
	var MBDefaults = __webpack_require__(416);
	var AssetIndexUI = __webpack_require__(514);
	var TradingTimesUI = __webpack_require__(517);
	var PortfolioInit = __webpack_require__(511);
	var Client = __webpack_require__(420);
	var getLanguage = __webpack_require__(424).get;
	var State = __webpack_require__(421).State;
	var Url = __webpack_require__(423);

	/*
	 * This file contains the code related to loading of trading page bottom analysis
	 * content. It will contain jquery so as to compatible with old code and less rewrite
	 *
	 * Please note that this will be removed in near future
	 */

	/*
	 * This function is called whenever we change market, form
	 * or underlying to load bet analysis for that particular event
	 */

	var TradingAnalysis_Beta = function () {
	    'use strict';

	    var hidden_class = 'invisible';
	    var form_name = void 0;

	    var requestTradeAnalysis = function requestTradeAnalysis() {
	        form_name = ((State.get('is_mb_trading') ? MBDefaults.get('category') : Defaults.get('formname')) || 'risefall').replace('matchdiff', 'digits');

	        $('#tab_last_digit').setVisibility(/(digits|overunder|evenodd)/.test(form_name));
	        sessionStorage.setItem('currentAnalysisTab_Beta', getActiveTab());
	        loadAnalysisTab();
	    };

	    /*
	     * This function bind event to link elements of bottom content
	     * navigation
	     */
	    var bindAnalysisTabEvent = function bindAnalysisTabEvent() {
	        if (Client.isLoggedIn()) {
	            $('#tab_portfolio').setVisibility(1);
	        }
	        $('#tab_asset_index').setVisibility(1);
	        $('#tab_trading_times').setVisibility(1);

	        $('#analysis_tabs').find('li a').on('click', function (e) {
	            e.preventDefault();
	            var li = e.target.parentElement;
	            sessionStorage.setItem('currentAnalysisTab_Beta', li.id);
	            if (!li.classList.contains('active')) {
	                loadAnalysisTab(li.id);
	            }
	        });
	    };

	    /*
	     * This function handles all the functionality on how to load
	     * tab according to current paramerted
	     */
	    var loadAnalysisTab = function loadAnalysisTab(tab) {
	        var current_tab = tab || getActiveTab();

	        $('#analysis_tabs').find('li').removeClass('active');
	        $('#' + current_tab).addClass('active');
	        toggleActiveAnalysisTabs();

	        switch (current_tab) {
	            case 'tab_graph':
	                showHighchart();
	                break;
	            case 'tab_portfolio':
	                PortfolioInit.onLoad();
	                break;
	            case 'tab_last_digit':
	                {
	                    var underlying = $('#digit_underlying option:selected').val() || $('#underlying').find('option:selected').val();
	                    var tick = $('#tick_count').val() || 100;
	                    GetTicks.request('', {
	                        ticks_history: underlying,
	                        end: 'latest',
	                        count: tick.toString()
	                    });
	                    break;
	                }
	            case 'tab_asset_index':
	                AssetIndexUI.onLoad({ framed: true });
	                $('#tab_asset').find('index-content').find('h1').hide();
	                break;
	            case 'tab_trading_times':
	                TradingTimesUI.onLoad({ framed: true });
	                $('#tab_trading').find('times-content').find('h1').hide();
	                break;
	            default:
	                {
	                    showExplanation();
	                    break;
	                }
	        }
	    };

	    /*
	     * function to toggle the active element for analysis menu
	     */
	    var toggleActiveAnalysisTabs = function toggleActiveAnalysisTabs() {
	        var current_tab = getActiveTab();
	        var analysis_container = document.getElementById('analysis_content');

	        if (analysis_container) {
	            var child_elements = analysis_container.children;
	            var current_tab_element = document.getElementById(current_tab + '-content');
	            var classes = current_tab_element.classList;

	            for (var i = 0, len = child_elements.length; i < len; i++) {
	                child_elements[i].classList.remove('selectedTab');
	                child_elements[i].classList.add(hidden_class);
	            }

	            classes.add('selectedTab');
	            classes.remove(hidden_class);
	        }
	    };

	    /*
	     * handle the display of proper explanation based on parameters
	     */
	    var showExplanation = function showExplanation() {
	        var $container = $('#tab_explanation-content');

	        $container.find('#explanation_winning > div, #explanation_explain > div, #explanation_image').setVisibility(0);
	        $container.find('#explanation_winning, #winning_' + form_name + ', #explanation_explain, #explain_' + form_name).setVisibility(1);

	        var images = {
	            risefall: {
	                image1: 'rise-fall-1.svg',
	                image2: 'rise-fall-2.svg'
	            },
	            higherlower: {
	                image1: 'higher-lower-1.svg',
	                image2: 'higher-lower-2.svg'
	            },
	            touchnotouch: {
	                image1: 'touch-notouch-1.svg',
	                image2: 'touch-notouch-2.svg'
	            },
	            endsinout: {
	                image1: 'in-out-1.svg',
	                image2: 'in-out-2.svg'
	            },
	            staysinout: {
	                image1: 'in-out-3.svg',
	                image2: 'in-out-4.svg'
	            },
	            updown: {
	                image1: 'up-down-1.svg',
	                image2: 'up-down-2.svg'
	            },
	            evenodd: {
	                image1: 'evenodd-1.svg',
	                image2: 'evenodd-2.svg'
	            },
	            overunder: {
	                image1: 'overunder-1.svg',
	                image2: 'overunder-2.svg'
	            }
	        };

	        if (images[form_name]) {
	            var language = getLanguage().toLowerCase();
	            var image_path = Url.urlForStatic('images/pages/trade-explanation/' + (language === 'ja' ? language + '/' : ''));
	            $container.find('#explanation_image_1').attr('src', image_path + images[form_name].image1);
	            $container.find('#explanation_image_2').attr('src', image_path + images[form_name].image2);
	            $container.find('#explanation_image').setVisibility(1);
	        }
	    };

	    return {
	        request: requestTradeAnalysis,
	        getActiveTab: getActiveTab,
	        bindAnalysisTabEvent: bindAnalysisTabEvent
	    };
	}();

	module.exports = TradingAnalysis_Beta;

/***/ },
/* 522 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var TradingAnalysis_Beta = __webpack_require__(521);
	var Barriers_Beta = __webpack_require__(450);
	var Durations_Beta = __webpack_require__(523);
	var Price_Beta = __webpack_require__(524);
	var Process_Beta = __webpack_require__(525);
	var Purchase_Beta = __webpack_require__(455);
	var chartFrameSource = __webpack_require__(509).chartFrameSource;
	var Defaults = __webpack_require__(437);
	var GetTicks = __webpack_require__(441);
	var Tick = __webpack_require__(448);
	var commonTrading = __webpack_require__(445);
	var getStartDateNode = __webpack_require__(443).getStartDateNode;
	var Notifications = __webpack_require__(446);
	var BinarySocket = __webpack_require__(427);
	var BinaryPjax = __webpack_require__(467);
	var GTM = __webpack_require__(464);
	var dateValueChanged = __webpack_require__(430).dateValueChanged;
	var isVisible = __webpack_require__(430).isVisible;
	var formatMoney = __webpack_require__(433).formatMoney;
	var onlyNumericOnKeypress = __webpack_require__(527);
	var TimePicker = __webpack_require__(528);

	/*
	 * TradingEvents object contains all the event handler function for
	 * websocket trading page
	 *
	 * We need it as object so that we can call TradingEvent.init() only on trading
	 * page for pjax to work else it will fire on all pages
	 *
	 */
	var TradingEvents_Beta = function () {
	    'use strict';

	    var initiate = function initiate() {
	        /*
	         * attach event to market list, so when client change market we need to update undelryings
	         * and request for new Contract details to populate the form and request price accordingly
	         */
	        var onMarketChange = function onMarketChange(market) {
	            commonTrading.showPriceOverlay();
	            Defaults.set('market', market);

	            // as different markets have different forms so remove from sessionStorage
	            // it will default to proper one
	            Defaults.remove('formname');
	            Defaults.remove('underlying');
	            Process_Beta.processMarket_Beta();
	            chartFrameSource();
	        };

	        var market_nav_element = document.getElementById('contract_markets');
	        if (market_nav_element) {
	            market_nav_element.addEventListener('change', function (e) {
	                onMarketChange(e.target.value);
	            });
	        }

	        /*
	         * attach event to form list, so when client click on different form we need to update form
	         * and request for new Contract details to populate the form and request price accordingly
	         */
	        var contractFormEventChange = function contractFormEventChange() {
	            Process_Beta.processContractForm_Beta();
	            TradingAnalysis_Beta.request();
	        };

	        var form_nav_element = document.getElementById('contract_form_name_nav');
	        if (form_nav_element) {
	            form_nav_element.addEventListener('click', function (e) {
	                var clicked_form = e.target;
	                if (clicked_form && clicked_form.getAttribute('menuitem')) {
	                    var is_form_active = clicked_form.classList.contains('active') || clicked_form.parentElement.classList.contains('active');
	                    Defaults.set('formname', clicked_form.getAttribute('menuitem'));

	                    // if form is already active then no need to send same request again
	                    commonTrading.toggleActiveCatMenuElement(form_nav_element, e.target.getAttribute('menuitem'));

	                    if (!is_form_active) {
	                        contractFormEventChange();
	                    }
	                }
	            });
	        }

	        /*
	         * attach event to underlying change, event need to request new contract details and price
	         */
	        var underlying_element = document.getElementById('underlying');
	        if (underlying_element) {
	            underlying_element.addEventListener('change', function (e) {
	                if (e.target) {
	                    chartFrameSource();
	                    commonTrading.showFormOverlay();
	                    commonTrading.showPriceOverlay();
	                    if (e.target.selectedIndex < 0) {
	                        e.target.selectedIndex = 0;
	                    }
	                    var underlying = e.target.value;
	                    Defaults.remove('barrier', 'barrier_high', 'barrier_low');
	                    Defaults.set('underlying', underlying);
	                    TradingAnalysis_Beta.request();

	                    Tick.clean();

	                    commonTrading.updateWarmChart();

	                    BinarySocket.send({ contracts_for: underlying }).then(function (response) {
	                        Notifications.hide('CONNECTION_ERROR');
	                        Process_Beta.processContract_Beta(response);
	                    });

	                    // forget the old tick id i.e. close the old tick stream
	                    Process_Beta.processForgetTicks_Beta();
	                    // get ticks for current underlying
	                    GetTicks.request(underlying);
	                    commonTrading.displayTooltip_Beta(Defaults.get('market'), underlying);
	                }
	            });
	        }

	        /*
	         * bind event to change in duration amount, request new price
	         */
	        var triggerOnDurationChange = function triggerOnDurationChange(e) {
	            if (e.target.value % 1 !== 0) {
	                e.target.value = Math.floor(e.target.value);
	            }
	            Defaults.set('duration_amount', e.target.value);
	            Durations_Beta.selectAmount(e.target.value);
	            Price_Beta.processPriceRequest_Beta();
	            commonTrading.submitForm(document.getElementById('websocket_form'));
	        };
	        var duration_amount_element = document.getElementById('duration_amount');
	        var input_event_triggered = false; // For triggering one of the two events.
	        if (duration_amount_element) {
	            duration_amount_element.addEventListener('keypress', onlyNumericOnKeypress);
	            // jquery needed for datepicker
	            $('#duration_amount').on('input', commonTrading.debounce(function (e) {
	                triggerOnDurationChange(e);
	                Durations_Beta.validateMinDurationAmount();
	                input_event_triggered = true;
	            })).on('change', commonTrading.debounce(function (e) {
	                // using Defaults, to update the value by datepicker if it was emptied by keyboard (delete)
	                Durations_Beta.validateMinDurationAmount();
	                if (input_event_triggered === false || !Defaults.get('duration_amount')) {
	                    triggerOnDurationChange(e);
	                } else {
	                    input_event_triggered = false;
	                }
	            }));
	        }

	        /*
	         * attach event to expiry time change, event need to populate duration
	         * and request new price
	         */
	        var expiry_type_element = document.getElementById('expiry_type');
	        if (expiry_type_element) {
	            expiry_type_element.addEventListener('change', function (e) {
	                Defaults.set('expiry_type', e.target.value);
	                Process_Beta.onExpiryTypeChange(e.target.value);
	                if (expiry_type_element.value !== 'endtime') Price_Beta.processPriceRequest_Beta();
	            });
	        }

	        /*
	         * bind event to change in duration units, populate duration and request price
	         */
	        var duration_unit_element = document.getElementById('duration_units');
	        if (duration_unit_element) {
	            duration_unit_element.addEventListener('change', function (e) {
	                Defaults.remove('barrier', 'barrier_high', 'barrier_low');
	                Process_Beta.onDurationUnitChange(e.target.value);
	                Price_Beta.processPriceRequest_Beta();
	            });
	        }

	        /*
	         * bind event to change in endtime date and time
	         */
	        var end_date_element = document.getElementById('expiry_date');
	        if (end_date_element) {
	            // need to use jquery as datepicker is used, if we switch to some other
	            // datepicker we can move back to javascript
	            $('#expiry_date').on('change input', function () {
	                if (!dateValueChanged(this, 'date')) {
	                    return false;
	                }
	                // if start time is less than end time
	                if (commonTrading.timeIsValid($('#expiry_date'))) {
	                    Durations_Beta.selectEndDate(moment(this.getAttribute('data-value')));
	                }
	                return true;
	            });
	        }

	        var end_time_element = document.getElementById('expiry_time');
	        if (end_time_element) {
	            /*
	             * attach datepicker and timepicker to end time durations
	             * have to use jquery
	             */
	            attachTimePicker();
	            $('#expiry_time').on('focus, click', attachTimePicker).on('keypress', function (ev) {
	                onlyNumericOnKeypress(ev, [58]);
	            }).on('change input blur', function () {
	                if (!dateValueChanged(this, 'time')) {
	                    return false;
	                }
	                // if start time is less than end time
	                if (commonTrading.timeIsValid($('#expiry_time'))) {
	                    Durations_Beta.setTime(end_time_element.value);
	                    Price_Beta.processPriceRequest_Beta();
	                }
	                return true;
	            });
	        }

	        /*
	         * attach event to change in amount, request new price only
	         */
	        var amount_element = document.getElementById('amount');
	        if (amount_element) {
	            amount_element.addEventListener('keypress', onlyNumericOnKeypress);

	            amount_element.addEventListener('input', commonTrading.debounce(function (e) {
	                e.target.value = e.target.value.replace(/[^0-9.]/g, '');
	                if (isStandardFloat(e.target.value)) {
	                    e.target.value = formatMoney(Defaults.get('currency'), parseFloat(e.target.value), 1);
	                }
	                Defaults.set('amount', e.target.value);
	                Price_Beta.processPriceRequest_Beta();
	                commonTrading.submitForm(document.getElementById('websocket_form'));
	            }));
	        }

	        /*
	         * attach event to start time, display duration based on
	         * whether start time is forward starting or not and request
	         * new price
	         */
	        var date_start_element = getStartDateNode();
	        if (date_start_element) {
	            date_start_element.addEventListener('change', function (e) {
	                Defaults.set('date_start', e.target.value);
	                var r = Durations_Beta.onStartDateChange(e.target.value);
	                if (r >= 0) {
	                    Price_Beta.processPriceRequest_Beta();
	                }
	            });
	        }

	        /*
	         * attach event to change in amount type that is whether its
	         * payout or stake and request new price
	         */
	        var amount_type_element = document.getElementById('amount_type');
	        if (amount_type_element) {
	            amount_type_element.addEventListener('change', function (e) {
	                Defaults.set('amount_type', e.target.value);
	                Price_Beta.processPriceRequest_Beta();
	            });
	        }

	        /*
	         * attach event to change in submarkets. We need to disable
	         * underlyings that are not in selected seubmarkets
	         */
	        var submarket_element = document.getElementById('submarket');
	        if (submarket_element) {
	            submarket_element.addEventListener('change', function (e) {
	                if (e.target) {
	                    var elem = document.getElementById('underlying');
	                    var underlyings = elem.children;

	                    for (var i = 0, len = underlyings.length; i < len; i++) {
	                        underlyings[i].disabled = e.target.value !== 'all' && e.target.value !== underlyings[i].className;
	                    }

	                    // as submarket change has modified the underlying list so we need to manually
	                    // fire change event for underlying
	                    document.querySelectorAll('#underlying option:enabled')[0].selected = 'selected';
	                    var event = new Event('change');
	                    elem.dispatchEvent(event);
	                }
	            });
	        }

	        /*
	         * attach an event to change in currency
	         */
	        var currency_element = document.getElementById('currency');
	        if (currency_element) {
	            currency_element.addEventListener('change', function (e) {
	                Defaults.set('currency', e.target.value);
	                Price_Beta.processPriceRequest_Beta();
	            });
	        }

	        /*
	         * attach event to purchase buttons to buy the current contract
	         */
	        $('.purchase_button').on('click dblclick', function () {
	            if (!isVisible(document.getElementById('confirmation_message_container'))) {
	                var id = this.getAttribute('data-purchase-id');
	                var ask_price = this.getAttribute('data-ask-price');

	                var params = { buy: id, price: ask_price, passthrough: {} };
	                Object.keys(this.attributes).forEach(function (attr) {
	                    if (attr && this.attributes[attr] && this.attributes[attr].name && !/data\-balloon/.test(this.attributes[attr].name)) {
	                        // do not send tooltip data
	                        var m = this.attributes[attr].name.match(/data\-(.+)/);

	                        if (m && m[1] && m[1] !== 'purchase-id' && m[1] !== 'passthrough') {
	                            params.passthrough[m[1]] = this.attributes[attr].value;
	                        }
	                    }
	                }, this);
	                if (id && ask_price) {
	                    BinarySocket.send(params).then(function (response) {
	                        Purchase_Beta.display(response);
	                        GTM.pushPurchaseData(response);
	                    });
	                    Price_Beta.incrFormId();
	                    Price_Beta.processForgetProposals_Beta();
	                }
	            }
	        });

	        /*
	         * attach event to close icon for purchase container
	         */
	        $('#close_confirmation_container, #contract_purchase_new_trade').on('click dblclick', function (e) {
	            if (e.target) {
	                e.preventDefault();
	                document.getElementById('contract_confirmation_container').style.display = 'none';
	                document.getElementById('contracts_list').style.display = 'flex';
	                Price_Beta.processPriceRequest_Beta();
	            }
	        });

	        /*
	         * attach an event to change in barrier
	         */
	        var barrier_element = document.getElementById('barrier');
	        if (barrier_element) {
	            $('#barrier').on('keypress', function (ev) {
	                onlyNumericOnKeypress(ev, [43, 45, 46]);
	            }).on('input', commonTrading.debounce(function (e) {
	                Barriers_Beta.validateBarrier();
	                Defaults.set('barrier', e.target.value);
	                Price_Beta.processPriceRequest_Beta();
	                commonTrading.submitForm(document.getElementById('websocket_form'));
	            }, 1000));
	        }

	        /*
	         * attach an event to change in low barrier
	         */
	        var low_barrier_element = document.getElementById('barrier_low');
	        if (low_barrier_element) {
	            low_barrier_element.addEventListener('input', commonTrading.debounce(function (e) {
	                Defaults.set('barrier_low', e.target.value);
	                Price_Beta.processPriceRequest_Beta();
	                commonTrading.submitForm(document.getElementById('websocket_form'));
	            }));
	        }

	        /*
	         * attach an event to change in high barrier
	         */
	        var high_barrier_element = document.getElementById('barrier_high');
	        if (high_barrier_element) {
	            high_barrier_element.addEventListener('input', commonTrading.debounce(function (e) {
	                Defaults.set('barrier_high', e.target.value);
	                Price_Beta.processPriceRequest_Beta();
	                commonTrading.submitForm(document.getElementById('websocket_form'));
	            }));
	        }

	        /*
	         * attach an event to change in digit prediction input
	         */
	        var prediction_element = document.getElementById('prediction');
	        if (prediction_element) {
	            prediction_element.addEventListener('change', commonTrading.debounce(function (e) {
	                Defaults.set('prediction', e.target.value);
	                Price_Beta.processPriceRequest_Beta();
	                commonTrading.submitForm(document.getElementById('websocket_form'));
	            }));
	        }

	        // For verifying there are 2 digits after decimal
	        var isStandardFloat = function isStandardFloat(value) {
	            return !isNaN(value) && value % 1 !== 0 && (+parseFloat(value)).toFixed(10).replace(/^-?\d*\.?|0+$/g, '').length > 2;
	        };

	        var init_logo = document.getElementById('trading_init_progress');
	        if (init_logo) {
	            init_logo.addEventListener('click', commonTrading.debounce(function () {
	                commonTrading.reloadPage();
	            }));
	        }

	        var tip = document.getElementById('symbol_tip');
	        if (tip) {
	            tip.addEventListener('click', commonTrading.debounce(function (e) {
	                BinaryPjax.load(e.target.getAttribute('target'));
	            }));
	        }
	    };

	    var attachTimePicker = function attachTimePicker() {
	        var date_start = document.getElementById('date_start').value;
	        var now = !date_start || date_start === 'now';
	        var current_moment = now ? window.time ? window.time : moment.utc() : parseInt(date_start) * 1000;
	        TimePicker.init({
	            selector: '#expiry_time',
	            minTime: current_moment
	        });
	    };

	    return {
	        init: initiate
	    };
	}();

	module.exports = TradingEvents_Beta;

/***/ },
/* 523 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var Barriers_Beta = __webpack_require__(450);
	var Contract_Beta = __webpack_require__(451);
	var Price_Beta = __webpack_require__(524);
	var commonTrading = __webpack_require__(445);
	var processTradingTimesAnswer = __webpack_require__(443).processTradingTimesAnswer;
	var Defaults = __webpack_require__(437);
	var BinarySocket = __webpack_require__(427);
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var elementTextContent = __webpack_require__(430).elementTextContent;
	var isVisible = __webpack_require__(430).isVisible;
	var toISOFormat = __webpack_require__(449).toISOFormat;
	var toReadableFormat = __webpack_require__(449).toReadableFormat;
	var DatePicker = __webpack_require__(519);

	/*
	 * Handles duration processing display
	 *
	 * It process `Contract.durations()` and display them according to
	 * the current `Contract.form()` and `Contract.barriers()`
	 *
	 * It also populate expiry type select box i.e Durations and Endtime select
	 *
	 */

	var Durations_Beta = function () {
	    'use strict';

	    var selected_duration = {},
	        has_end_date = 0;

	    var displayDurations = function displayDurations() {
	        var start_type = void 0;
	        if (Defaults.get('date_start') !== 'now' && State.get('is_start_dates_displayed') && moment(Defaults.get('date_start') * 1000).isAfter(moment())) {
	            start_type = 'forward';
	        } else {
	            start_type = 'spot';
	        }

	        var durations = Contract_Beta.durations();
	        if (durations === false) {
	            document.getElementById('expiry_row').style.display = 'none';
	            Defaults.remove('expiry_type', 'duration_amount', 'duration_units', 'expiry_date', 'expiry_time');
	            return false;
	        }

	        var target = document.getElementById('duration_units');
	        var form_name = Contract_Beta.form();
	        var barrier_category = Contract_Beta.barrier();
	        var duration_container = {};

	        while (target && target.firstChild) {
	            target.removeChild(target.firstChild);
	        }

	        Object.keys(durations).forEach(function (key) {
	            Object.keys(durations[key][form_name]).forEach(function (form) {
	                if (durations[key][form_name].hasOwnProperty(form)) {
	                    var obj = {};
	                    if (barrier_category) {
	                        obj = durations[key][form_name][barrier_category];
	                    } else {
	                        obj = durations[key][form_name][form];
	                    }
	                    Object.keys(obj).forEach(function (type) {
	                        if (start_type) {
	                            if (start_type === type && !duration_container.hasOwnProperty(start_type)) {
	                                duration_container[key] = obj[start_type];
	                            }
	                        } else if (!duration_container.hasOwnProperty(type)) {
	                            duration_container[key] = obj[type];
	                        }
	                    });
	                }
	            });
	        });

	        var duration_list = {};
	        Object.keys(duration_container).forEach(function (duration) {
	            var text_mapping_min = durationTextValueMappings(duration_container[duration].min_contract_duration);
	            var text_mapping_max = durationTextValueMappings(duration_container[duration].max_contract_duration);
	            var min_unit = text_mapping_min.unit;

	            if (duration === 'intraday') {
	                switch (min_unit) {
	                    case 's':
	                        duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max);
	                        duration_list.m = makeDurationOption(durationTextValueMappings('1m'), text_mapping_max, true);
	                        duration_list.h = makeDurationOption(durationTextValueMappings('1h'), text_mapping_max);
	                        break;
	                    case 'm':
	                        duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max, true);
	                        duration_list.h = makeDurationOption(durationTextValueMappings('1h'), text_mapping_max);
	                        break;
	                    case 'h':
	                        duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max);
	                        break;
	                    default:
	                        duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max);
	                        break;
	                }
	            } else if (duration === 'daily' || duration === 'tick') {
	                duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max);
	            }
	        });
	        var list = Object.keys(duration_list).sort(function (a, b) {
	            return commonTrading.durationOrder(a) > commonTrading.durationOrder(b) ? 1 : -1;
	        });
	        has_end_date = 0;
	        for (var k = 0; k < list.length; k++) {
	            var d = list[k];
	            if (d !== 't') {
	                has_end_date = 1;
	            }
	            if (duration_list.hasOwnProperty(d)) {
	                target.appendChild(duration_list[d]);
	            }
	        }

	        if (selected_duration.unit) {
	            if (!commonTrading.selectOption(selected_duration.unit, target)) {
	                selected_duration = {};
	            }
	        }

	        durationPopulate();
	        return true;
	    };

	    var makeDurationOption = function makeDurationOption(map_min, map_max, is_selected) {
	        var option = document.createElement('option');
	        var content = document.createTextNode(map_min.text);
	        option.setAttribute('value', map_min.unit);
	        option.setAttribute('data-minimum', map_min.value);
	        if (map_max.value && map_max.unit) {
	            var max = convertDurationUnit(map_max.value, map_max.unit, map_min.unit);
	            if (max) {
	                option.setAttribute('data-maximum', max);
	            }
	        }
	        if (is_selected) {
	            option.setAttribute('selected', 'selected');
	        }
	        option.appendChild(content);
	        return option;
	    };

	    var convertDurationUnit = function convertDurationUnit(value, from_unit, to_unit) {
	        if (!value || !from_unit || !to_unit) return null;
	        if (from_unit === to_unit) return value;
	        var seconds = {
	            s: 1,
	            m: 60,
	            h: 3600,
	            d: 3600 * 24
	        };
	        return value * seconds[from_unit] / seconds[to_unit];
	    };

	    var displayEndTime = function displayEndTime() {
	        var date_start = document.getElementById('date_start').value;
	        var now = !date_start || date_start === 'now';
	        var current_moment = moment(now ? window.time : parseInt(date_start) * 1000).add(5, 'minutes').utc();
	        var expiry_date = Defaults.get('expiry_date') ? moment(Defaults.get('expiry_date')) : current_moment,
	            expiry_time = Defaults.get('expiry_time') || current_moment.format('HH:mm'),
	            expiry_date_iso = toISOFormat(expiry_date);

	        if (moment(expiry_date_iso + ' ' + expiry_time).valueOf() < current_moment.valueOf()) {
	            expiry_date = current_moment;
	            expiry_date_iso = toISOFormat(expiry_date);
	            expiry_time = current_moment.format('HH:mm');
	        }

	        var expiry_date_el = document.getElementById('expiry_date');
	        var expiry_time_el = document.getElementById('expiry_time');

	        expiry_date_el.value = toReadableFormat(expiry_date);
	        expiry_date_el.setAttribute('data-value', expiry_date_iso);
	        expiry_time_el.value = expiry_time;
	        expiry_time_el.setAttribute('data-value', expiry_time);
	        Defaults.set('expiry_date', expiry_date_iso);
	        Defaults.set('expiry_time', expiry_time);
	        Durations_Beta.setTime(expiry_time);

	        durationPopulate();
	    };

	    var durationTextValueMappings = function durationTextValueMappings(str) {
	        var mapping = {
	            s: localize('seconds'),
	            m: localize('minutes'),
	            h: localize('hours'),
	            d: localize('days'),
	            t: localize('ticks')
	        };

	        var arry = str ? str.toString().match(/[a-zA-Z]+|[0-9]+/g) : [];
	        var obj = {};

	        if (arry.length > 1) {
	            obj.unit = arry[1];
	            obj.text = mapping[arry[1]];
	            obj.value = arry[0];
	        } else {
	            obj.unit = 't';
	            obj.text = mapping.t;
	            obj.value = arry[0];
	        }

	        return obj;
	    };

	    var durationPopulate = function durationPopulate() {
	        var unit = document.getElementById('duration_units');
	        if (!unit.options[unit.selectedIndex]) return;
	        var unit_min_value = unit.options[unit.selectedIndex].getAttribute('data-minimum');
	        var unit_max_value = unit.options[unit.selectedIndex].getAttribute('data-maximum');
	        var unit_value = Defaults.get('duration_amount') || unit_min_value;
	        unit.value = Defaults.get('duration_units') && document.querySelectorAll('select[id="duration_units"] [value="' + Defaults.get('duration_units') + '"]').length ? Defaults.get('duration_units') : unit.value;
	        elementTextContent(document.getElementById('duration_minimum'), unit_min_value);
	        elementTextContent(document.getElementById('duration_maximum'), unit_max_value);
	        if (selected_duration.amount && selected_duration.unit > unit_value) {
	            unit_value = selected_duration.amount;
	        }
	        document.getElementById('duration_amount').value = unit_value;
	        Defaults.set('duration_amount', unit_value);
	        displayExpiryType();
	        Defaults.set('duration_units', unit.value);

	        // jquery for datepicker
	        var amount_element = $('#duration_amount');
	        var duration_id = '#duration_amount';
	        if (unit.value === 'd') {
	            DatePicker.init({
	                selector: duration_id,
	                type: 'diff',
	                minDate: 1,
	                maxDate: 364,
	                native: false
	            });
	            amount_element.change(function (value) {
	                var day_diff = void 0;
	                var $duration_amount_val = $('#duration_amount').val();
	                if ($duration_amount_val) {
	                    day_diff = $duration_amount_val;
	                } else {
	                    value = value.target.getAttribute('data-value');
	                    var date = value ? new Date(value) : new Date();
	                    var today = window.time ? window.time.valueOf() : new Date();
	                    day_diff = Math.ceil((date - today) / (1000 * 60 * 60 * 24));
	                }
	                amount_element.val(day_diff);
	            });
	        } else {
	            DatePicker.hide(duration_id);
	        }

	        if ($('#expiry_date').is(':visible')) {
	            DatePicker.init({
	                selector: '#expiry_date',
	                minDate: 0,
	                maxDate: 364
	            });
	        }

	        validateMinDurationAmount();
	        // we need to call it here as for days we need to show absolute barriers
	        Barriers_Beta.display();
	    };

	    var displayExpiryType = function displayExpiryType() {
	        var target = document.getElementById('expiry_type');
	        var fragment = document.createDocumentFragment();

	        // in case of having endtime as expiry_type and change the form to contract types
	        // which only have duration and do not support endtime, it should change the Default value
	        // to get corrected based on contract situations
	        if ($('#expiry_type').find('option[value=' + Defaults.get('expiry_type') + ']').length === 0 && target.value) {
	            Defaults.set('expiry_type', target.value);
	        }
	        var current_selected = Defaults.get('expiry_type') || target.value || 'duration';
	        var hide_id = current_selected === 'duration' ? 'endtime' : 'duration',
	            id = current_selected;

	        id = document.getElementById('expiry_type_' + id);
	        if (id) {
	            id.style.display = 'flex';
	        }
	        // need to hide the non selected one
	        hide_id = document.getElementById('expiry_type_' + hide_id);
	        if (hide_id) {
	            hide_id.style.display = 'none';
	        }

	        while (target && target.firstChild) {
	            target.removeChild(target.firstChild);
	        }

	        var option = document.createElement('option'),
	            content = document.createTextNode(localize('Duration'));

	        option.setAttribute('value', 'duration');
	        if (current_selected === 'duration') {
	            option.setAttribute('selected', 'selected');
	        }
	        option.appendChild(content);
	        fragment.appendChild(option);

	        if (has_end_date) {
	            option = document.createElement('option');
	            content = document.createTextNode(localize('End Time'));
	            option.setAttribute('value', 'endtime');
	            if (current_selected === 'endtime') {
	                option.setAttribute('selected', 'selected');
	            }
	            option.appendChild(content);
	            fragment.appendChild(option);
	        }
	        target.appendChild(fragment);
	    };

	    var selectEndDate = function selectEndDate(end_date) {
	        var expiry_time = document.getElementById('expiry_time');
	        var date_start = document.getElementById('date_start');
	        var end_date_readable = toReadableFormat(end_date);
	        var end_date_iso = toISOFormat(end_date);
	        $('#expiry_date').val(end_date_readable).attr('data-value', end_date_iso);
	        Defaults.set('expiry_date', end_date_iso);
	        if (end_date.isAfter(window.time.format('YYYY-MM-DD HH:mm'), 'day')) {
	            Durations_Beta.setTime('');
	            Defaults.remove('expiry_time');
	            setNow(); // start time
	            date_start.setAttribute('disabled', 'disabled');
	            expiry_time.hide();
	            processTradingTimesRequest_Beta(end_date_iso);
	        } else {
	            date_start.removeAttribute('disabled');
	            if (!expiry_time.value) {
	                var new_time = moment(window.time).add(5, 'minutes').utc().format('HH:mm');
	                expiry_time.value = new_time;
	                expiry_time.setAttribute('data-value', new_time);
	            }
	            Durations_Beta.setTime(expiry_time.value);
	            Defaults.set('expiry_time', Defaults.get('expiry_time') || expiry_time.value);
	            expiry_time.show();
	            Price_Beta.processPriceRequest_Beta();
	        }

	        Barriers_Beta.display();
	    };

	    var validateMinDurationAmount = function validateMinDurationAmount() {
	        var duration_amount_element = document.getElementById('duration_amount');
	        var duration_min_element = document.getElementById('duration_minimum');
	        var duration_max_element = document.getElementById('duration_maximum');
	        if (!isVisible(duration_amount_element) || !isVisible(duration_min_element)) return;
	        if (+duration_amount_element.value < +duration_min_element.textContent || +duration_max_element.textContent && +duration_amount_element.value > +duration_max_element.textContent) {
	            duration_amount_element.classList.add('error-field');
	        } else {
	            duration_amount_element.classList.remove('error-field');
	        }
	    };

	    var onStartDateChange = function onStartDateChange(value) {
	        var $date_start_select = $('#date_start');
	        if (!value || !$date_start_select.find('option[value=' + value + ']').length) {
	            return 0;
	        }

	        var yellow_border = 'light-yellow-background';
	        if (value !== 'now') {
	            $date_start_select.addClass(yellow_border);
	        } else {
	            $date_start_select.removeClass(yellow_border);
	        }

	        $date_start_select.val(value);

	        var make_price_request = 1;
	        var $expiry_time = $('#expiry_time');
	        if (value !== 'now' && Defaults.get('expiry_type') === 'endtime') {
	            make_price_request = -1;
	            var end_time = moment(parseInt(value) * 1000).add(5, 'minutes').utc();
	            Durations_Beta.setTime(commonTrading.timeIsValid($expiry_time) && Defaults.get('expiry_time') ? Defaults.get('expiry_time') : end_time.format('HH:mm'));
	            Durations_Beta.selectEndDate(commonTrading.timeIsValid($expiry_time) && (Defaults.get('expiry_date') ? moment(Defaults.get('expiry_date')) : end_time));
	        }
	        commonTrading.timeIsValid($expiry_time);
	        Durations_Beta.display();
	        return make_price_request;
	    };

	    var setNow = function setNow() {
	        var $date_start = $('#date_start');
	        if ($date_start.find('option[value="now"]').length) {
	            $date_start.val('now').removeClass('light-yellow-background');
	            Defaults.set('date_start', 'now');
	        }
	    };

	    var processTradingTimesRequest_Beta = function processTradingTimesRequest_Beta(date) {
	        var trading_times = Durations_Beta.trading_times();
	        if (trading_times.hasOwnProperty(date)) {
	            Price_Beta.processPriceRequest_Beta();
	        } else {
	            commonTrading.showPriceOverlay();
	            BinarySocket.send({ trading_times: date }).then(function (response) {
	                processTradingTimesAnswer(response);
	                Price_Beta.processPriceRequest_Beta();
	            });
	        }
	    };

	    return {
	        display: displayDurations,
	        displayEndTime: displayEndTime,
	        populate: durationPopulate,
	        selectEndDate: selectEndDate,
	        validateMinDurationAmount: validateMinDurationAmount,
	        onStartDateChange: onStartDateChange,

	        setTime: function setTime(time) {
	            $('#expiry_time').val(time);Defaults.set('expiry_time', time);
	        },
	        selectAmount: function selectAmount(a) {
	            selected_duration.amount = a;
	        },
	        selectUnit: function selectUnit(u) {
	            selected_duration.unit = u;
	        }
	    };
	}();

	module.exports = Durations_Beta;

/***/ },
/* 524 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var moment = __webpack_require__(305);
	var Contract_Beta = __webpack_require__(451);
	var commonTrading = __webpack_require__(445);
	var displayPriceMovement = __webpack_require__(443).displayPriceMovement;
	var getStartDateNode = __webpack_require__(443).getStartDateNode;
	var getTradingTimes = __webpack_require__(443).getTradingTimes;
	var Defaults = __webpack_require__(437);
	var BinarySocket = __webpack_require__(427);
	var localize = __webpack_require__(428).localize;
	var elementTextContent = __webpack_require__(430).elementTextContent;
	var isVisible = __webpack_require__(430).isVisible;
	var formatMoney = __webpack_require__(433).formatMoney;

	/*
	 * Price object handles all the functions we need to display prices
	 *
	 * We create Price proposal that we need to send to server to get price,
	 * longcode and all other information that we need to get the price for
	 * current contract
	 *
	 *
	 * Usage:
	 *
	 * `socket.send(Price.proposal())` to send price proposal to sever
	 * `Price.display()` to display the price details returned from server
	 */
	var Price_Beta = function () {
	    'use strict';

	    var type_display_id_mapping = {},
	        form_id = 0;

	    var createProposal = function createProposal(type_of_contract) {
	        var proposal = {
	            proposal: 1,
	            subscribe: 1
	        };
	        var contract_type = type_of_contract;
	        var start_time = getStartDateNode();
	        var underlying = document.getElementById('underlying');
	        var amount_type = document.getElementById('amount_type');
	        var currency = document.getElementById('currency');
	        var payout = document.getElementById('amount');
	        var expiry_type = document.getElementById('expiry_type');
	        var duration = document.getElementById('duration_amount');
	        var duration_unit = document.getElementById('duration_units');
	        var end_date = document.getElementById('expiry_date');
	        var barrier = document.getElementById('barrier');
	        var high_barrier = document.getElementById('barrier_high');
	        var low_barrier = document.getElementById('barrier_low');
	        var prediction = document.getElementById('prediction');

	        if (payout && isVisible(payout) && payout.value) {
	            proposal.amount = parseFloat(payout.value);
	        }

	        if (amount_type && isVisible(amount_type) && amount_type.value) {
	            proposal.basis = amount_type.value;
	        }

	        if (contract_type) {
	            proposal.contract_type = type_of_contract;
	        }

	        if (currency && (currency.value || currency.getAttribute('value'))) {
	            proposal.currency = currency.value || currency.getAttribute('value');
	        }

	        if (underlying && underlying.value) {
	            proposal.symbol = underlying.value;
	        }

	        if (start_time && isVisible(start_time) && start_time.value !== 'now') {
	            proposal.date_start = start_time.value;
	        }

	        if (expiry_type && isVisible(expiry_type) && expiry_type.value === 'duration') {
	            proposal.duration = parseInt(duration.value);
	            proposal.duration_unit = duration_unit.value;
	        } else if (expiry_type && isVisible(expiry_type) && expiry_type.value === 'endtime') {
	            var end_date2 = end_date.getAttribute('data-value');
	            var end_time2 = Defaults.get('expiry_time');
	            if (!end_time2) {
	                var trading_times = getTradingTimes();
	                if (trading_times.hasOwnProperty(end_date2) && _typeof(trading_times[end_date2][underlying.value]) === 'object' && trading_times[end_date2][underlying.value].length && trading_times[end_date2][underlying.value][0] !== '--') {
	                    if (trading_times[end_date2][underlying.value].length > 1) {
	                        end_time2 = trading_times[end_date2][underlying.value][1];
	                    } else {
	                        end_time2 = trading_times[end_date2][underlying.value];
	                    }
	                }
	            }

	            proposal.date_expiry = moment.utc(end_date2 + ' ' + (end_time2 || '23:59:59')).unix();
	            // For stopping tick trade behaviour
	            proposal.duration_unit = 'm';
	        }

	        if (barrier && isVisible(barrier) && barrier.value) {
	            proposal.barrier = barrier.value;
	        }

	        if (high_barrier && isVisible(high_barrier) && high_barrier.value) {
	            proposal.barrier = high_barrier.value;
	        }

	        if (low_barrier && isVisible(low_barrier) && low_barrier.value) {
	            proposal.barrier2 = low_barrier.value;
	        }

	        if (prediction && isVisible(prediction)) {
	            proposal.barrier = parseInt(prediction.value);
	        }

	        if (contract_type) {
	            proposal.contract_type = type_of_contract;
	        }

	        proposal.passthrough = {
	            form_id: form_id
	        };

	        commonTrading.resetPriceMovement();

	        return proposal;
	    };

	    var display = function display(details, contract_type) {
	        var proposal = details.proposal;
	        var id = proposal ? proposal.id : '';
	        var params = details.echo_req;

	        var type = params.contract_type;
	        if (id && !type) {
	            type = type_display_id_mapping[id];
	        }

	        if (params && id && Object.getOwnPropertyNames(params).length > 0) {
	            type_display_id_mapping[id] = type;
	        }

	        var position = commonTrading.contractTypeDisplayMapping(type);

	        if (!position) {
	            return;
	        }

	        var container = document.getElementById('price_container_' + position);
	        if (!container) return;
	        if (!$(container).is(':visible')) {
	            $(container).fadeIn(200, function () {
	                $(container).css('display', 'flex');
	            });
	        }

	        var h4 = container.getElementsByClassName('contract_heading')[0];
	        var amount = container.getElementsByClassName('contract_amount')[0];
	        var payout_amount = container.getElementsByClassName('contract_payout')[0];
	        var stake = container.getElementsByClassName('stake')[0];
	        var payout = container.getElementsByClassName('payout')[0];
	        var purchase = container.getElementsByClassName('purchase_button')[0];
	        var description = container.getElementsByClassName('contract_description')[0];
	        var comment = container.getElementsByClassName('price_comment')[0];
	        var error = container.getElementsByClassName('contract_error')[0];
	        var currency = document.getElementById('currency');

	        var display_type = type ? contract_type ? contract_type[type] : '' : '';
	        if (display_type) {
	            h4.setAttribute('class', 'contract_heading ' + type);
	            elementTextContent(h4, display_type);
	        }

	        var setData = function setData(data) {
	            if (!data) return;
	            if (data.display_value) {
	                $('.stake:hidden').show();
	                elementTextContent(stake, localize('Stake') + ': ');
	                elementTextContent(amount, formatMoney(currency.value || currency.getAttribute('value'), data.display_value));
	                $('.stake_wrapper:hidden').show();
	            } else {
	                $('.stake_wrapper:visible').hide();
	            }

	            if (data.payout) {
	                elementTextContent(payout, localize('Payout') + ': ');
	                elementTextContent(payout_amount, formatMoney(currency.value || currency.getAttribute('value'), +data.payout));
	                $('.payout_wrapper:hidden').show();
	            } else {
	                $('.payout_wrapper:visible').hide();
	            }

	            if (data.longcode && window.innerWidth > 500) {
	                description.setAttribute('data-balloon', data.longcode);
	            } else {
	                description.removeAttribute('data-balloon');
	            }
	        };

	        if (details.error) {
	            purchase.hide();
	            comment.hide();
	            setData(details.error.details);
	            error.show();
	            elementTextContent(error, details.error.message);
	        } else {
	            setData(proposal);
	            if ($('#websocket_form').find('.error-field').length > 0) {
	                purchase.hide();
	            } else {
	                purchase.show();
	            }
	            comment.show();
	            error.hide();
	            commonTrading.displayCommentPrice(comment, currency.value || currency.getAttribute('value'), proposal.ask_price, proposal.payout);
	            var old_price = purchase.getAttribute('data-display_value');
	            var old_payout = purchase.getAttribute('data-payout');
	            displayPriceMovement(amount, old_price, proposal.display_value);
	            displayPriceMovement(payout_amount, old_payout, proposal.payout);
	            purchase.setAttribute('data-purchase-id', id);
	            purchase.setAttribute('data-ask-price', proposal.ask_price);
	            purchase.setAttribute('data-display_value', proposal.display_value);
	            purchase.setAttribute('data-payout', proposal.payout);
	            purchase.setAttribute('data-symbol', id);
	            Object.keys(params).forEach(function (key) {
	                if (key && key !== 'proposal') {
	                    purchase.setAttribute('data-' + key, params[key]);
	                }
	            });
	        }
	    };

	    var clearMapping = function clearMapping() {
	        type_display_id_mapping = {};
	    };

	    var clearFormId = function clearFormId() {
	        form_id = 0;
	    };

	    /*
	     * Function to request for cancelling the current price proposal
	     */
	    var processForgetProposals_Beta = function processForgetProposals_Beta() {
	        commonTrading.showPriceOverlay();
	        BinarySocket.send({
	            forget_all: 'proposal'
	        });
	        Price_Beta.clearMapping();
	    };

	    /*
	     * Function to process and calculate price based on current form
	     * parameters or change in form parameters
	     */
	    var processPriceRequest_Beta = function processPriceRequest_Beta() {
	        Price_Beta.incrFormId();
	        processForgetProposals_Beta();
	        commonTrading.showPriceOverlay();
	        var types = Contract_Beta.contractType()[Contract_Beta.form()];
	        if (Contract_Beta.form() === 'digits') {
	            switch (sessionStorage.getItem('formname')) {
	                case 'matchdiff':
	                    types = {
	                        DIGITMATCH: 1,
	                        DIGITDIFF: 1
	                    };
	                    break;
	                case 'evenodd':
	                    types = {
	                        DIGITEVEN: 1,
	                        DIGITODD: 1
	                    };
	                    break;
	                case 'overunder':
	                    types = {
	                        DIGITOVER: 1,
	                        DIGITUNDER: 1
	                    };
	                // no default
	            }
	        }
	        Object.keys(types).forEach(function (type_of_contract) {
	            BinarySocket.send(Price_Beta.proposal(type_of_contract), { callback: function callback(response) {
	                    if (response.echo_req && response.echo_req.passthrough && response.echo_req.passthrough.form_id === form_id) {
	                        commonTrading.hideOverlayContainer();
	                        Price_Beta.display(response, Contract_Beta.contractType()[Contract_Beta.form()]);
	                        commonTrading.hidePriceOverlay();
	                    }
	                } });
	        });
	    };

	    return {
	        proposal: createProposal,
	        display: display,
	        clearMapping: clearMapping,
	        clearFormId: clearFormId,
	        idDisplayMapping: function idDisplayMapping() {
	            return type_display_id_mapping;
	        },
	        getFormId: function getFormId() {
	            return form_id;
	        },
	        incrFormId: function incrFormId() {
	            form_id++;
	        },

	        processForgetProposals_Beta: processForgetProposals_Beta,
	        processPriceRequest_Beta: processPriceRequest_Beta
	    };
	}();

	module.exports = Price_Beta;

/***/ },
/* 525 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var moment = __webpack_require__(305);
	var TradingAnalysis_Beta = __webpack_require__(521);
	var Contract_Beta = __webpack_require__(451);
	var Durations_Beta = __webpack_require__(523);
	var Price_Beta = __webpack_require__(524);
	var StartDates_Beta = __webpack_require__(526);
	var commonTrading = __webpack_require__(445);
	var Defaults = __webpack_require__(437);
	var GetTicks = __webpack_require__(441);
	var Notifications = __webpack_require__(446);
	var Symbols = __webpack_require__(447);
	var Tick = __webpack_require__(448);
	var BinarySocket = __webpack_require__(427);
	var AssetIndexUI = __webpack_require__(514);
	var TradingTimesUI = __webpack_require__(517);
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var elementInnerHtml = __webpack_require__(430).elementInnerHtml;

	var Process_Beta = function () {
	    'use strict';

	    /*
	     * This function process the active symbols to get markets
	     * and underlying list
	     */

	    var processActiveSymbols_Beta = function processActiveSymbols_Beta() {
	        BinarySocket.send({ active_symbols: 'brief' }).then(function (response) {
	            // populate the Symbols object
	            Symbols.details(response);

	            var market = commonTrading.getDefaultMarket();

	            // store the market
	            Defaults.set('market', market);

	            commonTrading.displayMarkets('contract_markets', Symbols.markets(), market);
	            processMarket_Beta();
	            AssetIndexUI.setActiveSymbols(response);
	            TradingTimesUI.setActiveSymbols(response);
	        });
	    };

	    /*
	     * Function to call when market has changed
	     */
	    var processMarket_Beta = function processMarket_Beta() {
	        // we can get market from sessionStorage as allowed market
	        // is already set when this is called
	        var market = Defaults.get('market'),
	            symbol = Defaults.get('underlying');

	        // change to default market if query string contains an invalid market
	        if (!market || !Symbols.underlyings()[market]) {
	            market = commonTrading.getDefaultMarket();
	            Defaults.set('market', market);
	        }
	        if (!symbol || !Symbols.underlyings()[market][symbol]) {
	            symbol = undefined;
	        }
	        commonTrading.displayUnderlyings('underlying', Symbols.underlyings()[market], symbol);

	        marketUnderlying_Beta();
	    };

	    /*
	     * Function to call when underlying has changed
	     */
	    var marketUnderlying_Beta = function marketUnderlying_Beta() {
	        var underlying_element = document.getElementById('underlying');
	        if (!underlying_element) {
	            return;
	        }

	        if (underlying_element.selectedIndex < 0) {
	            underlying_element.selectedIndex = 0;
	        }
	        var underlying = underlying_element.value;
	        Defaults.set('underlying', underlying);

	        commonTrading.showFormOverlay();

	        // get ticks for current underlying
	        GetTicks.request(underlying);

	        Tick.clean();

	        commonTrading.updateWarmChart();

	        BinarySocket.clearTimeouts();

	        BinarySocket.send({ contracts_for: underlying }).then(function (response) {
	            Notifications.hide('CONNECTION_ERROR');
	            processContract_Beta(response);
	        });

	        commonTrading.displayTooltip_Beta(Defaults.get('market'), underlying);
	    };

	    /*
	     * Function to display contract form for current underlying
	     */
	    var processContract_Beta = function processContract_Beta(contracts) {
	        if (contracts.hasOwnProperty('error') && contracts.error.code === 'InvalidSymbol') {
	            Price_Beta.processForgetProposals_Beta();
	            var container = document.getElementById('contract_confirmation_container');
	            var message_container = document.getElementById('confirmation_message');
	            var confirmation_error = document.getElementById('confirmation_error');
	            var confirmation_error_contents = document.getElementById('confirmation_error_contents');
	            var contracts_list = document.getElementById('contracts_list');
	            container.style.display = 'block';
	            contracts_list.style.display = 'none';
	            message_container.hide();
	            confirmation_error.show();
	            elementInnerHtml(confirmation_error_contents, contracts.error.message + ' <a href="javascript:;" onclick="sessionStorage.removeItem(\'underlying\'); window.location.reload();">' + localize('Please reload the page') + '</a>');
	            return;
	        }

	        State.set('is_chart_allowed', !(contracts.contracts_for && contracts.contracts_for.feed_license && contracts.contracts_for.feed_license === 'chartonly'));

	        document.getElementById('trading_socket_container_beta').classList.add('show');
	        var init_logo = document.getElementById('trading_init_progress');
	        if (init_logo.style.display !== 'none') {
	            init_logo.style.display = 'none';
	            Defaults.update();
	        }

	        Contract_Beta.setContracts(contracts);

	        var contract_categories = Contract_Beta.contractForms();
	        var formname = void 0;
	        if (Defaults.get('formname') && contract_categories && contract_categories[Defaults.get('formname')]) {
	            formname = Defaults.get('formname');
	        } else {
	            var tree = commonTrading.getContractCategoryTree(contract_categories);
	            if (tree[0]) {
	                if (_typeof(tree[0]) === 'object') {
	                    formname = tree[0][1][0];
	                } else {
	                    formname = tree[0];
	                }
	            }
	        }

	        // set form to session storage
	        Defaults.set('formname', formname);

	        commonTrading.displayContractForms('contract_form_name_nav', contract_categories, formname);

	        processContractForm_Beta();

	        TradingAnalysis_Beta.request();

	        commonTrading.hideFormOverlay();
	    };

	    var processContractForm_Beta = function processContractForm_Beta() {
	        Contract_Beta.details(sessionStorage.getItem('formname'));

	        StartDates_Beta.display();

	        displayPrediction_Beta();

	        var r1 = void 0;
	        if (State.get('is_start_dates_displayed') && Defaults.get('date_start') && Defaults.get('date_start') !== 'now') {
	            r1 = Durations_Beta.onStartDateChange(Defaults.get('date_start'));
	            if (!r1 || Defaults.get('expiry_type') === 'endtime') Durations_Beta.display();
	        } else {
	            Durations_Beta.display();
	        }

	        if (Defaults.get('amount')) $('#amount').val(Defaults.get('amount'));else Defaults.set('amount', document.getElementById('amount').value);

	        if (Defaults.get('amount_type')) commonTrading.selectOption(Defaults.get('amount_type'), document.getElementById('amount_type'));else Defaults.set('amount_type', document.getElementById('amount_type').value);

	        if (Defaults.get('currency')) commonTrading.selectOption(Defaults.get('currency'), document.getElementById('currency'));

	        var expiry_type = Defaults.get('expiry_type') || 'duration';
	        var make_price_request = onExpiryTypeChange(expiry_type);

	        if (make_price_request >= 0) {
	            Price_Beta.processPriceRequest_Beta();
	        }
	    };

	    var displayPrediction_Beta = function displayPrediction_Beta() {
	        var prediction_element = document.getElementById('prediction_row');
	        if (Contract_Beta.form() === 'digits' && sessionStorage.getItem('formname') !== 'evenodd') {
	            prediction_element.show();
	            if (Defaults.get('prediction')) {
	                commonTrading.selectOption(Defaults.get('prediction'), document.getElementById('prediction'));
	            } else {
	                Defaults.set('prediction', document.getElementById('prediction').value);
	            }
	        } else {
	            prediction_element.hide();
	            Defaults.remove('prediction');
	        }
	    };

	    var forgetTradingStreams_Beta = function forgetTradingStreams_Beta() {
	        Price_Beta.processForgetProposals_Beta();
	        processForgetTicks_Beta();
	    };

	    /*
	     * cancel the current tick stream
	     * this need to be invoked before makin
	     */
	    var processForgetTicks_Beta = function processForgetTicks_Beta() {
	        BinarySocket.send({
	            forget_all: 'ticks'
	        });
	    };

	    var onExpiryTypeChange = function onExpiryTypeChange(value) {
	        var $expiry_type = $('#expiry_type');
	        if (!value || !$expiry_type.find('option[value=' + value + ']').length) {
	            value = 'duration';
	        }
	        $expiry_type.val(value);

	        var make_price_request = 0;
	        if (value === 'endtime') {
	            Durations_Beta.displayEndTime();
	            if (Defaults.get('expiry_date')) {
	                Durations_Beta.selectEndDate(moment(Defaults.get('expiry_date')));
	                make_price_request = -1;
	            }
	            Defaults.remove('duration_units', 'duration_amount');
	        } else {
	            StartDates_Beta.enable();
	            Durations_Beta.display();
	            if (Defaults.get('duration_units')) {
	                onDurationUnitChange(Defaults.get('duration_units'));
	            }
	            var duration_amount = Defaults.get('duration_amount');
	            if (duration_amount && duration_amount > $('#duration_minimum').text()) {
	                $('#duration_amount').val(duration_amount);
	            }
	            make_price_request = 1;
	            Defaults.remove('expiry_date', 'expiry_time', 'end_date');
	            Durations_Beta.validateMinDurationAmount();
	        }

	        return make_price_request;
	    };

	    var onDurationUnitChange = function onDurationUnitChange(value) {
	        var $duration_units = $('#duration_units');
	        if (!value || !$duration_units.find('option[value=' + value + ']').length) {
	            return 0;
	        }

	        $duration_units.val(value);
	        Defaults.set('duration_units', value);

	        Durations_Beta.selectUnit(value);
	        Durations_Beta.populate();

	        return 1;
	    };

	    return {
	        processActiveSymbols_Beta: processActiveSymbols_Beta,
	        processMarket_Beta: processMarket_Beta,
	        processContract_Beta: processContract_Beta,
	        processContractForm_Beta: processContractForm_Beta,
	        forgetTradingStreams_Beta: forgetTradingStreams_Beta,
	        processForgetTicks_Beta: processForgetTicks_Beta,
	        onExpiryTypeChange: onExpiryTypeChange,
	        onDurationUnitChange: onDurationUnitChange
	    };
	}();

	module.exports = Process_Beta;

/***/ },
/* 526 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var Contract_Beta = __webpack_require__(451);
	var Durations_Beta = __webpack_require__(523);
	var getStartDateNode = __webpack_require__(443).getStartDateNode;
	var Defaults = __webpack_require__(437);
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;

	/*
	 * Handles start time display
	 *
	 * It process `Contract.startDates` in case of forward
	 * starting contracts and populate the start time select
	 * box
	 */

	var StartDates_Beta = function () {
	    'use strict';

	    var has_now = 0;
	    State.remove('is_start_dates_displayed');

	    var compareStartDate = function compareStartDate(a, b) {
	        return a.date < b.date ? -1 : a.date > b.date ? 1 : 0;
	    };

	    var displayStartDates = function displayStartDates() {
	        var start_dates = Contract_Beta.startDates();

	        if (start_dates && start_dates.list && start_dates.list.length) {
	            var target = getStartDateNode();
	            var fragment = document.createDocumentFragment();
	            var row = document.getElementById('date_start_row');
	            var option = void 0,
	                content = void 0;

	            row.style.display = 'flex';

	            while (target && target.firstChild) {
	                target.removeChild(target.firstChild);
	            }

	            if (start_dates.has_spot) {
	                option = document.createElement('option');
	                content = document.createTextNode(localize('Now'));
	                option.setAttribute('value', 'now');
	                $('#date_start').removeClass('light-yellow-background');
	                option.appendChild(content);
	                fragment.appendChild(option);
	                has_now = 1;
	            } else {
	                has_now = 0;
	            }

	            start_dates.list.sort(compareStartDate);

	            var first = void 0;
	            start_dates.list.forEach(function (start_date) {
	                var a = moment.unix(start_date.open).utc();
	                var b = moment.unix(start_date.close).utc();

	                var rounding = 5 * 60 * 1000;
	                var start = moment.utc();

	                if (moment(start).isAfter(moment(a))) {
	                    a = start;
	                }

	                a = moment(Math.ceil(+a / rounding) * rounding).utc();

	                while (a.isBefore(b)) {
	                    if (a.unix() - start.unix() > 5 * 60) {
	                        option = document.createElement('option');
	                        option.setAttribute('value', a.utc().unix());
	                        if (typeof first === 'undefined' && !has_now) {
	                            first = a.utc().unix();
	                        }
	                        content = document.createTextNode(a.format('HH:mm ddd').replace(' ', ' GMT, '));
	                        if (option.value === Defaults.get('date_start')) {
	                            option.setAttribute('selected', 'selected');
	                        }
	                        option.appendChild(content);
	                        fragment.appendChild(option);
	                    }
	                    a.add(5, 'minutes');
	                }
	            });
	            target.appendChild(fragment);
	            Defaults.set('date_start', target.value);
	            State.set('is_start_dates_displayed', true);
	            if (first) {
	                Durations_Beta.onStartDateChange(first);
	            }
	        } else {
	            State.remove('is_start_dates_displayed');
	            document.getElementById('date_start_row').style.display = 'none';
	            Defaults.remove('date_start');
	        }
	    };

	    return {
	        display: displayStartDates,
	        disable: function disable() {
	            getStartDateNode().setAttribute('disabled', 'disabled');
	        },
	        enable: function enable() {
	            getStartDateNode().removeAttribute('disabled');
	        }
	    };
	}();

	module.exports = StartDates_Beta;

/***/ },
/* 527 */
/***/ function(module, exports) {

	'use strict';

	var onlyNumericOnKeypress = function onlyNumericOnKeypress(ev, optional_value) {
	    var key = ev.which;
	    var char = String.fromCharCode(key);
	    var array_of_char = [8, 37, 39, 46]; // delete, backspace, arrow keys
	    if (optional_value && optional_value.length > 0) {
	        array_of_char = array_of_char.concat(optional_value);
	    }
	    if (char === '.' && ev.target.value.indexOf(char) >= 0 || !/[0-9\.]/.test(char) && array_of_char.indexOf(key) < 0 || /['%]/.test(char)) {
	        // similarity to arrows key code in some browsers
	        ev.returnValue = false;
	        ev.preventDefault();
	    }
	};

	module.exports = onlyNumericOnKeypress;

/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var localize = __webpack_require__(428).localize;
	var clearable = __webpack_require__(417).clearable;
	var checkInput = __webpack_require__(430).checkInput;
	var padLeft = __webpack_require__(449).padLeft;

	var TimePicker = function () {
	    'use strict';

	    var time_pickers = {};

	    var init = function init(options) {
	        hide(options.selector);
	        time_pickers[options.selector] = {};

	        config(options);
	        $(window).resize(function () {
	            checkWidth(options.selector);
	        });
	    };

	    var hide = function hide(selector) {
	        $(selector).timepicker('destroy').removeAttr('data-picker').off('keydown');
	    };

	    var create = function create(selector) {
	        var $this = void 0;
	        $(selector).keydown(function (e) {
	            if (e.which === 13) {
	                $this = $(this);
	                e.preventDefault();
	                e.stopPropagation();
	                $this.timepicker('setTime', $this.val());
	                $this.timepicker('hide');
	                $this.blur();
	                return false;
	            }
	            return true;
	        }).timepicker(time_pickers[selector].config_data);
	    };

	    var timeNow = function timeNow() {
	        return moment.utc(window.time);
	    };

	    var config = function config(options) {
	        var time_now = timeNow();

	        var obj_config = {
	            hourText: localize('Hour'),
	            minuteText: localize('Minute'),
	            amPmText: localize(['AM', 'PM'])
	        };

	        if (options.minTime) {
	            options.minTime = options.minTime === 'now' ? time_now : moment.utc(options.minTime);
	            if (options.minTime.isBefore(time_now)) {
	                options.minTime = time_now;
	            }
	            obj_config.minTime = { hour: parseInt(options.minTime.hour()), minute: parseInt(options.minTime.minute()) };
	        }

	        if (options.maxTime) {
	            options.maxTime = moment.utc(options.maxTime);
	            obj_config.maxTime = { hour: parseInt(options.maxTime.hour()), minute: parseInt(options.maxTime.minute()) };
	        }

	        var $this = void 0;
	        obj_config.onSelect = function (time) {
	            $this = $(this);
	            var this_selector = '#' + $this.attr('id');
	            var old_value = $(this_selector).attr('data-value');

	            if (old_value && old_value === time) return false;

	            var new_time = void 0;
	            if (!time.match(/^(:?[0-3]\d):(:?[0-5]\d):(:?[0-5]\d)$/)) {
	                time_now = timeNow();
	                var invalid = time.match(/([a-z0-9]*):([a-z0-9]*):?([a-z0-9]*)?/);
	                var hour = time_now.format('hh'),
	                    minute = time_now.format('mm'),
	                    second = time_now.format('ss');

	                if (typeof invalid[1] !== 'undefined' && isFinite(invalid[1])) hour = formatTime(invalid[1]);
	                if (typeof invalid[2] !== 'undefined' && isFinite(invalid[2])) minute = formatTime(invalid[2]);
	                if (typeof invalid[3] !== 'undefined' && isFinite(invalid[3])) second = formatTime(invalid[3]);

	                new_time = moment(time_now.format('YYYY-MM-DD') + ' ' + [hour, minute, second].join(':')).format('HH:mm');

	                if (old_value && old_value === new_time) return false;
	                $this.val(new_time);
	            }
	            $this.attr('data-value', new_time || time);
	            $(this_selector).trigger('change', [new_time || time]);

	            if ($this.hasClass('clearable')) {
	                clearable($this);
	            }

	            return true;
	        };

	        time_pickers[options.selector].config_data = obj_config;

	        checkWidth(options.selector);
	    };

	    var formatTime = function formatTime(time) {
	        return padLeft(time, 2, '0');
	    };

	    var toTime = function toTime(time) {
	        return [formatTime(time.hour), formatTime(time.minute), '00'].join(':');
	    };

	    var checkWidth = function checkWidth(selector) {
	        var $selector = $(selector);
	        var time_picker_conf = time_pickers[selector].config_data;
	        if ($(window).width() < 770 && checkInput('time', 'not-a-time') && $selector.attr('data-picker') !== 'native') {
	            hide(selector);
	            $selector.attr({ type: 'time', 'data-picker': 'native' }).removeAttr('readonly');

	            var minTime = time_picker_conf.minTime;
	            if (minTime) $selector.attr('min', toTime(minTime));

	            var maxTime = time_picker_conf.maxTime;
	            if (maxTime) $selector.attr('max', toTime(maxTime));
	            return;
	        }
	        if ($(window).width() > 769 && $selector.attr('data-picker') !== 'jquery' || $(window).width() < 770 && !checkInput('time', 'not-a-time')) {
	            $selector.attr({ type: 'text', 'data-picker': 'jquery', readonly: 'readonly' });
	            $selector.removeAttr('min max');
	            create(selector);
	        }
	    };

	    return {
	        init: init
	    };
	}();

	module.exports = TimePicker;

/***/ },
/* 529 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Defaults = __webpack_require__(437);
	var Client = __webpack_require__(420);
	var formatCurrency = __webpack_require__(433).formatCurrency;

	/*
	 * Handles currency display
	 *
	 * It process 'socket.send({payout_currencies:1})` response
	 * and display them
	 */
	var displayCurrencies = function displayCurrencies() {
	    'use strict';

	    var target = document.getElementById('currency');
	    var fragment = document.createDocumentFragment();
	    var currencies = Client.get('currencies').split(',');

	    if (!target) {
	        return;
	    }

	    while (target && target.firstChild) {
	        target.removeChild(target.firstChild);
	    }

	    if (currencies.length > 1) {
	        currencies.forEach(function (currency) {
	            var option = document.createElement('option');
	            var content = document.createTextNode(currency);

	            option.setAttribute('value', currency);

	            option.appendChild(content);
	            fragment.appendChild(option);
	        });

	        target.appendChild(fragment);
	        Defaults.set('currency', target.value);
	    } else {
	        $('#currency').replaceWith($('<span/>', { id: target.getAttribute('id'), class: target.getAttribute('class'), value: currencies[0], text: formatCurrency(currencies[0]) }));
	        Defaults.set('currency', currencies[0]);
	    }
	};

	module.exports = displayCurrencies;

/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var localize = __webpack_require__(428).localize;
	var EnjoyHint = __webpack_require__(531);
	var Cookies = __webpack_require__(422);

	/*
	 *  This is developed to simplify the usage of enjoyhint (https://github.com/xbsoftware/enjoyhint)
	 *
	 *  How to Implement in a page:
	 *  1. Add the button element to the template: <div id="guideBtn"></div>
	 *  2. Add the js initialization call, having the customized parameters: Guide.init({script : 'trading'});
	 *  3. Add the script data to getScript() method
	 */

	var Guide = function () {
	    var opt = void 0,
	        cookie_name = void 0,
	        btn_next = void 0,
	        btn_finish = void 0;

	    var init = function init(options) {
	        opt = {
	            script: '', // the script name in scripts
	            autoStart: false, // false: start by button click
	            guideBtnID: '#guideBtn',
	            btnText: localize('Walkthrough Guide'), // guide start button's text
	            blink_class: 'highlight',
	            blink_inDelay: 1000,
	            blink_outDelay: 1000,
	            blink_interval: 3000, // 0: continous blinking (blink_inDelay + blink_outDelay)
	            blink_count: 0 };
	        $.extend(true, opt, options);

	        cookie_name = 'hide_guide';
	        btn_next = { className: 'button', html: $('<span/>', { text: localize('Next') }) };
	        btn_finish = { className: 'button btnFinish', html: $('<span/>', { text: localize('Finish') }) };

	        if ($(opt.guideBtnID).length === 0) {
	            console.warn('Could not find the button placeholder: <div id="' + opt.guideBtnID + '"></div>');
	            return;
	        }

	        if (opt.script.length === 0) {
	            console.warn('"script" name should be specified');
	            return;
	        }

	        if (isDisabled()) {
	            $(opt.guideBtnID).remove();
	            return;
	        }

	        makeButton();
	    };

	    /*
	     *  do not show the guide button if its close (X) has been clicked before
	     */
	    var isDisabled = function isDisabled() {
	        var disabled = Cookies.get(cookie_name);
	        return !!disabled && $.inArray(opt.script, disabled.split(',')) >= 0;
	    };

	    /*
	     *  handle the guide button appearance using a cookie for all scripts
	     */
	    var setDisabled = function setDisabled() {
	        if (!isDisabled()) {
	            var disabled = Cookies.get(cookie_name);
	            Cookies.set(cookie_name, !disabled ? opt.script : disabled + ',' + opt.script);
	        }
	    };

	    /*
	     *  generate the button's html
	     */
	    var makeButton = function makeButton() {
	        if ($(opt.guideBtnID).children().length > 0) {
	            return;
	        }

	        $(opt.guideBtnID).addClass('gr-hide-m pulser').append($('<span/>', { class: 'close', text: 'X' })).append($('<strong/>'));
	        $(opt.guideBtnID + ' strong').html('<span></span>' + opt.btnText);

	        setEvents();
	    };

	    /*
	     *  both buttons' click event
	     */
	    var setEvents = function setEvents() {
	        $(opt.guideBtnID + ' strong').click(function () {
	            var enjoyhint_instance = new EnjoyHint({});
	            enjoyhint_instance.setScript(getScript(opt.script));
	            enjoyhint_instance.runScript();
	        });

	        if (opt.autoStart) {
	            $(opt.guideBtnID).click();
	        }

	        // Hide button
	        $(opt.guideBtnID + ' span.close').click(function () {
	            setDisabled();
	            $(opt.guideBtnID).remove();
	        });
	    };

	    /*
	     *  each page's script
	     */
	    var getScript = function getScript(script_name) {
	        if (script_name !== 'trading') {
	            return null;
	        }
	        return [{
	            selector: '#contract_markets',
	            description: '<h1>' + localize('Step') + ' 1</h1>' + localize('Select your market'),
	            event_type: 'next',
	            nextButton: btn_next
	        }, {
	            selector: '#underlying',
	            description: '<h1>' + localize('Step') + ' 2</h1>' + localize('Select your underlying asset'),
	            event_type: 'next',
	            nextButton: btn_next
	        }, {
	            selector: '#contract_form_name_nav',
	            description: '<h1>' + localize('Step') + ' 3</h1>' + localize('Select your trade type'),
	            event_type: 'next',
	            nextButton: btn_next
	        }, {
	            selector: '#websocket_form',
	            description: '<h1>' + localize('Step') + ' 4</h1>' + localize('Adjust trade parameters'),
	            event_type: 'next',
	            nextButton: btn_next
	        }, {
	            selector: '#contracts_list',
	            description: '<h1>' + localize('Step') + ' 5</h1>' + localize('Predict the direction<br />and purchase'),
	            event_type: 'next',
	            nextButton: btn_finish
	        }];
	    };

	    return {
	        init: init
	    };
	}();

	module.exports = Guide;

/***/ },
/* 531 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	// https://github.com/xbsoftware/enjoyhint
	// (+ some custom changes for binary.com)

	var $ = __webpack_require__(1);
	var Kinetic = __webpack_require__(532);

	module.exports = function (_options) {
	    var that = this;
	    // Some options
	    var defaults = {
	        onStart: function onStart() {},
	        onEnd: function onEnd() {}
	    };
	    var options = $.extend(defaults, _options);

	    var data = [];
	    var current_step = 0;

	    $body = $('body');

	    /********************* PRIVAT METHODS ***************************************/
	    var init = function init() {
	        if ($('.enjoyhint')) $('.enjoyhint').remove();
	        $("html, body").css({ 'overflow': 'hidden' });
	        $(document).on("touchmove", lockTouch);

	        $body.enjoyhint({
	            onNextClick: function onNextClick() {
	                current_step++;
	                stepAction();
	            },
	            onSkipClick: function onSkipClick() {
	                var step_data = data[current_step];
	                var $element = $(step_data.selector);
	                off(step_data.event);
	                $element.off(makeEventName(step_data.event));
	                destroyEnjoy();
	            }
	        });
	    };

	    var lockTouch = function lockTouch(e) {
	        e.preventDefault();
	    };

	    var destroyEnjoy = function destroyEnjoy() {
	        $body = $('body');
	        $('.enjoyhint').remove();
	        $("html, body").css({ 'overflow': 'auto' });
	        $("html, body").css({ 'overflow-x': 'hidden' });
	        $(document).off("touchmove", lockTouch);
	    };

	    that.clear = function () {
	        //Remove userClass and set default text
	        $(".enjoyhint_next_btn").removeClass(that.nextUserClass);
	        $(".enjoyhint_next_btn").text("Next");
	        $(".enjoyhint_skip_btn").removeClass(that.skipUserClass);
	        $(".enjoyhint_skip_btn").text("Skip");
	    };

	    var $body = $('body');
	    var stepAction = function stepAction() {
	        if (data && data[current_step]) {
	            $(".enjoyhint").removeClass("enjoyhint-step-" + current_step);
	            $(".enjoyhint").addClass("enjoyhint-step-" + (current_step + 1));
	            var step_data = data[current_step];
	            if (step_data.onBeforeStart && typeof step_data.onBeforeStart === 'function') {
	                step_data.onBeforeStart();
	            }
	            var timeout = step_data.timeout || 0;
	            setTimeout(function () {
	                if (!step_data.selector) {
	                    for (var prop in step_data) {
	                        if (step_data.hasOwnProperty(prop) && prop.split(" ")[1]) {
	                            step_data.selector = prop.split(" ")[1];
	                            step_data.event = prop.split(" ")[0];
	                            if (prop.split(" ")[0] == 'next' || prop.split(" ")[0] == 'auto' || prop.split(" ")[0] == 'custom') {
	                                step_data.event_type = prop.split(" ")[0];
	                            }
	                            step_data.description = step_data[prop];
	                        }
	                    }
	                }
	                setTimeout(function () {
	                    that.clear();
	                }, 250);
	                $(document.body).scrollTo(step_data.selector, step_data.scrollAnimationSpeed || 250, { offset: -100 });
	                setTimeout(function () {
	                    var $element = $(step_data.selector);
	                    var event = makeEventName(step_data.event);

	                    $body.enjoyhint('show');
	                    $body.enjoyhint('hide_next');
	                    var $event_element = $element;
	                    if (step_data.event_selector) {
	                        $event_element = $(step_data.event_selector);
	                    }
	                    if (!step_data.event_type && step_data.event == "key") {
	                        $element.keydown(function (event) {
	                            if (event.which == step_data.keyCode) {
	                                current_step++;
	                                stepAction();
	                            }
	                        });
	                    }
	                    if (step_data.showNext == true) {
	                        $body.enjoyhint('show_next');
	                    }
	                    if (step_data.showSkip == true) {
	                        $body.enjoyhint('show_skip');
	                    } else {
	                        $body.enjoyhint('hide_skip');
	                    }
	                    if (step_data.showSkip == true) {}

	                    if (step_data.nextButton) {
	                        $(".enjoyhint_next_btn").addClass(step_data.nextButton.className || "");
	                        $(".enjoyhint_next_btn").html(step_data.nextButton.html || "Next");
	                        that.nextUserClass = step_data.nextButton.className;
	                    }

	                    if (step_data.skipButton) {
	                        $(".enjoyhint_skip_btn").addClass(step_data.skipButton.className || "");
	                        $(".enjoyhint_skip_btn").html(step_data.skipButton.html || "Skip");
	                        that.skipUserClass = step_data.skipButton.className;
	                    }

	                    if (step_data.event_type) {
	                        switch (step_data.event_type) {
	                            case 'auto':
	                                $element[step_data.event]();
	                                switch (step_data.event) {
	                                    case 'click':
	                                        break;
	                                }
	                                current_step++;
	                                stepAction();
	                                return;
	                                break;
	                            case 'custom':
	                                on(step_data.event, function () {
	                                    current_step++;
	                                    off(step_data.event);
	                                    stepAction();
	                                });
	                                break;
	                            case 'next':
	                                $body.enjoyhint('show_next');
	                                break;

	                        }
	                    } else {
	                        $event_element.on(event, function (e) {
	                            if (step_data.keyCode && e.keyCode != step_data.keyCode) {
	                                return;
	                            }
	                            current_step++;
	                            $(this).off(event);

	                            stepAction();
	                        });
	                    }
	                    var max_habarites = Math.max($element.outerWidth(), $element.outerHeight());
	                    var radius = step_data.radius || Math.round(max_habarites / 2) + 5;
	                    var offset = $element.offset();
	                    var w = $element.outerWidth();
	                    var h = $element.outerHeight();
	                    var shape_margin = step_data.margin !== undefined ? step_data.margin : 10;
	                    var coords = {
	                        x: offset.left + Math.round(w / 2),
	                        y: offset.top + Math.round(h / 2) - $(document).scrollTop()
	                    };
	                    var shape_data = {
	                        center_x: coords.x,
	                        center_y: coords.y,
	                        text: step_data.description,
	                        top: step_data.top,
	                        bottom: step_data.bottom,
	                        left: step_data.left,
	                        right: step_data.right,
	                        margin: step_data.margin,
	                        scroll: step_data.scroll
	                    };

	                    if (step_data.shape && step_data.shape == 'circle') {
	                        shape_data.shape = 'circle';
	                        shape_data.radius = radius;
	                    } else {
	                        shape_data.radius = 0;
	                        shape_data.width = w + shape_margin;
	                        shape_data.height = h + shape_margin;
	                    }
	                    $body.enjoyhint('render_label_with_shape', shape_data);
	                }, step_data.scrollAnimationSpeed + 20 || 270);
	            }, timeout);
	        } else {
	            $body.enjoyhint('hide');
	            options.onEnd();
	            destroyEnjoy();
	        }
	    };

	    var makeEventName = function makeEventName(name, is_custom) {
	        return name + (is_custom ? 'custom' : '') + '.enjoy_hint';
	    };

	    var on = function on(event_name, callback) {
	        $body.on(makeEventName(event_name, true), callback);
	    };
	    var off = function off(event_name) {
	        $body.off(makeEventName(event_name, true));
	    };

	    /********************* PUBLIC METHODS ***************************************/
	    that.runScript = function () {
	        current_step = 0;
	        options.onStart();
	        stepAction();
	    };

	    that.resumeScript = function () {
	        stepAction();
	    };

	    that.getCurrentStep = function () {
	        return current_step;
	    };

	    that.trigger = function (event_name) {
	        $body.trigger(makeEventName(event_name, true));
	    };

	    that.setScript = function (_data) {
	        if (_data) {
	            data = _data;
	        }
	    };

	    //support deprecated API methods
	    that.set = function (_data) {
	        that.setScript(_data);
	    };

	    that.setSteps = function (_data) {
	        that.setScript(_data);
	    };

	    that.run = function () {
	        that.runScript();
	    };

	    that.resume = function () {
	        that.resumeScript();
	    };

	    init();
	};

	if (typeof CanvasRenderingContext2D !== 'undefined') {
	    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
	        if (w < 2 * r) r = w / 2;
	        if (h < 2 * r) r = h / 2;
	        this.beginPath();
	        this.moveTo(x + r, y);
	        this.arcTo(x + w, y, x + w, y + h, r);
	        this.arcTo(x + w, y + h, x, y + h, r);
	        this.arcTo(x, y + h, x, y, r);
	        this.arcTo(x, y, x + w, y, r);
	        this.closePath();
	        return this;
	    };
	}

	var methods = {
	    init: function init(options) {
	        //console.log(options,'-------------');
	        return this.each(function () {
	            var defaults = {
	                onNextClick: function onNextClick() {},
	                onSkipClick: function onSkipClick() {},
	                animation_time: 800
	            };

	            this.enjoyhint_obj = {};
	            var that = this.enjoyhint_obj;
	            var $that = $(this);
	            var $body = $('body');
	            that.options = jQuery.extend(defaults, options);

	            //general classes
	            that.gcl = {
	                chooser: 'enjoyhint'
	            };

	            // classes
	            that.cl = {
	                enjoy_hint: 'enjoyhint',
	                hide: 'enjoyhint_hide',
	                disable_events_element: 'enjoyhint_disable_events',
	                btn: 'enjoyhint_btn',
	                skip_btn: 'enjoyhint_skip_btn',
	                close_btn: 'enjoyhint_close_btn',
	                next_btn: 'enjoyhint_next_btn',
	                main_canvas: 'enjoyhint_canvas',
	                main_svg: 'enjoyhint_svg',
	                svg_wrapper: 'enjoyhint_svg_wrapper',
	                svg_transparent: 'enjoyhint_svg_transparent',
	                kinetic_container: 'kinetic_container'
	            };
	            function makeSVG(tag, attrs) {
	                var el = document.createElementNS('http://www.w3.org/2000/svg', tag);
	                for (var k in attrs) {
	                    el.setAttribute(k, attrs[k]);
	                }return el;
	            }

	            // =======================================================================
	            // ========================---- enjoyhint ----==============================
	            // =======================================================================
	            that.canvas_size = {
	                w: $(window).width() * 1.4,
	                h: $(window).height() * 1.4
	            };
	            var canvas_id = "enj_canvas";

	            that.enjoyhint = $('<div>', { 'class': that.cl.enjoy_hint + ' ' + that.cl.svg_transparent }).appendTo($that);
	            that.enjoyhint_svg_wrapper = $('<div>', { 'class': that.cl.svg_wrapper + ' ' + that.cl.svg_transparent }).appendTo(that.enjoyhint);
	            that.$stage_container = $('<div id="' + that.cl.kinetic_container + '">').appendTo(that.enjoyhint);
	            that.$canvas = $('<canvas id="' + canvas_id + '" width="' + that.canvas_size.w + '" height="' + that.canvas_size.h + '" class="' + that.cl.main_canvas + '">').appendTo(that.enjoyhint);
	            that.$svg = $('<svg width="' + that.canvas_size.w + '" height="' + that.canvas_size.h + '" class="' + that.cl.main_canvas + ' ' + that.cl.main_svg + '">').appendTo(that.enjoyhint_svg_wrapper);
	            var defs = $(makeSVG('defs'));
	            var marker = $(makeSVG('marker', { id: "arrowMarker", viewBox: "0 0 36 21", refX: "21", refY: "10", markerUnits: "strokeWidth", orient: "auto", markerWidth: "16", markerHeight: "12" }));
	            var polilyne = $(makeSVG('path', { style: "fill:none; stroke:rgb(255,255,255); stroke-width:2", d: "M0,0 c30,11 30,9 0,20" }));
	            defs.append(marker.append(polilyne)).appendTo(that.$svg);
	            that.kinetic_stage = new Kinetic.Stage({
	                container: that.cl.kinetic_container,
	                width: that.canvas_size.w,
	                height: that.canvas_size.h
	            });
	            //console.log(that.enjoyhint);

	            that.layer = new Kinetic.Layer();
	            that.rect = new Kinetic.Rect({
	                //          x: 0,
	                //          y: 0,
	                fill: 'rgba(0,0,0,0.6)',
	                width: that.canvas_size.w,
	                height: that.canvas_size.h
	            });

	            var $top_dis_events = $('<div>', { 'class': that.cl.disable_events_element }).appendTo(that.enjoyhint);
	            var $bottom_dis_events = $top_dis_events.clone().appendTo(that.enjoyhint);
	            var $left_dis_events = $top_dis_events.clone().appendTo(that.enjoyhint);
	            var $right_dis_events = $top_dis_events.clone().appendTo(that.enjoyhint);

	            that.$skip_btn = $('<div>', { 'class': that.cl.skip_btn }).appendTo(that.enjoyhint).html('Skip').click(function (e) {
	                that.hide();
	                that.options.onSkipClick();
	            });
	            that.$next_btn = $('<div>', { 'class': that.cl.next_btn }).appendTo(that.enjoyhint).html('Next').click(function (e) {
	                that.options.onNextClick();
	            });

	            that.$close_btn = $('<div>', { 'class': that.cl.close_btn }).appendTo(that.enjoyhint).html('').click(function (e) {
	                that.hide();
	                that.options.onSkipClick();
	            });

	            that.$canvas.mousedown(function (e) {
	                //console.log('cl')
	                $('canvas').css({ left: '4000px' });

	                var BottomElement = document.elementFromPoint(e.clientX, e.clientY);
	                //console.log(BottomElement.tagName)
	                $('canvas').css({ left: '0' });

	                $(BottomElement).click();
	                //          that.$canvas.show();
	                return false;
	            });

	            var circle_r = 0;
	            var shape_init_shift = 130;
	            that.shape = new Kinetic.Shape({
	                radius: circle_r,
	                center_x: -shape_init_shift,
	                center_y: -shape_init_shift,
	                width: 0,
	                height: 0,
	                sceneFunc: function sceneFunc(context) {
	                    var ctx = this.getContext("2d")._context;
	                    var pos = this.pos;
	                    var def_comp = ctx.globalCompositeOperation;
	                    ctx.globalCompositeOperation = 'destination-out';
	                    ctx.beginPath();

	                    var x = this.attrs.center_x - Math.round(this.attrs.width / 2);
	                    var y = this.attrs.center_y - Math.round(this.attrs.height / 2);
	                    ctx.roundRect(x, y, this.attrs.width, this.attrs.height, this.attrs.radius);
	                    ctx.fillStyle = "red";
	                    ctx.fill();

	                    ctx.globalCompositeOperation = def_comp;
	                }
	            });
	            that.shape.radius = circle_r;
	            that.layer.add(that.rect);
	            that.layer.add(that.shape);
	            that.kinetic_stage.add(that.layer);

	            var enjoyhint_elements = [that.enjoyhint, $top_dis_events, $bottom_dis_events, $left_dis_events, $right_dis_events];

	            that.show = function () {
	                that.enjoyhint.removeClass(that.cl.hide);
	            };

	            that.hide = function () {
	                that.enjoyhint.addClass(that.cl.hide);
	                var tween = new Kinetic.Tween({
	                    node: that.shape,
	                    duration: 0.002,
	                    center_x: -shape_init_shift,
	                    center_y: -shape_init_shift
	                });
	                tween.play();
	            };

	            that.hide();

	            that.hideNextBtn = function () {
	                that.$next_btn.addClass(that.cl.hide);
	                that.nextBtn = "hide";
	            };
	            that.showNextBtn = function () {
	                that.$next_btn.removeClass(that.cl.hide);
	                that.nextBtn = "show";
	            };

	            that.hideSkipBtn = function () {
	                that.$skip_btn.addClass(that.cl.hide);
	            };
	            that.showSkipBtn = function () {
	                that.$skip_btn.removeClass(that.cl.hide);
	            };

	            that.renderCircle = function (data) {
	                var r = data.r || 0;
	                var x = data.x || 0;
	                var y = data.y || 0;

	                var tween = new Kinetic.Tween({
	                    node: that.shape,
	                    duration: 0.2,
	                    center_x: x,
	                    center_y: y,
	                    width: r * 2,
	                    height: r * 2,
	                    radius: r
	                });
	                tween.play();

	                var left = x - r;
	                var right = x + r;
	                var top = y - r;
	                var bottom = y + r;
	                var margin = 20;
	                return {
	                    x: x,
	                    y: y,
	                    left: left,
	                    right: right,
	                    top: top,
	                    bottom: bottom,
	                    conn: {
	                        left: {
	                            x: left - margin,
	                            y: y
	                        },
	                        right: {
	                            x: right + margin,
	                            y: y
	                        },
	                        top: {
	                            x: x,
	                            y: top - margin
	                        },
	                        bottom: {
	                            x: x,
	                            y: bottom + margin
	                        }
	                    }
	                };
	            };

	            that.renderRect = function (data) {
	                var r = data.r || 0;
	                var x = data.x || 0;
	                var y = data.y || 0;
	                var w = data.w || 0;
	                var h = data.h || 0;
	                var margin = 20;
	                var tween = new Kinetic.Tween({
	                    node: that.shape,
	                    duration: 0.2,
	                    center_x: x,
	                    center_y: y,
	                    width: w,
	                    height: h,
	                    radius: r
	                });
	                tween.play();
	                var half_w = Math.round(w / 2);
	                var half_h = Math.round(h / 2);
	                var left = x - half_w;
	                var right = x + half_w;
	                var top = y - half_h;
	                var bottom = y + half_h;
	                return {
	                    x: x,
	                    y: y,
	                    left: left,
	                    right: right,
	                    top: top,
	                    bottom: bottom,
	                    conn: {
	                        left: {
	                            x: left - margin,
	                            y: y
	                        },
	                        right: {
	                            x: right + margin,
	                            y: y
	                        },
	                        top: {
	                            x: x,
	                            y: top - margin
	                        },
	                        bottom: {
	                            x: x,
	                            y: bottom + margin
	                        }
	                    }
	                };
	            };
	            that.renderLabel = function (data) {
	                var x = data.x || 0;
	                var y = data.y || 0;
	                var text = data.text || 0;

	                var label = that.getLabelElement({
	                    x: x,
	                    y: y,
	                    text: data.text
	                });
	                var label_w = label.width();
	                var label_h = label.height();
	                var label_left = label.offset().left;
	                var label_right = label.offset().left + label_w;
	                var label_top = label.offset().top - $(document).scrollTop();;
	                var label_bottom = label.offset().top + label_h;

	                var margin = 10;
	                var conn_left = {
	                    x: label_left - margin,
	                    y: label_top + Math.round(label_h / 2)
	                };
	                var conn_right = {
	                    x: label_right + margin,
	                    y: label_top + Math.round(label_h / 2)
	                };
	                var conn_top = {
	                    x: label_left + Math.round(label_w / 2),
	                    y: label_top - margin
	                };
	                var conn_bottom = {
	                    x: label_left + Math.round(label_w / 2),
	                    y: label_bottom + margin
	                };
	                label.detach();
	                setTimeout(function () {
	                    $('#enjoyhint_label').remove();
	                    label.appendTo(that.enjoyhint);
	                }, that.options.animation_time / 2);
	                return {
	                    label: label,
	                    left: label_left,
	                    right: label_right,
	                    top: label_top,
	                    bottom: label_bottom,
	                    conn: {
	                        left: conn_left,
	                        right: conn_right,
	                        top: conn_top,
	                        bottom: conn_bottom
	                    }

	                };
	            };
	            that.renderArrow = function (data) {
	                var x_from = data.x_from || 0;
	                var y_from = data.y_from || 0;
	                var x_to = data.x_to || 0;
	                var y_to = data.y_to || 0;
	                var by_top_side = data.by_top_side;
	                var control_point_x = 0;
	                var control_point_y = 0;
	                if (by_top_side) {
	                    if (y_from >= y_to) {
	                        control_point_y = y_to;
	                        control_point_x = x_from;
	                    } else {
	                        control_point_y = y_from;
	                        control_point_x = x_to;
	                    }
	                } else {
	                    if (y_from >= y_to) {
	                        control_point_y = y_from;
	                        control_point_x = x_to;
	                    } else {
	                        control_point_y = y_to;
	                        control_point_x = x_from;
	                    }
	                }

	                var text = data.text || '';
	                that.enjoyhint.addClass(that.cl.svg_transparent);
	                setTimeout(function () {
	                    $('#enjoyhint_arrpw_line').remove();
	                    var d = 'M' + x_from + ',' + y_from + ' Q' + control_point_x + ',' + control_point_y + ' ' + x_to + ',' + y_to;
	                    that.$svg.append(makeSVG('path', { style: "fill:none; stroke:rgb(255,255,255); stroke-width:3", 'marker-end': "url(#arrowMarker)", d: d, id: 'enjoyhint_arrpw_line' }));
	                    that.enjoyhint.removeClass(that.cl.svg_transparent);
	                }, that.options.animation_time / 2);
	            };

	            that.getLabelElement = function (data) {
	                return $('<div>', { "class": 'enjoy_hint_label', id: 'enjoyhint_label' }).css({
	                    'top': data.y + 'px',
	                    'left': data.x + 'px'
	                }).html(data.text).appendTo(that.enjoyhint);
	            };

	            that.disableEventsNearRect = function (rect) {
	                $top_dis_events.css({
	                    top: '0',
	                    left: '0'
	                }).height(rect.top);
	                $bottom_dis_events.css({
	                    top: rect.bottom + 'px',
	                    left: '0'
	                });
	                $left_dis_events.css({
	                    top: '0',
	                    left: 0 + 'px'
	                }).width(rect.left);
	                $right_dis_events.css({
	                    top: '0',
	                    left: rect.right + 'px'
	                });
	            };

	            that.renderLabelWithShape = function (data) {
	                var shape_type = data.shape || 'rect';
	                var shape_data = {};

	                var half_w = 0;
	                var half_h = 0;

	                var shape_offsets = {
	                    top: data.top || 0,
	                    bottom: data.bottom || 0,
	                    left: data.left || 0,
	                    right: data.right || 0
	                };

	                switch (shape_type) {
	                    case 'circle':
	                        half_w = half_h = data.radius;
	                        var sides_pos = {
	                            top: data.center_y - half_h + shape_offsets.top,
	                            bottom: data.center_y + half_h - shape_offsets.bottom,
	                            left: data.center_x - half_w + shape_offsets.left,
	                            right: data.center_x + half_w - shape_offsets.right
	                        };
	                        var width = sides_pos.right - sides_pos.left;
	                        var height = sides_pos.bottom - sides_pos.top;
	                        data.radius = Math.round(Math.min(width, height) / 2);
	                        //new half habarites
	                        half_w = half_h = Math.round(data.radius / 2);

	                        var new_half_w = Math.round(width / 2);
	                        var new_half_h = Math.round(height / 2);
	                        //new center_x and center_y
	                        data.center_x = sides_pos.left + new_half_w;
	                        data.center_y = sides_pos.top + new_half_h;

	                        shape_data = that.renderCircle({
	                            x: data.center_x,
	                            y: data.center_y,
	                            r: data.radius
	                        });

	                        break;
	                    case 'rect':
	                        half_w = Math.round(data.width / 2);
	                        half_h = Math.round(data.height / 2);

	                        var sides_pos = {
	                            top: data.center_y - half_h + shape_offsets.top,
	                            bottom: data.center_y + half_h - shape_offsets.bottom,
	                            left: data.center_x - half_w + shape_offsets.left,
	                            right: data.center_x + half_w - shape_offsets.right
	                        };
	                        data.width = sides_pos.right - sides_pos.left;
	                        data.height = sides_pos.bottom - sides_pos.top;

	                        half_w = Math.round(data.width / 2);
	                        half_h = Math.round(data.height / 2);
	                        //new center_x and center_y
	                        data.center_x = sides_pos.left + half_w;
	                        data.center_y = sides_pos.top + half_h;
	                        shape_data = that.renderRect({
	                            x: data.center_x,
	                            y: data.center_y,
	                            w: data.width,
	                            h: data.height,
	                            r: data.radius
	                        });
	                        break;
	                }

	                var body_size = {
	                    w: that.enjoyhint.width(),
	                    h: that.enjoyhint.height()
	                };
	                //temp label used for detect label width and height
	                var label = that.getLabelElement({
	                    x: 0,
	                    y: 0,
	                    text: data.text
	                });
	                var label_width = label.outerWidth();
	                var label_height = label.outerHeight();
	                label.remove();
	                var top_offset = data.center_y - half_h;
	                var bottom_offset = body_size.h - (data.center_y + half_h);
	                var left_offset = data.center_x - half_w;
	                var right_offset = body_size.w - (data.center_x + half_w);

	                var label_hor_side = body_size.w - data.center_x < data.center_x ? 'left' : 'right';
	                var label_ver_side = body_size.h - data.center_y < data.center_y ? 'top' : 'bottom';
	                var label_shift = 150;
	                var label_margin = 40;
	                var label_shift_with_label_width = label_shift + label_width + label_margin;
	                var label_shift_with_label_height = label_shift + label_height + label_margin;
	                var label_hor_offset = half_w + label_shift;
	                var label_ver_offset = half_h + label_shift;

	                var label_x = label_hor_side == 'left' ? data.center_x - label_hor_offset - label_width : data.center_x + label_hor_offset;
	                var label_y = label_ver_side == 'top' ? data.center_y - label_ver_offset - label_height : data.center_y + label_ver_offset;
	                if (top_offset < label_shift_with_label_height && bottom_offset < label_shift_with_label_height) {
	                    label_y = data.center_y + label_margin;
	                }
	                if (left_offset < label_shift_with_label_width && right_offset < label_shift_with_label_width) {
	                    label_x = data.center_x;
	                }

	                var label_data = that.renderLabel({
	                    x: label_x,
	                    y: label_y,
	                    text: data.text
	                });

	                that.$next_btn.css({
	                    left: label_x,
	                    top: label_y + label_height + 15
	                });
	                var left_skip = label_x + that.$next_btn.width() + 10;
	                //console.log(that.nextBtn);
	                if (that.nextBtn == "hide") {
	                    left_skip = label_x;
	                }

	                that.$skip_btn.css({
	                    left: left_skip,
	                    top: label_y + label_height + 15
	                });
	                that.$close_btn.css({
	                    right: 10,
	                    top: 10
	                });

	                that.disableEventsNearRect({
	                    top: shape_data.top,
	                    bottom: shape_data.bottom,
	                    left: shape_data.left,
	                    right: shape_data.right
	                });

	                var x_to = 0;
	                var y_to = 0;
	                var arrow_side = false;
	                var conn_label_side = 'left';
	                var conn_circle_side = 'left';

	                var is_center = label_data.left <= shape_data.x && label_data.right >= shape_data.x;
	                var is_left = label_data.right < shape_data.x;
	                var is_right = label_data.left > shape_data.x;

	                var is_abs_left = label_data.right < shape_data.left;
	                var is_abs_right = label_data.left > shape_data.right;

	                var is_top = label_data.bottom < shape_data.top;
	                var is_bottom = label_data.top > shape_data.bottom;
	                var is_mid = label_data.bottom >= shape_data.y && label_data.top <= shape_data.y;
	                var is_mid_top = label_data.bottom <= shape_data.y && !is_top;
	                var is_mid_bottom = label_data.top >= shape_data.y && !is_bottom;

	                function setArrowData(l_s, c_s, a_s) {
	                    conn_label_side = l_s;
	                    conn_circle_side = c_s;
	                    arrow_side = a_s;
	                }

	                function sideStatements(top_s, mid_top_s, mid_s, mid_bottom_s, bottom_s) {
	                    var statement = [];
	                    if (is_top) {
	                        statement = top_s;
	                    } else if (is_mid_top) {
	                        statement = mid_top_s;
	                    } else if (is_mid) {
	                        statement = mid_s;
	                    } else if (is_mid_bottom) {
	                        statement = mid_bottom_s;
	                    } else {
	                        //bottom
	                        statement = bottom_s;
	                    }
	                    if (!statement) {
	                        return;
	                    } else {
	                        setArrowData(statement[0], statement[1], statement[2]);
	                    }
	                }

	                if (is_center) {
	                    if (is_top) {
	                        setArrowData('bottom', 'top', 'top');
	                    } else if (is_bottom) {
	                        setArrowData('top', 'bottom', 'bottom');
	                    } else {
	                        return;
	                    }
	                } else if (is_left) {
	                    sideStatements(['right', 'top', 'top'], //top
	                    ['bottom', 'left', 'bottom'], //mid_top
	                    ['right', 'left', 'top'], //mid
	                    ['top', 'left', 'top'], //mid_bot
	                    ['right', 'bottom', 'bottom'] //bot
	                    );
	                } else {
	                    //right
	                    sideStatements(['left', 'top', 'top'], //top
	                    ['bottom', 'right', 'bottom'], //mid_top
	                    ['left', 'right', 'top'], //mid
	                    ['top', 'right', 'top'], //mid_bot
	                    ['left', 'bottom', 'bottom'] //bot
	                    );
	                }

	                var label_conn_coordinates = label_data.conn[conn_label_side];
	                var circle_conn_coordinates = shape_data.conn[conn_circle_side];
	                var by_top_side = arrow_side == 'top' ? true : false;
	                that.renderArrow({
	                    x_from: label_conn_coordinates.x,
	                    y_from: label_conn_coordinates.y,
	                    x_to: circle_conn_coordinates.x,
	                    y_to: circle_conn_coordinates.y,
	                    by_top_side: by_top_side
	                });
	            };

	            that.clear = function () {
	                that.ctx.clearRect(0, 0, 3000, 2000);
	            };

	            return this;
	        });
	    },

	    set: function set(val) {
	        this.each(function () {
	            this.enjoyhint_obj.setValue(val);
	        });
	        return this;
	    },

	    show: function show() {
	        this.each(function () {
	            this.enjoyhint_obj.show();
	        });
	        return this;
	    },

	    hide: function hide() {
	        this.each(function () {
	            this.enjoyhint_obj.hide();
	        });
	        return this;
	    },

	    hide_next: function hide_next() {
	        this.each(function () {
	            this.enjoyhint_obj.hideNextBtn();
	        });
	        return this;
	    },

	    show_next: function show_next() {
	        this.each(function () {
	            this.enjoyhint_obj.showNextBtn();
	        });
	        return this;
	    },

	    hide_skip: function hide_skip() {
	        this.each(function () {
	            this.enjoyhint_obj.hideSkipBtn();
	        });
	        return this;
	    },

	    show_skip: function show_skip() {
	        this.each(function () {
	            this.enjoyhint_obj.showSkipBtn();
	        });
	        return this;
	    },

	    render_circle: function render_circle(x, y, r) {
	        this.each(function () {
	            this.enjoyhint_obj.renderCircle(x, y, r);
	        });
	        return this;
	    },

	    render_label: function render_label(x, y, r) {
	        this.each(function () {
	            this.enjoyhint_obj.renderLabel(x, y, r);
	        });
	        return this;
	    },

	    render_label_with_shape: function render_label_with_shape(data) {
	        this.each(function () {
	            this.enjoyhint_obj.renderLabelWithShape(data);
	        });
	        return this;
	    },

	    clear: function clear() {
	        this.each(function () {
	            this.enjoyhint_obj.clear();
	        });
	        return this;
	    },

	    close: function close(val) {
	        this.each(function () {
	            this.enjoyhint_obj.closePopdown();
	        });
	        return this;
	    }
	};

	$.fn.enjoyhint = function (method) {
	    //console.log(method);
	    if (methods[method]) {
	        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
	    } else if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {
	        return methods.init.apply(this, arguments);
	    } else {
	        $.error('Method ' + method + ' does not exist on $.numinput');
	    }
	    return this;
	};

/***/ },
/* 532 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * KineticJS JavaScript Framework v5.2.0
	 * http://lavrton.github.io/KineticJS/
	 * Licensed under the MIT or GPL Version 2 licenses.
	 * Date: 2015-01-22
	 *
	 * Original work Copyright (C) 2011 - 2013 by Eric Rowell
	 * Modified work Copyright (C) 2014 - 2015 by Anton Lavrenov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	/**
	 * @namespace Kinetic
	 */
	/*jshint -W079, -W020*/
	var Kinetic = {};
	(function(root) {
	    var PI_OVER_180 = Math.PI / 180;

	    Kinetic = {
	        // public
	        version: '5.2.0',

	        // private
	        stages: [],
	        idCounter: 0,
	        ids: {},
	        names: {},
	        shapes: {},
	        listenClickTap: false,
	        inDblClickWindow: false,

	        // configurations
	        enableTrace: false,
	        traceArrMax: 100,
	        dblClickWindow: 400,
	        /**
	         * Global pixel ratio configuration. KineticJS automatically detect pixel ratio of current device.
	         * But you may override such property, if you want to use your value.
	         * @property pixelRatio
	         * @default undefined
	         * @memberof Kinetic
	         * @example
	         * Kinetic.pixelRatio = 1;
	         */
	        pixelRatio: undefined,
	        /**
	         * Drag distance property. If you start to drag a node you may want to wait until pointer is moved to some distance from start point,
	         * only then start dragging.
	         * @property dragDistance
	         * @default 0
	         * @memberof Kinetic
	         * @example
	         * Kinetic.dragDistance = 10;
	         */
	        dragDistance : 0,
	        /**
	         * Use degree values for angle properties. You may set this property to false if you want to use radiant values.
	         * @property angleDeg
	         * @default true
	         * @memberof Kinetic
	         * @example
	         * node.rotation(45); // 45 degrees
	         * Kinetic.angleDeg = false;
	         * node.rotation(Math.PI / 2); // PI/2 radian
	         */
	        angleDeg: true,
	         /**
	         * Show different warnings about errors or wrong API usage
	         * @property showWarnings
	         * @default true
	         * @memberof Kinetic
	         * @example
	         * Kinetic.showWarnings = false;
	         */
	        showWarnings : true,



	        /**
	         * @namespace Filters
	         * @memberof Kinetic
	         */
	        Filters: {},

	        /**
	         * Node constructor. Nodes are entities that can be transformed, layered,
	         * and have bound events. The stage, layers, groups, and shapes all extend Node.
	         * @constructor
	         * @memberof Kinetic
	         * @abstract
	         * @param {Object} config
	         * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	         */
	        Node: function(config) {
	            this._init(config);
	        },

	        /**
	         * Shape constructor.  Shapes are primitive objects such as rectangles,
	         *  circles, text, lines, etc.
	         * @constructor
	         * @memberof Kinetic
	         * @augments Kinetic.Node
	         * @param {Object} config
	         * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	         * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	         * @example
	         * var customShape = new Kinetic.Shape({
	         *   x: 5,
	         *   y: 10,
	         *   fill: 'red',
	         *   // a Kinetic.Canvas renderer is passed into the drawFunc function
	         *   drawFunc: function(context) {
	         *     context.beginPath();
	         *     context.moveTo(200, 50);
	         *     context.lineTo(420, 80);
	         *     context.quadraticCurveTo(300, 100, 260, 170);
	         *     context.closePath();
	         *     context.fillStrokeShape(this);
	         *   }
	         *});
	         */
	        Shape: function(config) {
	            this.__init(config);
	        },

	        /**
	         * Container constructor.&nbsp; Containers are used to contain nodes or other containers
	         * @constructor
	         * @memberof Kinetic
	         * @augments Kinetic.Node
	         * @abstract
	         * @param {Object} config
	         * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	         * * @param {Object} [config.clip] set clip
	     * @param {Number} [config.clipX] set clip x
	     * @param {Number} [config.clipY] set clip y
	     * @param {Number} [config.clipWidth] set clip width
	     * @param {Number} [config.clipHeight] set clip height

	         */
	        Container: function(config) {
	            this.__init(config);
	        },

	        /**
	         * Stage constructor.  A stage is used to contain multiple layers
	         * @constructor
	         * @memberof Kinetic
	         * @augments Kinetic.Container
	         * @param {Object} config
	         * @param {String|Element} config.container Container id or DOM element
	         * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	         * @example
	         * var stage = new Kinetic.Stage({
	         *   width: 500,
	         *   height: 800,
	         *   container: 'containerId'
	         * });
	         */
	        Stage: function(config) {
	            this.___init(config);
	        },

	        /**
	         * BaseLayer constructor. 
	         * @constructor
	         * @memberof Kinetic
	         * @augments Kinetic.Container
	         * @param {Object} config
	         * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
	         * to clear the canvas before each layer draw.  The default value is true.
	         * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	         * * @param {Object} [config.clip] set clip
	     * @param {Number} [config.clipX] set clip x
	     * @param {Number} [config.clipY] set clip y
	     * @param {Number} [config.clipWidth] set clip width
	     * @param {Number} [config.clipHeight] set clip height

	         * @example
	         * var layer = new Kinetic.Layer();
	         */
	        BaseLayer: function(config) {
	            this.___init(config);
	        },

	        /**
	         * Layer constructor.  Layers are tied to their own canvas element and are used
	         * to contain groups or shapes.
	         * @constructor
	         * @memberof Kinetic
	         * @augments Kinetic.BaseLayer
	         * @param {Object} config
	         * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
	         * to clear the canvas before each layer draw.  The default value is true.
	         * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	         * * @param {Object} [config.clip] set clip
	     * @param {Number} [config.clipX] set clip x
	     * @param {Number} [config.clipY] set clip y
	     * @param {Number} [config.clipWidth] set clip width
	     * @param {Number} [config.clipHeight] set clip height

	         * @example
	         * var layer = new Kinetic.Layer();
	         */
	        Layer: function(config) {
	            this.____init(config);
	        },

	        /**
	         * FastLayer constructor. Layers are tied to their own canvas element and are used
	         * to contain shapes only.  If you don't need node nesting, mouse and touch interactions,
	         * or event pub/sub, you should use FastLayer instead of Layer to create your layers.
	         * It renders about 2x faster than normal layers.
	         * @constructor
	         * @memberof Kinetic
	         * @augments Kinetic.BaseLayer
	         * @param {Object} config
	         * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
	         * to clear the canvas before each layer draw.  The default value is true.
	         * @param {Boolean} [config.visible]
	         * @param {String} [config.id] unique id
	         * @param {String} [config.name] non-unique name
	         * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	         * * @param {Object} [config.clip] set clip
	     * @param {Number} [config.clipX] set clip x
	     * @param {Number} [config.clipY] set clip y
	     * @param {Number} [config.clipWidth] set clip width
	     * @param {Number} [config.clipHeight] set clip height

	         * @example
	         * var layer = new Kinetic.FastLayer();
	         */
	        FastLayer: function(config) {
	            this.____init(config);
	        },

	        /**
	         * Group constructor.  Groups are used to contain shapes or other groups.
	         * @constructor
	         * @memberof Kinetic
	         * @augments Kinetic.Container
	         * @param {Object} config
	         * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	         * * @param {Object} [config.clip] set clip
	     * @param {Number} [config.clipX] set clip x
	     * @param {Number} [config.clipY] set clip y
	     * @param {Number} [config.clipWidth] set clip width
	     * @param {Number} [config.clipHeight] set clip height

	         * @example
	         * var group = new Kinetic.Group();
	         */
	        Group: function(config) {
	            this.___init(config);
	        },

	        /**
	         * returns whether or not drag and drop is currently active
	         * @method
	         * @memberof Kinetic
	         */
	        isDragging: function() {
	            var dd = Kinetic.DD;

	            // if DD is not included with the build, then
	            // drag and drop is not even possible
	            if (dd) {
	                return dd.isDragging;
	            } else {
	                return false;
	            }
	        },
	        /**
	        * returns whether or not a drag and drop operation is ready, but may
	        *  not necessarily have started
	        * @method
	        * @memberof Kinetic
	        */
	        isDragReady: function() {
	            var dd = Kinetic.DD;

	            // if DD is not included with the build, then
	            // drag and drop is not even possible
	            if (dd) {
	                return !!dd.node;
	            } else {
	                return false;
	            }
	        },
	        _addId: function(node, id) {
	            if(id !== undefined) {
	                this.ids[id] = node;
	            }
	        },
	        _removeId: function(id) {
	            if(id !== undefined) {
	                delete this.ids[id];
	            }
	        },
	        _addName: function(node, name) {
	            if(name !== undefined) {

	                var names = name.split(/\s/g);
	                for(var n = 0; n < names.length; n++) {
	                    var subname = names[n];
	                    if (subname) {
	                        if(this.names[subname] === undefined) {
	                            this.names[subname] = [];
	                        }
	                        this.names[subname].push(node);
	                    }
	                }
	            }
	        },
	        _removeName: function(name, _id) {
	            if(name !== undefined) {
	                var nodes = this.names[name];
	                if(nodes !== undefined) {
	                    for(var n = 0; n < nodes.length; n++) {
	                        var no = nodes[n];
	                        if(no._id === _id) {
	                            nodes.splice(n, 1);
	                        }
	                    }
	                    if(nodes.length === 0) {
	                        delete this.names[name];
	                    }
	                }
	            }
	        },
	        getAngle: function(angle) {
	            return this.angleDeg ? angle * PI_OVER_180 : angle;
	        },
	        _parseUA: function(userAgent) {
	            var ua = userAgent.toLowerCase(),
	                // jQuery UA regex
	                match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
	                /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
	                /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
	                /(msie) ([\w.]+)/.exec( ua ) ||
	                ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
	                [],

	                // adding mobile flag as well
	                mobile = !!(userAgent.match(/Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i)),
	                ieMobile = !!(userAgent.match(/IEMobile/i));
	                
	            return {
	                browser: match[ 1 ] || '',
	                version: match[ 2 ] || '0',

	                // adding mobile flab
	                mobile: mobile,
	                ieMobile: ieMobile  // If this is true (i.e., WP8), then Kinetic touch events are executed instead of equivalent Kinetic mouse events
	            };
	        },
	        // user agent  
	        UA: undefined
	    };

	    Kinetic.UA = Kinetic._parseUA((root.navigator && root.navigator.userAgent) || '');
	    
	})(this);

	// Uses Node, AMD or browser globals to create a module.

	// If you want something that will work in other stricter CommonJS environments,
	// or if you need to create a circular dependency, see commonJsStrict.js

	// Defines a module "returnExports" that depends another module called "b".
	// Note that the name of the module is implied by the file name. It is best
	// if the file name and the exported global have matching names.

	// If the 'b' module also uses this type of boilerplate, then
	// in the browser, it will create a global .b that is used below.

	// If you do not want to support the browser global path, then you
	// can remove the `root` use and the passing `this` as the first arg to
	// the top function.

	// if the module has no dependencies, the above pattern can be simplified to
	( function(root, factory) {
	    if( true) {
	        var KineticJS = factory();
	        // runtime-check for browserify
	        if(global.window === global) {
	            Kinetic.document = global.document;
	            Kinetic.window = global;
	        } else {
	            // Node. Does not work with strict CommonJS, but
	            // only CommonJS-like enviroments that support module.exports,
	            // like Node.
	            var Canvas = __webpack_require__(533);
	            var jsdom = __webpack_require__(534).jsdom;

	            Kinetic.document = jsdom('<!DOCTYPE html><html><head></head><body></body></html>');
	            Kinetic.window = Kinetic.document.createWindow();
	            Kinetic.window.Image = Canvas.Image;
	            Kinetic._nodeCanvas = Canvas;
	        }

	        Kinetic.root = root;
	        module.exports = KineticJS;
	        return;
	    }
	    else if( typeof define === 'function' && define.amd) {
	        // AMD. Register as an anonymous module.
	        define(factory);
	    }
	    Kinetic.document = document;
	    Kinetic.window = window;
	    Kinetic.root = root;

	}(this, function() {

	    // Just return a value to define the module export.
	    // This example returns an object, but the module
	    // can return a function as the exported value.
	    return Kinetic;
	}));
	;(function() {
	    /**
	     * Collection constructor.  Collection extends
	     *  Array.  This class is used in conjunction with {@link Kinetic.Container#get}
	     * @constructor
	     * @memberof Kinetic
	     */
	    Kinetic.Collection = function() {
	        var args = [].slice.call(arguments), length = args.length, i = 0;

	        this.length = length;
	        for(; i < length; i++) {
	            this[i] = args[i];
	        }
	        return this;
	    };
	    Kinetic.Collection.prototype = [];
	    /**
	     * iterate through node array and run a function for each node.
	     *  The node and index is passed into the function
	     * @method
	     * @memberof Kinetic.Collection.prototype
	     * @param {Function} func
	     * @example
	     * // get all nodes with name foo inside layer, and set x to 10 for each
	     * layer.get('.foo').each(function(shape, n) {
	     *   shape.setX(10);
	     * });
	     */
	    Kinetic.Collection.prototype.each = function(func) {
	        for(var n = 0; n < this.length; n++) {
	            func(this[n], n);
	        }
	    };
	    /**
	     * convert collection into an array
	     * @method
	     * @memberof Kinetic.Collection.prototype
	     */
	    Kinetic.Collection.prototype.toArray = function() {
	        var arr = [],
	            len = this.length,
	            n;

	        for(n = 0; n < len; n++) {
	            arr.push(this[n]);
	        }
	        return arr;
	    };
	    /**
	     * convert array into a collection
	     * @method
	     * @memberof Kinetic.Collection
	     * @param {Array} arr
	     */
	    Kinetic.Collection.toCollection = function(arr) {
	        var collection = new Kinetic.Collection(),
	            len = arr.length,
	            n;

	        for(n = 0; n < len; n++) {
	            collection.push(arr[n]);
	        }
	        return collection;
	    };

	    // map one method by it's name
	    Kinetic.Collection._mapMethod = function(methodName) {
	        Kinetic.Collection.prototype[methodName] = function() {
	            var len = this.length,
	                i;

	            var args = [].slice.call(arguments);
	            for(i = 0; i < len; i++) {
	                this[i][methodName].apply(this[i], args);
	            }

	            return this;
	        };
	    };

	    Kinetic.Collection.mapMethods = function(constructor) {
	        var prot = constructor.prototype;
	        for(var methodName in prot) {
	            Kinetic.Collection._mapMethod(methodName);
	        }
	    };

	    /*
	    * Last updated November 2011
	    * By Simon Sarris
	    * www.simonsarris.com
	    * sarris@acm.org
	    *
	    * Free to use and distribute at will
	    * So long as you are nice to people, etc
	    */

	    /*
	    * The usage of this class was inspired by some of the work done by a forked
	    * project, KineticJS-Ext by Wappworks, which is based on Simon's Transform
	    * class.  Modified by Eric Rowell
	    */

	    /**
	     * Transform constructor
	     * @constructor
	     * @param {Array} [m] Optional six-element matrix
	     * @memberof Kinetic
	     */
	    Kinetic.Transform = function(m) {
	        this.m = (m && m.slice()) || [1, 0, 0, 1, 0, 0];
	    };

	    Kinetic.Transform.prototype = {
	        /**
	         * Copy Kinetic.Transform object
	         * @method
	         * @memberof Kinetic.Transform.prototype
	         * @returns {Kinetic.Transform}
	         */
	        copy: function() {
	            return new Kinetic.Transform(this.m);
	        },
	        /**
	         * Transform point
	         * @method
	         * @memberof Kinetic.Transform.prototype
	         * @param {Object} point 2D point(x, y)
	         * @returns {Object} 2D point(x, y)
	         */
	        point: function(point) {
	            var m = this.m;
	            return {
	                x: m[0] * point.x + m[2] * point.y + m[4],
	                y: m[1] * point.x + m[3] * point.y + m[5]
	            };
	        },
	        /**
	         * Apply translation
	         * @method
	         * @memberof Kinetic.Transform.prototype
	         * @param {Number} x
	         * @param {Number} y
	         * @returns {Kinetic.Transform}
	         */
	        translate: function(x, y) {
	            this.m[4] += this.m[0] * x + this.m[2] * y;
	            this.m[5] += this.m[1] * x + this.m[3] * y;
	            return this;
	        },
	        /**
	         * Apply scale
	         * @method
	         * @memberof Kinetic.Transform.prototype
	         * @param {Number} sx
	         * @param {Number} sy
	         * @returns {Kinetic.Transform}
	         */
	        scale: function(sx, sy) {
	            this.m[0] *= sx;
	            this.m[1] *= sx;
	            this.m[2] *= sy;
	            this.m[3] *= sy;
	            return this;
	        },
	        /**
	         * Apply rotation
	         * @method
	         * @memberof Kinetic.Transform.prototype
	         * @param {Number} rad  Angle in radians
	         * @returns {Kinetic.Transform}
	         */
	        rotate: function(rad) {
	            var c = Math.cos(rad);
	            var s = Math.sin(rad);
	            var m11 = this.m[0] * c + this.m[2] * s;
	            var m12 = this.m[1] * c + this.m[3] * s;
	            var m21 = this.m[0] * -s + this.m[2] * c;
	            var m22 = this.m[1] * -s + this.m[3] * c;
	            this.m[0] = m11;
	            this.m[1] = m12;
	            this.m[2] = m21;
	            this.m[3] = m22;
	            return this;
	        },
	        /**
	         * Returns the translation
	         * @method
	         * @memberof Kinetic.Transform.prototype
	         * @returns {Object} 2D point(x, y)
	         */
	        getTranslation: function() {
	            return {
	                x: this.m[4],
	                y: this.m[5]
	            };
	        },
	        /**
	         * Apply skew
	         * @method
	         * @memberof Kinetic.Transform.prototype
	         * @param {Number} sx
	         * @param {Number} sy
	         * @returns {Kinetic.Transform}
	         */
	        skew: function(sx, sy) {
	            var m11 = this.m[0] + this.m[2] * sy;
	            var m12 = this.m[1] + this.m[3] * sy;
	            var m21 = this.m[2] + this.m[0] * sx;
	            var m22 = this.m[3] + this.m[1] * sx;
	            this.m[0] = m11;
	            this.m[1] = m12;
	            this.m[2] = m21;
	            this.m[3] = m22;
	            return this;
	         },
	        /**
	         * Transform multiplication
	         * @method
	         * @memberof Kinetic.Transform.prototype
	         * @param {Kinetic.Transform} matrix
	         * @returns {Kinetic.Transform}
	         */
	        multiply: function(matrix) {
	            var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
	            var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

	            var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
	            var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

	            var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
	            var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

	            this.m[0] = m11;
	            this.m[1] = m12;
	            this.m[2] = m21;
	            this.m[3] = m22;
	            this.m[4] = dx;
	            this.m[5] = dy;
	            return this;
	        },
	        /**
	         * Invert the matrix
	         * @method
	         * @memberof Kinetic.Transform.prototype
	         * @returns {Kinetic.Transform}
	         */
	        invert: function() {
	            var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
	            var m0 = this.m[3] * d;
	            var m1 = -this.m[1] * d;
	            var m2 = -this.m[2] * d;
	            var m3 = this.m[0] * d;
	            var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
	            var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
	            this.m[0] = m0;
	            this.m[1] = m1;
	            this.m[2] = m2;
	            this.m[3] = m3;
	            this.m[4] = m4;
	            this.m[5] = m5;
	            return this;
	        },
	        /**
	         * return matrix
	         * @method
	         * @memberof Kinetic.Transform.prototype
	         */
	        getMatrix: function() {
	            return this.m;
	        },
	        /**
	         * set to absolute position via translation
	         * @method
	         * @memberof Kinetic.Transform.prototype
	         * @returns {Kinetic.Transform}
	         * @author ericdrowell
	         */
	        setAbsolutePosition: function(x, y) {
	            var m0 = this.m[0],
	                m1 = this.m[1],
	                m2 = this.m[2],
	                m3 = this.m[3],
	                m4 = this.m[4],
	                m5 = this.m[5],
	                yt = ((m0 * (y - m5)) - (m1 * (x - m4))) / ((m0 * m3) - (m1 * m2)),
	                xt = (x - m4 - (m2 * yt)) / m0;

	            return this.translate(xt, yt);
	        }
	    };

	    // CONSTANTS
	    var CONTEXT_2D = '2d',
	        OBJECT_ARRAY = '[object Array]',
	        OBJECT_NUMBER = '[object Number]',
	        OBJECT_STRING = '[object String]',
	        PI_OVER_DEG180 = Math.PI / 180,
	        DEG180_OVER_PI = 180 / Math.PI,
	        HASH = '#',
	        EMPTY_STRING = '',
	        ZERO = '0',
	        KINETIC_WARNING = 'Kinetic warning: ',
	        KINETIC_ERROR = 'Kinetic error: ',
	        RGB_PAREN = 'rgb(',
	        COLORS = {
	            aqua: [0,255,255],
	            lime: [0,255,0],
	            silver: [192,192,192],
	            black: [0,0,0],
	            maroon: [128,0,0],
	            teal: [0,128,128],
	            blue: [0,0,255],
	            navy: [0,0,128],
	            white: [255,255,255],
	            fuchsia: [255,0,255],
	            olive:[128,128,0],
	            yellow: [255,255,0],
	            orange: [255,165,0],
	            gray: [128,128,128],
	            purple: [128,0,128],
	            green: [0,128,0],
	            red: [255,0,0],
	            pink: [255,192,203],
	            cyan: [0,255,255],
	            transparent: [255,255,255,0]
	        },

	        RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;

	    /**
	     * @namespace Util
	     * @memberof Kinetic
	     */
	    Kinetic.Util = {
	        /*
	         * cherry-picked utilities from underscore.js
	         */
	        _isElement: function(obj) {
	            return !!(obj && obj.nodeType == 1);
	        },
	        _isFunction: function(obj) {
	            return !!(obj && obj.constructor && obj.call && obj.apply);
	        },
	        _isObject: function(obj) {
	            return (!!obj && obj.constructor == Object);
	        },
	        _isArray: function(obj) {
	            return Object.prototype.toString.call(obj) == OBJECT_ARRAY;
	        },
	        _isNumber: function(obj) {
	            return Object.prototype.toString.call(obj) == OBJECT_NUMBER;
	        },
	        _isString: function(obj) {
	            return Object.prototype.toString.call(obj) == OBJECT_STRING;
	        },
	        // Returns a function, that, when invoked, will only be triggered at most once
	        // during a given window of time. Normally, the throttled function will run
	        // as much as it can, without ever going more than once per `wait` duration;
	        // but if you'd like to disable the execution on the leading edge, pass
	        // `{leading: false}`. To disable execution on the trailing edge, ditto.
	        _throttle: function(func, wait, opts) {
	            var context, args, result;
	            var timeout = null;
	            var previous = 0;
	            var options = opts || {};
	            var later = function() {
	                previous = options.leading === false ? 0 : new Date().getTime();
	                timeout = null;
	                result = func.apply(context, args);
	                context = args = null;
	            };
	            return function() {
	                var now = new Date().getTime();
	                if (!previous && options.leading === false) {
	                    previous = now;
	                }
	                var remaining = wait - (now - previous);
	                context = this;
	                args = arguments;
	                if (remaining <= 0) {
	                  clearTimeout(timeout);
	                  timeout = null;
	                  previous = now;
	                  result = func.apply(context, args);
	                  context = args = null;
	                } else if (!timeout && options.trailing !== false) {
	                  timeout = setTimeout(later, remaining);
	                }
	                return result;
	            };
	        },
	        /*
	         * other utils
	         */
	        _hasMethods: function(obj) {
	            var names = [],
	                key;

	            for(key in obj) {
	                if(this._isFunction(obj[key])) {
	                    names.push(key);
	                }
	            }
	            return names.length > 0;
	        },
	        createCanvasElement: function() {
	            var canvas = Kinetic.document.createElement('canvas');
	            // on some environments canvas.style is readonly
	            try {
	                canvas.style = canvas.style || {};
	            } catch (e) {
	            }
	            return canvas;
	        },
	        isBrowser: function() {
	            return (typeof exports !==  'object');
	        },
	        _isInDocument: function(el) {
	            while(el = el.parentNode) {
	                if(el == Kinetic.document) {
	                    return true;
	                }
	            }
	            return false;
	        },
	        _simplifyArray: function(arr) {
	            var retArr = [],
	                len = arr.length,
	                util = Kinetic.Util,
	                n, val;

	            for (n=0; n<len; n++) {
	                val = arr[n];
	                if (util._isNumber(val)) {
	                    val = Math.round(val * 1000) / 1000;
	                }
	                else if (!util._isString(val)) {
	                    val = val.toString();
	                }

	                retArr.push(val);
	            }

	            return retArr;
	        },
	        /*
	         * arg can be an image object or image data
	         */
	        _getImage: function(arg, callback) {
	            var imageObj, canvas;

	            // if arg is null or undefined
	            if(!arg) {
	                callback(null);
	            }

	            // if arg is already an image object
	            else if(this._isElement(arg)) {
	                callback(arg);
	            }

	            // if arg is a string, then it's a data url
	            else if(this._isString(arg)) {
	                imageObj = new Kinetic.window.Image();
	                imageObj.onload = function() {
	                    callback(imageObj);
	                };
	                imageObj.src = arg;
	            }

	            //if arg is an object that contains the data property, it's an image object
	            else if(arg.data) {
	                canvas = Kinetic.Util.createCanvasElement();
	                canvas.width = arg.width;
	                canvas.height = arg.height;
	                var _context = canvas.getContext(CONTEXT_2D);
	                _context.putImageData(arg, 0, 0);
	                this._getImage(canvas.toDataURL(), callback);
	            }
	            else {
	                callback(null);
	            }
	        },
	        _getRGBAString: function(obj) {
	            var red = obj.red || 0,
	                green = obj.green || 0,
	                blue = obj.blue || 0,
	                alpha = obj.alpha || 1;

	            return [
	                'rgba(',
	                red,
	                ',',
	                green,
	                ',',
	                blue,
	                ',',
	                alpha,
	                ')'
	            ].join(EMPTY_STRING);
	        },
	        _rgbToHex: function(r, g, b) {
	            return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
	        },
	        _hexToRgb: function(hex) {
	            hex = hex.replace(HASH, EMPTY_STRING);
	            var bigint = parseInt(hex, 16);
	            return {
	                r: (bigint >> 16) & 255,
	                g: (bigint >> 8) & 255,
	                b: bigint & 255
	            };
	        },
	        /**
	         * return random hex color
	         * @method
	         * @memberof Kinetic.Util.prototype
	         */
	        getRandomColor: function() {
	            var randColor = (Math.random() * 0xFFFFFF << 0).toString(16);
	            while (randColor.length < 6) {
	                randColor = ZERO + randColor;
	            }
	            return HASH + randColor;
	        },
	        /**
	         * return value with default fallback
	         * @method
	         * @memberof Kinetic.Util.prototype
	         */
	        get: function(val, def) {
	            if (val === undefined) {
	                return def;
	            }
	            else {
	                return val;
	            }
	        },
	        /**
	         * get RGB components of a color
	         * @method
	         * @memberof Kinetic.Util.prototype
	         * @param {String} color
	         * @example
	         * // each of the following examples return {r:0, g:0, b:255}
	         * var rgb = Kinetic.Util.getRGB('blue');
	         * var rgb = Kinetic.Util.getRGB('#0000ff');
	         * var rgb = Kinetic.Util.getRGB('rgb(0,0,255)');
	         */
	        getRGB: function(color) {
	            var rgb;
	            // color string
	            if (color in COLORS) {
	                rgb = COLORS[color];
	                return {
	                    r: rgb[0],
	                    g: rgb[1],
	                    b: rgb[2]
	                };
	            }
	            // hex
	            else if (color[0] === HASH) {
	                return this._hexToRgb(color.substring(1));
	            }
	            // rgb string
	            else if (color.substr(0, 4) === RGB_PAREN) {
	                rgb = RGB_REGEX.exec(color.replace(/ /g,''));
	                return {
	                    r: parseInt(rgb[1], 10),
	                    g: parseInt(rgb[2], 10),
	                    b: parseInt(rgb[3], 10)
	                };
	            }
	            // default
	            else {
	                return {
	                    r: 0,
	                    g: 0,
	                    b: 0
	                };
	            }
	        },
	        // o1 takes precedence over o2
	        _merge: function(o1, o2) {
	            var retObj = this._clone(o2);
	            for(var key in o1) {
	                if(this._isObject(o1[key])) {
	                    retObj[key] = this._merge(o1[key], retObj[key]);
	                }
	                else {
	                    retObj[key] = o1[key];
	                }
	            }
	            return retObj;
	        },
	        cloneObject: function(obj) {
	            var retObj = {};
	            for(var key in obj) {
	                if(this._isObject(obj[key])) {
	                    retObj[key] = this.cloneObject(obj[key]);
	                }
	                else if (this._isArray(obj[key])) {
	                    retObj[key] = this.cloneArray(obj[key]);
	                } else {
	                    retObj[key] = obj[key];
	                }
	            }
	            return retObj;
	        },
	        cloneArray: function(arr) {
	            return arr.slice(0);
	        },
	        _degToRad: function(deg) {
	            return deg * PI_OVER_DEG180;
	        },
	        _radToDeg: function(rad) {
	            return rad * DEG180_OVER_PI;
	        },
	        _capitalize: function(str) {
	            return str.charAt(0).toUpperCase() + str.slice(1);
	        },
	        error: function(str) {
	            throw new Error(KINETIC_ERROR + str);
	        },
	        warn: function(str) {
	            /*
	             * IE9 on Windows7 64bit will throw a JS error
	             * if we don't use window.console in the conditional
	             */
	            if(Kinetic.root.console && console.warn && Kinetic.showWarnings) {
	                console.warn(KINETIC_WARNING + str);
	            }
	        },
	        extend: function(child, parent) {
	                function ctor() {
	                    this.constructor = child;
	                }
	                ctor.prototype = parent.prototype;
	                var old_proto = child.prototype;
	                child.prototype = new ctor();
	                for (var key in old_proto) {
	                    if (old_proto.hasOwnProperty(key)) {
	                        child.prototype[key] = old_proto[key];
	                    }
	                }
	                child.__super__ = parent.prototype;
	        },
	        /**
	         * adds methods to a constructor prototype
	         * @method
	         * @memberof Kinetic.Util.prototype
	         * @param {Function} constructor
	         * @param {Object} methods
	         */
	        addMethods: function(constructor, methods) {
	            var key;

	            for (key in methods) {
	                constructor.prototype[key] = methods[key];
	            }
	        },
	        _getControlPoints: function(x0, y0, x1, y1, x2, y2, t) {
	            var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)),
	                d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)),
	                fa = t * d01 / (d01 + d12),
	                fb = t * d12 / (d01 + d12),
	                p1x = x1 - fa * (x2 - x0),
	                p1y = y1 - fa * (y2 - y0),
	                p2x = x1 + fb * (x2 - x0),
	                p2y = y1 + fb * (y2 - y0);

	            return [p1x ,p1y, p2x, p2y];
	        },
	        _expandPoints: function(p, tension) {
	            var len = p.length,
	                allPoints = [],
	                n, cp;

	            for (n=2; n<len-2; n+=2) {
	                cp = Kinetic.Util._getControlPoints(p[n-2], p[n-1], p[n], p[n+1], p[n+2], p[n+3], tension);
	                allPoints.push(cp[0]);
	                allPoints.push(cp[1]);
	                allPoints.push(p[n]);
	                allPoints.push(p[n+1]);
	                allPoints.push(cp[2]);
	                allPoints.push(cp[3]);
	            }

	            return allPoints;
	        },
	        _removeLastLetter: function(str) {
	            return str.substring(0, str.length - 1);
	        }
	    };
	})();
	;(function() {
	    // calculate pixel ratio
	    var canvas = Kinetic.Util.createCanvasElement(),
	        context = canvas.getContext('2d'),
	        // if using a mobile device, calculate the pixel ratio.  Otherwise, just use
	        // 1.  For desktop browsers, if the user has zoom enabled, it affects the pixel ratio
	        // and causes artifacts on the canvas.  As of 02/26/2014, there doesn't seem to be a way
	        // to reliably calculate the browser zoom for modern browsers, which is why we just set
	        // the pixel ratio to 1 for desktops
	        _pixelRatio = Kinetic.UA.mobile ? (function() {
	            var devicePixelRatio = window.devicePixelRatio || 1,
	            backingStoreRatio = context.webkitBackingStorePixelRatio
	                || context.mozBackingStorePixelRatio
	                || context.msBackingStorePixelRatio
	                || context.oBackingStorePixelRatio
	                || context.backingStorePixelRatio
	                || 1;
	            return devicePixelRatio / backingStoreRatio;
	        })() : 1;

	    /**
	     * Canvas Renderer constructor
	     * @constructor
	     * @abstract
	     * @memberof Kinetic
	     * @param {Object} config
	     * @param {Number} config.width
	     * @param {Number} config.height
	     * @param {Number} config.pixelRatio KineticJS automatically handles pixel ratio adjustments in order to render crisp drawings
	     *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
	     *  of 1.  Some high end tablets and phones, like iPhones and iPads (not the mini) have a device pixel ratio 
	     *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel 
	     *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
	     *  specified, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
	     *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
	     */
	    Kinetic.Canvas = function(config) {
	        this.init(config);
	    };

	    Kinetic.Canvas.prototype = {
	        init: function(config) {
	            var conf = config || {};

	            var pixelRatio = conf.pixelRatio || Kinetic.pixelRatio || _pixelRatio;

	            this.pixelRatio = pixelRatio;
	            this._canvas = Kinetic.Util.createCanvasElement();

	            // set inline styles
	            this._canvas.style.padding = 0;
	            this._canvas.style.margin = 0;
	            this._canvas.style.border = 0;
	            this._canvas.style.background = 'transparent';
	            this._canvas.style.position = 'absolute';
	            this._canvas.style.top = 0;
	            this._canvas.style.left = 0;
	        },
	        /**
	         * get canvas context
	         * @method
	         * @memberof Kinetic.Canvas.prototype
	         * @returns {CanvasContext} context
	         */
	        getContext: function() {
	            return this.context;
	        },
	        /**
	         * get pixel ratio
	         * @method
	         * @memberof Kinetic.Canvas.prototype
	         * @returns {Number} pixel ratio
	         */
	        getPixelRatio: function() {
	            return this.pixelRatio;
	        },
	        /**
	         * get pixel ratio
	         * @method
	         * @memberof Kinetic.Canvas.prototype
	         * @param {Number} pixelRatio KineticJS automatically handles pixel ratio adustments in order to render crisp drawings 
	         *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
	         *  of 1.  Some high end tablets and phones, like iPhones and iPads (not the mini) have a device pixel ratio 
	         *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel 
	         *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
	         *  specificed, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
	         *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
	         */
	        setPixelRatio: function(pixelRatio) {
	            this.pixelRatio = pixelRatio;
	            this.setSize(this.getWidth(), this.getHeight());
	        },
	        /**
	         * set width
	         * @method
	         * @memberof Kinetic.Canvas.prototype
	         * @param {Number} width
	         */
	        setWidth: function(width) {
	            // take into account pixel ratio
	            this.width = this._canvas.width = width * this.pixelRatio;
	            this._canvas.style.width = width + 'px';
	        },
	        /**
	         * set height
	         * @method
	         * @memberof Kinetic.Canvas.prototype
	         * @param {Number} height
	         */
	        setHeight: function(height) {
	            // take into account pixel ratio
	            this.height = this._canvas.height = height * this.pixelRatio;
	            this._canvas.style.height = height + 'px';
	        },
	        /**
	         * get width
	         * @method
	         * @memberof Kinetic.Canvas.prototype
	         * @returns {Number} width
	         */
	        getWidth: function() {
	            return this.width;
	        },
	        /**
	         * get height
	         * @method
	         * @memberof Kinetic.Canvas.prototype
	         * @returns {Number} height
	         */
	        getHeight: function() {
	            return this.height;
	        },
	        /**
	         * set size
	         * @method
	         * @memberof Kinetic.Canvas.prototype
	         * @param {Number} width
	         * @param {Number} height
	         */
	        setSize: function(width, height) {
	            this.setWidth(width);
	            this.setHeight(height);
	        },
	        /**
	         * to data url
	         * @method
	         * @memberof Kinetic.Canvas.prototype
	         * @param {String} mimeType
	         * @param {Number} quality between 0 and 1 for jpg mime types
	         * @returns {String} data url string
	         */
	        toDataURL: function(mimeType, quality) {
	            try {
	                // If this call fails (due to browser bug, like in Firefox 3.6),
	                // then revert to previous no-parameter image/png behavior
	                return this._canvas.toDataURL(mimeType, quality);
	            }
	            catch(e) {
	                try {
	                    return this._canvas.toDataURL();
	                }
	                catch(err) {
	                    Kinetic.Util.warn('Unable to get data URL. ' + err.message);
	                    return '';
	                }
	            }
	        }
	    };

	    Kinetic.SceneCanvas = function(config) {
	        var conf = config || {};
	        var width = conf.width || 0,
	            height = conf.height || 0;

	        Kinetic.Canvas.call(this, conf);
	        this.context = new Kinetic.SceneContext(this);
	        this.setSize(width, height);
	    };

	    Kinetic.SceneCanvas.prototype = {
	        setWidth: function(width) {
	            var pixelRatio = this.pixelRatio,
	                _context = this.getContext()._context;

	            Kinetic.Canvas.prototype.setWidth.call(this, width);
	            _context.scale(pixelRatio, pixelRatio);
	        },
	        setHeight: function(height) {
	            var pixelRatio = this.pixelRatio,
	                _context = this.getContext()._context;

	            Kinetic.Canvas.prototype.setHeight.call(this, height);
	            _context.scale(pixelRatio, pixelRatio);
	        }
	    };
	    Kinetic.Util.extend(Kinetic.SceneCanvas, Kinetic.Canvas);

	    Kinetic.HitCanvas = function(config) {
	        var conf = config || {};
	        var width = conf.width || 0,
	            height = conf.height || 0;
	            
	        Kinetic.Canvas.call(this, conf);
	        this.context = new Kinetic.HitContext(this);
	        this.setSize(width, height);
	        this.hitCanvas = true;
	    };
	    Kinetic.Util.extend(Kinetic.HitCanvas, Kinetic.Canvas);

	})();
	;(function() {
	    var COMMA = ',',
	        OPEN_PAREN = '(',
	        CLOSE_PAREN = ')',
	        OPEN_PAREN_BRACKET = '([',
	        CLOSE_BRACKET_PAREN = '])',
	        SEMICOLON = ';',
	        DOUBLE_PAREN = '()',
	        // EMPTY_STRING = '',
	        EQUALS = '=',
	        // SET = 'set',
	        CONTEXT_METHODS = [
	            'arc',
	            'arcTo',
	            'beginPath',
	            'bezierCurveTo',
	            'clearRect',
	            'clip',
	            'closePath',
	            'createLinearGradient',
	            'createPattern',
	            'createRadialGradient',
	            'drawImage',
	            'fill',
	            'fillText',
	            'getImageData',
	            'createImageData',
	            'lineTo',
	            'moveTo',
	            'putImageData',
	            'quadraticCurveTo',
	            'rect',
	            'restore',
	            'rotate',
	            'save',
	            'scale',
	            'setLineDash',
	            'setTransform',
	            'stroke',
	            'strokeText',
	            'transform',
	            'translate'
	        ];

	    /**
	     * Canvas Context constructor
	     * @constructor
	     * @abstract
	     * @memberof Kinetic
	     */
	    Kinetic.Context = function(canvas) {
	        this.init(canvas);
	    };

	    Kinetic.Context.prototype = {
	        init: function(canvas) {
	            this.canvas = canvas;
	            this._context = canvas._canvas.getContext('2d');

	            if (Kinetic.enableTrace) {
	                this.traceArr = [];
	                this._enableTrace();
	            }
	        },
	        /**
	         * fill shape
	         * @method
	         * @memberof Kinetic.Context.prototype
	         * @param {Kinetic.Shape} shape
	         */
	        fillShape: function(shape) {
	            if(shape.getFillEnabled()) {
	                this._fill(shape);
	            }
	        },
	        /**
	         * stroke shape
	         * @method
	         * @memberof Kinetic.Context.prototype
	         * @param {Kinetic.Shape} shape
	         */
	        strokeShape: function(shape) {
	            if(shape.getStrokeEnabled()) {
	                this._stroke(shape);
	            }
	        },
	        /**
	         * fill then stroke
	         * @method
	         * @memberof Kinetic.Context.prototype
	         * @param {Kinetic.Shape} shape
	         */
	        fillStrokeShape: function(shape) {
	            var fillEnabled = shape.getFillEnabled();
	            if(fillEnabled) {
	                this._fill(shape);
	            }
	            if(shape.getStrokeEnabled()) {
	                this._stroke(shape);
	            }
	        },
	        /**
	         * get context trace if trace is enabled
	         * @method
	         * @memberof Kinetic.Context.prototype
	         * @param {Boolean} relaxed if false, return strict context trace, which includes method names, method parameters
	         *  properties, and property values.  If true, return relaxed context trace, which only returns method names and
	         *  properites.
	         * @returns {String}
	         */
	        getTrace: function(relaxed) {
	            var traceArr = this.traceArr,
	                len = traceArr.length,
	                str = '',
	                n, trace, method, args;

	            for (n=0; n<len; n++) {
	                trace = traceArr[n];
	                method = trace.method;

	                // methods
	                if (method) {
	                    args = trace.args;
	                    str += method;
	                    if (relaxed) {
	                        str += DOUBLE_PAREN;
	                    }
	                    else {
	                        if (Kinetic.Util._isArray(args[0])) {
	                            str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
	                        }
	                        else {
	                            str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
	                        }
	                    }
	                }
	                // properties
	                else {
	                    str += trace.property;
	                    if (!relaxed) {
	                        str += EQUALS + trace.val;
	                    }
	                }

	                str += SEMICOLON;
	            }

	            return str;
	        },
	        /**
	         * clear trace if trace is enabled
	         * @method
	         * @memberof Kinetic.Context.prototype
	         */
	        clearTrace: function() {
	            this.traceArr = [];
	        },
	        _trace: function(str) {
	            var traceArr = this.traceArr,
	                len;
	 
	            traceArr.push(str);
	            len = traceArr.length;

	            if (len >= Kinetic.traceArrMax) {
	                traceArr.shift();
	            }
	        },
	        /**
	         * reset canvas context transform
	         * @method
	         * @memberof Kinetic.Context.prototype
	         */
	        reset: function() {
	            var pixelRatio = this.getCanvas().getPixelRatio();
	            this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
	        },
	        /**
	         * get canvas
	         * @method
	         * @memberof Kinetic.Context.prototype
	         * @returns {Kinetic.Canvas}
	         */
	        getCanvas: function() {
	            return this.canvas;
	        },
	        /**
	         * clear canvas
	         * @method
	         * @memberof Kinetic.Context.prototype
	         * @param {Object} [bounds]
	         * @param {Number} [bounds.x]
	         * @param {Number} [bounds.y]
	         * @param {Number} [bounds.width]
	         * @param {Number} [bounds.height]
	         */
	        clear: function(bounds) {
	            var canvas = this.getCanvas();
	            
	            if (bounds) {
	                this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
	            }
	            else {
	                this.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
	            }
	        },
	        _applyLineCap: function(shape) {
	            var lineCap = shape.getLineCap();
	            if(lineCap) {
	                this.setAttr('lineCap', lineCap);
	            }
	        },
	        _applyOpacity: function(shape) {
	            var absOpacity = shape.getAbsoluteOpacity();
	            if(absOpacity !== 1) {
	                this.setAttr('globalAlpha', absOpacity);
	            }
	        },
	        _applyLineJoin: function(shape) {
	            var lineJoin = shape.getLineJoin();
	            if(lineJoin) {
	                this.setAttr('lineJoin', lineJoin);
	            }
	        },
	        setAttr: function(attr, val) {
	            this._context[attr] = val;
	        },

	        // context pass through methods
	        arc: function() {
	            var a = arguments;
	            this._context.arc(a[0], a[1], a[2], a[3], a[4], a[5]);
	        },
	        beginPath: function() {
	            this._context.beginPath();
	        },
	        bezierCurveTo: function() {
	            var a = arguments;
	            this._context.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
	        },
	        clearRect: function() {
	            var a = arguments;
	            this._context.clearRect(a[0], a[1], a[2], a[3]);
	        },
	        clip: function() {
	            this._context.clip();
	        },
	        closePath: function() {
	            this._context.closePath();
	        },
	        createImageData: function() {
	            var a = arguments;
	            if(a.length === 2) {
	                return this._context.createImageData(a[0], a[1]);
	            }
	            else if(a.length === 1) {
	                return this._context.createImageData(a[0]);
	            }
	        },
	        createLinearGradient: function() {
	            var a = arguments;
	            return this._context.createLinearGradient(a[0], a[1], a[2], a[3]);
	        },
	        createPattern: function() {
	            var a = arguments;
	            return this._context.createPattern(a[0], a[1]);
	        },
	        createRadialGradient: function() {
	            var a = arguments;
	            return this._context.createRadialGradient(a[0], a[1], a[2], a[3], a[4], a[5]);
	        },
	        drawImage: function() {
	            var a = arguments,
	                _context = this._context;

	            if(a.length === 3) {
	                _context.drawImage(a[0], a[1], a[2]);
	            }
	            else if(a.length === 5) {
	                _context.drawImage(a[0], a[1], a[2], a[3], a[4]);
	            }
	            else if(a.length === 9) {
	                _context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
	            }
	        },
	        fill: function() {
	            this._context.fill();
	        },
	        fillText: function() {
	            var a = arguments;
	            this._context.fillText(a[0], a[1], a[2]);
	        },
	        getImageData: function() {
	            var a = arguments;
	            return this._context.getImageData(a[0], a[1], a[2], a[3]);
	        },
	        lineTo: function() {
	            var a = arguments;
	            this._context.lineTo(a[0], a[1]);
	        },
	        moveTo: function() {
	            var a = arguments;
	            this._context.moveTo(a[0], a[1]);
	        },
	        rect: function() {
	            var a = arguments;
	            this._context.rect(a[0], a[1], a[2], a[3]);
	        },
	        putImageData: function() {
	            var a = arguments;
	            this._context.putImageData(a[0], a[1], a[2]);
	        },
	        quadraticCurveTo: function() {
	            var a = arguments;
	            this._context.quadraticCurveTo(a[0], a[1], a[2], a[3]);
	        },
	        restore: function() {
	            this._context.restore();
	        },
	        rotate: function() {
	            var a = arguments;
	            this._context.rotate(a[0]);
	        },
	        save: function() {
	            this._context.save();
	        },
	        scale: function() {
	            var a = arguments;
	            this._context.scale(a[0], a[1]);
	        },
	        setLineDash: function() {
	            var a = arguments,
	                _context = this._context;

	            // works for Chrome and IE11
	            if(this._context.setLineDash) {
	                _context.setLineDash(a[0]);
	            }
	            // verified that this works in firefox
	            else if('mozDash' in _context) {
	                _context.mozDash = a[0];
	            }
	            // does not currently work for Safari
	            else if('webkitLineDash' in _context) {
	                _context.webkitLineDash = a[0];
	            }

	            // no support for IE9 and IE10
	        },
	        setTransform: function() {
	            var a = arguments;
	            this._context.setTransform(a[0], a[1], a[2], a[3], a[4], a[5]);
	        },
	        stroke: function() {
	            this._context.stroke();
	        },
	        strokeText: function() {
	            var a = arguments;
	            this._context.strokeText(a[0], a[1], a[2]);
	        },
	        transform: function() {
	            var a = arguments;
	            this._context.transform(a[0], a[1], a[2], a[3], a[4], a[5]);
	        },
	        translate: function() {
	            var a = arguments;
	            this._context.translate(a[0], a[1]);
	        },
	        _enableTrace: function() {
	            var that = this,
	                len = CONTEXT_METHODS.length,
	                _simplifyArray = Kinetic.Util._simplifyArray,
	                origSetter = this.setAttr,
	                n, args;

	            // to prevent creating scope function at each loop
	            var func = function(methodName) {
	                    var origMethod = that[methodName],
	                        ret;

	                    that[methodName] = function() {
	                        args = _simplifyArray(Array.prototype.slice.call(arguments, 0));
	                        ret = origMethod.apply(that, arguments);
	           
	                        that._trace({
	                            method: methodName,
	                            args: args
	                        });
	                 
	                        return ret;
	                    };
	            };
	            // methods
	            for (n=0; n<len; n++) {
	                func(CONTEXT_METHODS[n]);
	            }

	            // attrs
	            that.setAttr = function() {
	                origSetter.apply(that, arguments);
	                that._trace({
	                    property: arguments[0],
	                    val: arguments[1]
	                });
	            };
	        }
	    };

	    Kinetic.SceneContext = function(canvas) {
	        Kinetic.Context.call(this, canvas);
	    };

	    Kinetic.SceneContext.prototype = {
	        _fillColor: function(shape) {
	            var fill = shape.fill()
	                || Kinetic.Util._getRGBAString({
	                    red: shape.fillRed(),
	                    green: shape.fillGreen(),
	                    blue: shape.fillBlue(),
	                    alpha: shape.fillAlpha()
	                });

	            this.setAttr('fillStyle', fill);
	            shape._fillFunc(this);
	        },
	        _fillPattern: function(shape) {
	            var fillPatternImage = shape.getFillPatternImage(),
	                fillPatternX = shape.getFillPatternX(),
	                fillPatternY = shape.getFillPatternY(),
	                fillPatternScale = shape.getFillPatternScale(),
	                fillPatternRotation = Kinetic.getAngle(shape.getFillPatternRotation()),
	                fillPatternOffset = shape.getFillPatternOffset(),
	                fillPatternRepeat = shape.getFillPatternRepeat();

	            if(fillPatternX || fillPatternY) {
	                this.translate(fillPatternX || 0, fillPatternY || 0);
	            }
	            if(fillPatternRotation) {
	                this.rotate(fillPatternRotation);
	            }
	            if(fillPatternScale) {
	                this.scale(fillPatternScale.x, fillPatternScale.y);
	            }
	            if(fillPatternOffset) {
	                this.translate(-1 * fillPatternOffset.x, -1 * fillPatternOffset.y);
	            }

	            this.setAttr('fillStyle', this.createPattern(fillPatternImage, fillPatternRepeat || 'repeat'));
	            this.fill();
	        },
	        _fillLinearGradient: function(shape) {
	            var start = shape.getFillLinearGradientStartPoint(),
	                end = shape.getFillLinearGradientEndPoint(),
	                colorStops = shape.getFillLinearGradientColorStops(),
	                grd = this.createLinearGradient(start.x, start.y, end.x, end.y);

	            if (colorStops) {
	                // build color stops
	                for(var n = 0; n < colorStops.length; n += 2) {
	                    grd.addColorStop(colorStops[n], colorStops[n + 1]);
	                }
	                this.setAttr('fillStyle', grd);
	                this.fill();
	            }
	        },
	        _fillRadialGradient: function(shape) {
	            var start = shape.getFillRadialGradientStartPoint(),
	                end = shape.getFillRadialGradientEndPoint(),
	                startRadius = shape.getFillRadialGradientStartRadius(),
	                endRadius = shape.getFillRadialGradientEndRadius(),
	                colorStops = shape.getFillRadialGradientColorStops(),
	                grd = this.createRadialGradient(start.x, start.y, startRadius, end.x, end.y, endRadius);
	           
	            // build color stops
	            for(var n = 0; n < colorStops.length; n += 2) {
	                grd.addColorStop(colorStops[n], colorStops[n + 1]);
	            }
	            this.setAttr('fillStyle', grd);
	            this.fill();
	        },
	        _fill: function(shape) {
	            var hasColor = shape.fill() || shape.fillRed() || shape.fillGreen() || shape.fillBlue(),
	                hasPattern = shape.getFillPatternImage(),
	                hasLinearGradient = shape.getFillLinearGradientColorStops(),
	                hasRadialGradient = shape.getFillRadialGradientColorStops(),
	                fillPriority = shape.getFillPriority();

	            // priority fills
	            if(hasColor && fillPriority === 'color') {
	                this._fillColor(shape);
	            }
	            else if(hasPattern && fillPriority === 'pattern') {
	                this._fillPattern(shape);
	            }
	            else if(hasLinearGradient && fillPriority === 'linear-gradient') {
	                this._fillLinearGradient(shape);
	            }
	            else if(hasRadialGradient && fillPriority === 'radial-gradient') {
	                this._fillRadialGradient(shape);
	            }
	            // now just try and fill with whatever is available
	            else if(hasColor) {
	                this._fillColor(shape);
	            }
	            else if(hasPattern) {
	                this._fillPattern(shape);
	            }
	            else if(hasLinearGradient) {
	                this._fillLinearGradient(shape);
	            }
	            else if(hasRadialGradient) {
	                this._fillRadialGradient(shape);
	            }
	        },
	        _stroke: function(shape) {
	            var dash = shape.dash(),
	                strokeScaleEnabled = shape.getStrokeScaleEnabled();

	            if(shape.hasStroke()) {
	                if (!strokeScaleEnabled) {
	                    this.save();
	                    this.setTransform(1, 0, 0, 1, 0, 0);
	                }

	                this._applyLineCap(shape);
	                if(dash && shape.dashEnabled()) {
	                    this.setLineDash(dash);
	                }

	                this.setAttr('lineWidth', shape.strokeWidth());
	                this.setAttr('strokeStyle', shape.stroke()
	                    || Kinetic.Util._getRGBAString({
	                        red: shape.strokeRed(),
	                        green: shape.strokeGreen(),
	                        blue: shape.strokeBlue(),
	                        alpha: shape.strokeAlpha()
	                    }));

	                shape._strokeFunc(this);
	                
	                if (!strokeScaleEnabled) {
	                    this.restore();
	                }
	            }
	        },
	        _applyShadow: function(shape) {
	            var util = Kinetic.Util,
	                absOpacity = shape.getAbsoluteOpacity(),
	                color = util.get(shape.getShadowColor(), 'black'),
	                blur = util.get(shape.getShadowBlur(), 5),
	                shadowOpacity = util.get(shape.getShadowOpacity(), 1),
	                offset = util.get(shape.getShadowOffset(), {
	                    x: 0,
	                    y: 0
	                });

	            if(shadowOpacity) {
	                this.setAttr('globalAlpha', shadowOpacity * absOpacity);
	            }

	            this.setAttr('shadowColor', color);
	            this.setAttr('shadowBlur', blur);
	            this.setAttr('shadowOffsetX', offset.x);
	            this.setAttr('shadowOffsetY', offset.y);
	        
	        }
	    };
	    Kinetic.Util.extend(Kinetic.SceneContext, Kinetic.Context);

	    Kinetic.HitContext = function(canvas) {
	        Kinetic.Context.call(this, canvas);
	    };

	    Kinetic.HitContext.prototype = {
	        _fill: function(shape) {
	            this.save();
	            this.setAttr('fillStyle', shape.colorKey);
	            shape._fillFuncHit(this);
	            this.restore();
	        },
	        _stroke: function(shape) {
	            if(shape.hasStroke()) {
	                this._applyLineCap(shape);
	                this.setAttr('lineWidth', shape.strokeWidth());
	                this.setAttr('strokeStyle', shape.colorKey);
	                shape._strokeFuncHit(this);
	            }
	        }
	    };
	    Kinetic.Util.extend(Kinetic.HitContext, Kinetic.Context);
	})();
	;/*jshint unused:false */
	(function() {
	    // CONSTANTS
	    var GET = 'get',
	        RGB = 'RGB',
	        SET = 'set';

	    Kinetic.Factory = {
	        addGetterSetter: function(constructor, attr, def, validator, after) {
	            this.addGetter(constructor, attr, def);
	            this.addSetter(constructor, attr, validator, after);
	            this.addOverloadedGetterSetter(constructor, attr);
	        },
	        addGetter: function(constructor, attr, def) {
	            var method = GET + Kinetic.Util._capitalize(attr);

	            constructor.prototype[method] = function() {
	                var val = this.attrs[attr];
	                return val === undefined ? def : val;
	            };
	        },
	        addSetter: function(constructor, attr, validator, after) {
	            var method = SET + Kinetic.Util._capitalize(attr);

	            constructor.prototype[method] = function(val) {
	                if (validator) {
	                    val = validator.call(this, val);
	                }

	                this._setAttr(attr, val);

	                if (after) {
	                    after.call(this);
	                }

	                return this;
	            };
	        },
	        addComponentsGetterSetter: function(constructor, attr, components, validator, after) {
	            var len = components.length,
	                capitalize = Kinetic.Util._capitalize,
	                getter = GET + capitalize(attr),
	                setter = SET + capitalize(attr),
	                n, component;

	            // getter
	            constructor.prototype[getter] = function() {
	                var ret = {};

	                for (n=0; n<len; n++) {
	                    component = components[n];
	                    ret[component] = this.getAttr(attr + capitalize(component));
	                }

	                return ret;
	            };

	            // setter
	            constructor.prototype[setter] = function(val) {
	                var oldVal = this.attrs[attr],
	                    key;

	                if (validator) {
	                    val = validator.call(this, val);
	                }

	                for (key in val) {
	                    this._setAttr(attr + capitalize(key), val[key]);
	                }

	                this._fireChangeEvent(attr, oldVal, val);
	                
	                if (after) {
	                    after.call(this);
	                }

	                return this;
	            };

	            this.addOverloadedGetterSetter(constructor, attr);
	        },
	        addOverloadedGetterSetter: function(constructor, attr) {
	            var capitalizedAttr = Kinetic.Util._capitalize(attr),
	                setter = SET + capitalizedAttr,
	                getter = GET + capitalizedAttr;

	            constructor.prototype[attr] = function() {
	                // setting
	                if (arguments.length) {
	                    this[setter](arguments[0]);
	                    return this;
	                }
	                // getting
	                else {
	                    return this[getter]();
	                }
	            };
	        },
	        backCompat: function(constructor, methods) {
	            var key;

	            for (key in methods) {
	                constructor.prototype[key] = constructor.prototype[methods[key]];
	            }
	        },
	        afterSetFilter: function() {
	            this._filterUpToDate = false;
	        }
	    };

	    Kinetic.Validators = {
	        /**
	         * @return {number}
	         */
	        RGBComponent: function(val) {
	            if (val > 255) {
	                return 255;
	            } else if (val < 0) {
	                return 0;
	            } else {
	                return Math.round(val);
	            }
	        },
	        alphaComponent: function(val) {
	            if (val > 1) {
	                return 1;
	            }
	            // chrome does not honor alpha values of 0
	            else if (val < 0.0001) {
	                return 0.0001;
	            }
	            else {
	                return val;
	            }
	        }
	    };
	})();;(function() {
	    // CONSTANTS
	    var ABSOLUTE_OPACITY = 'absoluteOpacity',
	        ABSOLUTE_TRANSFORM = 'absoluteTransform',
	        CHANGE = 'Change',
	        CHILDREN = 'children',
	        DOT = '.',
	        EMPTY_STRING = '',
	        GET = 'get',
	        ID = 'id',
	        KINETIC = 'kinetic',
	        LISTENING = 'listening',
	        MOUSEENTER = 'mouseenter',
	        MOUSELEAVE = 'mouseleave',
	        NAME = 'name',
	        SET = 'set',
	        SHAPE = 'Shape',
	        SPACE = ' ',
	        STAGE = 'stage',
	        TRANSFORM = 'transform',
	        UPPER_STAGE = 'Stage',
	        VISIBLE = 'visible',
	        CLONE_BLACK_LIST = ['id'],

	        TRANSFORM_CHANGE_STR = [
	            'xChange.kinetic',
	            'yChange.kinetic',
	            'scaleXChange.kinetic',
	            'scaleYChange.kinetic',
	            'skewXChange.kinetic',
	            'skewYChange.kinetic',
	            'rotationChange.kinetic',
	            'offsetXChange.kinetic',
	            'offsetYChange.kinetic',
	            'transformsEnabledChange.kinetic'
	        ].join(SPACE);


	    Kinetic.Util.addMethods(Kinetic.Node, {
	        _init: function(config) {
	            var that = this;
	            this._id = Kinetic.idCounter++;
	            this.eventListeners = {};
	            this.attrs = {};
	            this._cache = {};
	            this._filterUpToDate = false;
	            this.setAttrs(config);

	            // event bindings for cache handling
	            this.on(TRANSFORM_CHANGE_STR, function() {
	                this._clearCache(TRANSFORM);
	                that._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	            });
	            this.on('visibleChange.kinetic', function() {
	                that._clearSelfAndDescendantCache(VISIBLE);
	            });
	            this.on('listeningChange.kinetic', function() {
	                that._clearSelfAndDescendantCache(LISTENING);
	            });
	            this.on('opacityChange.kinetic', function() {
	                that._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
	            });
	        },
	        _clearCache: function(attr){
	            if (attr) {
	                delete this._cache[attr];
	            }
	            else {
	                this._cache = {};
	            }
	        },
	        _getCache: function(attr, privateGetter){
	            var cache = this._cache[attr];

	            // if not cached, we need to set it using the private getter method.
	            if (cache === undefined) {
	                this._cache[attr] = privateGetter.call(this);
	            }

	            return this._cache[attr];
	        },
	        /*
	         * when the logic for a cached result depends on ancestor propagation, use this
	         * method to clear self and children cache
	         */
	        _clearSelfAndDescendantCache: function(attr) {
	            this._clearCache(attr);

	            if (this.children) {
	                this.getChildren().each(function(node) {
	                    node._clearSelfAndDescendantCache(attr);
	                });
	            }
	        },
	        /**
	        * clear cached canvas
	        * @method
	        * @memberof Kinetic.Node.prototype
	        * @returns {Kinetic.Node}
	        * @example
	        * node.clearCache();
	        */
	        clearCache: function() {
	            delete this._cache.canvas;
	            this._filterUpToDate = false;
	            return this;
	        },
	        /**
	        * cache node to improve drawing performance, apply filters, or create more accurate
	        *  hit regions
	        * @method
	        * @memberof Kinetic.Node.prototype
	        * @param {Object} config
	        * @param {Number} [config.x]
	        * @param {Number} [config.y]
	        * @param {Number} [config.width]
	        * @param {Number} [config.height]
	        * @param {Boolean} [config.drawBorder] when set to true, a red border will be drawn around the cached
	        *  region for debugging purposes
	        * @returns {Kinetic.Node}
	        * @example
	        * // cache a shape with the x,y position of the bounding box at the center and
	        * // the width and height of the bounding box equal to the width and height of
	        * // the shape obtained from shape.width() and shape.height()
	        * image.cache();
	        *
	        * // cache a node and define the bounding box position and size
	        * node.cache({
	        *   x: -30,
	        *   y: -30,
	        *   width: 100,
	        *   height: 200
	        * });
	        *
	        * // cache a node and draw a red border around the bounding box
	        * // for debugging purposes
	        * node.cache({
	        *   x: -30,
	        *   y: -30,
	        *   width: 100,
	        *   height: 200,
	        *   drawBorder: true
	        * });
	        */
	        cache: function(config) {
	            var conf = config || {},
	                x = conf.x || 0,
	                y = conf.y || 0,
	                width = conf.width || this.width(),
	                height = conf.height || this.height(),
	                drawBorder = conf.drawBorder || false;

	            if (width === 0 || height === 0) {
	                Kinetic.Util.warn('Width or height of caching configuration equals 0. Cache is ignored.');
	                return;
	            }
	            var cachedSceneCanvas = new Kinetic.SceneCanvas({
	                    pixelRatio: 1,
	                    width: width,
	                    height: height
	                }),
	                cachedFilterCanvas = new Kinetic.SceneCanvas({
	                    pixelRatio: 1,
	                    width: width,
	                    height: height
	                }),
	                cachedHitCanvas = new Kinetic.HitCanvas({
	                    width: width,
	                    height: height
	                }),
	                sceneContext = cachedSceneCanvas.getContext(),
	                hitContext = cachedHitCanvas.getContext();

	            cachedHitCanvas.isCache = true;

	            this.clearCache();
	   
	            sceneContext.save();
	            hitContext.save();

	            // this will draw a red border around the cached box for
	            // debugging purposes
	            if (drawBorder) {
	                sceneContext.save();
	                sceneContext.beginPath();
	                sceneContext.rect(0, 0, width, height);
	                sceneContext.closePath();
	                sceneContext.setAttr('strokeStyle', 'red');
	                sceneContext.setAttr('lineWidth', 5);
	                sceneContext.stroke();
	                sceneContext.restore();
	            }

	            sceneContext.translate(x * -1, y * -1);
	            hitContext.translate(x * -1, y * -1);

	            // don't need to translate canvas if shape is not added to layer
	            if (this.nodeType === 'Shape') {
	                sceneContext.translate(this.x() * -1, this.y() * -1);
	                hitContext.translate(this.x() * -1, this.y() * -1);
	            }

	            this.drawScene(cachedSceneCanvas, this);
	            this.drawHit(cachedHitCanvas, this);

	            sceneContext.restore();
	            hitContext.restore();

	            this._cache.canvas = {
	                scene: cachedSceneCanvas,
	                filter: cachedFilterCanvas,
	                hit: cachedHitCanvas
	            };

	            return this;
	        },
	        _drawCachedSceneCanvas: function(context) {
	            context.save();
	            this.getLayer()._applyTransform(this, context);
	            context._applyOpacity(this);
	            context.drawImage(this._getCachedSceneCanvas()._canvas, 0, 0);
	            context.restore();
	        },
	        _getCachedSceneCanvas: function() {
	            var filters = this.filters(),
	                cachedCanvas = this._cache.canvas,
	                sceneCanvas = cachedCanvas.scene,
	                filterCanvas = cachedCanvas.filter,
	                filterContext = filterCanvas.getContext(),
	                len, imageData, n, filter;

	            if (filters) {
	                if (!this._filterUpToDate) {
	                    try {
	                        len = filters.length;
	                        filterContext.clear();
	                        // copy cached canvas onto filter context
	                        filterContext.drawImage(sceneCanvas._canvas, 0, 0);
	                        imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());

	                        // apply filters to filter context
	                        for (n=0; n<len; n++) {
	                            filter = filters[n];
	                            filter.call(this, imageData);
	                            filterContext.putImageData(imageData, 0, 0);
	                        }
	                    }
	                    catch(e) {
	                        Kinetic.Util.warn('Unable to apply filter. ' + e.message);
	                    }

	                    this._filterUpToDate = true;
	                }

	                return filterCanvas;
	            }
	            else {
	                return sceneCanvas;
	            }
	        },
	        _drawCachedHitCanvas: function(context) {
	            var cachedCanvas = this._cache.canvas,
	                hitCanvas = cachedCanvas.hit;

	            context.save();
	            this.getLayer()._applyTransform(this, context);
	            context.drawImage(hitCanvas._canvas, 0, 0);
	            context.restore();
	        },
	        /**
	         * bind events to the node. KineticJS supports mouseover, mousemove,
	         *  mouseout, mouseenter, mouseleave, mousedown, mouseup, mousewheel, click, dblclick, touchstart, touchmove,
	         *  touchend, tap, dbltap, dragstart, dragmove, and dragend events. The Kinetic Stage supports
	         *  contentMouseover, contentMousemove, contentMouseout, contentMousedown, contentMouseup,
	         *  contentClick, contentDblclick, contentTouchstart, contentTouchmove, contentTouchend, contentTap,
	         *  and contentDblTap.  Pass in a string of events delimmited by a space to bind multiple events at once
	         *  such as 'mousedown mouseup mousemove'. Include a namespace to bind an
	         *  event by name such as 'click.foobar'.
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {String} evtStr e.g. 'click', 'mousedown touchstart', 'mousedown.foo touchstart.foo'
	         * @param {Function} handler The handler function is passed an event object
	         * @returns {Kinetic.Node}
	         * @example
	         * // add click listener
	         * node.on('click', function() {
	         *   console.log('you clicked me!');
	         * });
	         *
	         * // get the target node
	         * node.on('click', function(evt) {
	         *   console.log(evt.target);
	         * });
	         *
	         * // stop event propagation
	         * node.on('click', function(evt) {
	         *   evt.cancelBubble = true;
	         * });
	         *
	         * // bind multiple listeners
	         * node.on('click touchstart', function() {
	         *   console.log('you clicked/touched me!');
	         * });
	         *
	         * // namespace listener
	         * node.on('click.foo', function() {
	         *   console.log('you clicked/touched me!');
	         * });
	         *
	         * // get the event type
	         * node.on('click tap', function(evt) {
	         *   var eventType = evt.type;
	         * });
	         *
	         * // get native event object
	         * node.on('click tap', function(evt) {
	         *   var nativeEvent = evt.evt;
	         * });
	         *
	         * // for change events, get the old and new val
	         * node.on('xChange', function(evt) {
	         *   var oldVal = evt.oldVal;
	         *   var newVal = evt.newVal;
	         * });
	         */
	        on: function(evtStr, handler) {
	            var events = evtStr.split(SPACE),
	                len = events.length,
	                n, event, parts, baseEvent, name;

	             /*
	             * loop through types and attach event listeners to
	             * each one.  eg. 'click mouseover.namespace mouseout'
	             * will create three event bindings
	             */
	            for(n = 0; n < len; n++) {
	                event = events[n];
	                parts = event.split(DOT);
	                baseEvent = parts[0];
	                name = parts[1] || EMPTY_STRING;

	                // create events array if it doesn't exist
	                if(!this.eventListeners[baseEvent]) {
	                    this.eventListeners[baseEvent] = [];
	                }

	                this.eventListeners[baseEvent].push({
	                    name: name,
	                    handler: handler
	                });
	            }

	            return this;
	        },
	        /**
	         * remove event bindings from the node. Pass in a string of
	         *  event types delimmited by a space to remove multiple event
	         *  bindings at once such as 'mousedown mouseup mousemove'.
	         *  include a namespace to remove an event binding by name
	         *  such as 'click.foobar'. If you only give a name like '.foobar',
	         *  all events in that namespace will be removed.
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {String} evtStr e.g. 'click', 'mousedown touchstart', '.foobar'
	         * @returns {Kinetic.Node}
	         * @example
	         * // remove listener
	         * node.off('click');
	         *
	         * // remove multiple listeners
	         * node.off('click touchstart');
	         *
	         * // remove listener by name
	         * node.off('click.foo');
	         */
	        off: function(evtStr) {
	            var events = (evtStr || '').split(SPACE),
	                len = events.length,
	                n, t, event, parts, baseEvent, name;

	            if (!evtStr) {
	                // remove all events
	                for(t in this.eventListeners) {
	                    this._off(t);
	                }
	            }
	            for(n = 0; n < len; n++) {
	                event = events[n];
	                parts = event.split(DOT);
	                baseEvent = parts[0];
	                name = parts[1];

	                if(baseEvent) {
	                    if(this.eventListeners[baseEvent]) {
	                        this._off(baseEvent, name);
	                    }
	                }
	                else {
	                    for(t in this.eventListeners) {
	                        this._off(t, name);
	                    }
	                }
	            }
	            return this;
	        },
	        // some event aliases for third party integration like HammerJS
	        dispatchEvent: function(evt) {
	            var e = {
	              target: this,
	              type: evt.type,
	              evt: evt
	            };
	            this.fire(evt.type, e);
	        },
	        addEventListener: function(type, handler) {
	            // we have to pass native event to handler
	            this.on(type, function(evt){
	                handler.call(this, evt.evt);
	            });
	        },
	        removeEventListener : function(type) {
	            this.off(type);
	        },
	        /**
	         * remove self from parent, but don't destroy
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Kinetic.Node}
	         * @example
	         * node.remove();
	         */
	        remove: function() {
	            var parent = this.getParent();

	            if(parent && parent.children) {
	                parent.children.splice(this.index, 1);
	                parent._setChildrenIndices();
	                delete this.parent;
	            }

	            // every cached attr that is calculated via node tree
	            // traversal must be cleared when removing a node
	            this._clearSelfAndDescendantCache(STAGE);
	            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	            this._clearSelfAndDescendantCache(VISIBLE);
	            this._clearSelfAndDescendantCache(LISTENING);
	            this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);

	            return this;
	        },
	        /**
	         * remove and destroy self
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @example
	         * node.destroy();
	         */
	        destroy: function() {
	            // remove from ids and names hashes
	            Kinetic._removeId(this.getId());
	            Kinetic._removeName(this.getName(), this._id);

	            this.remove();
	        },
	        /**
	         * get attr
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {String} attr
	         * @returns {Integer|String|Object|Array}
	         * @example
	         * var x = node.getAttr('x');
	         */
	        getAttr: function(attr) {
	            var method = GET + Kinetic.Util._capitalize(attr);
	            if(Kinetic.Util._isFunction(this[method])) {
	                return this[method]();
	            }
	            // otherwise get directly
	            else {
	                return this.attrs[attr];
	            }
	        },
	        /**
	        * get ancestors
	        * @method
	        * @memberof Kinetic.Node.prototype
	        * @returns {Kinetic.Collection}
	        * @example
	        * shape.getAncestors().each(function(node) {
	        *   console.log(node.getId());
	        * })
	        */
	        getAncestors: function() {
	            var parent = this.getParent(),
	                ancestors = new Kinetic.Collection();

	            while (parent) {
	                ancestors.push(parent);
	                parent = parent.getParent();
	            }

	            return ancestors;
	        },
	        /**
	         * get attrs object literal
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Object}
	         */
	        getAttrs: function() {
	            return this.attrs || {};
	        },
	        /**
	         * set multiple attrs at once using an object literal
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {Object} config object containing key value pairs
	         * @returns {Kinetic.Node}
	         * @example
	         * node.setAttrs({
	         *   x: 5,
	         *   fill: 'red'
	         * });
	         */
	        setAttrs: function(config) {
	            var key, method;

	            if(config) {
	                for(key in config) {
	                    if (key === CHILDREN || config[key] instanceof Kinetic.Node) {

	                    }
	                    else {
	                        method = SET + Kinetic.Util._capitalize(key);
	                        // use setter if available
	                        if(Kinetic.Util._isFunction(this[method])) {
	                            this[method](config[key]);
	                        }
	                        // otherwise set directly
	                        else {
	                            this._setAttr(key, config[key]);
	                        }
	                    }
	                }
	            }
	            return this;
	        },
	        /**
	         * determine if node is listening for events by taking into account ancestors.
	         *
	         * Parent    | Self      | isListening
	         * listening | listening | 
	         * ----------+-----------+------------
	         * T         | T         | T 
	         * T         | F         | F
	         * F         | T         | T 
	         * F         | F         | F
	         * ----------+-----------+------------
	         * T         | I         | T
	         * F         | I         | F
	         * I         | I         | T
	         *
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Boolean}
	         */
	        isListening: function() {
	            return this._getCache(LISTENING, this._isListening);
	        },
	        _isListening: function() {
	            var listening = this.getListening(),
	                parent = this.getParent();

	            // the following conditions are a simplification of the truth table above.
	            // please modify carefully
	            if (listening === 'inherit') {
	                if (parent) {
	                    return parent.isListening();
	                }
	                else {
	                    return true;
	                }
	            }
	            else {
	                return listening;
	            }
	        },
	        /**
	         * determine if node is visible by taking into account ancestors.
	         *
	         * Parent    | Self      | isVisible
	         * visible   | visible   | 
	         * ----------+-----------+------------
	         * T         | T         | T 
	         * T         | F         | F
	         * F         | T         | T 
	         * F         | F         | F
	         * ----------+-----------+------------
	         * T         | I         | T
	         * F         | I         | F
	         * I         | I         | T

	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Boolean}
	         */
	        isVisible: function() {
	            return this._getCache(VISIBLE, this._isVisible);
	        },
	        _isVisible: function() {
	            var visible = this.getVisible(),
	                parent = this.getParent();

	            // the following conditions are a simplification of the truth table above.
	            // please modify carefully
	            if (visible === 'inherit') {
	                if (parent) {
	                    return parent.isVisible();
	                }
	                else {
	                    return true;
	                }
	            }
	            else {
	                return visible;
	            }
	        },
	        /**
	         * determine if listening is enabled by taking into account descendants.  If self or any children
	         * have _isListeningEnabled set to true, then self also has listening enabled.
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Boolean}
	         */
	        shouldDrawHit: function(canvas) {
	            var layer = this.getLayer();
	            return  (canvas && canvas.isCache) || (layer && layer.hitGraphEnabled())
	                && this.isListening() && this.isVisible();
	        },
	        /**
	         * show node
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Kinetic.Node}
	         */
	        show: function() {
	            this.setVisible(true);
	            return this;
	        },
	        /**
	         * hide node.  Hidden nodes are no longer detectable
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Kinetic.Node}
	         */
	        hide: function() {
	            this.setVisible(false);
	            return this;
	        },
	        /**
	         * get zIndex relative to the node's siblings who share the same parent
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Integer}
	         */
	        getZIndex: function() {
	            return this.index || 0;
	        },
	        /**
	         * get absolute z-index which takes into account sibling
	         *  and ancestor indices
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Integer}
	         */
	        getAbsoluteZIndex: function() {
	            var depth = this.getDepth(),
	                that = this,
	                index = 0,
	                nodes, len, n, child;

	            function addChildren(children) {
	                nodes = [];
	                len = children.length;
	                for(n = 0; n < len; n++) {
	                    child = children[n];
	                    index++;

	                    if(child.nodeType !== SHAPE) {
	                        nodes = nodes.concat(child.getChildren().toArray());
	                    }

	                    if(child._id === that._id) {
	                        n = len;
	                    }
	                }

	                if(nodes.length > 0 && nodes[0].getDepth() <= depth) {
	                    addChildren(nodes);
	                }
	            }
	            if(that.nodeType !== UPPER_STAGE) {
	                addChildren(that.getStage().getChildren());
	            }

	            return index;
	        },
	        /**
	         * get node depth in node tree.  Returns an integer.
	         *  e.g. Stage depth will always be 0.  Layers will always be 1.  Groups and Shapes will always
	         *  be >= 2
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Integer}
	         */
	        getDepth: function() {
	            var depth = 0,
	                parent = this.parent;

	            while(parent) {
	                depth++;
	                parent = parent.parent;
	            }
	            return depth;
	        },
	        setPosition: function(pos) {
	            this.setX(pos.x);
	            this.setY(pos.y);
	            return this;
	        },
	        getPosition: function() {
	            return {
	                x: this.getX(),
	                y: this.getY()
	            };
	        },
	        /**
	         * get absolute position relative to the top left corner of the stage container div
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Object}
	         */
	        getAbsolutePosition: function() {
	            var absoluteMatrix = this.getAbsoluteTransform().getMatrix(),
	                absoluteTransform = new Kinetic.Transform(),
	                offset = this.offset();

	            // clone the matrix array
	            absoluteTransform.m = absoluteMatrix.slice();
	            absoluteTransform.translate(offset.x, offset.y);

	            return absoluteTransform.getTranslation();
	        },
	        /**
	         * set absolute position
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {Object} pos
	         * @param {Number} pos.x
	         * @param {Number} pos.y
	         * @returns {Kinetic.Node}
	         */
	        setAbsolutePosition: function(pos) {
	            var origTrans = this._clearTransform(),
	                it;

	            // don't clear translation
	            this.attrs.x = origTrans.x;
	            this.attrs.y = origTrans.y;
	            delete origTrans.x;
	            delete origTrans.y;

	            // unravel transform
	            it = this.getAbsoluteTransform();

	            it.invert();
	            it.translate(pos.x, pos.y);
	            pos = {
	                x: this.attrs.x + it.getTranslation().x,
	                y: this.attrs.y + it.getTranslation().y
	            };

	            this.setPosition({x:pos.x, y:pos.y});
	            this._setTransform(origTrans);

	            return this;
	        },
	        _setTransform: function(trans) {
	            var key;

	            for(key in trans) {
	                this.attrs[key] = trans[key];
	            }

	            this._clearCache(TRANSFORM);
	            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	        },
	        _clearTransform: function() {
	            var trans = {
	                x: this.getX(),
	                y: this.getY(),
	                rotation: this.getRotation(),
	                scaleX: this.getScaleX(),
	                scaleY: this.getScaleY(),
	                offsetX: this.getOffsetX(),
	                offsetY: this.getOffsetY(),
	                skewX: this.getSkewX(),
	                skewY: this.getSkewY()
	            };

	            this.attrs.x = 0;
	            this.attrs.y = 0;
	            this.attrs.rotation = 0;
	            this.attrs.scaleX = 1;
	            this.attrs.scaleY = 1;
	            this.attrs.offsetX = 0;
	            this.attrs.offsetY = 0;
	            this.attrs.skewX = 0;
	            this.attrs.skewY = 0;

	            this._clearCache(TRANSFORM);
	            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);

	            // return original transform
	            return trans;
	        },
	        /**
	         * move node by an amount relative to its current position
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {Object} change
	         * @param {Number} change.x
	         * @param {Number} change.y
	         * @returns {Kinetic.Node}
	         * @example
	         * // move node in x direction by 1px and y direction by 2px
	         * node.move({
	         *   x: 1,
	         *   y: 2)
	         * });
	         */
	        move: function(change) {
	            var changeX = change.x,
	                changeY = change.y,
	                x = this.getX(),
	                y = this.getY();

	            if(changeX !== undefined) {
	                x += changeX;
	            }

	            if(changeY !== undefined) {
	                y += changeY;
	            }

	            this.setPosition({x:x, y:y});
	            return this;
	        },
	        _eachAncestorReverse: function(func, top) {
	            var family = [],
	                parent = this.getParent(),
	                len, n;

	            // if top node is defined, and this node is top node,
	            // there's no need to build a family tree.  just execute
	            // func with this because it will be the only node
	            if (top && top._id === this._id) {
	                func(this);
	                return true;
	            }

	            family.unshift(this);

	            while(parent && (!top || parent._id !== top._id)) {
	                family.unshift(parent);
	                parent = parent.parent;
	            }

	            len = family.length;
	            for(n = 0; n < len; n++) {
	                func(family[n]);
	            }
	        },
	        /**
	         * rotate node by an amount in degrees relative to its current rotation
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {Number} theta
	         * @returns {Kinetic.Node}
	         */
	        rotate: function(theta) {
	            this.setRotation(this.getRotation() + theta);
	            return this;
	        },
	        /**
	         * move node to the top of its siblings
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Boolean}
	         */
	        moveToTop: function() {
	            if (!this.parent) {
	                Kinetic.Util.warn('Node has no parent. moveToTop function is ignored.');
	                return;
	            }
	            var index = this.index;
	            this.parent.children.splice(index, 1);
	            this.parent.children.push(this);
	            this.parent._setChildrenIndices();
	            return true;
	        },
	        /**
	         * move node up
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Boolean}
	         */
	        moveUp: function() {
	            if (!this.parent) {
	                Kinetic.Util.warn('Node has no parent. moveUp function is ignored.');
	                return;
	            }
	            var index = this.index,
	                len = this.parent.getChildren().length;
	            if(index < len - 1) {
	                this.parent.children.splice(index, 1);
	                this.parent.children.splice(index + 1, 0, this);
	                this.parent._setChildrenIndices();
	                return true;
	            }
	            return false;
	        },
	        /**
	         * move node down
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Boolean}
	         */
	        moveDown: function() {
	            if (!this.parent) {
	                Kinetic.Util.warn('Node has no parent. moveDown function is ignored.');
	                return;
	            }
	            var index = this.index;
	            if(index > 0) {
	                this.parent.children.splice(index, 1);
	                this.parent.children.splice(index - 1, 0, this);
	                this.parent._setChildrenIndices();
	                return true;
	            }
	            return false;
	        },
	        /**
	         * move node to the bottom of its siblings
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Boolean}
	         */
	        moveToBottom: function() {
	            if (!this.parent) {
	                Kinetic.Util.warn('Node has no parent. moveToBottom function is ignored.');
	                return;
	            }
	            var index = this.index;
	            if(index > 0) {
	                this.parent.children.splice(index, 1);
	                this.parent.children.unshift(this);
	                this.parent._setChildrenIndices();
	                return true;
	            }
	            return false;
	        },
	        /**
	         * set zIndex relative to siblings
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {Integer} zIndex
	         * @returns {Kinetic.Node}
	         */
	        setZIndex: function(zIndex) {
	            if (!this.parent) {
	                Kinetic.Util.warn('Node has no parent. zIndex parameter is ignored.');
	                return;
	            }
	            var index = this.index;
	            this.parent.children.splice(index, 1);
	            this.parent.children.splice(zIndex, 0, this);
	            this.parent._setChildrenIndices();
	            return this;
	        },
	        /**
	         * get absolute opacity
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Number}
	         */
	        getAbsoluteOpacity: function() {
	            return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
	        },
	        _getAbsoluteOpacity: function() {
	            var absOpacity = this.getOpacity();
	            if(this.getParent()) {
	                absOpacity *= this.getParent().getAbsoluteOpacity();
	            }
	            return absOpacity;
	        },
	        /**
	         * move node to another container
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {Container} newContainer
	         * @returns {Kinetic.Node}
	         * @example
	         * // move node from current layer into layer2
	         * node.moveTo(layer2);
	         */
	        moveTo: function(newContainer) {
	            // do nothing if new container is already parent
	            if (this.getParent() !== newContainer) {
	                this.remove();
	                newContainer.add(this);
	            }
	            return this;
	        },
	        /**
	         * convert Node into an object for serialization.  Returns an object.
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Object}
	         */
	        toObject: function() {
	            var type = Kinetic.Util,
	                obj = {},
	                attrs = this.getAttrs(),
	                key, val, getter, defaultValue;

	            obj.attrs = {};

	            // serialize only attributes that are not function, image, DOM, or objects with methods
	            for(key in attrs) {
	                val = attrs[key];
	                if (!type._isFunction(val) && !type._isElement(val) && !(type._isObject(val) && type._hasMethods(val))) {
	                    getter = this[key];
	                    // remove attr value so that we can extract the default value from the getter
	                    delete attrs[key];
	                    defaultValue = getter ? getter.call(this) : null;
	                    // restore attr value
	                    attrs[key] = val;
	                    if (defaultValue !== val) {
	                        obj.attrs[key] = val;
	                    }
	                }
	            }

	            obj.className = this.getClassName();
	            return obj;
	        },
	        /**
	         * convert Node into a JSON string.  Returns a JSON string.
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {String}}
	         */
	        toJSON: function() {
	            return JSON.stringify(this.toObject());
	        },
	        /**
	         * get parent container
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Kinetic.Node}
	         */
	        getParent: function() {
	            return this.parent;
	        },
	        /**
	         * get layer ancestor
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Kinetic.Layer}
	         */
	        getLayer: function() {
	            var parent = this.getParent();
	            return parent ? parent.getLayer() : null;
	        },
	        /**
	         * get stage ancestor
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Kinetic.Stage}
	         */
	        getStage: function() {
	            return this._getCache(STAGE, this._getStage);
	        },
	        _getStage: function() {
	            var parent = this.getParent();
	            if(parent) {
	                return parent.getStage();
	            }
	            else {
	                return undefined;
	            }
	        },
	        /**
	         * fire event
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {String} eventType event type.  can be a regular event, like click, mouseover, or mouseout, or it can be a custom event, like myCustomEvent
	         * @param {Event} [evt] event object
	         * @param {Boolean} [bubble] setting the value to false, or leaving it undefined, will result in the event
	         *  not bubbling.  Setting the value to true will result in the event bubbling.
	         * @returns {Kinetic.Node}
	         * @example
	         * // manually fire click event
	         * node.fire('click');
	         *
	         * // fire custom event
	         * node.fire('foo');
	         *
	         * // fire custom event with custom event object
	         * node.fire('foo', {
	         *   bar: 10
	         * });
	         *
	         * // fire click event that bubbles
	         * node.fire('click', null, true);
	         */
	        fire: function(eventType, evt, bubble) {
	            // bubble
	            if (bubble) {
	                this._fireAndBubble(eventType, evt || {});
	            }
	            // no bubble
	            else {
	                this._fire(eventType, evt || {});
	            }
	            return this;
	        },
	        /**
	         * get absolute transform of the node which takes into
	         *  account its ancestor transforms
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Kinetic.Transform}
	         */
	        getAbsoluteTransform: function(top) {
	            // if using an argument, we can't cache the result.
	            if (top) {
	                return this._getAbsoluteTransform(top);
	            }
	            // if no argument, we can cache the result
	            else {
	                return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
	            }
	        },
	        _getAbsoluteTransform: function(top) {
	            var at = new Kinetic.Transform(),
	                transformsEnabled, trans;

	            // start with stage and traverse downwards to self
	            this._eachAncestorReverse(function(node) {
	                transformsEnabled = node.transformsEnabled();
	                trans = node.getTransform();

	                if (transformsEnabled === 'all') {
	                    at.multiply(trans);
	                }
	                else if (transformsEnabled === 'position') {
	                    at.translate(node.x(), node.y());
	                }
	            }, top);
	            return at;
	        },
	        /**
	         * get transform of the node
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Kinetic.Transform}
	         */
	        getTransform: function() {
	            return this._getCache(TRANSFORM, this._getTransform);
	        },
	        _getTransform: function() {
	            var m = new Kinetic.Transform(),
	                x = this.getX(),
	                y = this.getY(),
	                rotation = Kinetic.getAngle(this.getRotation()),
	                scaleX = this.getScaleX(),
	                scaleY = this.getScaleY(),
	                skewX = this.getSkewX(),
	                skewY = this.getSkewY(),
	                offsetX = this.getOffsetX(),
	                offsetY = this.getOffsetY();

	            if(x !== 0 || y !== 0) {
	                m.translate(x, y);
	            }
	            if(rotation !== 0) {
	                m.rotate(rotation);
	            }
	            if(skewX !== 0 || skewY !== 0) {
	                m.skew(skewX, skewY);
	            }
	            if(scaleX !== 1 || scaleY !== 1) {
	                m.scale(scaleX, scaleY);
	            }
	            if(offsetX !== 0 || offsetY !== 0) {
	                m.translate(-1 * offsetX, -1 * offsetY);
	            }

	            return m;
	        },
	        /**
	         * clone node.  Returns a new Node instance with identical attributes.  You can also override
	         *  the node properties with an object literal, enabling you to use an existing node as a template
	         *  for another node
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {Object} obj override attrs
	         * @returns {Kinetic.Node}
	         * @example
	         * // simple clone
	         * var clone = node.clone();
	         *
	         * // clone a node and override the x position
	         * var clone = rect.clone({
	         *   x: 5
	         * });
	         */
	        clone: function(obj) {
	            // instantiate new node
	            var className = this.getClassName(),
	                attrs = Kinetic.Util.cloneObject(this.attrs),
	                key, allListeners, len, n, listener;
	            // filter black attrs
	            for (var i in CLONE_BLACK_LIST) {
	                var blockAttr = CLONE_BLACK_LIST[i];
	                delete attrs[blockAttr];
	            }
	            // apply attr overrides
	            for (key in obj) {
	                attrs[key] = obj[key];
	            }

	            var node = new Kinetic[className](attrs);
	            // copy over listeners
	            for(key in this.eventListeners) {
	                allListeners = this.eventListeners[key];
	                len = allListeners.length;
	                for(n = 0; n < len; n++) {
	                    listener = allListeners[n];
	                    /*
	                     * don't include kinetic namespaced listeners because
	                     *  these are generated by the constructors
	                     */
	                    if(listener.name.indexOf(KINETIC) < 0) {
	                        // if listeners array doesn't exist, then create it
	                        if(!node.eventListeners[key]) {
	                            node.eventListeners[key] = [];
	                        }
	                        node.eventListeners[key].push(listener);
	                    }
	                }
	            }
	            return node;
	        },
	        /**
	         * Creates a composite data URL. If MIME type is not
	         * specified, then "image/png" will result. For "image/jpeg", specify a quality
	         * level as quality (range 0.0 - 1.0)
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {Object} config
	         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
	         *  "image/png" is the default
	         * @param {Number} [config.x] x position of canvas section
	         * @param {Number} [config.y] y position of canvas section
	         * @param {Number} [config.width] width of canvas section
	         * @param {Number} [config.height] height of canvas section
	         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
	         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
	         *  is very high quality
	         * @returns {String}
	         */
	        toDataURL: function(config) {
	            config = config || {};

	            var mimeType = config.mimeType || null,
	                quality = config.quality || null,
	                stage = this.getStage(),
	                x = config.x || 0,
	                y = config.y || 0,
	                canvas = new Kinetic.SceneCanvas({
	                    width: config.width || this.getWidth() || (stage ? stage.getWidth() : 0),
	                    height: config.height || this.getHeight() || (stage ? stage.getHeight() : 0),
	                    pixelRatio: 1
	                }),
	                context = canvas.getContext();

	            context.save();

	            if(x || y) {
	                context.translate(-1 * x, -1 * y);
	            }

	            this.drawScene(canvas);
	            context.restore();

	            return canvas.toDataURL(mimeType, quality);
	        },
	        /**
	         * converts node into an image.  Since the toImage
	         *  method is asynchronous, a callback is required.  toImage is most commonly used
	         *  to cache complex drawings as an image so that they don't have to constantly be redrawn
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {Object} config
	         * @param {Function} config.callback function executed when the composite has completed
	         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
	         *  "image/png" is the default
	         * @param {Number} [config.x] x position of canvas section
	         * @param {Number} [config.y] y position of canvas section
	         * @param {Number} [config.width] width of canvas section
	         * @param {Number} [config.height] height of canvas section
	         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
	         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
	         *  is very high quality
	         * @example
	         * var image = node.toImage({
	         *   callback: function(img) {
	         *     // do stuff with img
	         *   }
	         * });
	         */
	        toImage: function(config) {
	            Kinetic.Util._getImage(this.toDataURL(config), function(img) {
	                config.callback(img);
	            });
	        },
	        setSize: function(size) {
	            this.setWidth(size.width);
	            this.setHeight(size.height);
	            return this;
	        },
	        getSize: function() {
	            return {
	                width: this.getWidth(),
	                height: this.getHeight()
	            };
	        },
	        getWidth: function() {
	            return this.attrs.width || 0;
	        },
	        getHeight: function() {
	            return this.attrs.height || 0;
	        },
	        /**
	         * get class name, which may return Stage, Layer, Group, or shape class names like Rect, Circle, Text, etc.
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {String}
	         */
	        getClassName: function() {
	            return this.className || this.nodeType;
	        },
	        /**
	         * get the node type, which may return Stage, Layer, Group, or Node
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {String}
	         */
	        getType: function() {
	            return this.nodeType;
	        },
	        getDragDistance: function() {
	            // compare with undefined because we need to track 0 value
	            if (this.attrs.dragDistance !== undefined) {
	                return this.attrs.dragDistance;
	            } else if (this.parent) {
	                return this.parent.getDragDistance();
	            } else {
	                return Kinetic.dragDistance;
	            }
	        },
	        _get: function(selector) {
	            return this.className === selector || this.nodeType === selector ? [this] : [];
	        },
	        _off: function(type, name) {
	            var evtListeners = this.eventListeners[type],
	                i, evtName;

	            for(i = 0; i < evtListeners.length; i++) {
	                evtName = evtListeners[i].name;
	                // the following two conditions must be true in order to remove a handler:
	                // 1) the current event name cannot be kinetic unless the event name is kinetic
	                //    this enables developers to force remove a kinetic specific listener for whatever reason
	                // 2) an event name is not specified, or if one is specified, it matches the current event name
	                if((evtName !== 'kinetic' || name === 'kinetic') && (!name || evtName === name)) {
	                    evtListeners.splice(i, 1);
	                    if(evtListeners.length === 0) {
	                        delete this.eventListeners[type];
	                        break;
	                    }
	                    i--;
	                }
	            }
	        },
	        _fireChangeEvent: function(attr, oldVal, newVal) {
	            this._fire(attr + CHANGE, {
	                oldVal: oldVal,
	                newVal: newVal
	            });
	        },
	        setId: function(id) {
	            var oldId = this.getId();

	            Kinetic._removeId(oldId);
	            Kinetic._addId(this, id);
	            this._setAttr(ID, id);
	            return this;
	        },
	        setName: function(name) {
	            var oldName = this.getName();

	            Kinetic._removeName(oldName, this._id);
	            Kinetic._addName(this, name);
	            this._setAttr(NAME, name);
	            return this;
	        },
	        /**
	         * set attr
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @param {String} attr
	         * @param {*} val
	         * @returns {Kinetic.Node}
	         * @example
	         * node.setAttr('x', 5);
	         */
	        setAttr: function(attr, val) {
	            var method = SET + Kinetic.Util._capitalize(attr),
	                func = this[method];

	            if(Kinetic.Util._isFunction(func)) {
	                func.call(this, val);
	            }
	            // otherwise set directly
	            else {
	                this._setAttr(attr, val);
	            }
	            return this;
	        },
	        _setAttr: function(key, val) {
	            var oldVal;
	            if(val !== undefined) {
	                oldVal = this.attrs[key];
	                this.attrs[key] = val;
	                this._fireChangeEvent(key, oldVal, val);
	            }
	        },
	        _setComponentAttr: function(key, component, val) {
	            var oldVal;
	            if(val !== undefined) {
	                oldVal = this.attrs[key];

	                if (!oldVal) {
	                    // set value to default value using getAttr
	                    this.attrs[key] = this.getAttr(key);
	                }
	                
	                this.attrs[key][component] = val;
	                this._fireChangeEvent(key, oldVal, val);
	            }
	        },
	        _fireAndBubble: function(eventType, evt, compareShape) {
	            var okayToRun = true;

	            if(evt && this.nodeType === SHAPE) {
	                evt.target = this;
	            }

	            if(eventType === MOUSEENTER && compareShape && (this._id === compareShape._id || (this.isAncestorOf && this.isAncestorOf(compareShape)))) {
	                okayToRun = false;
	            }
	            else if(eventType === MOUSELEAVE && compareShape && (this._id === compareShape._id || (this.isAncestorOf && this.isAncestorOf(compareShape)))) {
	                okayToRun = false;
	            }
	            if(okayToRun) {
	                this._fire(eventType, evt);

	                // simulate event bubbling
	                var stopBubble = (eventType === MOUSEENTER || eventType === MOUSELEAVE) && ((compareShape && compareShape.isAncestorOf && compareShape.isAncestorOf(this)) || !!(compareShape && compareShape.isAncestorOf));
	                if(evt && !evt.cancelBubble && this.parent && this.parent.isListening() && (!stopBubble)) {
	                    if(compareShape && compareShape.parent) {
	                        this._fireAndBubble.call(this.parent, eventType, evt, compareShape.parent);
	                    }
	                    else {
	                        this._fireAndBubble.call(this.parent, eventType, evt);
	                    }
	                }
	            }
	        },
	        _fire: function(eventType, evt) {
	            var events = this.eventListeners[eventType],
	                i;

	            evt.type = eventType;

	            if (events) {
	                for(i = 0; i < events.length; i++) {
	                    events[i].handler.call(this, evt);
	                }
	            }
	        },
	        /**
	         * draw both scene and hit graphs.  If the node being drawn is the stage, all of the layers will be cleared and redrawn
	         * @method
	         * @memberof Kinetic.Node.prototype
	         * @returns {Kinetic.Node}
	         */
	        draw: function() {
	            this.drawScene();
	            this.drawHit();
	            return this;
	        }
	    });

	    /**
	     * create node with JSON string.  De-serializtion does not generate custom
	     *  shape drawing functions, images, or event handlers (this would make the
	     *  serialized object huge).  If your app uses custom shapes, images, and
	     *  event handlers (it probably does), then you need to select the appropriate
	     *  shapes after loading the stage and set these properties via on(), setDrawFunc(),
	     *  and setImage() methods
	     * @method
	     * @memberof Kinetic.Node
	     * @param {String} json
	     * @param {Element} [container] optional container dom element used only if you're
	     *  creating a stage node
	     */
	    Kinetic.Node.create = function(json, container) {
	        return this._createNode(JSON.parse(json), container);
	    };
	    Kinetic.Node._createNode = function(obj, container) {
	        var className = Kinetic.Node.prototype.getClassName.call(obj),
	            children = obj.children,
	            no, len, n;

	        // if container was passed in, add it to attrs
	        if(container) {
	            obj.attrs.container = container;
	        }

	        no = new Kinetic[className](obj.attrs);
	        if(children) {
	            len = children.length;
	            for(n = 0; n < len; n++) {
	                no.add(this._createNode(children[n]));
	            }
	        }

	        return no;
	    };


	    // =========================== add getters setters ===========================

	    Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'position');
	    /**
	     * get/set node position relative to parent
	     * @name position
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Object} pos
	     * @param {Number} pos.x
	     * @param {Number} pos.y
	     * @returns {Object}
	     * @example
	     * // get position
	     * var position = node.position();
	     *
	     * // set position
	     * node.position({
	     *   x: 5
	     *   y: 10
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'x', 0);

	    /**
	     * get/set x position
	     * @name x
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Number} x
	     * @returns {Object}
	     * @example
	     * // get x
	     * var x = node.x();
	     *
	     * // set x
	     * node.x(5);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'y', 0);

	    /**
	     * get/set y position
	     * @name y
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Number} y
	     * @returns {Integer}
	     * @example
	     * // get y
	     * var y = node.y();
	     *
	     * // set y
	     * node.y(5);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'opacity', 1);

	    /**
	     * get/set opacity.  Opacity values range from 0 to 1.
	     *  A node with an opacity of 0 is fully transparent, and a node
	     *  with an opacity of 1 is fully opaque
	     * @name opacity
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Object} opacity
	     * @returns {Number}
	     * @example
	     * // get opacity
	     * var opacity = node.opacity();
	     *
	     * // set opacity
	     * node.opacity(0.5);
	     */

	    Kinetic.Factory.addGetter(Kinetic.Node, 'name');
	    Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'name');

	    /**
	     * get/set name
	     * @name name
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {String} name
	     * @returns {String}
	     * @example
	     * // get name
	     * var name = node.name();
	     *
	     * // set name
	     * node.name('foo');
	     *
	     * // also node may have multiple names (as css classes)
	     * node.name('foo bar');
	     */

	    Kinetic.Factory.addGetter(Kinetic.Node, 'id');
	    Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'id');

	    /**
	     * get/set id
	     * @name id
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {String} id
	     * @returns {String}
	     * @example
	     * // get id
	     * var name = node.id();
	     *
	     * // set id
	     * node.id('foo');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'rotation', 0);

	    /**
	     * get/set rotation in degrees
	     * @name rotation
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Number} rotation
	     * @returns {Number}
	     * @example
	     * // get rotation in degrees
	     * var rotation = node.rotation();
	     *
	     * // set rotation in degrees
	     * node.rotation(45);
	     */

	    Kinetic.Factory.addComponentsGetterSetter(Kinetic.Node, 'scale', ['x', 'y']);

	    /**
	     * get/set scale
	     * @name scale
	     * @param {Object} scale
	     * @param {Number} scale.x
	     * @param {Number} scale.y
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @returns {Object}
	     * @example
	     * // get scale
	     * var scale = node.scale();
	     *
	     * // set scale 
	     * shape.scale({
	     *   x: 2
	     *   y: 3
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'scaleX', 1);

	    /**
	     * get/set scale x
	     * @name scaleX
	     * @param {Number} x
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @returns {Number}
	     * @example
	     * // get scale x
	     * var scaleX = node.scaleX();
	     *
	     * // set scale x
	     * node.scaleX(2);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'scaleY', 1);

	    /**
	     * get/set scale y
	     * @name scaleY
	     * @param {Number} y
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @returns {Number}
	     * @example
	     * // get scale y
	     * var scaleY = node.scaleY();
	     *
	     * // set scale y
	     * node.scaleY(2);
	     */

	    Kinetic.Factory.addComponentsGetterSetter(Kinetic.Node, 'skew', ['x', 'y']);

	    /**
	     * get/set skew
	     * @name skew
	     * @param {Object} skew
	     * @param {Number} skew.x
	     * @param {Number} skew.y
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @returns {Object}
	     * @example
	     * // get skew
	     * var skew = node.skew();
	     *
	     * // set skew 
	     * node.skew({
	     *   x: 20
	     *   y: 10
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'skewX', 0);

	    /**
	     * get/set skew x
	     * @name skewX
	     * @param {Number} x
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @returns {Number}
	     * @example
	     * // get skew x
	     * var skewX = node.skewX();
	     *
	     * // set skew x
	     * node.skewX(3);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'skewY', 0);

	    /**
	     * get/set skew y
	     * @name skewY
	     * @param {Number} y
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @returns {Number}
	     * @example
	     * // get skew y
	     * var skewY = node.skewY();
	     *
	     * // set skew y
	     * node.skewY(3);
	     */

	    Kinetic.Factory.addComponentsGetterSetter(Kinetic.Node, 'offset', ['x', 'y']);

	    /**
	     * get/set offset.  Offsets the default position and rotation point
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Object} offset
	     * @param {Number} offset.x
	     * @param {Number} offset.y
	     * @returns {Object}
	     * @example
	     * // get offset
	     * var offset = node.offset();
	     *
	     * // set offset
	     * node.offset({
	     *   x: 20
	     *   y: 10
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'offsetX', 0);

	    /**
	     * get/set offset x
	     * @name offsetX
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get offset x
	     * var offsetX = node.offsetX();
	     *
	     * // set offset x
	     * node.offsetX(3);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'offsetY', 0);

	    /**
	     * get/set offset y
	     * @name offsetY
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get offset y
	     * var offsetY = node.offsetY();
	     *
	     * // set offset y
	     * node.offsetY(3);
	     */

	    Kinetic.Factory.addSetter(Kinetic.Node, 'dragDistance');
	    Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'dragDistance');

	    /**
	     * get/set drag distance
	     * @name dragDistance
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Number} distance
	     * @returns {Number}
	     * @example
	     * // get drag distance
	     * var dragDistance = node.dragDistance();
	     *
	     * // set distance
	     * // node starts dragging only if pointer moved more then 3 pixels
	     * node.dragDistance(3);
	     * // or set globally
	     * Kinetic.dragDistance = 3;
	     */


	    Kinetic.Factory.addSetter(Kinetic.Node, 'width', 0);
	    Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'width');
	    /**
	     * get/set width
	     * @name width
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Number} width
	     * @returns {Number}
	     * @example
	     * // get width
	     * var width = node.width();
	     *
	     * // set width
	     * node.width(100);
	     */

	    Kinetic.Factory.addSetter(Kinetic.Node, 'height', 0);
	    Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'height');
	    /**
	     * get/set height
	     * @name height
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Number} height
	     * @returns {Number}
	     * @example
	     * // get height
	     * var height = node.height();
	     *
	     * // set height
	     * node.height(100);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'listening', 'inherit');
	    /**
	     * get/set listenig attr.  If you need to determine if a node is listening or not
	     *   by taking into account its parents, use the isListening() method  
	     * @name listening
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Boolean|String} listening Can be "inherit", true, or false.  The default is "inherit".
	     * @returns {Boolean|String}
	     * @example
	     * // get listening attr
	     * var listening = node.listening();
	     *
	     * // stop listening for events
	     * node.listening(false);
	     *
	     * // listen for events
	     * node.listening(true);
	     *
	     * // listen to events according to the parent
	     * node.listening('inherit');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'filters', undefined, function(val) {this._filterUpToDate = false;return val;});
	    /**
	     * get/set filters.  Filters are applied to cached canvases
	     * @name filters
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Array} filters array of filters
	     * @returns {Array}
	     * @example
	     * // get filters
	     * var filters = node.filters();
	     *
	     * // set a single filter
	     * node.cache();
	     * node.filters([Kinetic.Filters.Blur]);
	     *
	     * // set multiple filters
	     * node.cache();
	     * node.filters([
	     *   Kinetic.Filters.Blur,
	     *   Kinetic.Filters.Sepia,
	     *   Kinetic.Filters.Invert
	     * ]);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'visible', 'inherit');
	    /**
	     * get/set visible attr.  Can be "inherit", true, or false.  The default is "inherit".
	     *   If you need to determine if a node is visible or not
	     *   by taking into account its parents, use the isVisible() method  
	     * @name visible
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Boolean|String} visible
	     * @returns {Boolean|String}
	     * @example
	     * // get visible attr
	     * var visible = node.visible();
	     *
	     * // make invisible
	     * node.visible(false);
	     *
	     * // make visible
	     * node.visible(true);
	     *
	     * // make visible according to the parent
	     * node.visible('inherit');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'transformsEnabled', 'all');

	    /**
	     * get/set transforms that are enabled.  Can be "all", "none", or "position".  The default
	     *  is "all"
	     * @name transformsEnabled
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {String} enabled
	     * @returns {String}
	     * @example
	     * // enable position transform only to improve draw performance
	     * node.transformsEnabled('position');
	     *
	     * // enable all transforms
	     * node.transformsEnabled('all');
	     */



	    /**
	     * get/set node size
	     * @name size
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Object} size
	     * @param {Number} size.width
	     * @param {Number} size.height
	     * @returns {Object}
	     * @example
	     * // get node size
	     * var size = node.size();
	     * var x = size.x;
	     * var y = size.y;
	     *
	     * // set size
	     * node.size({
	     *   width: 100,
	     *   height: 200
	     * });
	     */
	    Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'size');

	    Kinetic.Factory.backCompat(Kinetic.Node, {
	        rotateDeg: 'rotate',
	        setRotationDeg: 'setRotation',
	        getRotationDeg: 'getRotation'
	    });

	    Kinetic.Collection.mapMethods(Kinetic.Node);
	})();
	;(function() {
	    /**
	    * Grayscale Filter
	    * @function
	    * @memberof Kinetic.Filters
	    * @param {Object} imageData
	    * @example
	    * node.cache();
	    * node.filters([Kinetic.Filters.Grayscale]);
	    */
	    Kinetic.Filters.Grayscale = function(imageData) {
	        var data = imageData.data,
	            len = data.length,
	            i, brightness;

	        for(i = 0; i < len; i += 4) {
	            brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
	            // red
	            data[i] = brightness;
	            // green
	            data[i + 1] = brightness;
	            // blue
	            data[i + 2] = brightness;
	        }
	    };
	})();
	;(function() {
	    /**
	     * Brighten Filter.  
	     * @function
	     * @memberof Kinetic.Filters
	     * @param {Object} imageData
	     * @example
	     * node.cache();
	     * node.filters([Kinetic.Filters.Brighten]);
	     * node.brightness(0.8);
	     */
	    Kinetic.Filters.Brighten = function(imageData) {
	        var brightness = this.brightness() * 255,
	            data = imageData.data,
	            len = data.length,
	            i;

	        for(i = 0; i < len; i += 4) {
	            // red
	            data[i] += brightness;
	            // green
	            data[i + 1] += brightness;
	            // blue
	            data[i + 2] += brightness;
	        }
	    };

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'brightness', 0, null, Kinetic.Factory.afterSetFilter);
	    /**
	    * get/set filter brightness.  The brightness is a number between -1 and 1.&nbsp; Positive values 
	    *  brighten the pixels and negative values darken them. Use with {@link Kinetic.Filters.Brighten} filter.
	    * @name brightness
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Number} brightness value between -1 and 1
	    * @returns {Number}
	    */

	})();
	;(function() {
	    /**
	    * Invert Filter
	    * @function
	    * @memberof Kinetic.Filters
	    * @param {Object} imageData
	    * @example
	    * node.cache();
	    * node.filters([Kinetic.Filters.Invert]);
	    */
	    Kinetic.Filters.Invert = function(imageData) {
	        var data = imageData.data,
	            len = data.length,
	            i;

	        for(i = 0; i < len; i += 4) {
	            // red
	            data[i] = 255 - data[i];
	            // green
	            data[i + 1] = 255 - data[i + 1];
	            // blue
	            data[i + 2] = 255 - data[i + 2];
	        }
	    };
	})();;/*
	 the Gauss filter
	 master repo: https://github.com/pavelpower/kineticjsGaussFilter/
	*/
	(function() {
	    /*

	     StackBlur - a fast almost Gaussian Blur For Canvas

	     Version:   0.5
	     Author:    Mario Klingemann
	     Contact:   mario@quasimondo.com
	     Website:   http://www.quasimondo.com/StackBlurForCanvas
	     Twitter:   @quasimondo

	     In case you find this class useful - especially in commercial projects -
	     I am not totally unhappy for a small donation to my PayPal account
	     mario@quasimondo.de

	     Or support me on flattr:
	     https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

	     Copyright (c) 2010 Mario Klingemann

	     Permission is hereby granted, free of charge, to any person
	     obtaining a copy of this software and associated documentation
	     files (the "Software"), to deal in the Software without
	     restriction, including without limitation the rights to use,
	     copy, modify, merge, publish, distribute, sublicense, and/or sell
	     copies of the Software, and to permit persons to whom the
	     Software is furnished to do so, subject to the following
	     conditions:

	     The above copyright notice and this permission notice shall be
	     included in all copies or substantial portions of the Software.

	     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	     OTHER DEALINGS IN THE SOFTWARE.
	     */

	    function BlurStack() {
	        this.r = 0;
	        this.g = 0;
	        this.b = 0;
	        this.a = 0;
	        this.next = null;
	    }

	    var mul_table = [
	        512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
	        454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
	        482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
	        437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
	        497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
	        320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
	        446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
	        329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
	        505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
	        399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
	        324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
	        268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
	        451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
	        385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
	        332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
	        289,287,285,282,280,278,275,273,271,269,267,265,263,261,259
	    ];

	    var shg_table = [
	        9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
	        17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
	        19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
	        20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
	        21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
	        21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
	        22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
	        22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
	        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
	        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
	        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
	        23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
	    ];

	    function filterGaussBlurRGBA( imageData, radius) {

	        var pixels = imageData.data,
	            width = imageData.width,
	            height = imageData.height;

	        var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,
	            r_out_sum, g_out_sum, b_out_sum, a_out_sum,
	            r_in_sum, g_in_sum, b_in_sum, a_in_sum,
	            pr, pg, pb, pa, rbs;

	        var div = radius + radius + 1,
	            widthMinus1  = width - 1,
	            heightMinus1 = height - 1,
	            radiusPlus1  = radius + 1,
	            sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2,
	            stackStart = new BlurStack(),
	            stackEnd = null,
	            stack = stackStart,
	            stackIn = null,
	            stackOut = null,
	            mul_sum = mul_table[radius],
	            shg_sum = shg_table[radius];

	        for ( i = 1; i < div; i++ ) {
	            stack = stack.next = new BlurStack();
	            if ( i == radiusPlus1 ){
	                stackEnd = stack;
	            }
	        }

	        stack.next = stackStart;

	        yw = yi = 0;

	        for ( y = 0; y < height; y++ )
	        {
	            r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

	            r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
	            g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
	            b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
	            a_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );

	            r_sum += sumFactor * pr;
	            g_sum += sumFactor * pg;
	            b_sum += sumFactor * pb;
	            a_sum += sumFactor * pa;

	            stack = stackStart;

	            for( i = 0; i < radiusPlus1; i++ )
	            {
	                stack.r = pr;
	                stack.g = pg;
	                stack.b = pb;
	                stack.a = pa;
	                stack = stack.next;
	            }

	            for( i = 1; i < radiusPlus1; i++ )
	            {
	                p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
	                r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
	                g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
	                b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
	                a_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;

	                r_in_sum += pr;
	                g_in_sum += pg;
	                b_in_sum += pb;
	                a_in_sum += pa;

	                stack = stack.next;
	            }


	            stackIn = stackStart;
	            stackOut = stackEnd;
	            for ( x = 0; x < width; x++ )
	            {
	                pixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;
	                if ( pa !== 0 )
	                {
	                    pa = 255 / pa;
	                    pixels[yi]   = ((r_sum * mul_sum) >> shg_sum) * pa;
	                    pixels[yi+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
	                    pixels[yi+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
	                } else {
	                    pixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;
	                }

	                r_sum -= r_out_sum;
	                g_sum -= g_out_sum;
	                b_sum -= b_out_sum;
	                a_sum -= a_out_sum;

	                r_out_sum -= stackIn.r;
	                g_out_sum -= stackIn.g;
	                b_out_sum -= stackIn.b;
	                a_out_sum -= stackIn.a;

	                p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;

	                r_in_sum += ( stackIn.r = pixels[p]);
	                g_in_sum += ( stackIn.g = pixels[p+1]);
	                b_in_sum += ( stackIn.b = pixels[p+2]);
	                a_in_sum += ( stackIn.a = pixels[p+3]);

	                r_sum += r_in_sum;
	                g_sum += g_in_sum;
	                b_sum += b_in_sum;
	                a_sum += a_in_sum;

	                stackIn = stackIn.next;

	                r_out_sum += ( pr = stackOut.r );
	                g_out_sum += ( pg = stackOut.g );
	                b_out_sum += ( pb = stackOut.b );
	                a_out_sum += ( pa = stackOut.a );

	                r_in_sum -= pr;
	                g_in_sum -= pg;
	                b_in_sum -= pb;
	                a_in_sum -= pa;

	                stackOut = stackOut.next;

	                yi += 4;
	            }
	            yw += width;
	        }


	        for ( x = 0; x < width; x++ )
	        {
	            g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

	            yi = x << 2;
	            r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
	            g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
	            b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
	            a_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);

	            r_sum += sumFactor * pr;
	            g_sum += sumFactor * pg;
	            b_sum += sumFactor * pb;
	            a_sum += sumFactor * pa;

	            stack = stackStart;

	            for( i = 0; i < radiusPlus1; i++ )
	            {
	                stack.r = pr;
	                stack.g = pg;
	                stack.b = pb;
	                stack.a = pa;
	                stack = stack.next;
	            }

	            yp = width;

	            for( i = 1; i <= radius; i++ )
	            {
	                yi = ( yp + x ) << 2;

	                r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
	                g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
	                b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
	                a_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;

	                r_in_sum += pr;
	                g_in_sum += pg;
	                b_in_sum += pb;
	                a_in_sum += pa;

	                stack = stack.next;

	                if( i < heightMinus1 )
	                {
	                    yp += width;
	                }
	            }

	            yi = x;
	            stackIn = stackStart;
	            stackOut = stackEnd;
	            for ( y = 0; y < height; y++ )
	            {
	                p = yi << 2;
	                pixels[p+3] = pa = (a_sum * mul_sum) >> shg_sum;
	                if ( pa > 0 )
	                {
	                    pa = 255 / pa;
	                    pixels[p]   = ((r_sum * mul_sum) >> shg_sum ) * pa;
	                    pixels[p+1] = ((g_sum * mul_sum) >> shg_sum ) * pa;
	                    pixels[p+2] = ((b_sum * mul_sum) >> shg_sum ) * pa;
	                } else {
	                    pixels[p] = pixels[p+1] = pixels[p+2] = 0;
	                }

	                r_sum -= r_out_sum;
	                g_sum -= g_out_sum;
	                b_sum -= b_out_sum;
	                a_sum -= a_out_sum;

	                r_out_sum -= stackIn.r;
	                g_out_sum -= stackIn.g;
	                b_out_sum -= stackIn.b;
	                a_out_sum -= stackIn.a;

	                p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;

	                r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
	                g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
	                b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
	                a_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));

	                stackIn = stackIn.next;

	                r_out_sum += ( pr = stackOut.r );
	                g_out_sum += ( pg = stackOut.g );
	                b_out_sum += ( pb = stackOut.b );
	                a_out_sum += ( pa = stackOut.a );

	                r_in_sum -= pr;
	                g_in_sum -= pg;
	                b_in_sum -= pb;
	                a_in_sum -= pa;

	                stackOut = stackOut.next;

	                yi += width;
	            }
	        }
	    }

	    /**
	     * Blur Filter
	     * @function
	     * @name Blur
	     * @memberof Kinetic.Filters
	     * @param {Object} imageData
	     * @example
	     * node.cache();
	     * node.filters([Kinetic.Filters.Blur]);
	     * node.blurRadius(10);
	     */
	    Kinetic.Filters.Blur = function Blur(imageData) {
	        var radius = Math.round(this.blurRadius());

	        if (radius > 0) {
	            filterGaussBlurRGBA(imageData, radius);
	        }
	    };

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'blurRadius', 0, null, Kinetic.Factory.afterSetFilter);

	    /**
	    * get/set blur radius. Use with {@link Kinetic.Filters.Blur} filter
	    * @name blurRadius
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Integer} radius
	    * @returns {Integer}
	    */
	})();;(function() {

		function pixelAt(idata, x, y) {
			var idx = (y * idata.width + x) * 4;
			var d = [];
			d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
			return d;
		}

		function rgbDistance(p1, p2) {
			return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
		}

		function rgbMean(pTab) {
			var m = [0, 0, 0];

			for (var i = 0; i < pTab.length; i++) {
				m[0] += pTab[i][0];
				m[1] += pTab[i][1];
				m[2] += pTab[i][2];
			}

			m[0] /= pTab.length;
			m[1] /= pTab.length;
			m[2] /= pTab.length;

			return m;
		}

		function backgroundMask(idata, threshold) {
			var rgbv_no = pixelAt(idata, 0, 0);
			var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
			var rgbv_so = pixelAt(idata, 0, idata.height - 1);
			var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);


			var thres = threshold || 10;
			if (rgbDistance(rgbv_no, rgbv_ne) < thres && rgbDistance(rgbv_ne, rgbv_se) < thres && rgbDistance(rgbv_se, rgbv_so) < thres && rgbDistance(rgbv_so, rgbv_no) < thres) {

				// Mean color
				var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);

				// Mask based on color distance
				var mask = [];
				for (var i = 0; i < idata.width * idata.height; i++) {
					var d = rgbDistance(mean, [idata.data[i * 4], idata.data[i * 4 + 1], idata.data[i * 4 + 2]]);
					mask[i] = (d < thres) ? 0 : 255;
				}

				return mask;
			}
		}

		function applyMask(idata, mask) {
			for (var i = 0; i < idata.width * idata.height; i++) {
				idata.data[4 * i + 3] = mask[i];
			}
		}

		function erodeMask(mask, sw, sh) {

			var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
			var side = Math.round(Math.sqrt(weights.length));
			var halfSide = Math.floor(side / 2);

			var maskResult = [];
			for (var y = 0; y < sh; y++) {
				for (var x = 0; x < sw; x++) {

					var so = y * sw + x;
					var a = 0;
					for (var cy = 0; cy < side; cy++) {
						for (var cx = 0; cx < side; cx++) {
							var scy = y + cy - halfSide;
							var scx = x + cx - halfSide;

							if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

								var srcOff = scy * sw + scx;
								var wt = weights[cy * side + cx];

								a += mask[srcOff] * wt;
							}
						}
					}

					maskResult[so] = (a === 255 * 8) ? 255 : 0;
				}
			}

			return maskResult;
		}

		function dilateMask(mask, sw, sh) {

			var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
			var side = Math.round(Math.sqrt(weights.length));
			var halfSide = Math.floor(side / 2);

			var maskResult = [];
			for (var y = 0; y < sh; y++) {
				for (var x = 0; x < sw; x++) {

					var so = y * sw + x;
					var a = 0;
					for (var cy = 0; cy < side; cy++) {
						for (var cx = 0; cx < side; cx++) {
							var scy = y + cy - halfSide;
							var scx = x + cx - halfSide;

							if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

								var srcOff = scy * sw + scx;
								var wt = weights[cy * side + cx];

								a += mask[srcOff] * wt;
							}
						}
					}

					maskResult[so] = (a >= 255 * 4) ? 255 : 0;
				}
			}

			return maskResult;
		}

		function smoothEdgeMask(mask, sw, sh) {

			var weights = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9];
			var side = Math.round(Math.sqrt(weights.length));
			var halfSide = Math.floor(side / 2);

			var maskResult = [];
			for (var y = 0; y < sh; y++) {
				for (var x = 0; x < sw; x++) {

					var so = y * sw + x;
					var a = 0;
					for (var cy = 0; cy < side; cy++) {
						for (var cx = 0; cx < side; cx++) {
							var scy = y + cy - halfSide;
							var scx = x + cx - halfSide;

							if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

								var srcOff = scy * sw + scx;
								var wt = weights[cy * side + cx];

								a += mask[srcOff] * wt;
							}
						}
					}

					maskResult[so] = a;
				}
			}

			return maskResult;
		}
		
		/**
		 * Mask Filter
		 * @function
		 * @name Mask
		 * @memberof Kinetic.Filters
		 * @param {Object} imageData
		 * @example
	     * node.cache();
	     * node.filters([Kinetic.Filters.Mask]);
	     * node.threshold(0.1);
		 */
		Kinetic.Filters.Mask = function(imageData) {
			// Detect pixels close to the background color
			var threshold = this.threshold(),
	        mask = backgroundMask(imageData, threshold);
			if (mask) {
				// Erode
				mask = erodeMask(mask, imageData.width, imageData.height);

				// Dilate
				mask = dilateMask(mask, imageData.width, imageData.height);

				// Gradient
				mask = smoothEdgeMask(mask, imageData.width, imageData.height);

				// Apply mask
				applyMask(imageData, mask);
				
				// todo : Update hit region function according to mask
			}

			return imageData;
		};

		Kinetic.Factory.addGetterSetter(Kinetic.Node, 'threshold', 0, null, Kinetic.Factory.afterSetFilter);
	})();
	;(function () {
	    /**
	     * RGB Filter
	     * @function
	     * @name RGB
	     * @memberof Kinetic.Filters
	     * @param {Object} imageData
	     * @author ippo615
	     * @example
	     * node.cache();
	     * node.filters([Kinetic.Filters.RGB]);
	     * node.blue(120);
	     * node.green(200);
	     */
	    Kinetic.Filters.RGB = function (imageData) {
	        var data = imageData.data,
	            nPixels = data.length,
	            red = this.red(),
	            green = this.green(),
	            blue = this.blue(),
	            i, brightness;

	        for (i = 0; i < nPixels; i += 4) {
	            brightness = (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2])/255;
	            data[i    ] = brightness*red; // r
	            data[i + 1] = brightness*green; // g
	            data[i + 2] = brightness*blue; // b
	            data[i + 3] = data[i + 3]; // alpha
	        }
	    };

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'red', 0, function(val) {
	        this._filterUpToDate = false;
	        if (val > 255) {
	            return 255;
	        }
	        else if (val < 0) {
	            return 0;
	        }
	        else {
	            return Math.round(val);
	        }
	    });
	    /**
	    * get/set filter red value. Use with {@link Kinetic.Filters.RGB} filter.
	    * @name red
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Integer} red value between 0 and 255
	    * @returns {Integer}
	    */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'green', 0, function(val) {
	        this._filterUpToDate = false;
	        if (val > 255) {
	            return 255;
	        }
	        else if (val < 0) {
	            return 0;
	        }
	        else {
	            return Math.round(val);
	        }
	    });
	    /**
	    * get/set filter green value. Use with {@link Kinetic.Filters.RGB} filter.
	    * @name green
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Integer} green value between 0 and 255
	    * @returns {Integer}
	    */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'blue', 0, Kinetic.Validators.RGBComponent, Kinetic.Factory.afterSetFilter);
	    /**
	    * get/set filter blue value. Use with {@link Kinetic.Filters.RGB} filter.
	    * @name blue
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Integer} blue value between 0 and 255
	    * @returns {Integer}
	    */
	})();
	;(function () {

	    /**
	    * HSV Filter. Adjusts the hue, saturation and value
	    * @function
	    * @name HSV
	    * @memberof Kinetic.Filters
	    * @param {Object} imageData
	    * @author ippo615
	    * @example
	    * image.filters([Kinetic.Filters.HSV]);
	    * image.value(200);
	    */

	    Kinetic.Filters.HSV = function (imageData) {
	        var data = imageData.data,
	            nPixels = data.length,
	            v = Math.pow(2,this.value()),
	            s = Math.pow(2,this.saturation()),
	            h = Math.abs((this.hue()) + 360) % 360,
	            i;

	        // Basis for the technique used:
	        // http://beesbuzz.biz/code/hsv_color_transforms.php
	        // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
	        // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
	        // H is the hue shift in degrees (0 to 360)
	        // vsu = V*S*cos(H*PI/180);
	        // vsw = V*S*sin(H*PI/180);
	        //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
	        //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
	        //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

	        // Precompute the values in the matrix:
	        var vsu = v*s*Math.cos(h*Math.PI/180),
	            vsw = v*s*Math.sin(h*Math.PI/180);
	        // (result spot)(source spot)
	        var rr = 0.299*v+0.701*vsu+0.167*vsw,
	            rg = 0.587*v-0.587*vsu+0.330*vsw,
	            rb = 0.114*v-0.114*vsu-0.497*vsw;
	        var gr = 0.299*v-0.299*vsu-0.328*vsw,
	            gg = 0.587*v+0.413*vsu+0.035*vsw,
	            gb = 0.114*v-0.114*vsu+0.293*vsw;
	        var br = 0.299*v-0.300*vsu+1.250*vsw,
	            bg = 0.587*v-0.586*vsu-1.050*vsw,
	            bb = 0.114*v+0.886*vsu-0.200*vsw;

	        var r,g,b,a;

	        for (i = 0; i < nPixels; i += 4) {
	            r = data[i+0];
	            g = data[i+1];
	            b = data[i+2];
	            a = data[i+3];

	            data[i+0] = rr*r + rg*g + rb*b;
	            data[i+1] = gr*r + gg*g + gb*b;
	            data[i+2] = br*r + bg*g + bb*b;
	            data[i+3] = a; // alpha
	        }

	    };

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'hue', 0, null, Kinetic.Factory.afterSetFilter);
	    /**
	    * get/set hsv hue in degrees. Use with {@link Kinetic.Filters.HSV} or {@link Kinetic.Filters.HSL} filter.
	    * @name hue
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Number} hue value between 0 and 359
	    * @returns {Number}
	    */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'saturation', 0, null, Kinetic.Factory.afterSetFilter);
	    /**
	    * get/set hsv saturation. Use with {@link Kinetic.Filters.HSV} or {@link Kinetic.Filters.HSL} filter.
	    * @name saturation
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
	    * @returns {Number}
	    */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'value', 0, null, Kinetic.Factory.afterSetFilter);
	    /**
	    * get/set hsv value. Use with {@link Kinetic.Filters.HSV} filter.
	    * @name value
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
	    * @returns {Number}
	    */

	})();
	;(function () {

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'hue', 0, null, Kinetic.Factory.afterSetFilter);
	    /**
	    * get/set hsv hue in degrees. Use with {@link Kinetic.Filters.HSV} or {@link Kinetic.Filters.HSL} filter.
	    * @name hue
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Number} hue value between 0 and 359
	    * @returns {Number}
	    */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'saturation', 0, null, Kinetic.Factory.afterSetFilter);
	    /**
	    * get/set hsv saturation. Use with {@link Kinetic.Filters.HSV} or {@link Kinetic.Filters.HSL} filter.
	    * @name saturation
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
	    * @returns {Number}
	    */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'luminance', 0, null, Kinetic.Factory.afterSetFilter);
	    /**
	    * get/set hsl luminance. Use with {@link Kinetic.Filters.HSL} filter.
	    * @name value
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
	    * @returns {Number}
	    */

	    /**
	    * HSL Filter. Adjusts the hue, saturation and luminance (or lightness)
	    * @function
	    * @memberof Kinetic.Filters
	    * @param {Object} imageData
	    * @author ippo615
	    * @example
	    * image.filters([Kinetic.Filters.HSL]);
	    * image.luminance(200);
	    */

	    Kinetic.Filters.HSL = function (imageData) {
	        var data = imageData.data,
	            nPixels = data.length,
	            v = 1,
	            s = Math.pow(2,this.saturation()),
	            h = Math.abs((this.hue()) + 360) % 360,
	            l = this.luminance()*127,
	            i;

	        // Basis for the technique used:
	        // http://beesbuzz.biz/code/hsv_color_transforms.php
	        // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
	        // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
	        // H is the hue shift in degrees (0 to 360)
	        // vsu = V*S*cos(H*PI/180);
	        // vsw = V*S*sin(H*PI/180);
	        //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
	        //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
	        //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

	        // Precompute the values in the matrix:
	        var vsu = v*s*Math.cos(h*Math.PI/180),
	            vsw = v*s*Math.sin(h*Math.PI/180);
	        // (result spot)(source spot)
	        var rr = 0.299*v+0.701*vsu+0.167*vsw,
	            rg = 0.587*v-0.587*vsu+0.330*vsw,
	            rb = 0.114*v-0.114*vsu-0.497*vsw;
	        var gr = 0.299*v-0.299*vsu-0.328*vsw,
	            gg = 0.587*v+0.413*vsu+0.035*vsw,
	            gb = 0.114*v-0.114*vsu+0.293*vsw;
	        var br = 0.299*v-0.300*vsu+1.250*vsw,
	            bg = 0.587*v-0.586*vsu-1.050*vsw,
	            bb = 0.114*v+0.886*vsu-0.200*vsw;

	        var r,g,b,a;

	        for (i = 0; i < nPixels; i += 4) {
	            r = data[i+0];
	            g = data[i+1];
	            b = data[i+2];
	            a = data[i+3];

	            data[i+0] = rr*r + rg*g + rb*b + l;
	            data[i+1] = gr*r + gg*g + gb*b + l;
	            data[i+2] = br*r + bg*g + bb*b + l;
	            data[i+3] = a; // alpha
	        }
	    };
	})();
	;(function () {
	    /**
	     * Emboss Filter.
	     * Pixastic Lib - Emboss filter - v0.1.0
	     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
	     * License: [http://www.pixastic.com/lib/license.txt]
	     * @function
	     * @memberof Kinetic.Filters
	     * @param {Object} imageData
	     * @example
	     * node.cache();
	     * node.filters([Kinetic.Filters.Emboss]);
	     * node.embossStrength(0.8);
	     * node.embossWhiteLevel(0.3);
	     * node.embossDirection('right');
	     * node.embossBlend(true);
	     */
	    Kinetic.Filters.Emboss = function (imageData) {

	        // pixastic strength is between 0 and 10.  I want it between 0 and 1
	        // pixastic greyLevel is between 0 and 255.  I want it between 0 and 1.  Also,
	        // a max value of greyLevel yields a white emboss, and the min value yields a black
	        // emboss.  Therefore, I changed greyLevel to whiteLevel
	        var strength = this.embossStrength() * 10,
	            greyLevel = this.embossWhiteLevel() * 255,
	            direction = this.embossDirection(),
	            blend = this.embossBlend(),
	            dirY = 0,
	            dirX = 0,
	            data = imageData.data,
	            w = imageData.width,
	            h = imageData.height,
	            w4 = w*4,
	            y = h;

	        switch (direction) {
	            case 'top-left':
	                dirY = -1;
	                dirX = -1;
	                break;
	            case 'top':
	                dirY = -1;
	                dirX = 0;
	                break;
	            case 'top-right':
	                dirY = -1;
	                dirX = 1;
	                break;
	            case 'right':
	                dirY = 0;
	                dirX = 1;
	                break;
	            case 'bottom-right':
	                dirY = 1;
	                dirX = 1;
	                break;
	            case 'bottom':
	                dirY = 1;
	                dirX = 0;
	                break;
	            case 'bottom-left':
	                dirY = 1;
	                dirX = -1;
	                break;
	            case 'left':
	                dirY = 0;
	                dirX = -1;
	                break;
	        }

	        do {
	            var offsetY = (y-1)*w4;

	            var otherY = dirY;
	            if (y + otherY < 1){
	                otherY = 0;
	            }
	            if (y + otherY > h) {
	                otherY = 0;
	            }

	            var offsetYOther = (y-1+otherY)*w*4;

	            var x = w;
	            do {
	                var offset = offsetY + (x-1)*4;

	                var otherX = dirX;
	                if (x + otherX < 1){
	                    otherX = 0;
	                }
	                if (x + otherX > w) {
	                    otherX = 0;
	                }

	                var offsetOther = offsetYOther + (x-1+otherX)*4;

	                var dR = data[offset] - data[offsetOther];
	                var dG = data[offset+1] - data[offsetOther+1];
	                var dB = data[offset+2] - data[offsetOther+2];

	                var dif = dR;
	                var absDif = dif > 0 ? dif : -dif;

	                var absG = dG > 0 ? dG : -dG;
	                var absB = dB > 0 ? dB : -dB;

	                if (absG > absDif) {
	                    dif = dG;
	                }
	                if (absB > absDif) {
	                    dif = dB;
	                }

	                dif *= strength;

	                if (blend) {
	                    var r = data[offset] + dif;
	                    var g = data[offset+1] + dif;
	                    var b = data[offset+2] + dif;

	                    data[offset] = (r > 255) ? 255 : (r < 0 ? 0 : r);
	                    data[offset+1] = (g > 255) ? 255 : (g < 0 ? 0 : g);
	                    data[offset+2] = (b > 255) ? 255 : (b < 0 ? 0 : b);
	                } else {
	                    var grey = greyLevel - dif;
	                    if (grey < 0) {
	                        grey = 0;
	                    } else if (grey > 255) {
	                        grey = 255;
	                    }

	                    data[offset] = data[offset+1] = data[offset+2] = grey;
	                }

	            } while (--x);
	        } while (--y);
	    };

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'embossStrength', 0.5, null, Kinetic.Factory.afterSetFilter);
	    /**
	    * get/set emboss strength. Use with {@link Kinetic.Filters.Emboss} filter.
	    * @name embossStrength
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Number} level between 0 and 1.  Default is 0.5
	    * @returns {Number}
	    */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'embossWhiteLevel', 0.5, null, Kinetic.Factory.afterSetFilter);
	    /**
	    * get/set emboss white level. Use with {@link Kinetic.Filters.Emboss} filter.
	    * @name embossWhiteLevel
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Number} embossWhiteLevel between 0 and 1.  Default is 0.5
	    * @returns {Number}
	    */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'embossDirection', 'top-left', null, Kinetic.Factory.afterSetFilter);
	    /**
	    * get/set emboss direction. Use with {@link Kinetic.Filters.Emboss} filter.
	    * @name embossDirection
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {String} embossDirection can be top-left, top, top-right, right, bottom-right, bottom, bottom-left or left
	    *   The default is top-left
	    * @returns {String}
	    */

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'embossBlend', false, null, Kinetic.Factory.afterSetFilter);
	    /**
	    * get/set emboss blend. Use with {@link Kinetic.Filters.Emboss} filter.
	    * @name embossBlend
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Boolean} embossBlend
	    * @returns {Boolean}
	    */
	})();


	;(function () {
	    function remap(fromValue, fromMin, fromMax, toMin, toMax) {
	        // Compute the range of the data
	        var fromRange = fromMax - fromMin,
	          toRange = toMax - toMin,
	          toValue;

	        // If either range is 0, then the value can only be mapped to 1 value
	        if (fromRange === 0) {
	            return toMin + toRange / 2;
	        }
	        if (toRange === 0) {
	            return toMin;
	        }

	        // (1) untranslate, (2) unscale, (3) rescale, (4) retranslate
	        toValue = (fromValue - fromMin) / fromRange;
	        toValue = (toRange * toValue) + toMin;

	        return toValue;
	    }


	    /**
	    * Enhance Filter. Adjusts the colors so that they span the widest
	    *  possible range (ie 0-255). Performs w*h pixel reads and w*h pixel
	    *  writes.
	    * @function
	    * @name Enhance
	    * @memberof Kinetic.Filters
	    * @param {Object} imageData
	    * @author ippo615
	    * @example
	    * node.cache();
	    * node.filters([Kinetic.Filters.Enhance]);
	    * node.enhance(0.4);
	    */
	    Kinetic.Filters.Enhance = function (imageData) {
	        var data = imageData.data,
	            nSubPixels = data.length,
	            rMin = data[0], rMax = rMin, r,
	            gMin = data[1], gMax = gMin, g,
	            bMin = data[2], bMax = bMin, b,
	            i;

	        // If we are not enhancing anything - don't do any computation
	        var enhanceAmount = this.enhance();
	        if( enhanceAmount === 0 ){ return; }

	        // 1st Pass - find the min and max for each channel:
	        for (i = 0; i < nSubPixels; i += 4) {
	            r = data[i + 0];
	            if (r < rMin) { rMin = r; }
	            else if (r > rMax) { rMax = r; }
	            g = data[i + 1];
	            if (g < gMin) { gMin = g; } else
	            if (g > gMax) { gMax = g; }
	            b = data[i + 2];
	            if (b < bMin) { bMin = b; } else
	            if (b > bMax) { bMax = b; }
	            //a = data[i + 3];
	            //if (a < aMin) { aMin = a; } else
	            //if (a > aMax) { aMax = a; }
	        }

	        // If there is only 1 level - don't remap
	        if( rMax === rMin ){ rMax = 255; rMin = 0; }
	        if( gMax === gMin ){ gMax = 255; gMin = 0; }
	        if( bMax === bMin ){ bMax = 255; bMin = 0; }

	        var rMid, rGoalMax,rGoalMin,
	            gMid, gGoalMax,gGoalMin,
	            bMid, bGoalMax,bGoalMin;

	        // If the enhancement is positive - stretch the histogram 
	        if ( enhanceAmount > 0 ){
	            rGoalMax = rMax + enhanceAmount*(255-rMax);
	            rGoalMin = rMin - enhanceAmount*(rMin-0);
	            gGoalMax = gMax + enhanceAmount*(255-gMax);
	            gGoalMin = gMin - enhanceAmount*(gMin-0);
	            bGoalMax = bMax + enhanceAmount*(255-bMax);
	            bGoalMin = bMin - enhanceAmount*(bMin-0);
	        // If the enhancement is negative - compress the histogram
	        } else {
	            rMid = (rMax + rMin)*0.5;
	            rGoalMax = rMax + enhanceAmount*(rMax-rMid);
	            rGoalMin = rMin + enhanceAmount*(rMin-rMid);
	            gMid = (gMax + gMin)*0.5;
	            gGoalMax = gMax + enhanceAmount*(gMax-gMid);
	            gGoalMin = gMin + enhanceAmount*(gMin-gMid);
	            bMid = (bMax + bMin)*0.5;
	            bGoalMax = bMax + enhanceAmount*(bMax-bMid);
	            bGoalMin = bMin + enhanceAmount*(bMin-bMid);
	        }

	        // Pass 2 - remap everything, except the alpha
	        for (i = 0; i < nSubPixels; i += 4) {
	            data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
	            data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
	            data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
	            //data[i + 3] = remap(data[i + 3], aMin, aMax, aGoalMin, aGoalMax);
	        }
	    };

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'enhance', 0, null, Kinetic.Factory.afterSetFilter);

	    /**
	    * get/set enhance. Use with {@link Kinetic.Filters.Enhance} filter.
	    * @name enhance
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Float} amount
	    * @returns {Float}
	    */
	})();
	;(function () {

	    /**
	     * Posterize Filter. Adjusts the channels so that there are no more
	     *  than n different values for that channel. This is also applied
	     *  to the alpha channel.
	     * @function
	     * @name Posterize
	     * @author ippo615
	     * @memberof Kinetic.Filters
	     * @param {Object} imageData
	     * @example
	     * node.cache();
	     * node.filters([Kinetic.Filters.Posterize]);
	     * node.levels(0.8);
	     */

	    Kinetic.Filters.Posterize = function (imageData) {
	        // level must be between 1 and 255
	        var levels = Math.round(this.levels() * 254) + 1,
	            data = imageData.data,
	            len = data.length,
	            scale = (255 / levels),
	            i;

	        for (i = 0; i < len; i += 1) {
	            data[i] = Math.floor(data[i] / scale) * scale;
	        }
	    };

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'levels', 0.5, null, Kinetic.Factory.afterSetFilter);

	    /**
	    * get/set levels.  Must be a number between 0 and 1.  Use with {@link Kinetic.Filters.Posterize} filter.
	    * @name levels
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Number} level between 0 and 1
	    * @returns {Number}
	    */
	})();;(function () {

	    /**
	     * Noise Filter. Randomly adds or substracts to the color channels
	     * @function
	     * @name Noise
	     * @memberof Kinetic.Filters
	     * @param {Object} imageData
	     * @author ippo615
	     * @example
	     * node.cache();
	     * node.filters([Kinetic.Filters.Noise]);
	     * node.noise(0.8);
	     */
	    Kinetic.Filters.Noise = function (imageData) {
	        var amount = this.noise() * 255,
	            data = imageData.data,
	            nPixels = data.length,
	            half = amount / 2,
	            i;

	        for (i = 0; i < nPixels; i += 4) {
	            data[i + 0] += half - 2 * half * Math.random();
	            data[i + 1] += half - 2 * half * Math.random();
	            data[i + 2] += half - 2 * half * Math.random();
	        }
	    };

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'noise', 0.2, null, Kinetic.Factory.afterSetFilter);

	    /**
	    * get/set noise amount.  Must be a value between 0 and 1. Use with {@link Kinetic.Filters.Noise} filter.
	    * @name noise
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Number} noise
	    * @returns {Number}
	    */
	})();
	;(function () {

	    /**
	     * Pixelate Filter. Averages groups of pixels and redraws
	     *  them as larger pixels
	     * @function
	     * @name Pixelate
	     * @memberof Kinetic.Filters
	     * @param {Object} imageData
	     * @author ippo615
	     * @example
	     * node.cache();
	     * node.filters([Kinetic.Filters.Pixelate]);
	     * node.pixelSize(10);
	     */

	    Kinetic.Filters.Pixelate = function (imageData) {

	        var pixelSize = Math.ceil(this.pixelSize()),
	            width = imageData.width,
	            height = imageData.height,
	            x, y, i,
	            //pixelsPerBin = pixelSize * pixelSize,
	            red, green, blue, alpha,
	            nBinsX = Math.ceil(width / pixelSize),
	            nBinsY = Math.ceil(height / pixelSize),
	            xBinStart, xBinEnd, yBinStart, yBinEnd,
	            xBin, yBin, pixelsInBin;
	        imageData = imageData.data;

	        for (xBin = 0; xBin < nBinsX; xBin += 1) {
	            for (yBin = 0; yBin < nBinsY; yBin += 1) {
	        
	                // Initialize the color accumlators to 0
	                red = 0;
	                green = 0;
	                blue = 0;
	                alpha = 0;

	                // Determine which pixels are included in this bin
	                xBinStart = xBin * pixelSize;
	                xBinEnd = xBinStart + pixelSize;
	                yBinStart = yBin * pixelSize;
	                yBinEnd = yBinStart + pixelSize;

	                // Add all of the pixels to this bin!
	                pixelsInBin = 0;
	                for (x = xBinStart; x < xBinEnd; x += 1) {
	                    if( x >= width ){ continue; }
	                    for (y = yBinStart; y < yBinEnd; y += 1) {
	                        if( y >= height ){ continue; }
	                        i = (width * y + x) * 4;
	                        red += imageData[i + 0];
	                        green += imageData[i + 1];
	                        blue += imageData[i + 2];
	                        alpha += imageData[i + 3];
	                        pixelsInBin += 1;
	                    }
	                }

	                // Make sure the channels are between 0-255
	                red = red / pixelsInBin;
	                green = green / pixelsInBin;
	                blue = blue / pixelsInBin;

	                // Draw this bin
	                for (x = xBinStart; x < xBinEnd; x += 1) {
	                    if( x >= width ){ continue; }
	                    for (y = yBinStart; y < yBinEnd; y += 1) {
	                        if( y >= height ){ continue; }
	                        i = (width * y + x) * 4;
	                        imageData[i + 0] = red;
	                        imageData[i + 1] = green;
	                        imageData[i + 2] = blue;
	                        imageData[i + 3] = alpha;
	                    }
	                }
	            }
	        }
	      
	    };

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'pixelSize', 8, null, Kinetic.Factory.afterSetFilter);

	    /**
	    * get/set pixel size. Use with {@link Kinetic.Filters.Pixelate} filter.
	    * @name pixelSize
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Integer} pixelSize
	    * @returns {Integer}
	    */
	})();;(function () {

	    /**
	     * Threshold Filter. Pushes any value above the mid point to 
	     *  the max and any value below the mid point to the min.
	     *  This affects the alpha channel.
	     * @function
	     * @name Threshold
	     * @memberof Kinetic.Filters
	     * @param {Object} imageData
	     * @author ippo615
	     * @example
	     * node.cache();
	     * node.filters([Kinetic.Filters.Threshold]);
	     * node.threshold(0.1);
	     */

	    Kinetic.Filters.Threshold = function (imageData) {
	        var level = this.threshold() * 255,
	            data = imageData.data,
	            len = data.length,
	            i;

	        for (i = 0; i < len; i += 1) {
	            data[i] = data[i] < level ? 0 : 255;
	        }
	    };

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'threshold', 0.5, null, Kinetic.Factory.afterSetFilter);

	    /**
	    * get/set threshold.  Must be a value between 0 and 1. Use with {@link Kinetic.Filters.Threshold} or {@link Kinetic.Filters.Mask} filter.
	    * @name threshold
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Number} threshold
	    * @returns {Number}
	    */
	})();;(function() {
	    /**
	     * Sepia Filter
	     * Based on: Pixastic Lib - Sepia filter - v0.1.0
	     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
	     * @function
	     * @name Sepia
	     * @memberof Kinetic.Filters
	     * @param {Object} imageData
	     * @author Jacob Seidelin <jseidelin@nihilogic.dk>
	     * @license MPL v1.1 [http://www.pixastic.com/lib/license.txt]
	     * @example
	     * node.cache();
	     * node.filters([Kinetic.Filters.Sepia]);
	     */
	    Kinetic.Filters.Sepia = function (imageData) {
	        var data = imageData.data,
	            w = imageData.width,
	            y = imageData.height,
	            w4 = w*4,
	            offsetY, x, offset, or, og, ob, r, g, b;
	        
	        do {
	            offsetY = (y-1)*w4;
	            x = w;
	            do {
	                offset = offsetY + (x-1)*4;
	                
	                or = data[offset];
	                og = data[offset+1];
	                ob = data[offset+2];

	                r = or * 0.393 + og * 0.769 + ob * 0.189;
	                g = or * 0.349 + og * 0.686 + ob * 0.168;
	                b = or * 0.272 + og * 0.534 + ob * 0.131;

	                data[offset] = r > 255 ? 255 : r;
	                data[offset+1] = g > 255 ? 255 : g;
	                data[offset+2] = b > 255 ? 255 : b;
	                data[offset+3] = data[offset+3];
	            } while (--x);
	        } while (--y);
	    };
	})();
	;(function () {
	    /**
	     * Solarize Filter
	     * Pixastic Lib - Solarize filter - v0.1.0
	     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
	     * License: [http://www.pixastic.com/lib/license.txt]
	     * @function
	     * @name Solarize
	     * @memberof Kinetic.Filters
	     * @param {Object} imageData
	     * @example
	     * node.cache();
	     * node.filters([Kinetic.Filters.Solarize]);
	     */
	    Kinetic.Filters.Solarize = function (imageData) {
	        var data = imageData.data,
	            w = imageData.width,
	            h = imageData.height,
	            w4 = w*4,
	            y = h;

	        do {
	            var offsetY = (y-1)*w4;
	            var x = w;
	            do {
	                var offset = offsetY + (x-1)*4;
	                var r = data[offset];
	                var g = data[offset+1];
	                var b = data[offset+2];

	                if (r > 127) {
	                    r = 255 - r;
	                }
	                if (g > 127) {
	                    g = 255 - g;
	                }
	                if (b > 127) {
	                    b = 255 - b;
	                }

	                data[offset] = r;
	                data[offset+1] = g;
	                data[offset+2] = b;
	            } while (--x);
	        } while (--y);
	    };
	})();


	;/*jshint newcap:false */
	(function () {

	  /*
	   * ToPolar Filter. Converts image data to polar coordinates. Performs 
	   *  w*h*4 pixel reads and w*h pixel writes. The r axis is placed along
	   *  what would be the y axis and the theta axis along the x axis.
	   * @function
	   * @author ippo615
	   * @memberof Kinetic.Filters
	   * @param {ImageData} src, the source image data (what will be transformed)
	   * @param {ImageData} dst, the destination image data (where it will be saved)
	   * @param {Object} opt
	   * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
	   *  default is in the middle
	   * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
	   *  default is in the middle
	   */

	    var ToPolar = function(src,dst,opt){

	        var srcPixels = src.data,
	            dstPixels = dst.data,
	            xSize = src.width,
	            ySize = src.height,
	            xMid = opt.polarCenterX || xSize/2,
	            yMid = opt.polarCenterY || ySize/2,
	            i, x, y, r=0,g=0,b=0,a=0;

	        // Find the largest radius
	        var rad, rMax = Math.sqrt( xMid*xMid + yMid*yMid );
	        x = xSize - xMid;
	        y = ySize - yMid;
	        rad = Math.sqrt( x*x + y*y );
	        rMax = (rad > rMax)?rad:rMax;

	        // We'll be uisng y as the radius, and x as the angle (theta=t)
	        var rSize = ySize,
	            tSize = xSize,
	            radius, theta;

	        // We want to cover all angles (0-360) and we need to convert to
	        // radians (*PI/180)
	        var conversion = 360/tSize*Math.PI/180, sin, cos;

	        // var x1, x2, x1i, x2i, y1, y2, y1i, y2i, scale;

	        for( theta=0; theta<tSize; theta+=1 ){
	            sin = Math.sin(theta*conversion);
	            cos = Math.cos(theta*conversion);
	            for( radius=0; radius<rSize; radius+=1 ){
	                x = Math.floor(xMid+rMax*radius/rSize*cos);
	                y = Math.floor(yMid+rMax*radius/rSize*sin);
	                i = (y*xSize + x)*4;
	                r = srcPixels[i+0];
	                g = srcPixels[i+1];
	                b = srcPixels[i+2];
	                a = srcPixels[i+3];

	                // Store it
	                //i = (theta * xSize + radius) * 4;
	                i = (theta + radius*xSize) * 4;
	                dstPixels[i+0] = r;
	                dstPixels[i+1] = g;
	                dstPixels[i+2] = b;
	                dstPixels[i+3] = a;

	            }
	        }
	    };

	    /*
	     * FromPolar Filter. Converts image data from polar coordinates back to rectangular.
	     *  Performs w*h*4 pixel reads and w*h pixel writes.
	     * @function
	     * @author ippo615
	     * @memberof Kinetic.Filters
	     * @param {ImageData} src, the source image data (what will be transformed)
	     * @param {ImageData} dst, the destination image data (where it will be saved)
	     * @param {Object} opt
	     * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
	     *  default is in the middle
	     * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
	     *  default is in the middle
	     * @param {Number} [opt.polarRotation] amount to rotate the image counterclockwis,
	     *  0 is no rotation, 360 degrees is a full rotation
	     */

	    var FromPolar = function(src,dst,opt){

	        var srcPixels = src.data,
	            dstPixels = dst.data,
	            xSize = src.width,
	            ySize = src.height,
	            xMid = opt.polarCenterX || xSize/2,
	            yMid = opt.polarCenterY || ySize/2,
	            i, x, y, dx, dy, r=0,g=0,b=0,a=0;


	        // Find the largest radius
	        var rad, rMax = Math.sqrt( xMid*xMid + yMid*yMid );
	        x = xSize - xMid;
	        y = ySize - yMid;
	        rad = Math.sqrt( x*x + y*y );
	        rMax = (rad > rMax)?rad:rMax;

	        // We'll be uisng x as the radius, and y as the angle (theta=t)
	        var rSize = ySize,
	        tSize = xSize,
	        radius, theta,
	        phaseShift = opt.polarRotation || 0;

	        // We need to convert to degrees and we need to make sure
	        // it's between (0-360)
	        // var conversion = tSize/360*180/Math.PI;
	        //var conversion = tSize/360*180/Math.PI;

	        var x1, y1;

	        for( x=0; x<xSize; x+=1 ){
	            for( y=0; y<ySize; y+=1 ){
	                dx = x - xMid;
	                dy = y - yMid;
	                radius = Math.sqrt(dx*dx + dy*dy)*rSize/rMax;
	                theta = (Math.atan2(dy,dx)*180/Math.PI + 360 + phaseShift)%360;
	                theta = theta*tSize/360;
	                x1 = Math.floor(theta);
	                y1 = Math.floor(radius);
	                i = (y1*xSize + x1)*4;
	                r = srcPixels[i+0];
	                g = srcPixels[i+1];
	                b = srcPixels[i+2];
	                a = srcPixels[i+3];

	                // Store it
	                i = (y*xSize + x)*4;
	                dstPixels[i+0] = r;
	                dstPixels[i+1] = g;
	                dstPixels[i+2] = b;
	                dstPixels[i+3] = a;
	            }
	        }

	    };

	    //Kinetic.Filters.ToPolar = Kinetic.Util._FilterWrapDoubleBuffer(ToPolar);
	    //Kinetic.Filters.FromPolar = Kinetic.Util._FilterWrapDoubleBuffer(FromPolar);

	    // create a temporary canvas for working - shared between multiple calls
	    var tempCanvas = Kinetic.Util.createCanvasElement();

	    /*
	     * Kaleidoscope Filter. 
	     * @function
	     * @name Kaleidoscope
	     * @author ippo615
	     * @memberof Kinetic.Filters
	     * @example
	     * node.cache();
	     * node.filters([Kinetic.Filters.Kaleidoscope]);
	     * node.kaleidoscopePower(3);
	     * node.kaleidoscopeAngle(45);
	     */
	    Kinetic.Filters.Kaleidoscope = function(imageData){
	        var xSize = imageData.width,
	            ySize = imageData.height;

	        var x,y,xoff,i, r,g,b,a, srcPos, dstPos;
	        var power = Math.round( this.kaleidoscopePower() );
	        var angle = Math.round( this.kaleidoscopeAngle() );
	        var offset = Math.floor(xSize*(angle%360)/360);

	        if( power < 1 ){return;}

	        // Work with our shared buffer canvas
	        tempCanvas.width = xSize;
	        tempCanvas.height = ySize;
	        var scratchData = tempCanvas.getContext('2d').getImageData(0,0,xSize,ySize);

	        // Convert thhe original to polar coordinates
	        ToPolar( imageData, scratchData, {
	            polarCenterX:xSize/2,
	            polarCenterY:ySize/2
	        });

	        // Determine how big each section will be, if it's too small 
	        // make it bigger
	        var minSectionSize = xSize / Math.pow(2,power);
	        while( minSectionSize <= 8){
	            minSectionSize = minSectionSize*2;
	            power -= 1;
	        }
	        minSectionSize = Math.ceil(minSectionSize);
	        var sectionSize = minSectionSize;

	        // Copy the offset region to 0
	        // Depending on the size of filter and location of the offset we may need
	        // to copy the section backwards to prevent it from rewriting itself
	        var xStart = 0,
	          xEnd = sectionSize,
	          xDelta = 1;
	        if( offset+minSectionSize > xSize ){
	            xStart = sectionSize;
	            xEnd = 0;
	            xDelta = -1;
	        }
	        for( y=0; y<ySize; y+=1 ){
	            for( x=xStart; x !== xEnd; x+=xDelta ){
	                xoff = Math.round(x+offset)%xSize;
	                srcPos = (xSize*y+xoff)*4;
	                r = scratchData.data[srcPos+0];
	                g = scratchData.data[srcPos+1];
	                b = scratchData.data[srcPos+2];
	                a = scratchData.data[srcPos+3];
	                dstPos = (xSize*y+x)*4;
	                scratchData.data[dstPos+0] = r;
	                scratchData.data[dstPos+1] = g;
	                scratchData.data[dstPos+2] = b;
	                scratchData.data[dstPos+3] = a;
	            }
	        }

	        // Perform the actual effect
	        for( y=0; y<ySize; y+=1 ){
	            sectionSize = Math.floor( minSectionSize );
	            for( i=0; i<power; i+=1 ){
	                for( x=0; x<sectionSize+1; x+=1 ){
	                    srcPos = (xSize*y+x)*4;
	                    r = scratchData.data[srcPos+0];
	                    g = scratchData.data[srcPos+1];
	                    b = scratchData.data[srcPos+2];
	                    a = scratchData.data[srcPos+3];
	                    dstPos = (xSize*y+sectionSize*2-x-1)*4;
	                    scratchData.data[dstPos+0] = r;
	                    scratchData.data[dstPos+1] = g;
	                    scratchData.data[dstPos+2] = b;
	                    scratchData.data[dstPos+3] = a;
	                }
	                sectionSize *= 2;
	            }
	        }

	        // Convert back from polar coordinates
	        FromPolar(scratchData,imageData,{polarRotation:0});
	    };

	    /**
	    * get/set kaleidoscope power. Use with {@link Kinetic.Filters.Kaleidoscope} filter.
	    * @name kaleidoscopePower
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Integer} power of kaleidoscope
	    * @returns {Integer}
	    */
	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'kaleidoscopePower', 2, null, Kinetic.Factory.afterSetFilter);

	    /**
	    * get/set kaleidoscope angle. Use with {@link Kinetic.Filters.Kaleidoscope} filter.
	    * @name kaleidoscopeAngle
	    * @method
	    * @memberof Kinetic.Node.prototype
	    * @param {Integer} degrees
	    * @returns {Integer}
	    */
	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'kaleidoscopeAngle', 0, null, Kinetic.Factory.afterSetFilter);

	})();
	;(function() {
	    var BATCH_DRAW_STOP_TIME_DIFF = 500;

	    var now =(function() {
	        if (Kinetic.root.performance && Kinetic.root.performance.now) {
	            return function() {
	                return Kinetic.root.performance.now();
	            };
	        }
	        else {
	            return function() {
	                return new Date().getTime();
	            };
	        }
	    })();

	    var RAF = (function() {
	        return Kinetic.root.requestAnimationFrame
	            || Kinetic.root.webkitRequestAnimationFrame
	            || Kinetic.root.mozRequestAnimationFrame
	            || Kinetic.root.oRequestAnimationFrame
	            || Kinetic.root.msRequestAnimationFrame
	            || FRAF;
	    })();

	    function FRAF(callback) {
	        setTimeout(callback, 1000 / 60);
	    }

	    function requestAnimFrame() {
	        return RAF.apply(Kinetic.root, arguments);
	    }
	    
	    /**
	     * Animation constructor.  A stage is used to contain multiple layers and handle
	     * @constructor
	     * @memberof Kinetic
	     * @param {Function} func function executed on each animation frame.  The function is passed a frame object, which contains
	     *  timeDiff, lastTime, time, and frameRate properties.  The timeDiff property is the number of milliseconds that have passed
	     *  since the last animation frame.  The lastTime property is time in milliseconds that elapsed from the moment the animation started
	     *  to the last animation frame.  The time property is the time in milliseconds that ellapsed from the moment the animation started
	     *  to the current animation frame.  The frameRate property is the current frame rate in frames / second. Return false from function,
	     *  if you don't need to redraw layer/layers on some frames.
	     * @param {Kinetic.Layer|Array} [layers] layer(s) to be redrawn on each animation frame. Can be a layer, an array of layers, or null.
	     *  Not specifying a node will result in no redraw.
	     * @example
	     * // move a node to the right at 50 pixels / second
	     * var velocity = 50;
	     *
	     * var anim = new Kinetic.Animation(function(frame) {
	     *   var dist = velocity * (frame.timeDiff / 1000);
	     *   node.move(dist, 0);
	     * }, layer);
	     *
	     * anim.start();
	     */
	    Kinetic.Animation = function(func, layers) {
	        var Anim = Kinetic.Animation;
	        this.func = func;
	        this.setLayers(layers);
	        this.id = Anim.animIdCounter++;
	        this.frame = {
	            time: 0,
	            timeDiff: 0,
	            lastTime: now()
	        };
	    };
	    /*
	     * Animation methods
	     */
	    Kinetic.Animation.prototype = {
	        /**
	         * set layers to be redrawn on each animation frame
	         * @method
	         * @memberof Kinetic.Animation.prototype
	         * @param {Kinetic.Layer|Array} [layers] layer(s) to be redrawn.&nbsp; Can be a layer, an array of layers, or null.  Not specifying a node will result in no redraw.
	         */
	        setLayers: function(layers) {
	            var lays = [];
	            // if passing in no layers
	            if (!layers) {
	                lays = [];
	            }
	            // if passing in an array of Layers
	            // NOTE: layers could be an array or Kinetic.Collection.  for simplicity, I'm just inspecting
	            // the length property to check for both cases
	            else if (layers.length > 0) {
	                lays = layers;
	            }
	            // if passing in a Layer
	            else {
	                lays = [layers];
	            }

	            this.layers = lays;
	        },
	        /**
	         * get layers
	         * @method
	         * @memberof Kinetic.Animation.prototype
	         */
	        getLayers: function() {
	            return this.layers;
	        },
	        /**
	         * add layer.  Returns true if the layer was added, and false if it was not
	         * @method
	         * @memberof Kinetic.Animation.prototype
	         * @param {Kinetic.Layer} layer
	         */
	        addLayer: function(layer) {
	            var layers = this.layers,
	                len, n;

	            if (layers) {
	                len = layers.length;

	                // don't add the layer if it already exists
	                for (n = 0; n < len; n++) {
	                    if (layers[n]._id === layer._id) {
	                        return false;
	                    }
	                }
	            }
	            else {
	                this.layers = [];
	            }

	            this.layers.push(layer);
	            return true;
	        },
	        /**
	         * determine if animation is running or not.  returns true or false
	         * @method
	         * @memberof Kinetic.Animation.prototype
	         */
	        isRunning: function() {
	            var a = Kinetic.Animation,
	                animations = a.animations,
	                len = animations.length,
	                n;

	            for(n = 0; n < len; n++) {
	                if(animations[n].id === this.id) {
	                    return true;
	                }
	            }
	            return false;
	        },
	        /**
	         * start animation
	         * @method
	         * @memberof Kinetic.Animation.prototype
	         */
	        start: function() {
	            var Anim = Kinetic.Animation;
	            this.stop();
	            this.frame.timeDiff = 0;
	            this.frame.lastTime = now();
	            Anim._addAnimation(this);
	        },
	        /**
	         * stop animation
	         * @method
	         * @memberof Kinetic.Animation.prototype
	         */
	        stop: function() {
	            Kinetic.Animation._removeAnimation(this);
	        },
	        _updateFrameObject: function(time) {
	            this.frame.timeDiff = time - this.frame.lastTime;
	            this.frame.lastTime = time;
	            this.frame.time += this.frame.timeDiff;
	            this.frame.frameRate = 1000 / this.frame.timeDiff;
	        }
	    };
	    Kinetic.Animation.animations = [];
	    Kinetic.Animation.animIdCounter = 0;
	    Kinetic.Animation.animRunning = false;

	    Kinetic.Animation._addAnimation = function(anim) {
	        this.animations.push(anim);
	        this._handleAnimation();
	    };
	    Kinetic.Animation._removeAnimation = function(anim) {
	        var id = anim.id,
	            animations = this.animations,
	            len = animations.length,
	            n;

	        for(n = 0; n < len; n++) {
	            if(animations[n].id === id) {
	                this.animations.splice(n, 1);
	                break;
	            }
	        }
	    };

	    Kinetic.Animation._runFrames = function() {
	        var layerHash = {},
	            animations = this.animations,
	            anim, layers, func, n, i, layersLen, layer, key, needRedraw;
	        /*
	         * loop through all animations and execute animation
	         *  function.  if the animation object has specified node,
	         *  we can add the node to the nodes hash to eliminate
	         *  drawing the same node multiple times.  The node property
	         *  can be the stage itself or a layer
	         */
	        /*
	         * WARNING: don't cache animations.length because it could change while
	         * the for loop is running, causing a JS error
	         */

	        for(n = 0; n < animations.length; n++) {
	            anim = animations[n];
	            layers = anim.layers;
	            func = anim.func;


	            anim._updateFrameObject(now());
	            layersLen = layers.length;

	            // if animation object has a function, execute it
	            if (func) {
	                // allow anim bypassing drawing
	                needRedraw = (func.call(anim, anim.frame) !== false);
	            } else {
	                needRedraw = true;
	            }
	            if (needRedraw) {
	                for (i = 0; i < layersLen; i++) {
	                    layer = layers[i];

	                    if (layer._id !== undefined) {
	                        layerHash[layer._id] = layer;
	                    }
	                }
	            }
	        }

	        for (key in layerHash) {
	            layerHash[key].draw();
	        }
	    };
	    Kinetic.Animation._animationLoop = function() {
	        var Anim = Kinetic.Animation;

	        if(Anim.animations.length) {
	            requestAnimFrame(Anim._animationLoop);
	            Anim._runFrames();
	        }
	        else {
	            Anim.animRunning = false;
	        }
	    };
	    Kinetic.Animation._handleAnimation = function() {
	        var that = this;
	        if(!this.animRunning) {
	            this.animRunning = true;
	            that._animationLoop();
	        }
	    };

	    var moveTo = Kinetic.Node.prototype.moveTo;
	    Kinetic.Node.prototype.moveTo = function(container) {
	        moveTo.call(this, container);
	    };

	    /**
	     * batch draw
	     * @method
	     * @memberof Kinetic.Base.prototype
	     */
	    Kinetic.BaseLayer.prototype.batchDraw = function() {
	        var that = this,
	            Anim = Kinetic.Animation;

	        if (!this.batchAnim) {
	            this.batchAnim = new Anim(function() {
	                if (that.lastBatchDrawTime && now() - that.lastBatchDrawTime > BATCH_DRAW_STOP_TIME_DIFF) {
	                    that.batchAnim.stop();
	                }
	            }, this);
	        }

	        this.lastBatchDrawTime = now();

	        if (!this.batchAnim.isRunning()) {
	            this.draw();
	            this.batchAnim.start();
	        }
	    };

	    /**
	     * batch draw
	     * @method
	     * @memberof Kinetic.Stage.prototype
	     */
	    Kinetic.Stage.prototype.batchDraw = function() {
	        this.getChildren().each(function(layer) {
	            layer.batchDraw();
	        });
	    };
	})(this);
	;(function() {
	    var blacklist = {
	        node: 1,
	        duration: 1,
	        easing: 1,
	        onFinish: 1,
	        yoyo: 1
	    },

	    PAUSED = 1,
	    PLAYING = 2,
	    REVERSING = 3,

	    idCounter = 0;

	    /**
	     * Tween constructor.  Tweens enable you to animate a node between the current state and a new state.
	     *  You can play, pause, reverse, seek, reset, and finish tweens.  By default, tweens are animated using
	     *  a linear easing.  For more tweening options, check out {@link Kinetic.Easings}
	     * @constructor
	     * @memberof Kinetic
	     * @example
	     * // instantiate new tween which fully rotates a node in 1 second
	     * var tween = new Kinetic.Tween({
	     *   node: node,
	     *   rotationDeg: 360,
	     *   duration: 1,
	     *   easing: Kinetic.Easings.EaseInOut
	     * });
	     *
	     * // play tween
	     * tween.play();
	     *
	     * // pause tween
	     * tween.pause();
	     */
	    Kinetic.Tween = function(config) {
	        var that = this,
	            node = config.node,
	            nodeId = node._id,
	            duration,
	            easing = config.easing || Kinetic.Easings.Linear,
	            yoyo = !!config.yoyo,
	            key;

	        if (typeof config.duration === 'undefined') {
	            duration = 1;
	        } else if (config.duration === 0) {  // zero is bad value for duration
	            duration = 0.001;
	        } else {
	            duration = config.duration;
	        }
	        this.node = node;
	        this._id = idCounter++;

	        this.anim = new Kinetic.Animation(function() {
	            that.tween.onEnterFrame();
	        }, node.getLayer() || ((node instanceof Kinetic.Stage) ? node.getLayers() : null));

	        this.tween = new Tween(key, function(i) {
	            that._tweenFunc(i);
	        }, easing, 0, 1, duration * 1000, yoyo);

	        this._addListeners();

	        // init attrs map
	        if (!Kinetic.Tween.attrs[nodeId]) {
	            Kinetic.Tween.attrs[nodeId] = {};
	        }
	        if (!Kinetic.Tween.attrs[nodeId][this._id]) {
	            Kinetic.Tween.attrs[nodeId][this._id] = {};
	        }
	        // init tweens map
	        if (!Kinetic.Tween.tweens[nodeId]) {
	            Kinetic.Tween.tweens[nodeId] = {};
	        }

	        for (key in config) {
	            if (blacklist[key] === undefined) {
	                this._addAttr(key, config[key]);
	            }
	        }

	        this.reset();

	        // callbacks
	        this.onFinish = config.onFinish;
	        this.onReset = config.onReset;
	    };

	    // start/diff object = attrs.nodeId.tweenId.attr
	    Kinetic.Tween.attrs = {};
	    // tweenId = tweens.nodeId.attr
	    Kinetic.Tween.tweens = {};

	    Kinetic.Tween.prototype = {
	        _addAttr: function(key, end) {
	            var node = this.node,
	                nodeId = node._id,
	                start, diff, tweenId, n, len;

	            // remove conflict from tween map if it exists
	            tweenId = Kinetic.Tween.tweens[nodeId][key];

	            if (tweenId) {
	                delete Kinetic.Tween.attrs[nodeId][tweenId][key];
	            }

	            // add to tween map
	            start = node.getAttr(key);

	            if (Kinetic.Util._isArray(end)) {
	                diff = [];
	                len = end.length;
	                for (n=0; n<len; n++) {
	                    diff.push(end[n] - start[n]);
	                }

	            }
	            else {
	                diff = end - start;
	            }

	            Kinetic.Tween.attrs[nodeId][this._id][key] = {
	                start: start,
	                diff: diff
	            };
	            Kinetic.Tween.tweens[nodeId][key] = this._id;
	        },
	        _tweenFunc: function(i) {
	            var node = this.node,
	                attrs = Kinetic.Tween.attrs[node._id][this._id],
	                key, attr, start, diff, newVal, n, len;

	            for (key in attrs) {
	                attr = attrs[key];
	                start = attr.start;
	                diff = attr.diff;

	                if (Kinetic.Util._isArray(start)) {
	                    newVal = [];
	                    len = start.length;
	                    for (n=0; n<len; n++) {
	                        newVal.push(start[n] + (diff[n] * i));
	                    }
	                }
	                else {
	                    newVal = start + (diff * i);
	                }

	                node.setAttr(key, newVal);
	            }
	        },
	        _addListeners: function() {
	            var that = this;

	            // start listeners
	            this.tween.onPlay = function() {
	                that.anim.start();
	            };
	            this.tween.onReverse = function() {
	                that.anim.start();
	            };

	            // stop listeners
	            this.tween.onPause = function() {
	                that.anim.stop();
	            };
	            this.tween.onFinish = function() {
	                if (that.onFinish) {
	                    that.onFinish();
	                }
	            };
	            this.tween.onReset = function() {
	                if (that.onReset) {
	                    that.onReset();
	                }
	            };
	        },
	        /**
	         * play
	         * @method
	         * @memberof Kinetic.Tween.prototype
	         * @returns {Tween}
	         */
	        play: function() {
	            this.tween.play();
	            return this;
	        },
	        /**
	         * reverse
	         * @method
	         * @memberof Kinetic.Tween.prototype
	         * @returns {Tween}
	         */
	        reverse: function() {
	            this.tween.reverse();
	            return this;
	        },
	        /**
	         * reset
	         * @method
	         * @memberof Kinetic.Tween.prototype
	         * @returns {Tween}
	         */
	        reset: function() {
	            this.tween.reset();
	            return this;
	        },
	        /**
	         * seek
	         * @method
	         * @memberof Kinetic.Tween.prototype
	         * @param {Integer} t time in seconds between 0 and the duration
	         * @returns {Tween}
	         */
	        seek: function(t) {
	            this.tween.seek(t * 1000);
	            return this;
	        },
	        /**
	         * pause
	         * @method
	         * @memberof Kinetic.Tween.prototype
	         * @returns {Tween}
	         */
	        pause: function() {
	            this.tween.pause();
	            return this;
	        },
	        /**
	         * finish
	         * @method
	         * @memberof Kinetic.Tween.prototype
	         * @returns {Tween}
	         */
	        finish: function() {
	            this.tween.finish();
	            return this;
	        },
	        /**
	         * destroy
	         * @method
	         * @memberof Kinetic.Tween.prototype
	         */
	        destroy: function() {
	            var nodeId = this.node._id,
	                thisId = this._id,
	                attrs = Kinetic.Tween.tweens[nodeId],
	                key;

	            this.pause();

	            for (key in attrs) {
	                delete Kinetic.Tween.tweens[nodeId][key];
	            }

	            delete Kinetic.Tween.attrs[nodeId][thisId];
	        }
	    };

	    var Tween = function(prop, propFunc, func, begin, finish, duration, yoyo) {
	        this.prop = prop;
	        this.propFunc = propFunc;
	        this.begin = begin;
	        this._pos = begin;
	        this.duration = duration;
	        this._change = 0;
	        this.prevPos = 0;
	        this.yoyo = yoyo;
	        this._time = 0;
	        this._position = 0;
	        this._startTime = 0;
	        this._finish = 0;
	        this.func = func;
	        this._change = finish - this.begin;
	        this.pause();
	    };
	    /*
	     * Tween methods
	     */
	    Tween.prototype = {
	        fire: function(str) {
	            var handler = this[str];
	            if (handler) {
	                handler();
	            }
	        },
	        setTime: function(t) {
	            if(t > this.duration) {
	                if(this.yoyo) {
	                    this._time = this.duration;
	                    this.reverse();
	                }
	                else {
	                    this.finish();
	                }
	            }
	            else if(t < 0) {
	                if(this.yoyo) {
	                    this._time = 0;
	                    this.play();
	                }
	                else {
	                    this.reset();
	                }
	            }
	            else {
	                this._time = t;
	                this.update();
	            }
	        },
	        getTime: function() {
	            return this._time;
	        },
	        setPosition: function(p) {
	            this.prevPos = this._pos;
	            this.propFunc(p);
	            this._pos = p;
	        },
	        getPosition: function(t) {
	            if(t === undefined) {
	                t = this._time;
	            }
	            return this.func(t, this.begin, this._change, this.duration);
	        },
	        play: function() {
	            this.state = PLAYING;
	            this._startTime = this.getTimer() - this._time;
	            this.onEnterFrame();
	            this.fire('onPlay');
	        },
	        reverse: function() {
	            this.state = REVERSING;
	            this._time = this.duration - this._time;
	            this._startTime = this.getTimer() - this._time;
	            this.onEnterFrame();
	            this.fire('onReverse');
	        },
	        seek: function(t) {
	            this.pause();
	            this._time = t;
	            this.update();
	            this.fire('onSeek');
	        },
	        reset: function() {
	            this.pause();
	            this._time = 0;
	            this.update();
	            this.fire('onReset');
	        },
	        finish: function() {
	            this.pause();
	            this._time = this.duration;
	            this.update();
	            this.fire('onFinish');
	        },
	        update: function() {
	            this.setPosition(this.getPosition(this._time));
	        },
	        onEnterFrame: function() {
	            var t = this.getTimer() - this._startTime;
	            if(this.state === PLAYING) {
	                this.setTime(t);
	            }
	            else if (this.state === REVERSING) {
	                this.setTime(this.duration - t);
	            }
	        },
	        pause: function() {
	            this.state = PAUSED;
	            this.fire('onPause');
	        },
	        getTimer: function() {
	            return new Date().getTime();
	        }
	    };

	    /*
	    * These eases were ported from an Adobe Flash tweening library to JavaScript
	    * by Xaric
	    */

	    /**
	     * @namespace Easings
	     * @memberof Kinetic
	     */
	    Kinetic.Easings = {
	        /**
	        * back ease in
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'BackEaseIn': function(t, b, c, d) {
	            var s = 1.70158;
	            return c * (t /= d) * t * ((s + 1) * t - s) + b;
	        },
	        /**
	        * back ease out
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'BackEaseOut': function(t, b, c, d) {
	            var s = 1.70158;
	            return c * (( t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	        },
	        /**
	        * back ease in out
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'BackEaseInOut': function(t, b, c, d) {
	            var s = 1.70158;
	            if((t /= d / 2) < 1) {
	                return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
	            }
	            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
	        },
	        /**
	        * elastic ease in
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'ElasticEaseIn': function(t, b, c, d, a, p) {
	            // added s = 0
	            var s = 0;
	            if(t === 0) {
	                return b;
	            }
	            if((t /= d) == 1) {
	                return b + c;
	            }
	            if(!p) {
	                p = d * 0.3;
	            }
	            if(!a || a < Math.abs(c)) {
	                a = c;
	                s = p / 4;
	            }
	            else {
	                s = p / (2 * Math.PI) * Math.asin(c / a);
	            }
	            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	        },
	        /**
	        * elastic ease out
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'ElasticEaseOut': function(t, b, c, d, a, p) {
	            // added s = 0
	            var s = 0;
	            if(t === 0) {
	                return b;
	            }
	            if((t /= d) == 1) {
	                return b + c;
	            }
	            if(!p) {
	                p = d * 0.3;
	            }
	            if(!a || a < Math.abs(c)) {
	                a = c;
	                s = p / 4;
	            }
	            else {
	                s = p / (2 * Math.PI) * Math.asin(c / a);
	            }
	            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
	        },
	        /**
	        * elastic ease in out
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'ElasticEaseInOut': function(t, b, c, d, a, p) {
	            // added s = 0
	            var s = 0;
	            if(t === 0) {
	                return b;
	            }
	            if((t /= d / 2) == 2) {
	                return b + c;
	            }
	            if(!p) {
	                p = d * (0.3 * 1.5);
	            }
	            if(!a || a < Math.abs(c)) {
	                a = c;
	                s = p / 4;
	            }
	            else {
	                s = p / (2 * Math.PI) * Math.asin(c / a);
	            }
	            if(t < 1) {
	                return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	            }
	            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
	        },
	        /**
	        * bounce ease out
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'BounceEaseOut': function(t, b, c, d) {
	            if((t /= d) < (1 / 2.75)) {
	                return c * (7.5625 * t * t) + b;
	            }
	            else if(t < (2 / 2.75)) {
	                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
	            }
	            else if(t < (2.5 / 2.75)) {
	                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
	            }
	            else {
	                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
	            }
	        },
	        /**
	        * bounce ease in
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'BounceEaseIn': function(t, b, c, d) {
	            return c - Kinetic.Easings.BounceEaseOut(d - t, 0, c, d) + b;
	        },
	        /**
	        * bounce ease in out
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'BounceEaseInOut': function(t, b, c, d) {
	            if(t < d / 2) {
	                return Kinetic.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
	            }
	            else {
	                return Kinetic.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
	            }
	        },
	        /**
	        * ease in
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'EaseIn': function(t, b, c, d) {
	            return c * (t /= d) * t + b;
	        },
	        /**
	        * ease out
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'EaseOut': function(t, b, c, d) {
	            return -c * (t /= d) * (t - 2) + b;
	        },
	        /**
	        * ease in out
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'EaseInOut': function(t, b, c, d) {
	            if((t /= d / 2) < 1) {
	                return c / 2 * t * t + b;
	            }
	            return -c / 2 * ((--t) * (t - 2) - 1) + b;
	        },
	        /**
	        * strong ease in
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'StrongEaseIn': function(t, b, c, d) {
	            return c * (t /= d) * t * t * t * t + b;
	        },
	        /**
	        * strong ease out
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'StrongEaseOut': function(t, b, c, d) {
	            return c * (( t = t / d - 1) * t * t * t * t + 1) + b;
	        },
	        /**
	        * strong ease in out
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'StrongEaseInOut': function(t, b, c, d) {
	            if((t /= d / 2) < 1) {
	                return c / 2 * t * t * t * t * t + b;
	            }
	            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
	        },
	        /**
	        * linear
	        * @function
	        * @memberof Kinetic.Easings
	        */
	        'Linear': function(t, b, c, d) {
	            return c * t / d + b;
	        }
	    };
	})();
	;(function() {
	    Kinetic.DD = {
	        // properties
	        anim: new Kinetic.Animation(function() {
	            var b = this.dirty;
	            this.dirty = false;
	            return b;
	        }),
	        isDragging: false,
	        justDragged: false,
	        offset: {
	            x: 0,
	            y: 0
	        },
	        node: null,

	        // methods
	        _drag: function(evt) {
	            var dd = Kinetic.DD,
	                node = dd.node;

	            if(node) {
	               if(!dd.isDragging) {
	                    var pos = node.getStage().getPointerPosition();
	                    var dragDistance = node.dragDistance();
	                    var distance = Math.max(
	                        Math.abs(pos.x - dd.startPointerPos.x),
	                        Math.abs(pos.y - dd.startPointerPos.y)
	                    );
	                    if (distance < dragDistance) {
	                        return;
	                    }
	                }

	                node._setDragPosition(evt);
	                if(!dd.isDragging) {
	                    dd.isDragging = true;
	                    node.fire('dragstart', {
	                        type : 'dragstart',
	                        target : node,
	                        evt : evt
	                    }, true);
	                }

	                // execute ondragmove if defined
	                node.fire('dragmove', {
	                    type : 'dragmove',
	                    target : node,
	                    evt : evt
	                }, true);
	            }
	        },
	        _endDragBefore: function(evt) {
	            var dd = Kinetic.DD,
	                node = dd.node,
	                nodeType, layer;

	            if(node) {
	                nodeType = node.nodeType;
	                layer = node.getLayer();
	                dd.anim.stop();

	                // only fire dragend event if the drag and drop
	                // operation actually started.
	                if(dd.isDragging) {
	                    dd.isDragging = false;
	                    dd.justDragged = true;
	                    Kinetic.listenClickTap = false;

	                    if (evt) {
	                        evt.dragEndNode = node;
	                    }
	                }

	                delete dd.node;

	                (layer || node).draw();
	            }
	        },
	        _endDragAfter: function(evt) {
	            evt = evt || {};

	            var dragEndNode = evt.dragEndNode;

	            if (evt && dragEndNode) {
	                dragEndNode.fire('dragend', {
	                    type : 'dragend',
	                    target : dragEndNode,
	                    evt : evt
	                }, true);
	            }
	        }
	    };

	    // Node extenders

	    /**
	     * initiate drag and drop
	     * @method
	     * @memberof Kinetic.Node.prototype
	     */
	    Kinetic.Node.prototype.startDrag = function() {
	        var dd = Kinetic.DD,
	            stage = this.getStage(),
	            layer = this.getLayer(),
	            pos = stage.getPointerPosition(),
	            ap = this.getAbsolutePosition();

	        if(pos) {
	            if (dd.node) {
	                dd.node.stopDrag();
	            }

	            dd.node = this;
	            dd.startPointerPos = pos;
	            dd.offset.x = pos.x - ap.x;
	            dd.offset.y = pos.y - ap.y;
	            dd.anim.setLayers(layer || this.getLayers());
	            dd.anim.start();

	            this._setDragPosition();
	        }
	    };

	    Kinetic.Node.prototype._setDragPosition = function(evt) {
	        var dd = Kinetic.DD,
	            pos = this.getStage().getPointerPosition(),
	            dbf = this.getDragBoundFunc();
	        if (!pos) {
	            return;
	        }
	        var newNodePos = {
	            x: pos.x - dd.offset.x,
	            y: pos.y - dd.offset.y
	        };

	        if(dbf !== undefined) {
	            newNodePos = dbf.call(this, newNodePos, evt);
	        }
	        this.setAbsolutePosition(newNodePos);

	        if (!this._lastPos || this._lastPos.x !== newNodePos.x ||
	            this._lastPos.y !== newNodePos.y) {
	            dd.anim.dirty = true;
	        }

	        this._lastPos = newNodePos;
	    };

	    /**
	     * stop drag and drop
	     * @method
	     * @memberof Kinetic.Node.prototype
	     */
	    Kinetic.Node.prototype.stopDrag = function() {
	        var dd = Kinetic.DD,
	            evt = {};
	        dd._endDragBefore(evt);
	        dd._endDragAfter(evt);
	    };

	    Kinetic.Node.prototype.setDraggable = function(draggable) {
	        this._setAttr('draggable', draggable);
	        this._dragChange();
	    };

	    var origDestroy = Kinetic.Node.prototype.destroy;

	    Kinetic.Node.prototype.destroy = function() {
	        var dd = Kinetic.DD;

	        // stop DD
	        if(dd.node && dd.node._id === this._id) {

	            this.stopDrag();
	        }

	        origDestroy.call(this);
	    };

	    /**
	     * determine if node is currently in drag and drop mode
	     * @method
	     * @memberof Kinetic.Node.prototype
	     */
	    Kinetic.Node.prototype.isDragging = function() {
	        var dd = Kinetic.DD;
	        return !!(dd.node && dd.node._id === this._id && dd.isDragging);
	    };

	    Kinetic.Node.prototype._listenDrag = function() {
	        var that = this;

	        this._dragCleanup();

	        if (this.getClassName() === 'Stage') {
	            this.on('contentMousedown.kinetic contentTouchstart.kinetic', function(evt) {
	                if(!Kinetic.DD.node) {
	                    that.startDrag(evt);
	                }
	            });
	        }
	        else {
	            this.on('mousedown.kinetic touchstart.kinetic', function(evt) {
	                // ignore right and middle buttons
	                if (evt.evt.button === 1 || evt.evt.button === 2) {
	                    return;
	                }
	                if(!Kinetic.DD.node) {
	                    that.startDrag(evt);
	                }
	            });
	        }

	        // listening is required for drag and drop
	        /*
	        this._listeningEnabled = true;
	        this._clearSelfAndAncestorCache('listeningEnabled');
	        */
	    };

	    Kinetic.Node.prototype._dragChange = function() {
	        if(this.attrs.draggable) {
	            this._listenDrag();
	        }
	        else {
	            // remove event listeners
	            this._dragCleanup();

	            /*
	             * force drag and drop to end
	             * if this node is currently in
	             * drag and drop mode
	             */
	            var stage = this.getStage();
	            var dd = Kinetic.DD;
	            if(stage && dd.node && dd.node._id === this._id) {
	                dd.node.stopDrag();
	            }
	        }
	    };

	    Kinetic.Node.prototype._dragCleanup = function() {
	        if (this.getClassName() === 'Stage') {
	            this.off('contentMousedown.kinetic');
	            this.off('contentTouchstart.kinetic');
	        } else {
	            this.off('mousedown.kinetic');
	            this.off('touchstart.kinetic');
	        }
	    };

	    Kinetic.Factory.addGetterSetter(Kinetic.Node, 'dragBoundFunc');

	    /**
	     * get/set drag bound function.  This is used to override the default
	     *  drag and drop position
	     * @name dragBoundFunc
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Function} dragBoundFunc
	     * @returns {Function}
	     * @example
	     * // get drag bound function
	     * var dragBoundFunc = node.dragBoundFunc();
	     *
	     * // create vertical drag and drop
	     * node.dragBoundFunc(function(pos){
	     *   return {
	     *     x: this.getAbsolutePosition().x,
	     *     y: pos.y
	     *   };
	     * });
	     */

	    Kinetic.Factory.addGetter(Kinetic.Node, 'draggable', false);
	    Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node, 'draggable');

	     /**
	     * get/set draggable flag
	     * @name draggable
	     * @method
	     * @memberof Kinetic.Node.prototype
	     * @param {Boolean} draggable
	     * @returns {Boolean}
	     * @example
	     * // get draggable flag
	     * var draggable = node.draggable();
	     *
	     * // enable drag and drop
	     * node.draggable(true);
	     *
	     * // disable drag and drop
	     * node.draggable(false);
	     */

	    var html = Kinetic.document.documentElement;
	    html.addEventListener('mouseup', Kinetic.DD._endDragBefore, true);
	    html.addEventListener('touchend', Kinetic.DD._endDragBefore, true);

	    html.addEventListener('mouseup', Kinetic.DD._endDragAfter, false);
	    html.addEventListener('touchend', Kinetic.DD._endDragAfter, false);

	})();
	;(function() {
	    Kinetic.Util.addMethods(Kinetic.Container, {
	        __init: function(config) {
	            this.children = new Kinetic.Collection();
	            Kinetic.Node.call(this, config);
	        },
	        /**
	         * returns a {@link Kinetic.Collection} of direct descendant nodes
	         * @method
	         * @memberof Kinetic.Container.prototype
	         * @param {Function} [filterFunc] filter function
	         * @returns {Kinetic.Collection}
	         * @example
	         * // get all children
	         * var children = layer.getChildren();
	         *
	         * // get only circles
	         * var circles = layer.getChildren(function(node){
	         *    return node.getClassName() === 'Circle';
	         * });
	         */
	        getChildren: function(filterFunc) {
	            if (!filterFunc) {
	                return this.children;
	            } else {
	                var results = new Kinetic.Collection();
	                this.children.each(function(child){
	                    if (filterFunc(child)) {
	                        results.push(child);
	                    }
	                });
	                return results;
	            }
	        },
	        /**
	         * determine if node has children
	         * @method
	         * @memberof Kinetic.Container.prototype
	         * @returns {Boolean}
	         */
	        hasChildren: function() {
	            return this.getChildren().length > 0;
	        },
	        /**
	         * remove all children
	         * @method
	         * @memberof Kinetic.Container.prototype
	         */
	        removeChildren: function() {
	            var children = Kinetic.Collection.toCollection(this.children);
	            var child;
	            for (var i = 0; i < children.length; i++) {
	                child = children[i];
	                // reset parent to prevent many _setChildrenIndices calls
	                delete child.parent;
	                child.index = 0;
	                if (child.hasChildren()) {
	                    child.removeChildren();
	                }
	                child.remove();
	            }
	            children = null;
	            this.children = new Kinetic.Collection();
	            return this;
	        },
	        /**
	         * destroy all children
	         * @method
	         * @memberof Kinetic.Container.prototype
	         */
	        destroyChildren: function() {
	           var children = Kinetic.Collection.toCollection(this.children);
	            var child;
	            for (var i = 0; i < children.length; i++) {
	                child = children[i];
	                // reset parent to prevent many _setChildrenIndices calls
	                delete child.parent;
	                child.index = 0;
	                child.destroy();
	            }
	            children = null;
	            this.children = new Kinetic.Collection();
	            return this;
	        },
	        /**
	         * Add node or nodes to container.
	         * @method
	         * @memberof Kinetic.Container.prototype
	         * @param {...Kinetic.Node} child
	         * @returns {Container}
	         * @example
	         * layer.add(shape1, shape2, shape3);
	         */
	        add: function(child) {
	            if (arguments.length > 1) {
	                for (var i = 0; i < arguments.length; i++) {
	                    this.add(arguments[i]);
	                }
	                return this;
	            }
	            if (child.getParent()) {
	                child.moveTo(this);
	                return this;
	            }
	            var children = this.children;
	            this._validateAdd(child);
	            child.index = children.length;
	            child.parent = this;
	            children.push(child);
	            this._fire('add', {
	                child: child
	            });

	            // if node under drag we need to update drag animation
	            if (child.isDragging()) {
	                Kinetic.DD.anim.setLayers(child.getLayer());
	            }

	            // chainable
	            return this;
	        },
	        destroy: function() {
	            // destroy children
	            if (this.hasChildren()) {
	                this.destroyChildren();
	            }
	            // then destroy self
	            Kinetic.Node.prototype.destroy.call(this);
	        },
	        /**
	         * return a {@link Kinetic.Collection} of nodes that match the selector.  Use '#' for id selections
	         * and '.' for name selections.  You can also select by type or class name. Pass multiple selectors
	         * separated by a space.
	         * @method
	         * @memberof Kinetic.Container.prototype
	         * @param {String} selector
	         * @returns {Collection}
	         * @example
	         * // select node with id foo
	         * var node = stage.find('#foo');
	         *
	         * // select nodes with name bar inside layer
	         * var nodes = layer.find('.bar');
	         *
	         * // select all groups inside layer
	         * var nodes = layer.find('Group');
	         *
	         * // select all rectangles inside layer
	         * var nodes = layer.find('Rect');
	         *
	         * // select node with an id of foo or a name of bar inside layer
	         * var nodes = layer.find('#foo, .bar');
	         */
	        find: function(selector) {
	            var retArr = [],
	                selectorArr = selector.replace(/ /g, '').split(','),
	                len = selectorArr.length,
	                n, i, sel, arr, node, children, clen;

	            for (n = 0; n < len; n++) {
	                sel = selectorArr[n];

	                // id selector
	                if(sel.charAt(0) === '#') {
	                    node = this._getNodeById(sel.slice(1));
	                    if(node) {
	                        retArr.push(node);
	                    }
	                }
	                // name selector
	                else if(sel.charAt(0) === '.') {
	                    arr = this._getNodesByName(sel.slice(1));
	                    retArr = retArr.concat(arr);
	                }
	                // unrecognized selector, pass to children
	                else {
	                    children = this.getChildren();
	                    clen = children.length;
	                    for(i = 0; i < clen; i++) {
	                        retArr = retArr.concat(children[i]._get(sel));
	                    }
	                }
	            }

	            return Kinetic.Collection.toCollection(retArr);
	        },
	        _getNodeById: function(key) {
	            var node = Kinetic.ids[key];

	            if(node !== undefined && this.isAncestorOf(node)) {
	                return node;
	            }
	            return null;
	        },
	        _getNodesByName: function(key) {
	            var arr = Kinetic.names[key] || [];
	            return this._getDescendants(arr);
	        },
	        _get: function(selector) {
	            var retArr = Kinetic.Node.prototype._get.call(this, selector);
	            var children = this.getChildren();
	            var len = children.length;
	            for(var n = 0; n < len; n++) {
	                retArr = retArr.concat(children[n]._get(selector));
	            }
	            return retArr;
	        },
	        // extenders
	        toObject: function() {
	            var obj = Kinetic.Node.prototype.toObject.call(this);

	            obj.children = [];

	            var children = this.getChildren();
	            var len = children.length;
	            for(var n = 0; n < len; n++) {
	                var child = children[n];
	                obj.children.push(child.toObject());
	            }

	            return obj;
	        },
	        _getDescendants: function(arr) {
	            var retArr = [];
	            var len = arr.length;
	            for(var n = 0; n < len; n++) {
	                var node = arr[n];
	                if(this.isAncestorOf(node)) {
	                    retArr.push(node);
	                }
	            }

	            return retArr;
	        },
	        /**
	         * determine if node is an ancestor
	         * of descendant
	         * @method
	         * @memberof Kinetic.Container.prototype
	         * @param {Kinetic.Node} node
	         */
	        isAncestorOf: function(node) {
	            var parent = node.getParent();
	            while(parent) {
	                if(parent._id === this._id) {
	                    return true;
	                }
	                parent = parent.getParent();
	            }

	            return false;
	        },
	        clone: function(obj) {
	            // call super method
	            var node = Kinetic.Node.prototype.clone.call(this, obj);

	            this.getChildren().each(function(no) {
	                node.add(no.clone());
	            });
	            return node;
	        },
	        /**
	         * get all shapes that intersect a point.  Note: because this method must clear a temporary
	         * canvas and redraw every shape inside the container, it should only be used for special sitations
	         * because it performs very poorly.  Please use the {@link Kinetic.Stage#getIntersection} method if at all possible
	         * because it performs much better
	         * @method
	         * @memberof Kinetic.Container.prototype
	         * @param {Object} pos
	         * @param {Number} pos.x
	         * @param {Number} pos.y
	         * @returns {Array} array of shapes
	         */
	        getAllIntersections: function(pos) {
	            var arr = [];

	            this.find('Shape').each(function(shape) {
	                if(shape.isVisible() && shape.intersects(pos)) {
	                    arr.push(shape);
	                }
	            });

	            return arr;
	        },
	        _setChildrenIndices: function() {
	            this.children.each(function(child, n) {
	                child.index = n;
	            });
	        },
	        drawScene: function(can, top) {
	            var layer = this.getLayer(),
	                canvas = can || (layer && layer.getCanvas()),
	                context = canvas && canvas.getContext(),
	                cachedCanvas = this._cache.canvas,
	                cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;

	            if (this.isVisible()) {
	                if (cachedSceneCanvas) {
	                    this._drawCachedSceneCanvas(context);
	                }
	                else {
	                    this._drawChildren(canvas, 'drawScene', top);
	                }
	            }
	            return this;
	        },
	        drawHit: function(can, top) {
	            var layer = this.getLayer(),
	                canvas = can || (layer && layer.hitCanvas),
	                context = canvas && canvas.getContext(),
	                cachedCanvas = this._cache.canvas,
	                cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

	            if (this.shouldDrawHit(canvas)) {
	                if (layer) {
	                    layer.clearHitCache();
	                }
	                if (cachedHitCanvas) {
	                    this._drawCachedHitCanvas(context);
	                }
	                else {
	                    this._drawChildren(canvas, 'drawHit', top);
	                }
	            }
	            return this;
	        },
	        _drawChildren: function(canvas, drawMethod, top) {
	            var layer = this.getLayer(),
	                context = canvas && canvas.getContext(),
	                clipWidth = this.getClipWidth(),
	                clipHeight = this.getClipHeight(),
	                hasClip = clipWidth && clipHeight,
	                clipX, clipY;

	            if (hasClip && layer) {
	                clipX = this.getClipX();
	                clipY = this.getClipY();

	                context.save();
	                layer._applyTransform(this, context);
	                context.beginPath();
	                context.rect(clipX, clipY, clipWidth, clipHeight);
	                context.clip();
	                context.reset();
	            }

	            this.children.each(function(child) {
	                child[drawMethod](canvas, top);
	            });

	            if (hasClip) {
	                context.restore();
	            }
	        },
	        shouldDrawHit: function(canvas) {
	            var layer = this.getLayer();
	            var dd = Kinetic.DD;
	            var layerUnderDrag = dd && Kinetic.isDragging() && (Kinetic.DD.anim.getLayers().indexOf(layer) !== -1);
	            return  (canvas && canvas.isCache) || (layer && layer.hitGraphEnabled())
	                && this.isVisible() && !layerUnderDrag;
	        }
	    });

	    Kinetic.Util.extend(Kinetic.Container, Kinetic.Node);
	    // deprecated methods
	    Kinetic.Container.prototype.get = Kinetic.Container.prototype.find;

	    // add getters setters
	    Kinetic.Factory.addComponentsGetterSetter(Kinetic.Container, 'clip', ['x', 'y', 'width', 'height']);
	    /**
	     * get/set clip
	     * @method
	     * @name clip
	     * @memberof Kinetic.Container.prototype
	     * @param {Object} clip
	     * @param {Number} clip.x
	     * @param {Number} clip.y
	     * @param {Number} clip.width
	     * @param {Number} clip.height
	     * @returns {Object}
	     * @example
	     * // get clip
	     * var clip = container.clip();
	     *
	     * // set clip
	     * container.setClip({
	     *   x: 20,
	     *   y: 20,
	     *   width: 20,
	     *   height: 20
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Container, 'clipX');
	    /**
	     * get/set clip x
	     * @name clipX
	     * @method
	     * @memberof Kinetic.Container.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get clip x
	     * var clipX = container.clipX();
	     *
	     * // set clip x
	     * container.clipX(10);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Container, 'clipY');
	    /**
	     * get/set clip y
	     * @name clipY
	     * @method
	     * @memberof Kinetic.Container.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get clip y
	     * var clipY = container.clipY();
	     *
	     * // set clip y
	     * container.clipY(10);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Container, 'clipWidth');
	    /**
	     * get/set clip width
	     * @name clipWidth
	     * @method
	     * @memberof Kinetic.Container.prototype
	     * @param {Number} width
	     * @returns {Number}
	     * @example
	     * // get clip width
	     * var clipWidth = container.clipWidth();
	     *
	     * // set clip width
	     * container.clipWidth(100);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Container, 'clipHeight');
	    /**
	     * get/set clip height
	     * @name clipHeight
	     * @method
	     * @memberof Kinetic.Container.prototype
	     * @param {Number} height
	     * @returns {Number}
	     * @example
	     * // get clip height
	     * var clipHeight = container.clipHeight();
	     *
	     * // set clip height
	     * container.clipHeight(100);
	     */

	    Kinetic.Collection.mapMethods(Kinetic.Container);
	})();
	;(function() {
	    var HAS_SHADOW = 'hasShadow';

	    function _fillFunc(context) {
	        context.fill();
	    }
	    function _strokeFunc(context) {
	        context.stroke();
	    }
	    function _fillFuncHit(context) {
	        context.fill();
	    }
	    function _strokeFuncHit(context) {
	        context.stroke();
	    }

	    function _clearHasShadowCache() {
	        this._clearCache(HAS_SHADOW);
	    }

	    Kinetic.Util.addMethods(Kinetic.Shape, {
	        __init: function(config) {
	            this.nodeType = 'Shape';
	            this._fillFunc = _fillFunc;
	            this._strokeFunc = _strokeFunc;
	            this._fillFuncHit = _fillFuncHit;
	            this._strokeFuncHit = _strokeFuncHit;

	            // set colorKey
	            var shapes = Kinetic.shapes;
	            var key;

	            while(true) {
	                key = Kinetic.Util.getRandomColor();
	                if(key && !( key in shapes)) {
	                    break;
	                }
	            }

	            this.colorKey = key;
	            shapes[key] = this;

	            // call super constructor
	            Kinetic.Node.call(this, config);

	            this.on('shadowColorChange.kinetic shadowBlurChange.kinetic shadowOffsetChange.kinetic shadowOpacityChange.kinetic shadowEnabledChange.kinetic', _clearHasShadowCache);
	        },
	        hasChildren: function() {
	            return false;
	        },
	        getChildren: function() {
	            return [];
	        },
	        /**
	         * get canvas context tied to the layer
	         * @method
	         * @memberof Kinetic.Shape.prototype
	         * @returns {Kinetic.Context}
	         */
	        getContext: function() {
	            return this.getLayer().getContext();
	        },
	        /**
	         * get canvas renderer tied to the layer.  Note that this returns a canvas renderer, not a canvas element
	         * @method
	         * @memberof Kinetic.Shape.prototype
	         * @returns {Kinetic.Canvas}
	         */
	        getCanvas: function() {
	            return this.getLayer().getCanvas();
	        },
	        /**
	         * returns whether or not a shadow will be rendered
	         * @method
	         * @memberof Kinetic.Shape.prototype
	         * @returns {Boolean}
	         */
	        hasShadow: function() {
	            return this._getCache(HAS_SHADOW, this._hasShadow);
	        },
	        _hasShadow: function() {
	            return this.getShadowEnabled() && (this.getShadowOpacity() !== 0 && !!(this.getShadowColor() || this.getShadowBlur() || this.getShadowOffsetX() || this.getShadowOffsetY()));
	        },
	        /**
	         * returns whether or not the shape will be filled
	         * @method
	         * @memberof Kinetic.Shape.prototype
	         * @returns {Boolean}
	         */
	        hasFill: function() {
	            return !!(this.getFill() || this.getFillPatternImage() || this.getFillLinearGradientColorStops() || this.getFillRadialGradientColorStops());
	        },
	        /**
	         * returns whether or not the shape will be stroked
	         * @method
	         * @memberof Kinetic.Shape.prototype
	         * @returns {Boolean}
	         */
	        hasStroke: function() {
	            return !!(this.stroke() || this.strokeRed() || this.strokeGreen() || this.strokeBlue());
	        },
	        /**
	         * determines if point is in the shape, regardless if other shapes are on top of it.  Note: because
	         *  this method clears a temporary canvas and then redraws the shape, it performs very poorly if executed many times
	         *  consecutively.  Please use the {@link Kinetic.Stage#getIntersection} method if at all possible
	         *  because it performs much better
	         * @method
	         * @memberof Kinetic.Shape.prototype
	         * @param {Object} point 
	         * @param {Number} point.x
	         * @param {Number} point.y
	         * @returns {Boolean}
	         */
	        intersects: function(point) {
	            var stage = this.getStage(),
	                bufferHitCanvas = stage.bufferHitCanvas,
	                p;

	            bufferHitCanvas.getContext().clear();
	            this.drawScene(bufferHitCanvas);
	            p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;
	            return p[3] > 0;
	        },
	        // extends Node.prototype.destroy 
	        destroy: function() {
	            Kinetic.Node.prototype.destroy.call(this);
	            delete Kinetic.shapes[this.colorKey];
	        },
	        _useBufferCanvas: function() {
	            return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasFill() && this.hasStroke() && this.getStage();
	        },
	        drawScene: function(can, top) {
	            var layer = this.getLayer(),
	                canvas = can || layer.getCanvas(),
	                context = canvas.getContext(),
	                cachedCanvas = this._cache.canvas,
	                drawFunc = this.sceneFunc(),
	                hasShadow = this.hasShadow(),
	                stage, bufferCanvas, bufferContext;

	            if(this.isVisible()) {
	                if (cachedCanvas) {
	                    this._drawCachedSceneCanvas(context);
	                }
	                else if (drawFunc) {
	                    context.save();
	                    // if buffer canvas is needed
	                    if (this._useBufferCanvas()) {
	                        stage = this.getStage();
	                        bufferCanvas = stage.bufferCanvas;
	                        bufferContext = bufferCanvas.getContext();
	                        bufferContext.clear();
	                        bufferContext.save();
	                        bufferContext._applyLineJoin(this);
	                        // layer might be undefined if we are using cache before adding to layer
	                        if (layer) {
	                            layer._applyTransform(this, bufferContext, top);
	                        } else {
	                            var m = this.getAbsoluteTransform(top).getMatrix();
	                            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	                        }
	                     
	                        drawFunc.call(this, bufferContext);
	                        bufferContext.restore();

	                        if (hasShadow && !canvas.hitCanvas) {
	                            context.save();
	                            context._applyShadow(this);
	                            context.drawImage(bufferCanvas._canvas, 0, 0);
	                            context.restore();
	                        }

	                        context._applyOpacity(this);
	                        context.drawImage(bufferCanvas._canvas, 0, 0);
	                    }
	                    // if buffer canvas is not needed
	                    else {
	                        context._applyLineJoin(this);
	                        // layer might be undefined if we are using cache before adding to layer
	                        if (layer) {
	                            layer._applyTransform(this, context, top);
	                        } else {
	                            var o = this.getAbsoluteTransform(top).getMatrix();
	                            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
	                        }
	               
	                        if (hasShadow && !canvas.hitCanvas) {
	                            context.save();
	                            context._applyShadow(this);
	                            drawFunc.call(this, context);
	                            context.restore();
	                        }

	                        context._applyOpacity(this);
	                        drawFunc.call(this, context);
	                    }
	                    context.restore();
	                }
	            }

	            return this;
	        },
	        drawHit: function(can, top) {
	            var layer = this.getLayer(),
	                canvas = can || layer.hitCanvas,
	                context = canvas.getContext(),
	                drawFunc = this.hitFunc() || this.sceneFunc(),
	                cachedCanvas = this._cache.canvas,
	                cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

	            if(this.shouldDrawHit(canvas)) {
	                if (layer) {
	                    layer.clearHitCache();
	                }
	                if (cachedHitCanvas) {
	                    this._drawCachedHitCanvas(context);
	                }
	                else if (drawFunc) {
	                    context.save();
	                    context._applyLineJoin(this);
	                    if (layer) {
	                        layer._applyTransform(this, context, top);
	                    } else {
	                        var m = this.getAbsoluteTransform(top).getMatrix();
	                        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	                    }
	                   
	                    drawFunc.call(this, context);
	                    context.restore();
	                }
	                
	            }

	            return this;
	        },
	        /**
	        * draw hit graph using the cached scene canvas
	        * @method
	        * @memberof Kinetic.Shape.prototype
	        * @param {Integer} alphaThreshold alpha channel threshold that determines whether or not
	        *  a pixel should be drawn onto the hit graph.  Must be a value between 0 and 255.  
	        *  The default is 0
	        * @returns {Kinetic.Shape}
	        * @example
	        * shape.cache();
	        * shape.drawHitFromCache();
	        */
	        drawHitFromCache: function(alphaThreshold) {
	            var threshold = alphaThreshold || 0,
	                cachedCanvas = this._cache.canvas,
	                sceneCanvas = this._getCachedSceneCanvas(),
	                sceneContext = sceneCanvas.getContext(),
	                hitCanvas = cachedCanvas.hit,
	                hitContext = hitCanvas.getContext(),
	                width = sceneCanvas.getWidth(),
	                height = sceneCanvas.getHeight(),
	                sceneImageData, sceneData, hitImageData, hitData, len, rgbColorKey, i, alpha;

	            hitContext.clear();

	            try {
	                sceneImageData = sceneContext.getImageData(0, 0, width, height);
	                sceneData = sceneImageData.data;
	                hitImageData = hitContext.getImageData(0, 0, width, height);
	                hitData = hitImageData.data;
	                len = sceneData.length;
	                rgbColorKey = Kinetic.Util._hexToRgb(this.colorKey);

	                // replace non transparent pixels with color key
	                for(i = 0; i < len; i += 4) {
	                    alpha = sceneData[i + 3];
	                    if (alpha > threshold) {
	                        hitData[i] = rgbColorKey.r;
	                        hitData[i + 1] = rgbColorKey.g;
	                        hitData[i + 2] = rgbColorKey.b;
	                        hitData[i + 3] = 255;
	                    }
	                }

	                hitContext.putImageData(hitImageData, 0, 0);
	            }
	            catch(e) {
	                Kinetic.Util.warn('Unable to draw hit graph from cached scene canvas. ' + e.message);
	            }

	            return this;
	        }
	    });
	    Kinetic.Util.extend(Kinetic.Shape, Kinetic.Node);

	    // add getters and setters
	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'stroke');

	    /**
	     * get/set stroke color
	     * @name stroke
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {String} color
	     * @returns {String}
	     * @example
	     * // get stroke color
	     * var stroke = shape.stroke();
	     *
	     * // set stroke color with color string
	     * shape.stroke('green');
	     *
	     * // set stroke color with hex
	     * shape.stroke('#00ff00');
	     *
	     * // set stroke color with rgb
	     * shape.stroke('rgb(0,255,0)');
	     *
	     * // set stroke color with rgba and make it 50% opaque
	     * shape.stroke('rgba(0,255,0,0.5');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeRed', 0, Kinetic.Validators.RGBComponent);

	    /**
	     * get/set stroke red component
	     * @name strokeRed
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Integer} red
	     * @returns {Integer}
	     * @example
	     * // get stroke red component
	     * var strokeRed = shape.strokeRed();
	     *
	     * // set stroke red component
	     * shape.strokeRed(0);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeGreen', 0, Kinetic.Validators.RGBComponent);

	    /**
	     * get/set stroke green component
	     * @name strokeGreen
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Integer} green
	     * @returns {Integer}
	     * @example
	     * // get stroke green component
	     * var strokeGreen = shape.strokeGreen();
	     *
	     * // set stroke green component
	     * shape.strokeGreen(255);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeBlue', 0, Kinetic.Validators.RGBComponent);

	    /**
	     * get/set stroke blue component
	     * @name strokeBlue
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Integer} blue
	     * @returns {Integer}
	     * @example
	     * // get stroke blue component
	     * var strokeBlue = shape.strokeBlue();
	     *
	     * // set stroke blue component
	     * shape.strokeBlue(0);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeAlpha', 1, Kinetic.Validators.alphaComponent);

	    /**
	     * get/set stroke alpha component.  Alpha is a real number between 0 and 1.  The default
	     *  is 1.
	     * @name strokeAlpha
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} alpha
	     * @returns {Number}
	     * @example
	     * // get stroke alpha component
	     * var strokeAlpha = shape.strokeAlpha();
	     *
	     * // set stroke alpha component
	     * shape.strokeAlpha(0.5);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeWidth', 2);

	    /**
	     * get/set stroke width
	     * @name strokeWidth
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} strokeWidth
	     * @returns {Number}
	     * @example
	     * // get stroke width
	     * var strokeWidth = shape.strokeWidth();
	     *
	     * // set stroke width
	     * shape.strokeWidth();
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'lineJoin');

	    /**
	     * get/set line join.  Can be miter, round, or bevel.  The
	     *  default is miter
	     * @name lineJoin
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {String} lineJoin
	     * @returns {String}
	     * @example
	     * // get line join
	     * var lineJoin = shape.lineJoin();
	     *
	     * // set line join
	     * shape.lineJoin('round');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'lineCap');

	    /**
	     * get/set line cap.  Can be butt, round, or square
	     * @name lineCap
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {String} lineCap
	     * @returns {String}
	     * @example
	     * // get line cap
	     * var lineCap = shape.lineCap();
	     *
	     * // set line cap
	     * shape.lineCap('round');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'sceneFunc');

	    /**
	     * get/set scene draw function
	     * @name sceneFunc
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Function} drawFunc drawing function
	     * @returns {Function}
	     * @example
	     * // get scene draw function
	     * var sceneFunc = shape.sceneFunc();
	     *
	     * // set scene draw function
	     * shape.sceneFunc(function(context) {
	     *   context.beginPath();
	     *   context.rect(0, 0, this.width(), this.height());
	     *   context.closePath();
	     *   context.fillStrokeShape(this);
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'hitFunc');

	    /**
	     * get/set hit draw function
	     * @name hitFunc
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Function} drawFunc drawing function
	     * @returns {Function}
	     * @example
	     * // get hit draw function
	     * var hitFunc = shape.hitFunc();
	     *
	     * // set hit draw function
	     * shape.hitFunc(function(context) {
	     *   context.beginPath();
	     *   context.rect(0, 0, this.width(), this.height());
	     *   context.closePath();
	     *   context.fillStrokeShape(this);
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'dash');

	    /**
	     * get/set dash array for stroke.
	     * @name dash
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Array} dash
	     * @returns {Array}
	     * @example
	     *  // apply dashed stroke that is 10px long and 5 pixels apart
	     *  line.dash([10, 5]);
	     *  
	     *  // apply dashed stroke that is made up of alternating dashed 
	     *  // lines that are 10px long and 20px apart, and dots that have 
	     *  // a radius of 5px and are 20px apart
	     *  line.dash([10, 20, 0.001, 20]);
	     */


	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowColor');

	    /**
	     * get/set shadow color
	     * @name shadowColor
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {String} color
	     * @returns {String}
	     * @example
	     * // get shadow color
	     * var shadow = shape.shadowColor();
	     *
	     * // set shadow color with color string
	     * shape.shadowColor('green');
	     *
	     * // set shadow color with hex
	     * shape.shadowColor('#00ff00');
	     *
	     * // set shadow color with rgb
	     * shape.shadowColor('rgb(0,255,0)');
	     *
	     * // set shadow color with rgba and make it 50% opaque
	     * shape.shadowColor('rgba(0,255,0,0.5');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowRed', 0, Kinetic.Validators.RGBComponent);

	    /**
	     * get/set shadow red component
	     * @name shadowRed
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Integer} red
	     * @returns {Integer}
	     * @example
	     * // get shadow red component
	     * var shadowRed = shape.shadowRed();
	     *
	     * // set shadow red component
	     * shape.shadowRed(0);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowGreen', 0, Kinetic.Validators.RGBComponent);

	    /**
	     * get/set shadow green component
	     * @name shadowGreen
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Integer} green
	     * @returns {Integer}
	     * @example
	     * // get shadow green component
	     * var shadowGreen = shape.shadowGreen();
	     *
	     * // set shadow green component
	     * shape.shadowGreen(255);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowBlue', 0, Kinetic.Validators.RGBComponent);

	    /**
	     * get/set shadow blue component
	     * @name shadowBlue
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Integer} blue
	     * @returns {Integer}
	     * @example
	     * // get shadow blue component
	     * var shadowBlue = shape.shadowBlue();
	     *
	     * // set shadow blue component
	     * shape.shadowBlue(0);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowAlpha', 1, Kinetic.Validators.alphaComponent);

	    /**
	     * get/set shadow alpha component.  Alpha is a real number between 0 and 1.  The default
	     *  is 1.
	     * @name shadowAlpha
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} alpha
	     * @returns {Number}
	     * @example
	     * // get shadow alpha component
	     * var shadowAlpha = shape.shadowAlpha();
	     *
	     * // set shadow alpha component
	     * shape.shadowAlpha(0.5);
	     */
	     
	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowBlur');

	    /**
	     * get/set shadow blur
	     * @name shadowBlur
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} blur
	     * @returns {Number}
	     * @example
	     * // get shadow blur
	     * var shadowBlur = shape.shadowBlur();
	     *
	     * // set shadow blur
	     * shape.shadowBlur(10);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowOpacity');

	    /**
	     * get/set shadow opacity.  must be a value between 0 and 1
	     * @name shadowOpacity
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} opacity
	     * @returns {Number}
	     * @example
	     * // get shadow opacity
	     * var shadowOpacity = shape.shadowOpacity();
	     *
	     * // set shadow opacity
	     * shape.shadowOpacity(0.5);
	     */

	    Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'shadowOffset', ['x', 'y']);

	    /**
	     * get/set shadow offset
	     * @name shadowOffset
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Object} offset
	     * @param {Number} offset.x
	     * @param {Number} offset.y
	     * @returns {Object}
	     * @example
	     * // get shadow offset
	     * var shadowOffset = shape.shadowOffset();
	     *
	     * // set shadow offset
	     * shape.shadowOffset({
	     *   x: 20
	     *   y: 10
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowOffsetX', 0);

	     /**
	     * get/set shadow offset x
	     * @name shadowOffsetX
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get shadow offset x
	     * var shadowOffsetX = shape.shadowOffsetX();
	     *
	     * // set shadow offset x
	     * shape.shadowOffsetX(5);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowOffsetY', 0);

	     /**
	     * get/set shadow offset y
	     * @name shadowOffsetY
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get shadow offset y
	     * var shadowOffsetY = shape.shadowOffsetY();
	     *
	     * // set shadow offset y
	     * shape.shadowOffsetY(5);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternImage');

	    /**
	     * get/set fill pattern image
	     * @name fillPatternImage
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Image} image object
	     * @returns {Image}
	     * @example
	     * // get fill pattern image
	     * var fillPatternImage = shape.fillPatternImage();
	     *
	     * // set fill pattern image
	     * var imageObj = new Image();
	     * imageObj.onload = function() {
	     *   shape.fillPatternImage(imageObj);
	     * };
	     * imageObj.src = 'path/to/image/jpg';
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fill');

	    /**
	     * get/set fill color
	     * @name fill
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {String} color
	     * @returns {String}
	     * @example
	     * // get fill color
	     * var fill = shape.fill();
	     *
	     * // set fill color with color string
	     * shape.fill('green');
	     *
	     * // set fill color with hex
	     * shape.fill('#00ff00');
	     *
	     * // set fill color with rgb
	     * shape.fill('rgb(0,255,0)');
	     *
	     * // set fill color with rgba and make it 50% opaque
	     * shape.fill('rgba(0,255,0,0.5');
	     *
	     * // shape without fill
	     * shape.fill(null);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRed', 0, Kinetic.Validators.RGBComponent);

	    /**
	     * get/set fill red component
	     * @name fillRed
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Integer} red
	     * @returns {Integer}
	     * @example
	     * // get fill red component
	     * var fillRed = shape.fillRed();
	     *
	     * // set fill red component
	     * shape.fillRed(0);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillGreen', 0, Kinetic.Validators.RGBComponent);

	    /**
	     * get/set fill green component
	     * @name fillGreen
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Integer} green
	     * @returns {Integer}
	     * @example
	     * // get fill green component
	     * var fillGreen = shape.fillGreen();
	     *
	     * // set fill green component
	     * shape.fillGreen(255);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillBlue', 0, Kinetic.Validators.RGBComponent);

	    /**
	     * get/set fill blue component
	     * @name fillBlue
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Integer} blue
	     * @returns {Integer}
	     * @example
	     * // get fill blue component
	     * var fillBlue = shape.fillBlue();
	     *
	     * // set fill blue component
	     * shape.fillBlue(0);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillAlpha', 1, Kinetic.Validators.alphaComponent);

	    /**
	     * get/set fill alpha component.  Alpha is a real number between 0 and 1.  The default
	     *  is 1.
	     * @name fillAlpha
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} alpha
	     * @returns {Number}
	     * @example
	     * // get fill alpha component
	     * var fillAlpha = shape.fillAlpha();
	     *
	     * // set fill alpha component
	     * shape.fillAlpha(0.5);
	     */


	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternX', 0);

	    /**
	     * get/set fill pattern x
	     * @name fillPatternX
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill pattern x
	     * var fillPatternX = shape.fillPatternX();
	     * 
	     * // set fill pattern x
	     * shape.fillPatternX(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternY', 0);

	    /**
	     * get/set fill pattern y
	     * @name fillPatternY
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill pattern y
	     * var fillPatternY = shape.fillPatternY();
	     * 
	     * // set fill pattern y
	     * shape.fillPatternY(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillLinearGradientColorStops');

	    /**
	     * get/set fill linear gradient color stops
	     * @name fillLinearGradientColorStops
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Array} colorStops
	     * @returns {Array} colorStops
	     * @example
	     * // get fill linear gradient color stops
	     * var colorStops = shape.fillLinearGradientColorStops();
	     *
	     * // create a linear gradient that starts with red, changes to blue 
	     * // halfway through, and then changes to green
	     * shape.fillLinearGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientStartRadius', 0);

	    /**
	     * get/set fill radial gradient start radius
	     * @name fillRadialGradientStartRadius
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} radius
	     * @returns {Number}
	     * @example
	     * // get radial gradient start radius
	     * var startRadius = shape.fillRadialGradientStartRadius();
	     *
	     * // set radial gradient start radius
	     * shape.fillRadialGradientStartRadius(0);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientEndRadius', 0);

	    /**
	     * get/set fill radial gradient end radius
	     * @name fillRadialGradientEndRadius
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} radius
	     * @returns {Number}
	     * @example
	     * // get radial gradient end radius
	     * var endRadius = shape.fillRadialGradientEndRadius();
	     *
	     * // set radial gradient end radius
	     * shape.fillRadialGradientEndRadius(100);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientColorStops');

	    /**
	     * get/set fill radial gradient color stops
	     * @name fillRadialGradientColorStops
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} colorStops
	     * @returns {Array}
	     * @example
	     * // get fill radial gradient color stops
	     * var colorStops = shape.fillRadialGradientColorStops();
	     *
	     * // create a radial gradient that starts with red, changes to blue 
	     * // halfway through, and then changes to green
	     * shape.fillRadialGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternRepeat', 'repeat');

	    /**
	     * get/set fill pattern repeat.  Can be 'repeat', 'repeat-x', 'repeat-y', or 'no-repeat'.  The default is 'repeat'
	     * @name fillPatternRepeat
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {String} repeat
	     * @returns {String}
	     * @example
	     * // get fill pattern repeat
	     * var repeat = shape.fillPatternRepeat();
	     *
	     * // repeat pattern in x direction only
	     * shape.fillPatternRepeat('repeat-x');
	     *
	     * // do not repeat the pattern
	     * shape.fillPatternRepeat('no repeat');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillEnabled', true);

	    /**
	     * get/set fill enabled flag
	     * @name fillEnabled
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Boolean} enabled
	     * @returns {Boolean}
	     * @example
	     * // get fill enabled flag
	     * var fillEnabled = shape.fillEnabled();
	     *
	     * // disable fill
	     * shape.fillEnabled(false);
	     *
	     * // enable fill
	     * shape.fillEnabled(true);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeEnabled', true);

	    /**
	     * get/set stroke enabled flag
	     * @name strokeEnabled
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Boolean} enabled
	     * @returns {Boolean}
	     * @example
	     * // get stroke enabled flag
	     * var strokeEnabled = shape.strokeEnabled();
	     *
	     * // disable stroke
	     * shape.strokeEnabled(false);
	     *
	     * // enable stroke
	     * shape.strokeEnabled(true);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'shadowEnabled', true);

	    /**
	     * get/set shadow enabled flag
	     * @name shadowEnabled
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Boolean} enabled
	     * @returns {Boolean}
	     * @example
	     * // get shadow enabled flag
	     * var shadowEnabled = shape.shadowEnabled();
	     *
	     * // disable shadow
	     * shape.shadowEnabled(false);
	     *
	     * // enable shadow
	     * shape.shadowEnabled(true);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'dashEnabled', true);

	    /**
	     * get/set dash enabled flag
	     * @name dashEnabled
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Boolean} enabled
	     * @returns {Boolean}
	     * @example
	     * // get dash enabled flag
	     * var dashEnabled = shape.dashEnabled();
	     *
	     * // disable dash
	     * shape.dashEnabled(false);
	     *
	     * // enable dash
	     * shape.dashEnabled(true);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'strokeScaleEnabled', true);

	    /**
	     * get/set strokeScale enabled flag
	     * @name strokeScaleEnabled
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Boolean} enabled
	     * @returns {Boolean}
	     * @example
	     * // get stroke scale enabled flag
	     * var strokeScaleEnabled = shape.strokeScaleEnabled();
	     *
	     * // disable stroke scale
	     * shape.strokeScaleEnabled(false);
	     *
	     * // enable stroke scale
	     * shape.strokeScaleEnabled(true);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPriority', 'color');

	    /**
	     * get/set fill priority.  can be color, pattern, linear-gradient, or radial-gradient.  The default is color.
	     *   This is handy if you want to toggle between different fill types.
	     * @name fillPriority
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {String} priority
	     * @returns {String}
	     * @example
	     * // get fill priority
	     * var fillPriority = shape.fillPriority();
	     *
	     * // set fill priority
	     * shape.fillPriority('linear-gradient');
	     */

	    Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'fillPatternOffset', ['x', 'y']);

	    /**
	     * get/set fill pattern offset
	     * @name fillPatternOffset
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Object} offset
	     * @param {Number} offset.x
	     * @param {Number} offset.y
	     * @returns {Object}
	     * @example
	     * // get fill pattern offset
	     * var patternOffset = shape.fillPatternOffset();
	     *
	     * // set fill pattern offset
	     * shape.fillPatternOffset({
	     *   x: 20
	     *   y: 10
	     * });
	     */


	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternOffsetX', 0);
	    /**
	     * get/set fill pattern offset x
	     * @name fillPatternOffsetX
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill pattern offset x
	     * var patternOffsetX = shape.fillPatternOffsetX();
	     *
	     * // set fill pattern offset x
	     * shape.fillPatternOffsetX(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternOffsetY', 0);
	    /**
	     * get/set fill pattern offset y
	     * @name fillPatternOffsetY
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill pattern offset y
	     * var patternOffsetY = shape.fillPatternOffsetY();
	     *
	     * // set fill pattern offset y
	     * shape.fillPatternOffsetY(10);
	     */

	    Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'fillPatternScale', ['x', 'y']);

	    /**
	     * get/set fill pattern scale
	     * @name fillPatternScale
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Object} scale
	     * @param {Number} scale.x
	     * @param {Number} scale.y
	     * @returns {Object}
	     * @example
	     * // get fill pattern scale
	     * var patternScale = shape.fillPatternScale();
	     *
	     * // set fill pattern scale
	     * shape.fillPatternScale({
	     *   x: 2
	     *   y: 2
	     * });
	     */


	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternScaleX', 1);
	    /**
	     * get/set fill pattern scale x
	     * @name fillPatternScaleX
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill pattern scale x
	     * var patternScaleX = shape.fillPatternScaleX();
	     *
	     * // set fill pattern scale x
	     * shape.fillPatternScaleX(2);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternScaleY', 1);
	    /**
	     * get/set fill pattern scale y
	     * @name fillPatternScaleY
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill pattern scale y
	     * var patternScaleY = shape.fillPatternScaleY();
	     *
	     * // set fill pattern scale y
	     * shape.fillPatternScaleY(2);
	     */

	    Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'fillLinearGradientStartPoint', ['x', 'y']);

	    /**
	     * get/set fill linear gradient start point
	     * @name fillLinearGradientStartPoint
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Object} startPoint
	     * @param {Number} startPoint.x
	     * @param {Number} startPoint.y
	     * @returns {Object}
	     * @example
	     * // get fill linear gradient start point
	     * var startPoint = shape.fillLinearGradientStartPoint();
	     *
	     * // set fill linear gradient start point
	     * shape.fillLinearGradientStartPoint({
	     *   x: 20
	     *   y: 10
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillLinearGradientStartPointX', 0);
	    /**
	     * get/set fill linear gradient start point x
	     * @name fillLinearGradientStartPointX
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill linear gradient start point x
	     * var startPointX = shape.fillLinearGradientStartPointX();
	     *
	     * // set fill linear gradient start point x
	     * shape.fillLinearGradientStartPointX(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillLinearGradientStartPointY', 0);
	    /**
	     * get/set fill linear gradient start point y
	     * @name fillLinearGradientStartPointY
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill linear gradient start point y
	     * var startPointY = shape.fillLinearGradientStartPointY();
	     *
	     * // set fill linear gradient start point y
	     * shape.fillLinearGradientStartPointY(20);
	     */

	    Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'fillLinearGradientEndPoint', ['x', 'y']);

	    /**
	     * get/set fill linear gradient end point
	     * @name fillLinearGradientEndPoint
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Object} endPoint
	     * @param {Number} endPoint.x
	     * @param {Number} endPoint.y
	     * @returns {Object}
	     * @example
	     * // get fill linear gradient end point
	     * var endPoint = shape.fillLinearGradientEndPoint();
	     *
	     * // set fill linear gradient end point
	     * shape.fillLinearGradientEndPoint({
	     *   x: 20
	     *   y: 10
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillLinearGradientEndPointX', 0);
	    /**
	     * get/set fill linear gradient end point x
	     * @name fillLinearGradientEndPointX
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill linear gradient end point x
	     * var endPointX = shape.fillLinearGradientEndPointX();
	     *
	     * // set fill linear gradient end point x
	     * shape.fillLinearGradientEndPointX(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillLinearGradientEndPointY', 0);
	    /**
	     * get/set fill linear gradient end point y
	     * @name fillLinearGradientEndPointY
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill linear gradient end point y
	     * var endPointY = shape.fillLinearGradientEndPointY();
	     *
	     * // set fill linear gradient end point y
	     * shape.fillLinearGradientEndPointY(20);
	     */

	    Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'fillRadialGradientStartPoint', ['x', 'y']);

	    /**
	     * get/set fill radial gradient start point
	     * @name fillRadialGradientStartPoint
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Object} startPoint
	     * @param {Number} startPoint.x
	     * @param {Number} startPoint.y
	     * @returns {Object}
	     * @example
	     * // get fill radial gradient start point
	     * var startPoint = shape.fillRadialGradientStartPoint();
	     *
	     * // set fill radial gradient start point
	     * shape.fillRadialGradientStartPoint({
	     *   x: 20
	     *   y: 10
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientStartPointX', 0);
	    /**
	     * get/set fill radial gradient start point x
	     * @name fillRadialGradientStartPointX
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill radial gradient start point x
	     * var startPointX = shape.fillRadialGradientStartPointX();
	     *
	     * // set fill radial gradient start point x
	     * shape.fillRadialGradientStartPointX(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientStartPointY', 0);
	    /**
	     * get/set fill radial gradient start point y
	     * @name fillRadialGradientStartPointY
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill radial gradient start point y
	     * var startPointY = shape.fillRadialGradientStartPointY();
	     *
	     * // set fill radial gradient start point y
	     * shape.fillRadialGradientStartPointY(20);
	     */

	    Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape, 'fillRadialGradientEndPoint', ['x', 'y']);

	    /**
	     * get/set fill radial gradient end point
	     * @name fillRadialGradientEndPoint
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Object} endPoint
	     * @param {Number} endPoint.x
	     * @param {Number} endPoint.y
	     * @returns {Object}
	     * @example
	     * // get fill radial gradient end point
	     * var endPoint = shape.fillRadialGradientEndPoint();
	     *
	     * // set fill radial gradient end point
	     * shape.fillRadialGradientEndPoint({
	     *   x: 20
	     *   y: 10
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientEndPointX', 0);
	    /**
	     * get/set fill radial gradient end point x
	     * @name fillRadialGradientEndPointX
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill radial gradient end point x
	     * var endPointX = shape.fillRadialGradientEndPointX();
	     *
	     * // set fill radial gradient end point x
	     * shape.fillRadialGradientEndPointX(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillRadialGradientEndPointY', 0);
	    /**
	     * get/set fill radial gradient end point y
	     * @name fillRadialGradientEndPointY
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill radial gradient end point y
	     * var endPointY = shape.fillRadialGradientEndPointY();
	     *
	     * // set fill radial gradient end point y
	     * shape.fillRadialGradientEndPointY(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Shape, 'fillPatternRotation', 0);

	    /**
	     * get/set fill pattern rotation in degrees
	     * @name fillPatternRotation
	     * @method
	     * @memberof Kinetic.Shape.prototype
	     * @param {Number} rotation
	     * @returns {Kinetic.Shape}
	     * @example
	     * // get fill pattern rotation
	     * var patternRotation = shape.fillPatternRotation();
	     *
	     * // set fill pattern rotation
	     * shape.fillPatternRotation(20);
	     */


	    Kinetic.Factory.backCompat(Kinetic.Shape, {
	        dashArray: 'dash',
	        getDashArray: 'getDash',
	        setDashArray: 'getDash',

	        drawFunc: 'sceneFunc',
	        getDrawFunc: 'getSceneFunc',
	        setDrawFunc: 'setSceneFunc',

	        drawHitFunc: 'hitFunc',
	        getDrawHitFunc: 'getHitFunc',
	        setDrawHitFunc: 'setHitFunc'
	    });

	    Kinetic.Collection.mapMethods(Kinetic.Shape);
	})();
	;/*jshint unused:false */
	(function() {
	    // CONSTANTS
	    var STAGE = 'Stage',
	        STRING = 'string',
	        PX = 'px',

	        MOUSEOUT = 'mouseout',
	        MOUSELEAVE = 'mouseleave',
	        MOUSEOVER = 'mouseover',
	        MOUSEENTER = 'mouseenter',
	        MOUSEMOVE = 'mousemove',
	        MOUSEDOWN = 'mousedown',
	        MOUSEUP = 'mouseup',
	        CLICK = 'click',
	        DBL_CLICK = 'dblclick',
	        TOUCHSTART = 'touchstart',
	        TOUCHEND = 'touchend',
	        TAP = 'tap',
	        DBL_TAP = 'dbltap',
	        TOUCHMOVE = 'touchmove',
	        DOMMOUSESCROLL = 'DOMMouseScroll',
	        MOUSEWHEEL = 'mousewheel',
	        WHEEL = 'wheel',

	        CONTENT_MOUSEOUT = 'contentMouseout',
	        CONTENT_MOUSEOVER = 'contentMouseover',
	        CONTENT_MOUSEMOVE = 'contentMousemove',
	        CONTENT_MOUSEDOWN = 'contentMousedown',
	        CONTENT_MOUSEUP = 'contentMouseup',
	        CONTENT_CLICK = 'contentClick',
	        CONTENT_DBL_CLICK = 'contentDblclick',
	        CONTENT_TOUCHSTART = 'contentTouchstart',
	        CONTENT_TOUCHEND = 'contentTouchend',
	        CONTENT_DBL_TAP = 'contentDbltap',
	        CONTENT_TOUCHMOVE = 'contentTouchmove',

	        DIV = 'div',
	        RELATIVE = 'relative',
	        INLINE_BLOCK = 'inline-block',
	        KINETICJS_CONTENT = 'kineticjs-content',
	        SPACE = ' ',
	        UNDERSCORE = '_',
	        CONTAINER = 'container',
	        EMPTY_STRING = '',
	        EVENTS = [MOUSEDOWN, MOUSEMOVE, MOUSEUP, MOUSEOUT, TOUCHSTART, TOUCHMOVE, TOUCHEND, MOUSEOVER, DOMMOUSESCROLL, MOUSEWHEEL, WHEEL],

	        // cached variables
	        eventsLength = EVENTS.length;

	    function addEvent(ctx, eventName) {
	        ctx.content.addEventListener(eventName, function(evt) {
	            ctx[UNDERSCORE + eventName](evt);
	        }, false);
	    }

	    Kinetic.Util.addMethods(Kinetic.Stage, {
	        ___init: function(config) {
	            this.nodeType = STAGE;
	            // call super constructor
	            Kinetic.Container.call(this, config);
	            this._id = Kinetic.idCounter++;
	            this._buildDOM();
	            this._bindContentEvents();
	            this._enableNestedTransforms = false;
	            Kinetic.stages.push(this);
	        },
	        _validateAdd: function(child) {
	            if (child.getType() !== 'Layer') {
	                Kinetic.Util.error('You may only add layers to the stage.');
	            }
	        },
	        /**
	         * set container dom element which contains the stage wrapper div element
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         * @param {DomElement} container can pass in a dom element or id string
	         */
	        setContainer: function(container) {
	            if( typeof container === STRING) {
	                var id = container;
	                container = Kinetic.document.getElementById(container);
	                if (!container) {
	                    throw 'Can not find container in document with id ' + id;
	                }
	            }
	            this._setAttr(CONTAINER, container);
	            return this;
	        },
	        shouldDrawHit: function() {
	            return true;
	        },
	        draw: function() {
	            Kinetic.Node.prototype.draw.call(this);
	            return this;
	        },
	        /**
	         * draw layer scene graphs
	         * @name draw
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         */

	        /**
	         * draw layer hit graphs
	         * @name drawHit
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         */

	        /**
	         * set height
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         * @param {Number} height
	         */
	        setHeight: function(height) {
	            Kinetic.Node.prototype.setHeight.call(this, height);
	            this._resizeDOM();
	            return this;
	        },
	        /**
	         * set width
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         * @param {Number} width
	         */
	        setWidth: function(width) {
	            Kinetic.Node.prototype.setWidth.call(this, width);
	            this._resizeDOM();
	            return this;
	        },
	        /**
	         * clear all layers
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         */
	        clear: function() {
	            var layers = this.children,
	                len = layers.length,
	                n;

	            for(n = 0; n < len; n++) {
	                layers[n].clear();
	            }
	            return this;
	        },
	        clone: function(obj) {
	            if (!obj) {
	                obj = {};
	            }
	            obj.container = Kinetic.document.createElement(DIV);
	            
	            return Kinetic.Container.prototype.clone.call(this, obj);
	        },
	        /**
	         * destroy stage
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         */
	        destroy: function() {
	            var content = this.content;
	            Kinetic.Container.prototype.destroy.call(this);

	            if(content && Kinetic.Util._isInDocument(content)) {
	                this.getContainer().removeChild(content);
	            }
	            var index = Kinetic.stages.indexOf(this);
	            if (index > -1) {
	                Kinetic.stages.splice(index, 1);
	            }
	        },
	        /**
	         * get pointer position which can be a touch position or mouse position
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         * @returns {Object}
	         */
	        getPointerPosition: function() {
	            return this.pointerPos;
	        },
	        getStage: function() {
	            return this;
	        },
	        /**
	         * get stage content div element which has the
	         *  the class name "kineticjs-content"
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         */
	        getContent: function() {
	            return this.content;
	        },
	        /**
	         * Creates a composite data URL and requires a callback because the composite is generated asynchronously.
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         * @param {Object} config
	         * @param {Function} config.callback function executed when the composite has completed
	         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
	         *  "image/png" is the default
	         * @param {Number} [config.x] x position of canvas section
	         * @param {Number} [config.y] y position of canvas section
	         * @param {Number} [config.width] width of canvas section
	         * @param {Number} [config.height] height of canvas section
	         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
	         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
	         *  is very high quality
	         */
	        toDataURL: function(config) {
	            config = config || {};

	            var mimeType = config.mimeType || null,
	                quality = config.quality || null,
	                x = config.x || 0,
	                y = config.y || 0,
	                canvas = new Kinetic.SceneCanvas({
	                    width: config.width || this.getWidth(),
	                    height: config.height || this.getHeight(),
	                    pixelRatio: 1
	                }),
	                _context = canvas.getContext()._context,
	                layers = this.children;

	            if(x || y) {
	                _context.translate(-1 * x, -1 * y);
	            }

	            function drawLayer(n) {
	                var layer = layers[n],
	                    layerUrl = layer.toDataURL(),
	                    imageObj = new Kinetic.window.Image();

	                imageObj.onload = function() {
	                    _context.drawImage(imageObj, 0, 0);

	                    if(n < layers.length - 1) {
	                        drawLayer(n + 1);
	                    }
	                    else {
	                        config.callback(canvas.toDataURL(mimeType, quality));
	                    }
	                };
	                imageObj.src = layerUrl;
	            }
	            drawLayer(0);
	        },
	        /**
	         * converts stage into an image.
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         * @param {Object} config
	         * @param {Function} config.callback function executed when the composite has completed
	         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
	         *  "image/png" is the default
	         * @param {Number} [config.x] x position of canvas section
	         * @param {Number} [config.y] y position of canvas section
	         * @param {Number} [config.width] width of canvas section
	         * @param {Number} [config.height] height of canvas section
	         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
	         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
	         *  is very high quality
	         */
	        toImage: function(config) {
	            var cb = config.callback;

	            config.callback = function(dataUrl) {
	                Kinetic.Util._getImage(dataUrl, function(img) {
	                    cb(img);
	                });
	            };
	            this.toDataURL(config);
	        },
	        /**
	         * get visible intersection shape. This is the preferred
	         *  method for determining if a point intersects a shape or not
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         * @param {Object} pos
	         * @param {Number} pos.x
	         * @param {Number} pos.y
	         * @returns {Kinetic.Shape}
	         */
	        getIntersection: function(pos) {
	            var layers = this.getChildren(),
	                len = layers.length,
	                end = len - 1,
	                n, shape;

	            for(n = end; n >= 0; n--) {
	                shape = layers[n].getIntersection(pos);
	                if (shape) {
	                    return shape;
	                }
	            }

	            return null;
	        },
	        _resizeDOM: function() {
	            if(this.content) {
	                var width = this.getWidth(),
	                    height = this.getHeight(),
	                    layers = this.getChildren(),
	                    len = layers.length,
	                    n, layer;

	                // set content dimensions
	                this.content.style.width = width + PX;
	                this.content.style.height = height + PX;

	                this.bufferCanvas.setSize(width, height);
	                this.bufferHitCanvas.setSize(width, height);

	                // set layer dimensions
	                for(n = 0; n < len; n++) {
	                    layer = layers[n];
	                    layer.setSize(width, height);
	                    layer.draw();
	                }
	            }
	        },
	        /**
	         * add layer or layers to stage
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         * @param {...Kinetic.Layer} layer
	         * @example
	         * stage.add(layer1, layer2, layer3);
	         */
	        add: function(layer) {
	            if (arguments.length > 1) {
	                for (var i = 0; i < arguments.length; i++) {
	                    this.add(arguments[i]);
	                }
	                return;
	            }
	            Kinetic.Container.prototype.add.call(this, layer);
	            layer._setCanvasSize(this.width(), this.height());

	            // draw layer and append canvas to container
	            layer.draw();
	            this.content.appendChild(layer.canvas._canvas);

	            // chainable
	            return this;
	        },
	        getParent: function() {
	            return null;
	        },
	        getLayer: function() {
	            return null;
	        },
	        /**
	         * returns a {@link Kinetic.Collection} of layers
	         * @method
	         * @memberof Kinetic.Stage.prototype
	         */
	        getLayers: function() {
	            return this.getChildren();
	        },
	        _bindContentEvents: function() {
	            for (var n = 0; n < eventsLength; n++) {
	                addEvent(this, EVENTS[n]);
	            }
	        },
	        _mouseover: function(evt) {
	            if (!Kinetic.UA.mobile) {
	                this._setPointerPosition(evt);
	                this._fire(CONTENT_MOUSEOVER, {evt: evt});
	            }
	        },
	        _mouseout: function(evt) {
	            if (!Kinetic.UA.mobile) {
	                this._setPointerPosition(evt);
	                var targetShape = this.targetShape;

	                if(targetShape && !Kinetic.isDragging()) {
	                    targetShape._fireAndBubble(MOUSEOUT, {evt: evt});
	                    targetShape._fireAndBubble(MOUSELEAVE, {evt: evt});
	                    this.targetShape = null;
	                }
	                this.pointerPos = undefined;

	                this._fire(CONTENT_MOUSEOUT, {evt: evt});
	            }
	        },
	        _mousemove: function(evt) {
	        
	            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
	            if (Kinetic.UA.ieMobile) {
	                return this._touchmove(evt);
	            }
	            
	            // workaround fake mousemove event in chrome browser https://code.google.com/p/chromium/issues/detail?id=161464
	            if ((typeof evt.webkitMovementX !== 'undefined' || typeof evt.webkitMovementY !== 'undefined') && evt.webkitMovementY === 0 && evt.webkitMovementX === 0) {
	                return;
	            }
	            if (Kinetic.UA.mobile) {
	                return;
	            }
	            this._setPointerPosition(evt);
	            var dd = Kinetic.DD, shape;

	            if (!Kinetic.isDragging()) {
	                shape = this.getIntersection(this.getPointerPosition());
	                if(shape && shape.isListening()) {
	                    if(!Kinetic.isDragging() && (!this.targetShape || this.targetShape._id !== shape._id)) {
	                        if(this.targetShape) {
	                            this.targetShape._fireAndBubble(MOUSEOUT, {evt: evt}, shape);
	                            this.targetShape._fireAndBubble(MOUSELEAVE, {evt: evt}, shape);
	                        }
	                        shape._fireAndBubble(MOUSEOVER, {evt: evt}, this.targetShape);
	                        shape._fireAndBubble(MOUSEENTER, {evt: evt}, this.targetShape);
	                        this.targetShape = shape;
	                    }
	                    else {
	                        shape._fireAndBubble(MOUSEMOVE, {evt: evt});
	                    }
	                }
	                /*
	                 * if no shape was detected, clear target shape and try
	                 * to run mouseout from previous target shape
	                 */
	                else {
	                    if(this.targetShape && !Kinetic.isDragging()) {
	                        this.targetShape._fireAndBubble(MOUSEOUT, {evt: evt});
	                        this.targetShape._fireAndBubble(MOUSELEAVE, {evt: evt});
	                        this.targetShape = null;
	                    }

	                }

	                // content event
	                this._fire(CONTENT_MOUSEMOVE, {evt: evt});
	            }
	            if(dd) {
	                dd._drag(evt);
	            }

	            // always call preventDefault for desktop events because some browsers
	            // try to drag and drop the canvas element
	            if (evt.preventDefault) {
	                evt.preventDefault();
	            }
	        },
	        _mousedown: function(evt) {
	        
	            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event       
	            if (Kinetic.UA.ieMobile) {
	                return this._touchstart(evt);
	            }
	            
	            if (!Kinetic.UA.mobile) {
	                this._setPointerPosition(evt);
	                var shape = this.getIntersection(this.getPointerPosition());

	                Kinetic.listenClickTap = true;

	                if (shape && shape.isListening()) {
	                    this.clickStartShape = shape;
	                    shape._fireAndBubble(MOUSEDOWN, {evt: evt});
	                }

	                // content event
	                this._fire(CONTENT_MOUSEDOWN, {evt: evt});
	            }

	            // always call preventDefault for desktop events because some browsers
	            // try to drag and drop the canvas element
	            if (evt.preventDefault) {
	                evt.preventDefault();
	            }
	        },
	        _mouseup: function(evt) {
	        
	            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event       
	            if (Kinetic.UA.ieMobile) {
	                return this._touchend(evt);
	            }
	            if (!Kinetic.UA.mobile) {
	                this._setPointerPosition(evt);
	                var shape = this.getIntersection(this.getPointerPosition()),
	                    clickStartShape = this.clickStartShape,
	                    fireDblClick = false,
	                    dd = Kinetic.DD;

	                if(Kinetic.inDblClickWindow) {
	                    fireDblClick = true;
	                    Kinetic.inDblClickWindow = false;
	                }
	                // don't set inDblClickWindow after dragging
	                else if (!dd || !dd.justDragged) {
	                    Kinetic.inDblClickWindow = true;
	                } else if (dd) {
	                    dd.justDragged = false;
	                }

	                setTimeout(function() {
	                    Kinetic.inDblClickWindow = false;
	                }, Kinetic.dblClickWindow);

	                if (shape && shape.isListening()) {
	                    shape._fireAndBubble(MOUSEUP, {evt: evt});

	                    // detect if click or double click occurred
	                    if(Kinetic.listenClickTap && clickStartShape && clickStartShape._id === shape._id) {
	                        shape._fireAndBubble(CLICK, {evt: evt});

	                        if(fireDblClick) {
	                            shape._fireAndBubble(DBL_CLICK, {evt: evt});
	                        }
	                    }
	                }
	                // content events
	                this._fire(CONTENT_MOUSEUP, {evt: evt});
	                if (Kinetic.listenClickTap) {
	                    this._fire(CONTENT_CLICK, {evt: evt});
	                    if(fireDblClick) {
	                        this._fire(CONTENT_DBL_CLICK, {evt: evt});
	                    }
	                }

	                Kinetic.listenClickTap = false;
	            }

	            // always call preventDefault for desktop events because some browsers
	            // try to drag and drop the canvas element
	            if (evt.preventDefault) {
	                evt.preventDefault();
	            }
	        },
	        _touchstart: function(evt) {
	            this._setPointerPosition(evt);
	            var shape = this.getIntersection(this.getPointerPosition());

	            Kinetic.listenClickTap = true;

	            if (shape && shape.isListening()) {
	                this.tapStartShape = shape;
	                shape._fireAndBubble(TOUCHSTART, {evt: evt});

	                // only call preventDefault if the shape is listening for events
	                if (shape.isListening() && evt.preventDefault) {
	                    evt.preventDefault();
	                }
	            }
	            // content event
	            this._fire(CONTENT_TOUCHSTART, {evt: evt});
	        },
	        _touchend: function(evt) {
	            this._setPointerPosition(evt);
	            var shape = this.getIntersection(this.getPointerPosition()),
	                fireDblClick = false;

	            if(Kinetic.inDblClickWindow) {
	                fireDblClick = true;
	                Kinetic.inDblClickWindow = false;
	            }
	            else {
	                Kinetic.inDblClickWindow = true;
	            }

	            setTimeout(function() {
	                Kinetic.inDblClickWindow = false;
	            }, Kinetic.dblClickWindow);

	            if (shape && shape.isListening()) {
	                shape._fireAndBubble(TOUCHEND, {evt: evt});

	                // detect if tap or double tap occurred
	                if(Kinetic.listenClickTap && shape._id === this.tapStartShape._id) {
	                    shape._fireAndBubble(TAP, {evt: evt});

	                    if(fireDblClick) {
	                        shape._fireAndBubble(DBL_TAP, {evt: evt});
	                    }
	                }
	                // only call preventDefault if the shape is listening for events
	                if (shape.isListening() && evt.preventDefault) {
	                    evt.preventDefault();
	                }
	            }
	            // content events
	            if (Kinetic.listenClickTap) {
	                this._fire(CONTENT_TOUCHEND, {evt: evt});
	                if(fireDblClick) {
	                    this._fire(CONTENT_DBL_TAP, {evt: evt});
	                }
	            }

	            Kinetic.listenClickTap = false;
	        },
	        _touchmove: function(evt) {
	            this._setPointerPosition(evt);
	            var dd = Kinetic.DD,
	                shape;
	            if (!Kinetic.isDragging()) {
	                shape = this.getIntersection(this.getPointerPosition());
	                if (shape && shape.isListening()) {
	                    shape._fireAndBubble(TOUCHMOVE, {evt: evt});
	                    // only call preventDefault if the shape is listening for events
	                    if (shape.isListening() && evt.preventDefault) {
	                        evt.preventDefault();
	                    }
	                }
	                this._fire(CONTENT_TOUCHMOVE, {evt: evt});
	            }
	            if(dd) {
	                dd._drag(evt);
	                if (Kinetic.isDragging()) {
	                    evt.preventDefault();
	                }
	            }
	        },
	        _DOMMouseScroll: function(evt) {
	            this._mousewheel(evt);
	        },
	        _mousewheel: function(evt) {
	            this._setPointerPosition(evt);
	            var shape = this.getIntersection(this.getPointerPosition());

	            if (shape && shape.isListening()) {
	                shape._fireAndBubble(MOUSEWHEEL, {evt: evt});
	            }
	        },
	        _wheel: function(evt) {
	            this._mousewheel(evt);
	        },
	        _setPointerPosition: function(evt) {
	            var contentPosition = this._getContentPosition(),
	                offsetX = evt.offsetX,
	                clientX = evt.clientX,
	                x = null,
	                y = null,
	                touch;
	            evt = evt ? evt : window.event;

	            // touch events
	            if(evt.touches !== undefined) {
	                // currently, only handle one finger
	                if (evt.touches.length > 0) {

	                    touch = evt.touches[0];

	                    // get the information for finger #1
	                    x = touch.clientX - contentPosition.left;
	                    y = touch.clientY - contentPosition.top;
	                }
	            }
	            // mouse events
	            else {
	                // if offsetX is defined, assume that offsetY is defined as well
	                if (offsetX !== undefined) {
	                    x = offsetX;
	                    y = evt.offsetY;
	                }
	                // we unfortunately have to use UA detection here because accessing
	                // the layerX or layerY properties in newer versions of Chrome
	                // throws a JS warning.  layerX and layerY are required for FF
	                // when the container is transformed via CSS.
	                else if (Kinetic.UA.browser === 'mozilla') {
	                    x = evt.layerX;
	                    y = evt.layerY;
	                }
	                // if clientX is defined, assume that clientY is defined as well
	                else if (clientX !== undefined && contentPosition) {
	                    x = clientX - contentPosition.left;
	                    y = evt.clientY - contentPosition.top;
	                }
	            }

	            if (x !== null && y !== null) {
	                this.pointerPos = {
	                    x: x,
	                    y: y
	                };
	            }
	        },
	        _getContentPosition: function() {
	            var rect = this.content.getBoundingClientRect ? this.content.getBoundingClientRect() : { top: 0, left: 0 };
	            return {
	                top: rect.top,
	                left: rect.left
	            };
	        },
	        _buildDOM: function() {
	            var container = this.getContainer();
	            if (!container) {
	                if (Kinetic.Util.isBrowser()) {
	                    throw 'Stage has no container. A container is required.';
	                } else {
	                    // automatically create element for jsdom in nodejs env
	                    container = Kinetic.document.createElement(DIV);
	                }
	            }
	            // clear content inside container
	            container.innerHTML = EMPTY_STRING;

	            // content
	            this.content = Kinetic.document.createElement(DIV);
	            this.content.style.position = RELATIVE;
	            this.content.style.display = INLINE_BLOCK;
	            this.content.className = KINETICJS_CONTENT;
	            this.content.setAttribute('role', 'presentation');
	            container.appendChild(this.content);

	            // the buffer canvas pixel ratio must be 1 because it is used as an 
	            // intermediate canvas before copying the result onto a scene canvas.
	            // not setting it to 1 will result in an over compensation
	            this.bufferCanvas = new Kinetic.SceneCanvas({
	                pixelRatio: 1
	            });
	            this.bufferHitCanvas = new Kinetic.HitCanvas();

	            this._resizeDOM();
	        },
	        _onContent: function(typesStr, handler) {
	            var types = typesStr.split(SPACE),
	                len = types.length,
	                n, baseEvent;

	            for(n = 0; n < len; n++) {
	                baseEvent = types[n];
	                this.content.addEventListener(baseEvent, handler, false);
	            }
	        },
	        // currently cache function is now working for stage, because stage has no its own canvas element
	        // TODO: may be it is better to cache all children layers?
	        cache: function() {
	            Kinetic.Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');
	        },
	        clearCache : function() {
	        }
	    });
	    Kinetic.Util.extend(Kinetic.Stage, Kinetic.Container);

	    // add getters and setters
	    Kinetic.Factory.addGetter(Kinetic.Stage, 'container');
	    Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Stage, 'container');

	    /**
	     * get container DOM element
	     * @name container
	     * @method
	     * @memberof Kinetic.Stage.prototype
	     * @returns {DomElement} container
	     * @example
	     * // get container
	     * var container = stage.container();
	     * 
	     * // set container
	     * var container = document.createElement('div');
	     * body.appendChild(container);
	     * stage.container(container);
	     */

	})();
	;(function() {
	    Kinetic.Util.addMethods(Kinetic.BaseLayer, {
	        ___init: function(config) {
	            this.nodeType = 'Layer';
	            Kinetic.Container.call(this, config);
	        },
	        createPNGStream : function() {
	            return this.canvas._canvas.createPNGStream();
	        },
	        /**
	         * get layer canvas
	         * @method
	         * @memberof Kinetic.BaseLayer.prototype
	         */
	        getCanvas: function() {
	            return this.canvas;
	        },
	        /**
	         * get layer hit canvas
	         * @method
	         * @memberof Kinetic.BaseLayer.prototype
	         */
	        getHitCanvas: function() {
	            return this.hitCanvas;
	        },
	        /**
	         * get layer canvas context
	         * @method
	         * @memberof Kinetic.BaseLayer.prototype
	         */
	        getContext: function() {
	            return this.getCanvas().getContext();
	        },
	        /**
	         * clear scene and hit canvas contexts tied to the layer
	         * @method
	         * @memberof Kinetic.BaseLayer.prototype
	         * @param {Object} [bounds]
	         * @param {Number} [bounds.x]
	         * @param {Number} [bounds.y]
	         * @param {Number} [bounds.width]
	         * @param {Number} [bounds.height]
	         * @example
	         * layer.clear();
	         * layer.clear({
	         *   x : 0,
	         *   y : 0,
	         *   width : 100,
	         *   height : 100
	         * });
	         */
	        clear: function(bounds) {
	            this.getContext().clear(bounds);
	            this.getHitCanvas().getContext().clear(bounds);
	            return this;
	        },
	        clearHitCache: function() {
	            this._hitImageData = undefined;
	        },
	        // extend Node.prototype.setZIndex
	        setZIndex: function(index) {
	            Kinetic.Node.prototype.setZIndex.call(this, index);
	            var stage = this.getStage();
	            if(stage) {
	                stage.content.removeChild(this.getCanvas()._canvas);

	                if(index < stage.getChildren().length - 1) {
	                    stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[index + 1].getCanvas()._canvas);
	                }
	                else {
	                    stage.content.appendChild(this.getCanvas()._canvas);
	                }
	            }
	            return this;
	        },
	        // extend Node.prototype.moveToTop
	        moveToTop: function() {
	            Kinetic.Node.prototype.moveToTop.call(this);
	            var stage = this.getStage();
	            if(stage) {
	                stage.content.removeChild(this.getCanvas()._canvas);
	                stage.content.appendChild(this.getCanvas()._canvas);
	            }
	        },
	        // extend Node.prototype.moveUp
	        moveUp: function() {
	            if(Kinetic.Node.prototype.moveUp.call(this)) {
	                var stage = this.getStage();
	                if(stage) {
	                    stage.content.removeChild(this.getCanvas()._canvas);

	                    if(this.index < stage.getChildren().length - 1) {
	                        stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[this.index + 1].getCanvas()._canvas);
	                    }
	                    else {
	                        stage.content.appendChild(this.getCanvas()._canvas);
	                    }
	                }
	            }
	        },
	        // extend Node.prototype.moveDown
	        moveDown: function() {
	            if(Kinetic.Node.prototype.moveDown.call(this)) {
	                var stage = this.getStage();
	                if(stage) {
	                    var children = stage.getChildren();
	                    stage.content.removeChild(this.getCanvas()._canvas);
	                    stage.content.insertBefore(this.getCanvas()._canvas, children[this.index + 1].getCanvas()._canvas);
	                }
	            }
	        },
	        // extend Node.prototype.moveToBottom
	        moveToBottom: function() {
	            if(Kinetic.Node.prototype.moveToBottom.call(this)) {
	                var stage = this.getStage();
	                if(stage) {
	                    var children = stage.getChildren();
	                    stage.content.removeChild(this.getCanvas()._canvas);
	                    stage.content.insertBefore(this.getCanvas()._canvas, children[1].getCanvas()._canvas);
	                }
	            }
	        },
	        getLayer: function() {
	            return this;
	        },
	        remove: function() {
	            var _canvas = this.getCanvas()._canvas;

	            Kinetic.Node.prototype.remove.call(this);

	            if(_canvas && _canvas.parentNode && Kinetic.Util._isInDocument(_canvas)) {
	                _canvas.parentNode.removeChild(_canvas);
	            }
	            return this;
	        },
	        getStage: function() {
	            return this.parent;
	        },
	        setSize : function(width, height) {
	            this.canvas.setSize(width, height);
	        },
	        /**
	         * get/set width of layer.getter return width of stage. setter doing nothing.
	         * if you want change width use `stage.width(value);`
	         * @name width
	         * @method
	         * @memberof Kinetic.BaseLayer.prototype
	         * @returns {Number}
	         * @example
	         * var width = layer.width();
	         */
	        getWidth : function() {
	            if (this.parent) {
	                return this.parent.getWidth();
	            }
	        },
	        setWidth : function() {
	            Kinetic.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
	        },
	        /**
	         * get/set height of layer.getter return height of stage. setter doing nothing.
	         * if you want change height use `stage.height(value);`
	         * @name height
	         * @method
	         * @memberof Kinetic.BaseLayer.prototype
	         * @returns {Number}
	         * @example
	         * var height = layer.height();
	         */
	        getHeight : function() {
	            if (this.parent) {
	                return this.parent.getHeight();
	            }
	        },
	        setHeight : function() {
	            Kinetic.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
	        }
	    });
	    Kinetic.Util.extend(Kinetic.BaseLayer, Kinetic.Container);

	    // add getters and setters
	    Kinetic.Factory.addGetterSetter(Kinetic.BaseLayer, 'clearBeforeDraw', true);
	    /**
	     * get/set clearBeforeDraw flag which determines if the layer is cleared or not
	     *  before drawing
	     * @name clearBeforeDraw
	     * @method
	     * @memberof Kinetic.BaseLayer.prototype
	     * @param {Boolean} clearBeforeDraw
	     * @returns {Boolean}
	     * @example
	     * // get clearBeforeDraw flag
	     * var clearBeforeDraw = layer.clearBeforeDraw();
	     *
	     * // disable clear before draw
	     * layer.clearBeforeDraw(false);
	     *
	     * // enable clear before draw
	     * layer.clearBeforeDraw(true);
	     */

	    Kinetic.Collection.mapMethods(Kinetic.BaseLayer);
	})();
	;(function() {
	    // constants
	    var HASH = '#',
	        BEFORE_DRAW ='beforeDraw',
	        DRAW = 'draw',

	        /*
	         * 2 - 3 - 4
	         * |       |
	         * 1 - 0   5
	         *         |
	         * 8 - 7 - 6     
	         */
	        INTERSECTION_OFFSETS = [
	            {x:  0, y:  0}, // 0
	            {x: -1, y:  0}, // 1
	            {x: -1, y: -1}, // 2
	            {x:  0, y: -1}, // 3
	            {x:  1, y: -1}, // 4
	            {x:  1, y:  0}, // 5
	            {x:  1, y:  1}, // 6
	            {x:  0, y:  1}, // 7
	            {x: -1, y:  1}  // 8
	        ],
	        INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;


	    Kinetic.Util.addMethods(Kinetic.Layer, {
	        ____init: function(config) {
	            this.nodeType = 'Layer';
	            this.canvas = new Kinetic.SceneCanvas();
	            this.hitCanvas = new Kinetic.HitCanvas();
	            // call super constructor
	            Kinetic.BaseLayer.call(this, config);
	        },
	        _setCanvasSize: function(width, height) {
	            this.canvas.setSize(width, height);
	            this.hitCanvas.setSize(width, height);
	        },
	        _validateAdd: function(child) {
	            var type = child.getType();
	            if (type !== 'Group' && type !== 'Shape') {
	                Kinetic.Util.error('You may only add groups and shapes to a layer.');
	            }
	        },
	        /**
	         * get visible intersection shape. This is the preferred
	         * method for determining if a point intersects a shape or not
	         * @method
	         * @memberof Kinetic.Layer.prototype
	         * @param {Object} pos
	         * @param {Number} pos.x
	         * @param {Number} pos.y
	         * @returns {Kinetic.Shape}
	         */
	        getIntersection: function(pos) {
	            var obj, i, intersectionOffset, shape;

	            if(this.hitGraphEnabled() && this.isVisible()) {
	                // in some cases antialiased area may be bigger than 1px
	                // it is possible if we will cache node, then scale it a lot
	                // TODO: check { 0; 0 } point before loop, and remove it from INTERSECTION_OFFSETS.
	                var spiralSearchDistance = 1;
	                var continueSearch = false;
	                while (true) {
	                    for (i=0; i<INTERSECTION_OFFSETS_LEN; i++) {
	                        intersectionOffset = INTERSECTION_OFFSETS[i];
	                        obj = this._getIntersection({
	                            x: pos.x + intersectionOffset.x * spiralSearchDistance,
	                            y: pos.y + intersectionOffset.y * spiralSearchDistance
	                        });
	                        shape = obj.shape;
	                        if (shape) {
	                            return shape;
	                        }
	                        // we should continue search if we found antialiased pixel
	                        // that means our node somewhere very close
	                        else if (obj.antialiased) {
	                            continueSearch = true;
	                        }
	                    }
	                    // if no shape, and no antialiased pixel, we should end searching 
	                    if (continueSearch) {
	                        spiralSearchDistance += 1;
	                    } else {
	                        return;
	                    }
	                }
	            } else {
	                return null;
	            }
	        },
	        _getImageData: function(x, y) {
	            var width = this.hitCanvas.width || 1,
	                height = this.hitCanvas.height || 1,
	                index = (Math.round(y) * width ) + Math.round(x);

	            if (!this._hitImageData) {
	                this._hitImageData = this.hitCanvas.context.getImageData(0, 0, width, height);
	            }

	            return [
	                this._hitImageData.data[4 * index + 0] , // Red
	                this._hitImageData.data[4 * index + 1], // Green
	                this._hitImageData.data[4 * index + 2], // Blue
	                this._hitImageData.data[4 * index + 3] // Alpha
	            ];
	        },
	        _getIntersection: function(pos) {
	            var p = this.hitCanvas.context.getImageData(pos.x, pos.y, 1, 1).data,
	                p3 = p[3],
	                colorKey, shape;

	            // fully opaque pixel
	            if(p3 === 255) {
	                colorKey = Kinetic.Util._rgbToHex(p[0], p[1], p[2]);
	                shape = Kinetic.shapes[HASH + colorKey];
	                return {
	                    shape: shape
	                };
	            }
	            // antialiased pixel
	            else if(p3 > 0) {
	                return {
	                    antialiased: true
	                };
	            }
	            // empty pixel
	            else {
	                return {};
	            }
	        },
	        drawScene: function(can, top) {
	            var layer = this.getLayer(),
	                canvas = can || (layer && layer.getCanvas());

	            this._fire(BEFORE_DRAW, {
	                node: this
	            });

	            if(this.getClearBeforeDraw()) {
	                canvas.getContext().clear();
	            }
	            
	            Kinetic.Container.prototype.drawScene.call(this, canvas, top);

	            this._fire(DRAW, {
	                node: this
	            });

	            return this;
	        },
	        // the apply transform method is handled by the Layer and FastLayer class
	        // because it is up to the layer to decide if an absolute or relative transform
	        // should be used
	        _applyTransform: function(shape, context, top) {
	            var m = shape.getAbsoluteTransform(top).getMatrix();
	            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	        },
	        drawHit: function(can, top) {
	            var layer = this.getLayer(),
	                canvas = can || (layer && layer.hitCanvas);

	            if(layer && layer.getClearBeforeDraw()) {
	                layer.getHitCanvas().getContext().clear();
	            }

	            Kinetic.Container.prototype.drawHit.call(this, canvas, top);
	            this.imageData = null; // Clear imageData cache
	            return this;
	        },
	        /**
	         * clear scene and hit canvas contexts tied to the layer
	         * @method
	         * @memberof Kinetic.Layer.prototype
	         * @param {Object} [bounds]
	         * @param {Number} [bounds.x]
	         * @param {Number} [bounds.y]
	         * @param {Number} [bounds.width]
	         * @param {Number} [bounds.height]
	         * @example
	         * layer.clear();
	         * layer.clear({
	         *   x : 0,
	         *   y : 0,
	         *   width : 100,
	         *   height : 100
	         * });
	         */
	        clear: function(bounds) {
	            this.getContext().clear(bounds);
	            this.getHitCanvas().getContext().clear(bounds);
	            this.imageData = null; // Clear getImageData cache
	            return this;
	        },
	        // extend Node.prototype.setVisible
	        setVisible: function(visible) {
	            Kinetic.Node.prototype.setVisible.call(this, visible);
	            if(visible) {
	                this.getCanvas()._canvas.style.display = 'block';
	                this.hitCanvas._canvas.style.display = 'block';
	            }
	            else {
	                this.getCanvas()._canvas.style.display = 'none';
	                this.hitCanvas._canvas.style.display = 'none';
	            }
	            return this;
	        },
	        /**
	         * enable hit graph
	         * @name enableHitGraph
	         * @method
	         * @memberof Kinetic.Layer.prototype
	         * @returns {Layer}
	         */
	        enableHitGraph: function() {
	            this.setHitGraphEnabled(true);
	            return this;
	        },
	        /**
	         * disable hit graph
	         * @name disableHitGraph
	         * @method
	         * @memberof Kinetic.Layer.prototype
	         * @returns {Layer}
	         */
	        disableHitGraph: function() {
	            this.setHitGraphEnabled(false);
	            return this;
	        },
	        setSize : function(width, height) {
	            Kinetic.BaseLayer.prototype.setSize.call(this, width, height);
	            this.hitCanvas.setSize(width, height);
	        }
	    });
	    Kinetic.Util.extend(Kinetic.Layer, Kinetic.BaseLayer);

	    Kinetic.Factory.addGetterSetter(Kinetic.Layer, 'hitGraphEnabled', true);
	    /**
	     * get/set hitGraphEnabled flag.  Disabling the hit graph will greatly increase
	     *  draw performance because the hit graph will not be redrawn each time the layer is
	     *  drawn.  This, however, also disables mouse/touch event detection
	     * @name hitGraphEnabled
	     * @method
	     * @memberof Kinetic.Layer.prototype
	     * @param {Boolean} enabled
	     * @returns {Boolean}
	     * @example
	     * // get hitGraphEnabled flag
	     * var hitGraphEnabled = layer.hitGraphEnabled();
	     *
	     * // disable hit graph
	     * layer.hitGraphEnabled(false);
	     *
	     * // enable hit graph
	     * layer.hitGraphEnabled(true);
	     */
	    Kinetic.Collection.mapMethods(Kinetic.Layer);
	})();
	;(function() {

	    Kinetic.Util.addMethods(Kinetic.FastLayer, {
	        ____init: function(config) {
	            this.nodeType = 'Layer';
	            this.canvas = new Kinetic.SceneCanvas();
	            // call super constructor
	            Kinetic.BaseLayer.call(this, config);
	        },
	        _validateAdd: function(child) {
	            var type = child.getType();
	            if (type !== 'Shape') {
	                Kinetic.Util.error('You may only add shapes to a fast layer.');
	            }
	        },
	        _setCanvasSize: function(width, height) {
	            this.canvas.setSize(width, height);
	        },
	        hitGraphEnabled: function() {
	            return false;
	        },
	        getIntersection: function() {
	            return null;
	        },
	        drawScene: function(can) {
	            var layer = this.getLayer(),
	                canvas = can || (layer && layer.getCanvas());

	            if(this.getClearBeforeDraw()) {
	                canvas.getContext().clear();
	            }
	            
	            Kinetic.Container.prototype.drawScene.call(this, canvas);

	            return this;
	        },
	        // the apply transform method is handled by the Layer and FastLayer class
	        // because it is up to the layer to decide if an absolute or relative transform
	        // should be used
	        _applyTransform: function(shape, context, top) {
	            if (!top || top._id !== this._id) {
	                var m = shape.getTransform().getMatrix();
	                context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	            }
	        },
	        draw: function() {
	            this.drawScene();
	            return this;
	        },
	        /**
	         * clear scene and hit canvas contexts tied to the layer
	         * @method
	         * @memberof Kinetic.FastLayer.prototype
	         * @param {Object} [bounds]
	         * @param {Number} [bounds.x]
	         * @param {Number} [bounds.y]
	         * @param {Number} [bounds.width]
	         * @param {Number} [bounds.height]
	         * @example
	         * layer.clear();
	         * layer.clear({
	         *   x : 0,
	         *   y : 0,
	         *   width : 100,
	         *   height : 100
	         * });
	         */
	        clear: function(bounds) {
	            this.getContext().clear(bounds);
	            return this;
	        },
	        // extend Node.prototype.setVisible
	        setVisible: function(visible) {
	            Kinetic.Node.prototype.setVisible.call(this, visible);
	            if(visible) {
	                this.getCanvas()._canvas.style.display = 'block';
	            }
	            else {
	                this.getCanvas()._canvas.style.display = 'none';
	            }
	            return this;
	        }
	    });
	    Kinetic.Util.extend(Kinetic.FastLayer, Kinetic.BaseLayer);

	    Kinetic.Collection.mapMethods(Kinetic.FastLayer);
	})();
	;(function() {
	    Kinetic.Util.addMethods(Kinetic.Group, {
	        ___init: function(config) {
	            this.nodeType = 'Group';
	            // call super constructor
	            Kinetic.Container.call(this, config);
	        },
	        _validateAdd: function(child) {
	            var type = child.getType();
	            if (type !== 'Group' && type !== 'Shape') {
	                Kinetic.Util.error('You may only add groups and shapes to groups.');
	            }
	        }
	    });
	    Kinetic.Util.extend(Kinetic.Group, Kinetic.Container);

	    Kinetic.Collection.mapMethods(Kinetic.Group);
	})();
	;(function() {
	    /**
	     * Rect constructor
	     * @constructor
	     * @memberof Kinetic
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {Number} [config.cornerRadius]
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var rect = new Kinetic.Rect({
	     *   width: 100,
	     *   height: 50,
	     *   fill: 'red',
	     *   stroke: 'black',
	     *   strokeWidth: 5
	     * });
	     */
	    Kinetic.Rect = function(config) {
	        this.___init(config);
	    };

	    Kinetic.Rect.prototype = {
	        ___init: function(config) {
	            Kinetic.Shape.call(this, config);
	            this.className = 'Rect';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var cornerRadius = this.getCornerRadius(),
	                width = this.getWidth(),
	                height = this.getHeight();

	            
	            context.beginPath();

	            if(!cornerRadius) {
	                // simple rect - don't bother doing all that complicated maths stuff.
	                context.rect(0, 0, width, height);
	            }
	            else {
	                // arcTo would be nicer, but browser support is patchy (Opera)
	                context.moveTo(cornerRadius, 0);
	                context.lineTo(width - cornerRadius, 0);
	                context.arc(width - cornerRadius, cornerRadius, cornerRadius, Math.PI * 3 / 2, 0, false);
	                context.lineTo(width, height - cornerRadius);
	                context.arc(width - cornerRadius, height - cornerRadius, cornerRadius, 0, Math.PI / 2, false);
	                context.lineTo(cornerRadius, height);
	                context.arc(cornerRadius, height - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, false);
	                context.lineTo(0, cornerRadius);
	                context.arc(cornerRadius, cornerRadius, cornerRadius, Math.PI, Math.PI * 3 / 2, false);
	            }
	            context.closePath();
	            context.fillStrokeShape(this);
	        }
	    };

	    Kinetic.Util.extend(Kinetic.Rect, Kinetic.Shape);

	    Kinetic.Factory.addGetterSetter(Kinetic.Rect, 'cornerRadius', 0);
	    /**
	     * get/set corner radius
	     * @name cornerRadius
	     * @method
	     * @memberof Kinetic.Rect.prototype
	     * @param {Number} cornerRadius
	     * @returns {Number}
	     * @example
	     * // get corner radius
	     * var cornerRadius = rect.cornerRadius();
	     * 
	     * // set corner radius
	     * rect.cornerRadius(10);
	     */

	    Kinetic.Collection.mapMethods(Kinetic.Rect);
	})();
	;(function() {
	    // the 0.0001 offset fixes a bug in Chrome 27
	    var PIx2 = (Math.PI * 2) - 0.0001,
	        CIRCLE = 'Circle';

	    /**
	     * Circle constructor
	     * @constructor
	     * @memberof Kinetic
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {Number} config.radius
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * // create circle
	     * var circle = new Kinetic.Circle({
	     *   radius: 40,
	     *   fill: 'red',
	     *   stroke: 'black'
	     *   strokeWidth: 5
	     * });
	     */
	    Kinetic.Circle = function(config) {
	        this.___init(config);
	    };

	    Kinetic.Circle.prototype = {
	        ___init: function(config) {
	            // call super constructor
	            Kinetic.Shape.call(this, config);
	            this.className = CIRCLE;
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            context.beginPath();
	            context.arc(0, 0, this.getRadius(), 0, PIx2, false);
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        // implements Shape.prototype.getWidth()
	        getWidth: function() {
	            return this.getRadius() * 2;
	        },
	        // implements Shape.prototype.getHeight()
	        getHeight: function() {
	            return this.getRadius() * 2;
	        },
	        // implements Shape.prototype.setWidth()
	        setWidth: function(width) {
	            Kinetic.Node.prototype.setWidth.call(this, width);
	            if (this.radius() !== width / 2) {
	                this.setRadius(width / 2);
	            }
	        },
	        // implements Shape.prototype.setHeight()
	        setHeight: function(height) {
	            Kinetic.Node.prototype.setHeight.call(this, height);
	            if (this.radius() !== height / 2) {
	                this.setRadius(height / 2);
	            }
	        },
	        setRadius : function(val) {
	            this._setAttr('radius', val);
	            this.setWidth(val * 2);
	            this.setHeight(val * 2);
	        }
	    };
	    Kinetic.Util.extend(Kinetic.Circle, Kinetic.Shape);

	    // add getters setters
	    Kinetic.Factory.addGetter(Kinetic.Circle, 'radius', 0);
	    Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Circle, 'radius');

	    /**
	     * get/set radius
	     * @name radius
	     * @method
	     * @memberof Kinetic.Circle.prototype
	     * @param {Number} radius
	     * @returns {Number}
	     * @example
	     * // get radius
	     * var radius = circle.radius();
	     *
	     * // set radius
	     * circle.radius(10);
	     */

	    Kinetic.Collection.mapMethods(Kinetic.Circle);
	})();
	;(function() {
	    // the 0.0001 offset fixes a bug in Chrome 27
	    var PIx2 = (Math.PI * 2) - 0.0001,
	        ELLIPSE = 'Ellipse';

	    /**
	     * Ellipse constructor
	     * @constructor
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {Object} config.radius defines x and y radius
	     * @@ShapeParams
	     * @@NodeParams
	     * @example
	     * var ellipse = new Kinetic.Ellipse({
	     *   radius : {
	     *     x : 50,
	     *     y : 50
	     *   },
	     *   fill: 'red'
	     * });
	     */
	    Kinetic.Ellipse = function(config) {
	        this.___init(config);
	    };

	    Kinetic.Ellipse.prototype = {
	        ___init: function(config) {
	            // call super constructor
	            Kinetic.Shape.call(this, config);
	            this.className = ELLIPSE;
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var rx = this.getRadiusX(),
	                ry = this.getRadiusY();

	            context.beginPath();
	            context.save();
	            if(rx !== ry) {
	                context.scale(1, ry / rx);
	            }
	            context.arc(0, 0, rx, 0, PIx2, false);
	            context.restore();
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        // implements Shape.prototype.getWidth()
	        getWidth: function() {
	            return this.getRadiusX() * 2;
	        },
	        // implements Shape.prototype.getHeight()
	        getHeight: function() {
	            return this.getRadiusY() * 2;
	        },
	        // implements Shape.prototype.setWidth()
	        setWidth: function(width) {
	            Kinetic.Node.prototype.setWidth.call(this, width);
	            this.setRadius({
	                x: width / 2
	            });
	        },
	        // implements Shape.prototype.setHeight()
	        setHeight: function(height) {
	            Kinetic.Node.prototype.setHeight.call(this, height);
	            this.setRadius({
	                y: height / 2
	            });
	        }
	    };
	    Kinetic.Util.extend(Kinetic.Ellipse, Kinetic.Shape);

	    // add getters setters
	    Kinetic.Factory.addComponentsGetterSetter(Kinetic.Ellipse, 'radius', ['x', 'y']);

	    /**
	     * get/set radius
	     * @name radius
	     * @method
	     * @memberof Kinetic.Ellipse.prototype
	     * @param {Object} radius
	     * @param {Number} radius.x
	     * @param {Number} radius.y
	     * @returns {Object}
	     * @example
	     * // get radius
	     * var radius = ellipse.radius();
	     * 
	     * // set radius
	     * ellipse.radius({
	     *   x: 200,
	     *   y: 100
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Ellipse, 'radiusX', 0);
	    /**
	     * get/set radius x
	     * @name radiusX
	     * @method
	     * @memberof Kinetic.Ellipse.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get radius x
	     * var radiusX = ellipse.radiusX();
	     * 
	     * // set radius x
	     * ellipse.radiusX(200);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Ellipse, 'radiusY', 0);
	    /**
	     * get/set radius y
	     * @name radiusY
	     * @method
	     * @memberof Kinetic.Ellipse.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get radius y
	     * var radiusY = ellipse.radiusY();
	     * 
	     * // set radius y
	     * ellipse.radiusY(200);
	     */

	    Kinetic.Collection.mapMethods(Kinetic.Ellipse);

	})();;(function() {
	    // the 0.0001 offset fixes a bug in Chrome 27
	    var PIx2 = (Math.PI * 2) - 0.0001;
	    
	    /**
	     * Ring constructor
	     * @constructor
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {Number} config.innerRadius
	     * @param {Number} config.outerRadius
	     * @param {Boolean} [config.clockwise]
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var ring = new Kinetic.Ring({
	     *   innerRadius: 40,
	     *   outerRadius: 80,
	     *   fill: 'red',
	     *   stroke: 'black',
	     *   strokeWidth: 5
	     * });
	     */
	    Kinetic.Ring = function(config) {
	        this.___init(config);
	    };

	    Kinetic.Ring.prototype = {
	        ___init: function(config) {
	            // call super constructor
	            Kinetic.Shape.call(this, config);
	            this.className = 'Ring';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            context.beginPath();
	            context.arc(0, 0, this.getInnerRadius(), 0, PIx2, false);
	            context.moveTo(this.getOuterRadius(), 0);
	            context.arc(0, 0, this.getOuterRadius(), PIx2, 0, true);
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        // implements Shape.prototype.getWidth()
	        getWidth: function() {
	            return this.getOuterRadius() * 2;
	        },
	        // implements Shape.prototype.getHeight()
	        getHeight: function() {
	            return this.getOuterRadius() * 2;
	        },
	        // implements Shape.prototype.setWidth()
	        setWidth: function(width) {
	            Kinetic.Node.prototype.setWidth.call(this, width);
	            if (this.outerRadius() !== width / 2) {
	                this.setOuterRadius(width / 2);
	            }
	        },
	        // implements Shape.prototype.setHeight()
	        setHeight: function(height) {
	            Kinetic.Node.prototype.setHeight.call(this, height);
	            if (this.outerRadius() !== height / 2) {
	                this.setOuterRadius(height / 2);
	            }
	        },
	        setOuterRadius : function(val) {
	            this._setAttr('outerRadius', val);
	            this.setWidth(val * 2);
	            this.setHeight(val * 2);
	        }
	    };
	    Kinetic.Util.extend(Kinetic.Ring, Kinetic.Shape);

	    // add getters setters
	    Kinetic.Factory.addGetterSetter(Kinetic.Ring, 'innerRadius', 0);

	    /**
	     * get/set innerRadius
	     * @name innerRadius
	     * @method
	     * @memberof Kinetic.Ring.prototype
	     * @param {Number} innerRadius
	     * @returns {Number}
	     * @example
	     * // get inner radius
	     * var innerRadius = ring.innerRadius();
	     *
	     * // set inner radius
	     * ring.innerRadius(20);
	     */
	     
	    Kinetic.Factory.addGetter(Kinetic.Ring, 'outerRadius', 0);
	    Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Ring, 'outerRadius');

	    /**
	     * get/set outerRadius
	     * @name outerRadius
	     * @method
	     * @memberof Kinetic.Ring.prototype
	     * @param {Number} outerRadius
	     * @returns {Number}
	     * @example
	     * // get outer radius
	     * var outerRadius = ring.outerRadius();
	     *
	     * // set outer radius
	     * ring.outerRadius(20);
	     */

	    Kinetic.Collection.mapMethods(Kinetic.Ring);
	})();
	;(function() {
	    /**
	     * Wedge constructor
	     * @constructor
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {Number} config.angle in degrees
	     * @param {Number} config.radius
	     * @param {Boolean} [config.clockwise]
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * // draw a wedge that's pointing downwards
	     * var wedge = new Kinetic.Wedge({
	     *   radius: 40,
	     *   fill: 'red',
	     *   stroke: 'black'
	     *   strokeWidth: 5,
	     *   angleDeg: 60,
	     *   rotationDeg: -120
	     * });
	     */
	    Kinetic.Wedge = function(config) {
	        this.___init(config);
	    };

	    Kinetic.Wedge.prototype = {
	        ___init: function(config) {
	            // call super constructor
	            Kinetic.Shape.call(this, config);
	            this.className = 'Wedge';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            context.beginPath();
	            context.arc(0, 0, this.getRadius(), 0, Kinetic.getAngle(this.getAngle()), this.getClockwise());
	            context.lineTo(0, 0);
	            context.closePath();
	            context.fillStrokeShape(this);
	        }
	    };
	    Kinetic.Util.extend(Kinetic.Wedge, Kinetic.Shape);

	    // add getters setters
	    Kinetic.Factory.addGetterSetter(Kinetic.Wedge, 'radius', 0);

	    /**
	     * get/set radius
	     * @name radius
	     * @method
	     * @memberof Kinetic.Wedge.prototype
	     * @param {Number} radius
	     * @returns {Number}
	     * @example
	     * // get radius
	     * var radius = wedge.radius();
	     *
	     * // set radius
	     * wedge.radius(10);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Wedge, 'angle', 0);

	    /**
	     * get/set angle in degrees
	     * @name angle
	     * @method
	     * @memberof Kinetic.Wedge.prototype
	     * @param {Number} angle
	     * @returns {Number}
	     * @example
	     * // get angle
	     * var angle = wedge.angle();
	     *
	     * // set angle
	     * wedge.angle(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Wedge, 'clockwise', false);

	    /**
	     * get/set clockwise flag
	     * @name clockwise
	     * @method
	     * @memberof Kinetic.Wedge.prototype
	     * @param {Number} clockwise
	     * @returns {Number}
	     * @example
	     * // get clockwise flag
	     * var clockwise = wedge.clockwise();
	     *
	     * // draw wedge counter-clockwise
	     * wedge.clockwise(false);
	     *
	     * // draw wedge clockwise
	     * wedge.clockwise(true);
	     */

	    Kinetic.Factory.backCompat(Kinetic.Wedge, {
	        angleDeg: 'angle',
	        getAngleDeg: 'getAngle',
	        setAngleDeg: 'setAngle'
	    });

	    Kinetic.Collection.mapMethods(Kinetic.Wedge);
	})();
	;(function() {
	    /**
	     * Arc constructor
	     * @constructor
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {Number} config.angle in degrees
	     * @param {Number} config.innerRadius
	     * @param {Number} config.outerRadius
	     * @param {Boolean} [config.clockwise]
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * // draw a Arc that's pointing downwards
	     * var arc = new Kinetic.Arc({
	     *   innerRadius: 40,
	     *   outerRadius: 80,
	     *   fill: 'red',
	     *   stroke: 'black'
	     *   strokeWidth: 5,
	     *   angle: 60,
	     *   rotationDeg: -120
	     * });
	     */
	    Kinetic.Arc = function(config) {
	        this.___init(config);
	    };

	    Kinetic.Arc.prototype = {
	        ___init: function(config) {
	            // call super constructor
	            Kinetic.Shape.call(this, config);
	            this.className = 'Arc';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var angle = Kinetic.getAngle(this.angle()),
	                clockwise = this.clockwise();

	            context.beginPath();
	            context.arc(0, 0, this.getOuterRadius(), 0, angle, clockwise);
	            context.arc(0, 0, this.getInnerRadius(), angle, 0, !clockwise);
	            context.closePath();
	            context.fillStrokeShape(this);
	        }
	    };
	    Kinetic.Util.extend(Kinetic.Arc, Kinetic.Shape);

	    // add getters setters
	    Kinetic.Factory.addGetterSetter(Kinetic.Arc, 'innerRadius', 0);

	    /**
	     * get/set innerRadius
	     * @name innerRadius
	     * @method
	     * @memberof Kinetic.Arc.prototype
	     * @param {Number} innerRadius
	     * @returns {Number}
	     * @example
	     * // get inner radius
	     * var innerRadius = arc.innerRadius();
	     *
	     * // set inner radius
	     * arc.innerRadius(20);
	     */
	     
	    Kinetic.Factory.addGetterSetter(Kinetic.Arc, 'outerRadius', 0);

	    /**
	     * get/set outerRadius
	     * @name outerRadius
	     * @method
	     * @memberof Kinetic.Arc.prototype
	     * @param {Number} outerRadius
	     * @returns {Number}
	     * @example
	     * // get outer radius
	     * var outerRadius = arc.outerRadius();
	     *
	     * // set outer radius
	     * arc.outerRadius(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Arc, 'angle', 0);

	    /**
	     * get/set angle in degrees
	     * @name angle
	     * @method
	     * @memberof Kinetic.Arc.prototype
	     * @param {Number} angle
	     * @returns {Number}
	     * @example
	     * // get angle
	     * var angle = arc.angle();
	     *
	     * // set angle
	     * arc.angle(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Arc, 'clockwise', false);

	    /**
	     * get/set clockwise flag
	     * @name clockwise
	     * @method
	     * @memberof Kinetic.Arc.prototype
	     * @param {Boolean} clockwise
	     * @returns {Boolean}
	     * @example
	     * // get clockwise flag
	     * var clockwise = arc.clockwise();
	     *
	     * // draw arc counter-clockwise
	     * arc.clockwise(false);
	     *
	     * // draw arc clockwise
	     * arc.clockwise(true);
	     */

	    Kinetic.Collection.mapMethods(Kinetic.Arc);
	})();
	;(function() {

	    // CONSTANTS
	    var IMAGE = 'Image';

	    /**
	     * Image constructor
	     * @constructor
	     * @memberof Kinetic
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {Image} config.image
	     * @param {Object} [config.crop]
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var imageObj = new Image();
	     * imageObj.onload = function() {
	     *   var image = new Kinetic.Image({
	     *     x: 200,
	     *     y: 50,
	     *     image: imageObj,
	     *     width: 100,
	     *     height: 100
	     *   });
	     * };
	     * imageObj.src = '/path/to/image.jpg'
	     */
	    Kinetic.Image = function(config) {
	        this.___init(config);
	    };

	    Kinetic.Image.prototype = {
	        ___init: function(config) {
	            // call super constructor
	            Kinetic.Shape.call(this, config);
	            this.className = IMAGE;
	            this.sceneFunc(this._sceneFunc);
	            this.hitFunc(this._hitFunc);
	        },
	        _useBufferCanvas: function() {
	            return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasStroke() && this.getStage();
	        },
	        _sceneFunc: function(context) {
	            var width = this.getWidth(),
	                height = this.getHeight(),
	                image = this.getImage(),
	                cropWidth, cropHeight, params;

	            if (image) {
	                cropWidth = this.getCropWidth();
	                cropHeight = this.getCropHeight();
	                if (cropWidth && cropHeight) {
	                    params = [image, this.getCropX(), this.getCropY(), cropWidth, cropHeight, 0, 0, width, height];
	                } else {
	                    params = [image, 0, 0, width, height];
	                }
	            }

	            if (this.hasFill() || this.hasStroke() || this.hasShadow()) {
	                context.beginPath();
	                context.rect(0, 0, width, height);
	                context.closePath();
	                context.fillStrokeShape(this);
	            }

	            if (image) {
	                context.drawImage.apply(context, params);
	            }
	        },
	        _hitFunc: function(context) {
	            var width = this.getWidth(),
	                height = this.getHeight();

	            context.beginPath();
	            context.rect(0, 0, width, height);
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        getWidth: function() {
	            var image = this.getImage();
	            return this.attrs.width || (image ? image.width : 0);
	        },
	        getHeight: function() {
	            var image = this.getImage();
	            return this.attrs.height || (image ? image.height : 0);
	        }
	    };
	    Kinetic.Util.extend(Kinetic.Image, Kinetic.Shape);

	    // add getters setters
	    Kinetic.Factory.addGetterSetter(Kinetic.Image, 'image');

	    /**
	     * set image
	     * @name setImage
	     * @method
	     * @memberof Kinetic.Image.prototype
	     * @param {Image} image
	     */

	    /**
	     * get image
	     * @name getImage
	     * @method
	     * @memberof Kinetic.Image.prototype
	     * @returns {Image}
	     */

	    Kinetic.Factory.addComponentsGetterSetter(Kinetic.Image, 'crop', ['x', 'y', 'width', 'height']);
	    /**
	     * get/set crop
	     * @method
	     * @name crop
	     * @memberof Kinetic.Image.prototype
	     * @param {Object} crop 
	     * @param {Number} crop.x
	     * @param {Number} crop.y
	     * @param {Number} crop.width
	     * @param {Number} crop.height
	     * @returns {Object}
	     * @example
	     * // get crop
	     * var crop = image.crop();
	     *
	     * // set crop
	     * image.crop({
	     *   x: 20,
	     *   y: 20,
	     *   width: 20,
	     *   height: 20
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Image, 'cropX', 0);
	    /**
	     * get/set crop x
	     * @method
	     * @name cropX
	     * @memberof Kinetic.Image.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get crop x
	     * var cropX = image.cropX();
	     *
	     * // set crop x
	     * image.cropX(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Image, 'cropY', 0);
	    /**
	     * get/set crop y
	     * @name cropY
	     * @method
	     * @memberof Kinetic.Image.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get crop y
	     * var cropY = image.cropY();
	     *
	     * // set crop y
	     * image.cropY(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Image, 'cropWidth', 0);
	    /**
	     * get/set crop width
	     * @name cropWidth
	     * @method
	     * @memberof Kinetic.Image.prototype
	     * @param {Number} width
	     * @returns {Number}
	     * @example
	     * // get crop width
	     * var cropWidth = image.cropWidth();
	     *
	     * // set crop width
	     * image.cropWidth(20);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Image, 'cropHeight', 0);
	    /**
	     * get/set crop height
	     * @name cropHeight
	     * @method
	     * @memberof Kinetic.Image.prototype
	     * @param {Number} height
	     * @returns {Number}
	     * @example
	     * // get crop height
	     * var cropHeight = image.cropHeight();
	     *
	     * // set crop height
	     * image.cropHeight(20);
	     */

	    Kinetic.Collection.mapMethods(Kinetic.Image);
	})();
	;(function() {
	    // constants
	    var AUTO = 'auto',
	        //CANVAS = 'canvas',
	        CENTER = 'center',
	        CHANGE_KINETIC = 'Change.kinetic',
	        CONTEXT_2D = '2d',
	        DASH = '-',
	        EMPTY_STRING = '',
	        LEFT = 'left',
	        TEXT = 'text',
	        TEXT_UPPER = 'Text',
	        MIDDLE = 'middle',
	        NORMAL = 'normal',
	        PX_SPACE = 'px ',
	        SPACE = ' ',
	        RIGHT = 'right',
	        WORD = 'word',
	        CHAR = 'char',
	        NONE = 'none',
	        ATTR_CHANGE_LIST = ['fontFamily', 'fontSize', 'fontStyle', 'fontVariant', 'padding', 'align', 'lineHeight', 'text', 'width', 'height', 'wrap'],

	        // cached variables
	        attrChangeListLen = ATTR_CHANGE_LIST.length,
	        dummyContext = Kinetic.Util.createCanvasElement().getContext(CONTEXT_2D);

	    /**
	     * Text constructor
	     * @constructor
	     * @memberof Kinetic
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {String} [config.fontFamily] default is Arial
	     * @param {Number} [config.fontSize] in pixels.  Default is 12
	     * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
	     * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
	     * @param {String} config.text
	     * @param {String} [config.align] can be left, center, or right
	     * @param {Number} [config.padding]
	     * @param {Number} [config.width] default is auto
	     * @param {Number} [config.height] default is auto
	     * @param {Number} [config.lineHeight] default is 1
	     * @param {String} [config.wrap] can be word, char, or none. Default is word
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var text = new Kinetic.Text({
	     *   x: 10,
	     *   y: 15,
	     *   text: 'Simple Text',
	     *   fontSize: 30,
	     *   fontFamily: 'Calibri',
	     *   fill: 'green'
	     * });
	     */
	    Kinetic.Text = function(config) {
	        this.___init(config);
	    };
	    function _fillFunc(context) {
	        context.fillText(this.partialText, 0, 0);
	    }
	    function _strokeFunc(context) {
	        context.strokeText(this.partialText, 0, 0);
	    }

	    Kinetic.Text.prototype = {
	        ___init: function(config) {
	            config = config || {};
	            config.fill = config.fill || 'black';

	            if (config.width === undefined) {
	                config.width = AUTO;
	            }
	            if (config.height === undefined) {
	                config.height = AUTO;
	            }

	            // call super constructor
	            Kinetic.Shape.call(this, config);

	            this._fillFunc = _fillFunc;
	            this._strokeFunc = _strokeFunc;
	            this.className = TEXT_UPPER;

	            // update text data for certain attr changes
	            for(var n = 0; n < attrChangeListLen; n++) {
	                this.on(ATTR_CHANGE_LIST[n] + CHANGE_KINETIC, this._setTextData);
	            }

	            this._setTextData();
	            this.sceneFunc(this._sceneFunc);
	            this.hitFunc(this._hitFunc);
	        },
	        _sceneFunc: function(context) {
	            var p = this.getPadding(),
	                textHeight = this.getTextHeight(),
	                lineHeightPx = this.getLineHeight() * textHeight,
	                textArr = this.textArr,
	                textArrLen = textArr.length,
	                totalWidth = this.getWidth(),
	                n;

	            context.setAttr('font', this._getContextFont());
	            context.setAttr('textBaseline', MIDDLE);
	            context.setAttr('textAlign', LEFT);
	            context.save();
	            context.translate(p, 0);
	            context.translate(0, p + textHeight / 2);

	            // draw text lines
	            for(n = 0; n < textArrLen; n++) {
	                var obj = textArr[n],
	                    text = obj.text,
	                    width = obj.width;

	                // horizontal alignment
	                context.save();
	                if(this.getAlign() === RIGHT) {
	                    context.translate(totalWidth - width - p * 2, 0);
	                }
	                else if(this.getAlign() === CENTER) {
	                    context.translate((totalWidth - width - p * 2) / 2, 0);
	                }

	                this.partialText = text;
	                context.fillStrokeShape(this);
	                context.restore();
	                context.translate(0, lineHeightPx);
	            }
	            context.restore();
	        },
	        _hitFunc: function(context) {
	            var width = this.getWidth(),
	                height = this.getHeight();

	            context.beginPath();
	            context.rect(0, 0, width, height);
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        setText: function(text) {
	            var str = Kinetic.Util._isString(text) ? text : text.toString();
	            this._setAttr(TEXT, str);
	            return this;
	        },
	        /**
	         * get width of text area, which includes padding
	         * @method
	         * @memberof Kinetic.Text.prototype
	         * @returns {Number}
	         */
	        getWidth: function() {
	            return this.attrs.width === AUTO ? this.getTextWidth() + this.getPadding() * 2 : this.attrs.width;
	        },
	        /**
	         * get the height of the text area, which takes into account multi-line text, line heights, and padding
	         * @method
	         * @memberof Kinetic.Text.prototype
	         * @returns {Number}
	         */
	        getHeight: function() {
	            return this.attrs.height === AUTO ? (this.getTextHeight() * this.textArr.length * this.getLineHeight()) + this.getPadding() * 2 : this.attrs.height;
	        },
	        /**
	         * get text width
	         * @method
	         * @memberof Kinetic.Text.prototype
	         * @returns {Number}
	         */
	        getTextWidth: function() {
	            return this.textWidth;
	        },
	        /**
	         * get text height
	         * @method
	         * @memberof Kinetic.Text.prototype
	         * @returns {Number}
	         */
	        getTextHeight: function() {
	            return this.textHeight;
	        },
	        _getTextSize: function(text) {
	            var _context = dummyContext,
	                fontSize = this.getFontSize(),
	                metrics;

	            _context.save();
	            _context.font = this._getContextFont();

	            metrics = _context.measureText(text);
	            _context.restore();
	            return {
	                width: metrics.width,
	                height: parseInt(fontSize, 10)
	            };
	        },
	        _getContextFont: function() {
	            return this.getFontStyle() + SPACE + this.getFontVariant() + SPACE + this.getFontSize() + PX_SPACE + this.getFontFamily();
	        },
	        _addTextLine: function (line, width) {
	            return this.textArr.push({text: line, width: width});
	        },
	        _getTextWidth: function (text) {
	            return dummyContext.measureText(text).width;
	        },
	        _setTextData: function () {
	            var lines = this.getText().split('\n'),
	                fontSize = +this.getFontSize(),
	                textWidth = 0,
	                lineHeightPx = this.getLineHeight() * fontSize,
	                width = this.attrs.width,
	                height = this.attrs.height,
	                fixedWidth = width !== AUTO,
	                fixedHeight = height !== AUTO,
	                padding = this.getPadding(),
	                maxWidth = width - padding * 2,
	                maxHeightPx = height - padding * 2,
	                currentHeightPx = 0,
	                wrap = this.getWrap(),
	                shouldWrap = wrap !== NONE,
	                wrapAtWord = wrap !==  CHAR && shouldWrap;

	            this.textArr = [];
	            dummyContext.save();
	            dummyContext.font = this._getContextFont();
	            for (var i = 0, max = lines.length; i < max; ++i) {
	                var line = lines[i],
	                    lineWidth = this._getTextWidth(line);
	                if (fixedWidth && lineWidth > maxWidth) {
	                    /*
	                     * if width is fixed and line does not fit entirely
	                     * break the line into multiple fitting lines
	                     */
	                    while (line.length > 0) {
	                        /*
	                         * use binary search to find the longest substring that
	                         * that would fit in the specified width
	                         */
	                        var low = 0, high = line.length,
	                            match = '', matchWidth = 0;
	                        while (low < high) {
	                            var mid = (low + high) >>> 1,
	                                substr = line.slice(0, mid + 1),
	                                substrWidth = this._getTextWidth(substr);
	                            if (substrWidth <= maxWidth) {
	                                low = mid + 1;
	                                match = substr;
	                                matchWidth = substrWidth;
	                            } else {
	                                high = mid;
	                            }
	                        }
	                        /*
	                         * 'low' is now the index of the substring end
	                         * 'match' is the substring
	                         * 'matchWidth' is the substring width in px
	                         */
	                        if (match) {
	                            // a fitting substring was found
	                            if (wrapAtWord) {
	                                // try to find a space or dash where wrapping could be done
	                                var wrapIndex = Math.max(match.lastIndexOf(SPACE),
	                                                          match.lastIndexOf(DASH)) + 1;
	                                if (wrapIndex > 0) {
	                                    // re-cut the substring found at the space/dash position
	                                    low = wrapIndex;
	                                    match = match.slice(0, low);
	                                    matchWidth = this._getTextWidth(match);
	                                }
	                            }
	                            this._addTextLine(match, matchWidth);
	                            textWidth = Math.max(textWidth, matchWidth);
	                            currentHeightPx += lineHeightPx;
	                            if (!shouldWrap ||
	                                (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx)) {
	                                /*
	                                 * stop wrapping if wrapping is disabled or if adding
	                                 * one more line would overflow the fixed height
	                                 */
	                                break;
	                            }
	                            line = line.slice(low);
	                            if (line.length > 0) {
	                                // Check if the remaining text would fit on one line
	                                lineWidth = this._getTextWidth(line);
	                                if (lineWidth <= maxWidth) {
	                                    // if it does, add the line and break out of the loop
	                                    this._addTextLine(line, lineWidth);
	                                    currentHeightPx += lineHeightPx;
	                                    textWidth = Math.max(textWidth, lineWidth);
	                                    break;
	                                }
	                            }
	                        } else {
	                            // not even one character could fit in the element, abort
	                            break;
	                        }
	                    }
	                } else {
	                    // element width is automatically adjusted to max line width
	                    this._addTextLine(line, lineWidth);
	                    currentHeightPx += lineHeightPx;
	                    textWidth = Math.max(textWidth, lineWidth);
	                }
	                // if element height is fixed, abort if adding one more line would overflow
	                if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
	                    break;
	                }
	            }
	            dummyContext.restore();
	            this.textHeight = fontSize;
	            this.textWidth = textWidth;
	        }
	    };
	    Kinetic.Util.extend(Kinetic.Text, Kinetic.Shape);

	    // add getters setters
	    Kinetic.Factory.addGetterSetter(Kinetic.Text, 'fontFamily', 'Arial');

	    /**
	     * get/set font family
	     * @name fontFamily
	     * @method
	     * @memberof Kinetic.Text.prototype
	     * @param {String} fontFamily
	     * @returns {String}
	     * @example
	     * // get font family
	     * var fontFamily = text.fontFamily();
	     *
	     * // set font family
	     * text.fontFamily('Arial');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Text, 'fontSize', 12);

	    /**
	     * get/set font size in pixels
	     * @name fontSize
	     * @method
	     * @memberof Kinetic.Text.prototype
	     * @param {Number} fontSize
	     * @returns {Number}
	     * @example
	     * // get font size
	     * var fontSize = text.fontSize();
	     *
	     * // set font size to 22px
	     * text.fontSize(22);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Text, 'fontStyle', NORMAL);

	    /**
	     * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
	     * @name fontStyle
	     * @method
	     * @memberof Kinetic.Text.prototype
	     * @param {String} fontStyle
	     * @returns {String}
	     * @example
	     * // get font style
	     * var fontStyle = text.fontStyle();
	     *
	     * // set font style
	     * text.fontStyle('bold');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Text, 'fontVariant', NORMAL);

	    /**
	     * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
	     * @name fontVariant
	     * @method
	     * @memberof Kinetic.Text.prototype
	     * @param {String} fontVariant
	     * @returns {String}
	     * @example
	     * // get font variant
	     * var fontVariant = text.fontVariant();
	     *
	     * // set font variant
	     * text.fontVariant('small-caps');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Text, 'padding', 0);

	    /**
	     * set padding
	     * @name padding
	     * @method
	     * @memberof Kinetic.Text.prototype
	     * @param {Number} padding
	     * @returns {Number}
	     * @example
	     * // get padding
	     * var padding = text.padding();
	     * 
	     * // set padding to 10 pixels
	     * text.padding(10);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Text, 'align', LEFT);

	    /**
	     * get/set horizontal align of text.  Can be 'left', 'center', or 'right'
	     * @name align
	     * @method
	     * @memberof Kinetic.Text.prototype
	     * @param {String} align
	     * @returns {String}
	     * @example
	     * // get text align
	     * var align = text.align();
	     *
	     * // center text
	     * text.align('center');
	     *
	     * // align text to right
	     * text.align('right');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Text, 'lineHeight', 1);

	    /**
	     * get/set line height.  The default is 1.
	     * @name lineHeight
	     * @method
	     * @memberof Kinetic.Text.prototype
	     * @param {Number} lineHeight
	     * @returns {Number}
	     * @example 
	     * // get line height
	     * var lineHeight = text.lineHeight();
	     *
	     * // set the line height
	     * text.lineHeight(2);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Text, 'wrap', WORD);

	    /**
	     * get/set wrap.  Can be word, char, or none. Default is word.
	     * @name wrap
	     * @method
	     * @memberof Kinetic.Text.prototype
	     * @param {String} wrap
	     * @returns {String}
	     * @example
	     * // get wrap
	     * var wrap = text.wrap();
	     *
	     * // set wrap
	     * text.wrap('word');
	     */

	    Kinetic.Factory.addGetter(Kinetic.Text, 'text', EMPTY_STRING);
	    Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Text, 'text');

	    /**
	     * get/set text
	     * @name getText
	     * @method
	     * @memberof Kinetic.Text.prototype
	     * @param {String} text
	     * @returns {String}
	     * @example
	     * // get text
	     * var text = text.text();
	     * 
	     * // set text
	     * text.text('Hello world!');
	     */

	    Kinetic.Collection.mapMethods(Kinetic.Text);
	})();
	;(function() {
	    /**
	     * Line constructor.&nbsp; Lines are defined by an array of points and
	     *  a tension
	     * @constructor
	     * @memberof Kinetic
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {Array} config.points
	     * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
	     *   The default is 0
	     * @param {Boolean} [config.closed] defines whether or not the line shape is closed, creating a polygon or blob 
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var line = new Kinetic.Line({
	     *   x: 100,
	     *   y: 50,
	     *   points: [73, 70, 340, 23, 450, 60, 500, 20],
	     *   stroke: 'red',
	     *   tension: 1
	     * });
	     */
	    Kinetic.Line = function(config) {
	        this.___init(config);
	    };

	    Kinetic.Line.prototype = {
	        ___init: function(config) {
	            // call super constructor
	            Kinetic.Shape.call(this, config);
	            this.className = 'Line';

	            this.on('pointsChange.kinetic tensionChange.kinetic closedChange.kinetic', function() {
	                this._clearCache('tensionPoints');
	            });

	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var points = this.getPoints(),
	                length = points.length,
	                tension = this.getTension(),
	                closed = this.getClosed(),
	                tp, len, n;

	            if (!length) {
	                return;
	            }

	            context.beginPath();
	            context.moveTo(points[0], points[1]);

	            // tension
	            if(tension !== 0 && length > 4) {
	                tp = this.getTensionPoints();
	                len = tp.length;
	                n = closed ? 0 : 4;

	                if (!closed) {
	                    context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
	                }

	                while(n < len - 2) {
	                    context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
	                }

	                if (!closed) {
	                    context.quadraticCurveTo(tp[len-2], tp[len-1], points[length-2], points[length-1]);
	                }
	            }
	            // no tension
	            else {
	                for(n = 2; n < length; n+=2) {
	                    context.lineTo(points[n], points[n+1]);
	                }
	            }

	            // closed e.g. polygons and blobs
	            if (closed) {
	                context.closePath();
	                context.fillStrokeShape(this);
	            }
	            // open e.g. lines and splines
	            else {
	                context.strokeShape(this);
	            }
	        },
	        getTensionPoints: function() {
	            return this._getCache('tensionPoints', this._getTensionPoints);
	        },
	        _getTensionPoints: function() {
	            if (this.getClosed()) {
	                return this._getTensionPointsClosed();
	            }
	            else {
	                return Kinetic.Util._expandPoints(this.getPoints(), this.getTension());
	            }
	        },
	        _getTensionPointsClosed: function() {
	            var p = this.getPoints(),
	                len = p.length,
	                tension = this.getTension(),
	                util = Kinetic.Util,
	                firstControlPoints = util._getControlPoints(
	                    p[len-2],
	                    p[len-1],
	                    p[0],
	                    p[1],
	                    p[2],
	                    p[3],
	                    tension
	                ),
	                lastControlPoints = util._getControlPoints(
	                    p[len-4],
	                    p[len-3],
	                    p[len-2],
	                    p[len-1],
	                    p[0],
	                    p[1],
	                    tension
	                ),
	                middle = Kinetic.Util._expandPoints(p, tension),
	                tp = [
	                    firstControlPoints[2],
	                    firstControlPoints[3]
	                ]
	                .concat(middle)
	                .concat([
	                    lastControlPoints[0],
	                    lastControlPoints[1],
	                    p[len-2],
	                    p[len-1],
	                    lastControlPoints[2],
	                    lastControlPoints[3],
	                    firstControlPoints[0],
	                    firstControlPoints[1],
	                    p[0],
	                    p[1]
	                ]);
	                    
	            return tp;
	        }
	    };
	    Kinetic.Util.extend(Kinetic.Line, Kinetic.Shape);

	    // add getters setters
	    Kinetic.Factory.addGetterSetter(Kinetic.Line, 'closed', false);

	    /**
	     * get/set closed flag.  The default is false
	     * @name closed
	     * @method
	     * @memberof Kinetic.Line.prototype
	     * @param {Boolean} closed
	     * @returns {Boolean}
	     * @example
	     * // get closed flag
	     * var closed = line.closed();
	     *
	     * // close the shape
	     * line.closed(true);
	     *
	     * // open the shape
	     * line.closed(false);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Line, 'tension', 0);

	    /**
	     * get/set tension
	     * @name tension
	     * @method
	     * @memberof Kinetic.Line.prototype
	     * @param {Number} Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
	     *   The default is 0
	     * @returns {Number}
	     * @example
	     * // get tension
	     * var tension = line.tension();
	     *
	     * // set tension
	     * line.tension(3);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Line, 'points', []);
	    /**
	     * get/set points array
	     * @name points
	     * @method
	     * @memberof Kinetic.Line.prototype
	     * @param {Array} points
	     * @returns {Array}
	     * @example
	     * // get points
	     * var points = line.points();
	     *
	     * // set points
	     * line.points([10, 20, 30, 40, 50, 60]);
	     *
	     * // push a new point
	     * line.points(line.points().concat([70, 80]));
	     */

	    Kinetic.Collection.mapMethods(Kinetic.Line);
	})();;(function() {
	    /**
	     * Sprite constructor
	     * @constructor
	     * @memberof Kinetic
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {String} config.animation animation key
	     * @param {Object} config.animations animation map
	     * @param {Integer} [config.frameIndex] animation frame index
	     * @param {Image} config.image image object
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var imageObj = new Image();
	     * imageObj.onload = function() {
	     *   var sprite = new Kinetic.Sprite({
	     *     x: 200,
	     *     y: 100,
	     *     image: imageObj,
	     *     animation: 'standing',
	     *     animations: {
	     *       standing: [
	     *         // x, y, width, height (6 frames)
	     *         0, 0, 49, 109,
	     *         52, 0, 49, 109,
	     *         105, 0, 49, 109,
	     *         158, 0, 49, 109,
	     *         210, 0, 49, 109,
	     *         262, 0, 49, 109
	     *       ],
	     *       kicking: [
	     *         // x, y, width, height (6 frames)
	     *         0, 109, 45, 98,
	     *         45, 109, 45, 98,
	     *         95, 109, 63, 98,
	     *         156, 109, 70, 98,
	     *         229, 109, 60, 98,
	     *         287, 109, 41, 98
	     *       ]          
	     *     },
	     *     frameRate: 7,
	     *     frameIndex: 0
	     *   });
	     * };
	     * imageObj.src = '/path/to/image.jpg'
	     */
	    Kinetic.Sprite = function(config) {
	        this.___init(config);
	    };

	    Kinetic.Sprite.prototype = {
	        ___init: function(config) {
	            // call super constructor
	            Kinetic.Shape.call(this, config);
	            this.className = 'Sprite';

	            this._updated = true;
	            var that = this;
	            this.anim = new Kinetic.Animation(function() {
	                // if we don't need to redraw layer we should return false
	                var updated = that._updated;
	                that._updated = false;
	                return updated;
	            });
	            this.on('animationChange.kinetic', function() {
	                // reset index when animation changes
	                this.frameIndex(0);
	            });
	            this.on('frameIndexChange.kinetic', function() {
	                this._updated = true;
	            });
	            // smooth change for frameRate
	            this.on('frameRateChange.kinetic', function() {
	                if (!this.anim.isRunning()) {
	                    return;
	                }
	                clearInterval(this.interval);
	                this._setInterval();
	            });

	            this.sceneFunc(this._sceneFunc);
	            this.hitFunc(this._hitFunc);
	        },
	        _sceneFunc: function(context) {
	            var anim = this.getAnimation(),
	                index = this.frameIndex(),
	                ix4 = index * 4,
	                set = this.getAnimations()[anim],
	                offsets = this.frameOffsets(),
	                x =      set[ix4 + 0],
	                y =      set[ix4 + 1],
	                width =  set[ix4 + 2],
	                height = set[ix4 + 3],
	                image = this.getImage();

	            if(image) {
	                if (offsets) {
	                    var offset = offsets[anim],
	                    ix2 = index * 2;
	                    context.drawImage(image, x, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);
	                } else {
	                    context.drawImage(image, x, y, width, height, 0, 0, width, height);
	                }
	            }
	        },
	        _hitFunc: function(context) {
	            var anim = this.getAnimation(),
	                index = this.frameIndex(),
	                ix4 = index * 4,
	                set = this.getAnimations()[anim],
	                offsets = this.frameOffsets(),
	                width =  set[ix4 + 2],
	                height = set[ix4 + 3];

	            context.beginPath();
	            if (offsets) {
	                var offset = offsets[anim];
	                var ix2 = index * 2;
	                context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
	            } else {
	                context.rect(0, 0, width, height);
	            }
	            context.closePath();
	            context.fillShape(this);
	        },
	        _useBufferCanvas: function() {
	            return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasStroke();
	        },
	        _setInterval: function() {
	            var that = this;
	            this.interval = setInterval(function() {
	                that._updateIndex();
	            }, 1000 / this.getFrameRate());
	        },
	        /**
	         * start sprite animation
	         * @method
	         * @memberof Kinetic.Sprite.prototype
	         */
	        start: function() {
	            var layer = this.getLayer();

	            /*
	             * animation object has no executable function because
	             *  the updates are done with a fixed FPS with the setInterval
	             *  below.  The anim object only needs the layer reference for
	             *  redraw
	             */
	            this.anim.setLayers(layer);
	            this._setInterval();
	            this.anim.start();
	        },
	        /**
	         * stop sprite animation
	         * @method
	         * @memberof Kinetic.Sprite.prototype
	         */
	        stop: function() {
	            this.anim.stop();
	            clearInterval(this.interval);
	        },
	        /**
	         * determine if animation of sprite is running or not.  returns true or false
	         * @method
	         * @memberof Kinetic.Animation.prototype
	         * @returns {Boolean}
	         */
	        isRunning: function() {
	            return this.anim.isRunning();
	        },
	        _updateIndex: function() {
	            var index = this.frameIndex(),
	                animation = this.getAnimation(),
	                animations = this.getAnimations(),
	                anim = animations[animation],
	                len = anim.length / 4;

	            if(index < len - 1) {
	                this.frameIndex(index + 1);
	            }
	            else {
	                this.frameIndex(0);
	            }
	        }
	    };
	    Kinetic.Util.extend(Kinetic.Sprite, Kinetic.Shape);

	    // add getters setters
	    Kinetic.Factory.addGetterSetter(Kinetic.Sprite, 'animation');

	    /**
	     * get/set animation key
	     * @name animation
	     * @method
	     * @memberof Kinetic.Sprite.prototype
	     * @param {String} anim animation key
	     * @returns {String}
	     * @example
	     * // get animation key
	     * var animation = sprite.animation();
	     *
	     * // set animation key
	     * sprite.animation('kicking');
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Sprite, 'animations');

	    /**
	     * get/set animations map
	     * @name animations
	     * @method
	     * @memberof Kinetic.Sprite.prototype
	     * @param {Object} animations
	     * @returns {Object}
	     * @example
	     * // get animations map
	     * var animations = sprite.animations();
	     * 
	     * // set animations map
	     * sprite.animations({
	     *   standing: [
	     *     // x, y, width, height (6 frames)
	     *     0, 0, 49, 109,
	     *     52, 0, 49, 109,
	     *     105, 0, 49, 109,
	     *     158, 0, 49, 109,
	     *     210, 0, 49, 109,
	     *     262, 0, 49, 109
	     *   ],
	     *   kicking: [
	     *     // x, y, width, height (6 frames)
	     *     0, 109, 45, 98,
	     *     45, 109, 45, 98,
	     *     95, 109, 63, 98,
	     *     156, 109, 70, 98,
	     *     229, 109, 60, 98,
	     *     287, 109, 41, 98
	     *   ]          
	     * });
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Sprite, 'frameOffsets');

	    /**
	    * get/set offsets map
	    * @name offsets
	    * @method
	    * @memberof Kinetic.Sprite.prototype
	    * @param {Object} offsets
	    * @returns {Object}
	    * @example
	    * // get offsets map
	    * var offsets = sprite.offsets();
	    *
	    * // set offsets map
	    * sprite.offsets({
	    *   standing: [
	    *     // x, y (6 frames)
	    *     0, 0,
	    *     0, 0,
	    *     5, 0,
	    *     0, 0,
	    *     0, 3,
	    *     2, 0
	    *   ],
	    *   kicking: [
	    *     // x, y (6 frames)
	    *     0, 5,
	    *     5, 0,
	    *     10, 0,
	    *     0, 0,
	    *     2, 1,
	    *     0, 0
	    *   ]
	    * });
	    */
	 
	    Kinetic.Factory.addGetterSetter(Kinetic.Sprite, 'image');

	    /**
	     * get/set image
	     * @name image
	     * @method
	     * @memberof Kinetic.Sprite.prototype
	     * @param {Image} image
	     * @returns {Image}
	     * @example
	     * // get image
	     * var image = sprite.image();
	     *
	     * // set image
	     * sprite.image(imageObj);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Sprite, 'frameIndex', 0);

	    /**
	     * set/set animation frame index
	     * @name frameIndex
	     * @method
	     * @memberof Kinetic.Sprite.prototype
	     * @param {Integer} frameIndex
	     * @returns {Integer}
	     * @example
	     * // get animation frame index
	     * var frameIndex = sprite.frameIndex();
	     *
	     * // set animation frame index
	     * sprite.frameIndex(3);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Sprite, 'frameRate', 17);

	    /**
	     * get/set frame rate in frames per second.  Increase this number to make the sprite
	     *  animation run faster, and decrease the number to make the sprite animation run slower
	     *  The default is 17 frames per second
	     * @name frameRate
	     * @method
	     * @memberof Kinetic.Sprite.prototype
	     * @param {Integer} frameRate
	     * @returns {Integer}
	     * @example
	     * // get frame rate
	     * var frameRate = sprite.frameRate();
	     *
	     * // set frame rate to 2 frames per second
	     * sprite.frameRate(2);
	     */

	    Kinetic.Factory.backCompat(Kinetic.Sprite, {
	        index: 'frameIndex',
	        getIndex: 'getFrameIndex',
	        setIndex: 'setFrameIndex'
	    });

	    Kinetic.Collection.mapMethods(Kinetic.Sprite);
	})();
	;(function () {
	    /**
	     * Path constructor.
	     * @author Jason Follas
	     * @constructor
	     * @memberof Kinetic
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {String} config.data SVG data string
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var path = new Kinetic.Path({
	     *   x: 240,
	     *   y: 40,
	     *   data: 'M12.582,9.551C3.251,16.237,0.921,29.021,7.08,38.564l-2.36,1.689l4.893,2.262l4.893,2.262l-0.568-5.36l-0.567-5.359l-2.365,1.694c-4.657-7.375-2.83-17.185,4.352-22.33c7.451-5.338,17.817-3.625,23.156,3.824c5.337,7.449,3.625,17.813-3.821,23.152l2.857,3.988c9.617-6.893,11.827-20.277,4.935-29.896C35.591,4.87,22.204,2.658,12.582,9.551z',
	     *   fill: 'green',
	     *   scale: 2
	     * });
	     */
	    Kinetic.Path = function (config) {
	        this.___init(config);
	    };

	    Kinetic.Path.prototype = {
	        ___init: function (config) {
	            this.dataArray = [];
	            var that = this;

	            // call super constructor
	            Kinetic.Shape.call(this, config);
	            this.className = 'Path';

	            this.dataArray = Kinetic.Path.parsePathData(this.getData());
	            this.on('dataChange.kinetic', function () {
	                that.dataArray = Kinetic.Path.parsePathData(this.getData());
	            });

	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var ca = this.dataArray,
	                closedPath = false;

	            // context position
	            context.beginPath();
	            for (var n = 0; n < ca.length; n++) {
	                var c = ca[n].command;
	                var p = ca[n].points;
	                switch (c) {
	                    case 'L':
	                        context.lineTo(p[0], p[1]);
	                        break;
	                    case 'M':
	                        context.moveTo(p[0], p[1]);
	                        break;
	                    case 'C':
	                        context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
	                        break;
	                    case 'Q':
	                        context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
	                        break;
	                    case 'A':
	                        var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7];

	                        var r = (rx > ry) ? rx : ry;
	                        var scaleX = (rx > ry) ? 1 : rx / ry;
	                        var scaleY = (rx > ry) ? ry / rx : 1;

	                        context.translate(cx, cy);
	                        context.rotate(psi);
	                        context.scale(scaleX, scaleY);
	                        context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
	                        context.scale(1 / scaleX, 1 / scaleY);
	                        context.rotate(-psi);
	                        context.translate(-cx, -cy);

	                        break;
	                    case 'z':
	                        context.closePath();
	                        closedPath = true;
	                        break;
	                }
	            }

	            if (closedPath) {
	                context.fillStrokeShape(this);
	            }
	            else {
	                context.strokeShape(this);
	            }
	        }
	    };
	    Kinetic.Util.extend(Kinetic.Path, Kinetic.Shape);

	    Kinetic.Path.getLineLength = function(x1, y1, x2, y2) {
	        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	    };
	    Kinetic.Path.getPointOnLine = function(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
	        if(fromX === undefined) {
	            fromX = P1x;
	        }
	        if(fromY === undefined) {
	            fromY = P1y;
	        }

	        var m = (P2y - P1y) / ((P2x - P1x) + 0.00000001);
	        var run = Math.sqrt(dist * dist / (1 + m * m));
	        if(P2x < P1x) {
	            run *= -1;
	        }
	        var rise = m * run;
	        var pt;

	        if (P2x === P1x) { // vertical line
	            pt = {
	                x: fromX,
	                y: fromY + rise
	            };
	        } else if((fromY - P1y) / ((fromX - P1x) + 0.00000001) === m) {
	            pt = {
	                x: fromX + run,
	                y: fromY + rise
	            };
	        }
	        else {
	            var ix, iy;

	            var len = this.getLineLength(P1x, P1y, P2x, P2y);
	            if(len < 0.00000001) {
	                return undefined;
	            }
	            var u = (((fromX - P1x) * (P2x - P1x)) + ((fromY - P1y) * (P2y - P1y)));
	            u = u / (len * len);
	            ix = P1x + u * (P2x - P1x);
	            iy = P1y + u * (P2y - P1y);

	            var pRise = this.getLineLength(fromX, fromY, ix, iy);
	            var pRun = Math.sqrt(dist * dist - pRise * pRise);
	            run = Math.sqrt(pRun * pRun / (1 + m * m));
	            if(P2x < P1x) {
	                run *= -1;
	            }
	            rise = m * run;
	            pt = {
	                x: ix + run,
	                y: iy + rise
	            };
	        }

	        return pt;
	    };

	    Kinetic.Path.getPointOnCubicBezier = function(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
	        function CB1(t) {
	            return t * t * t;
	        }
	        function CB2(t) {
	            return 3 * t * t * (1 - t);
	        }
	        function CB3(t) {
	            return 3 * t * (1 - t) * (1 - t);
	        }
	        function CB4(t) {
	            return (1 - t) * (1 - t) * (1 - t);
	        }
	        var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
	        var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);

	        return {
	            x: x,
	            y: y
	        };
	    };
	    Kinetic.Path.getPointOnQuadraticBezier = function(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
	        function QB1(t) {
	            return t * t;
	        }
	        function QB2(t) {
	            return 2 * t * (1 - t);
	        }
	        function QB3(t) {
	            return (1 - t) * (1 - t);
	        }
	        var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
	        var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);

	        return {
	            x: x,
	            y: y
	        };
	    };
	    Kinetic.Path.getPointOnEllipticalArc = function(cx, cy, rx, ry, theta, psi) {
	        var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);
	        var pt = {
	            x: rx * Math.cos(theta),
	            y: ry * Math.sin(theta)
	        };
	        return {
	            x: cx + (pt.x * cosPsi - pt.y * sinPsi),
	            y: cy + (pt.x * sinPsi + pt.y * cosPsi)
	        };
	    };
	    /*
	     * get parsed data array from the data
	     *  string.  V, v, H, h, and l data are converted to
	     *  L data for the purpose of high performance Path
	     *  rendering
	     */
	    Kinetic.Path.parsePathData = function(data) {
	        // Path Data Segment must begin with a moveTo
	        //m (x y)+  Relative moveTo (subsequent points are treated as lineTo)
	        //M (x y)+  Absolute moveTo (subsequent points are treated as lineTo)
	        //l (x y)+  Relative lineTo
	        //L (x y)+  Absolute LineTo
	        //h (x)+    Relative horizontal lineTo
	        //H (x)+    Absolute horizontal lineTo
	        //v (y)+    Relative vertical lineTo
	        //V (y)+    Absolute vertical lineTo
	        //z (closepath)
	        //Z (closepath)
	        //c (x1 y1 x2 y2 x y)+ Relative Bezier curve
	        //C (x1 y1 x2 y2 x y)+ Absolute Bezier curve
	        //q (x1 y1 x y)+       Relative Quadratic Bezier
	        //Q (x1 y1 x y)+       Absolute Quadratic Bezier
	        //t (x y)+    Shorthand/Smooth Relative Quadratic Bezier
	        //T (x y)+    Shorthand/Smooth Absolute Quadratic Bezier
	        //s (x2 y2 x y)+       Shorthand/Smooth Relative Bezier curve
	        //S (x2 y2 x y)+       Shorthand/Smooth Absolute Bezier curve
	        //a (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+     Relative Elliptical Arc
	        //A (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+  Absolute Elliptical Arc

	        // return early if data is not defined
	        if(!data) {
	            return [];
	        }

	        // command string
	        var cs = data;

	        // command chars
	        var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
	        // convert white spaces to commas
	        cs = cs.replace(new RegExp(' ', 'g'), ',');
	        // create pipes so that we can split the data
	        for(var n = 0; n < cc.length; n++) {
	            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	        }
	        // create array
	        var arr = cs.split('|');
	        var ca = [];
	        // init context point
	        var cpx = 0;
	        var cpy = 0;
	        for( n = 1; n < arr.length; n++) {
	            var str = arr[n];
	            var c = str.charAt(0);
	            str = str.slice(1);
	            // remove ,- for consistency
	            str = str.replace(new RegExp(',-', 'g'), '-');
	            // add commas so that it's easy to split
	            str = str.replace(new RegExp('-', 'g'), ',-');
	            str = str.replace(new RegExp('e,-', 'g'), 'e-');
	            var p = str.split(',');
	            if(p.length > 0 && p[0] === '') {
	                p.shift();
	            }
	            // convert strings to floats
	            for(var i = 0; i < p.length; i++) {
	                p[i] = parseFloat(p[i]);
	            }
	            while(p.length > 0) {
	                if(isNaN(p[0])) {// case for a trailing comma before next command
	                    break;
	                }

	                var cmd = null;
	                var points = [];
	                var startX = cpx, startY = cpy;
	                // Move var from within the switch to up here (jshint)
	                var prevCmd, ctlPtx, ctlPty;     // Ss, Tt
	                var rx, ry, psi, fa, fs, x1, y1; // Aa


	                // convert l, H, h, V, and v to L
	                switch (c) {

	                    // Note: Keep the lineTo's above the moveTo's in this switch
	                    case 'l':
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'L':
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        points.push(cpx, cpy);
	                        break;

	                    // Note: lineTo handlers need to be above this point
	                    case 'm':
	                        var dx = p.shift();
	                        var dy = p.shift();
	                        cpx += dx;
	                        cpy += dy;
	                        cmd = 'M';
	                        // After closing the path move the current position 
	                        // to the the first point of the path (if any). 
	                        if(ca.length>2 && ca[ca.length-1].command==='z'){
	                            for(var idx=ca.length-2;idx>=0;idx--){
	                                if(ca[idx].command==='M'){
	                                    cpx=ca[idx].points[0]+dx;
	                                    cpy=ca[idx].points[1]+dy;
	                                    break;
	                                }
	                            }
	                        }
	                        points.push(cpx, cpy);
	                        c = 'l';
	                        // subsequent points are treated as relative lineTo
	                        break;
	                    case 'M':
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        cmd = 'M';
	                        points.push(cpx, cpy);
	                        c = 'L';
	                        // subsequent points are treated as absolute lineTo
	                        break;

	                    case 'h':
	                        cpx += p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'H':
	                        cpx = p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'v':
	                        cpy += p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'V':
	                        cpy = p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'C':
	                        points.push(p.shift(), p.shift(), p.shift(), p.shift());
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        points.push(cpx, cpy);
	                        break;
	                    case 'c':
	                        points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'C';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'S':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        prevCmd = ca[ca.length - 1];
	                        if(prevCmd.command === 'C') {
	                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
	                            ctlPty = cpy + (cpy - prevCmd.points[3]);
	                        }
	                        points.push(ctlPtx, ctlPty, p.shift(), p.shift());
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        cmd = 'C';
	                        points.push(cpx, cpy);
	                        break;
	                    case 's':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        prevCmd = ca[ca.length - 1];
	                        if(prevCmd.command === 'C') {
	                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
	                            ctlPty = cpy + (cpy - prevCmd.points[3]);
	                        }
	                        points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'C';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'Q':
	                        points.push(p.shift(), p.shift());
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        points.push(cpx, cpy);
	                        break;
	                    case 'q':
	                        points.push(cpx + p.shift(), cpy + p.shift());
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'Q';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'T':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        prevCmd = ca[ca.length - 1];
	                        if(prevCmd.command === 'Q') {
	                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
	                            ctlPty = cpy + (cpy - prevCmd.points[1]);
	                        }
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        cmd = 'Q';
	                        points.push(ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 't':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        prevCmd = ca[ca.length - 1];
	                        if(prevCmd.command === 'Q') {
	                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
	                            ctlPty = cpy + (cpy - prevCmd.points[1]);
	                        }
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'Q';
	                        points.push(ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 'A':
	                        rx = p.shift();
	                        ry = p.shift();
	                        psi = p.shift();
	                        fa = p.shift();
	                        fs = p.shift();
	                        x1 = cpx;
	                        y1 = cpy;
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        cmd = 'A';
	                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
	                        break;
	                    case 'a':
	                        rx = p.shift();
	                        ry = p.shift();
	                        psi = p.shift();
	                        fa = p.shift();
	                        fs = p.shift();
	                        x1 = cpx;
	                        y1 = cpy; cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'A';
	                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
	                        break;
	                }

	                ca.push({
	                    command: cmd || c,
	                    points: points,
	                    start: {
	                        x: startX,
	                        y: startY
	                    },
	                    pathLength: this.calcLength(startX, startY, cmd || c, points)
	                });
	            }

	            if(c === 'z' || c === 'Z') {
	                ca.push({
	                    command: 'z',
	                    points: [],
	                    start: undefined,
	                    pathLength: 0
	                });
	            }
	        }

	        return ca;
	    };
	    Kinetic.Path.calcLength = function(x, y, cmd, points) {
	        var len, p1, p2, t;
	        var path = Kinetic.Path;

	        switch (cmd) {
	            case 'L':
	                return path.getLineLength(x, y, points[0], points[1]);
	            case 'C':
	                // Approximates by breaking curve into 100 line segments
	                len = 0.0;
	                p1 = path.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
	                for( t = 0.01; t <= 1; t += 0.01) {
	                    p2 = path.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
	                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
	                    p1 = p2;
	                }
	                return len;
	            case 'Q':
	                // Approximates by breaking curve into 100 line segments
	                len = 0.0;
	                p1 = path.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);
	                for( t = 0.01; t <= 1; t += 0.01) {
	                    p2 = path.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
	                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
	                    p1 = p2;
	                }
	                return len;
	            case 'A':
	                // Approximates by breaking curve into line segments
	                len = 0.0;
	                var start = points[4];
	                // 4 = theta
	                var dTheta = points[5];
	                // 5 = dTheta
	                var end = points[4] + dTheta;
	                var inc = Math.PI / 180.0;
	                // 1 degree resolution
	                if(Math.abs(start - end) < inc) {
	                    inc = Math.abs(start - end);
	                }
	                // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi
	                p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
	                if(dTheta < 0) {// clockwise
	                    for( t = start - inc; t > end; t -= inc) {
	                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
	                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
	                        p1 = p2;
	                    }
	                }
	                else {// counter-clockwise
	                    for( t = start + inc; t < end; t += inc) {
	                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
	                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
	                        p1 = p2;
	                    }
	                }
	                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
	                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);

	                return len;
	        }

	        return 0;
	    };
	    Kinetic.Path.convertEndpointToCenterParameterization = function(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
	        // Derived from: http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
	        var psi = psiDeg * (Math.PI / 180.0);
	        var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;
	        var yp = -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;

	        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);

	        if(lambda > 1) {
	            rx *= Math.sqrt(lambda);
	            ry *= Math.sqrt(lambda);
	        }

	        var f = Math.sqrt((((rx * rx) * (ry * ry)) - ((rx * rx) * (yp * yp)) - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp) + (ry * ry) * (xp * xp)));

	        if(fa === fs) {
	            f *= -1;
	        }
	        if(isNaN(f)) {
	            f = 0;
	        }

	        var cxp = f * rx * yp / ry;
	        var cyp = f * -ry * xp / rx;

	        var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
	        var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;

	        var vMag = function(v) {
	            return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	        };
	        var vRatio = function(u, v) {
	            return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	        };
	        var vAngle = function(u, v) {
	            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
	        };
	        var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
	        var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	        var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	        var dTheta = vAngle(u, v);

	        if(vRatio(u, v) <= -1) {
	            dTheta = Math.PI;
	        }
	        if(vRatio(u, v) >= 1) {
	            dTheta = 0;
	        }
	        if(fs === 0 && dTheta > 0) {
	            dTheta = dTheta - 2 * Math.PI;
	        }
	        if(fs === 1 && dTheta < 0) {
	            dTheta = dTheta + 2 * Math.PI;
	        }
	        return [cx, cy, rx, ry, theta, dTheta, psi, fs];
	    };
	    // add getters setters
	    Kinetic.Factory.addGetterSetter(Kinetic.Path, 'data');

	    /**
	     * set SVG path data string.  This method
	     *  also automatically parses the data string
	     *  into a data array.  Currently supported SVG data:
	     *  M, m, L, l, H, h, V, v, Q, q, T, t, C, c, S, s, A, a, Z, z
	     * @name setData
	     * @method
	     * @memberof Kinetic.Path.prototype
	     * @param {String} SVG path command string
	     */

	    /**
	     * get SVG path data string
	     * @name getData
	     * @method
	     * @memberof Kinetic.Path.prototype
	     */

	    Kinetic.Collection.mapMethods(Kinetic.Path);
	})();
	;(function() {
	    var EMPTY_STRING = '',
	        //CALIBRI = 'Calibri',
	        NORMAL = 'normal';

	    /**
	     * Path constructor.
	     * @author Jason Follas
	     * @constructor
	     * @memberof Kinetic
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {String} [config.fontFamily] default is Calibri
	     * @param {Number} [config.fontSize] default is 12
	     * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
	     * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
	     * @param {String} config.text
	     * @param {String} config.data SVG data string
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var textpath = new Kinetic.TextPath({
	     *   x: 100,
	     *   y: 50,
	     *   fill: '#333',
	     *   fontSize: '24',
	     *   fontFamily: 'Arial',
	     *   text: 'All the world\'s a stage, and all the men and women merely players.',
	     *   data: 'M10,10 C0,0 10,150 100,100 S300,150 400,50'
	     * });
	     */
	    Kinetic.TextPath = function(config) {
	        this.___init(config);
	    };

	    function _fillFunc(context) {
	        context.fillText(this.partialText, 0, 0);
	    }
	    function _strokeFunc(context) {
	        context.strokeText(this.partialText, 0, 0);
	    }

	    Kinetic.TextPath.prototype = {
	        ___init: function(config) {
	            var that = this;
	            this.dummyCanvas = Kinetic.Util.createCanvasElement();
	            this.dataArray = [];

	            // call super constructor
	            Kinetic.Shape.call(this, config);

	            // overrides
	            // TODO: shouldn't this be on the prototype?
	            this._fillFunc = _fillFunc;
	            this._strokeFunc = _strokeFunc;
	            this._fillFuncHit = _fillFunc;
	            this._strokeFuncHit = _strokeFunc;
	            
	            this.className = 'TextPath';

	            this.dataArray = Kinetic.Path.parsePathData(this.attrs.data);
	            this.on('dataChange.kinetic', function() {
	                that.dataArray = Kinetic.Path.parsePathData(this.attrs.data);
	            });

	            // update text data for certain attr changes
	            this.on('textChange.kinetic textStroke.kinetic textStrokeWidth.kinetic', that._setTextData);
	            that._setTextData();
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            context.setAttr('font', this._getContextFont());
	            context.setAttr('textBaseline', 'middle');
	            context.setAttr('textAlign', 'left');
	            context.save();

	            var glyphInfo = this.glyphInfo;
	            for(var i = 0; i < glyphInfo.length; i++) {
	                context.save();

	                var p0 = glyphInfo[i].p0;

	                context.translate(p0.x, p0.y);
	                context.rotate(glyphInfo[i].rotation);
	                this.partialText = glyphInfo[i].text;

	                context.fillStrokeShape(this);
	                context.restore();

	                //// To assist with debugging visually, uncomment following
	                // context.beginPath();
	                // if (i % 2)
	                // context.strokeStyle = 'cyan';
	                // else
	                // context.strokeStyle = 'green';
	                // var p1 = glyphInfo[i].p1;
	                // context.moveTo(p0.x, p0.y);
	                // context.lineTo(p1.x, p1.y);
	                // context.stroke();
	            }
	            context.restore();
	        },
	        /**
	         * get text width in pixels
	         * @method
	         * @memberof Kinetic.TextPath.prototype
	         */
	        getTextWidth: function() {
	            return this.textWidth;
	        },
	        /**
	         * get text height in pixels
	         * @method
	         * @memberof Kinetic.TextPath.prototype
	         */
	        getTextHeight: function() {
	            return this.textHeight;
	        },
	        /**
	         * set text
	         * @method
	         * @memberof Kinetic.TextPath.prototype
	         * @param {String} text
	         */
	        setText: function(text) {
	            Kinetic.Text.prototype.setText.call(this, text);
	        },
	        _getTextSize: function(text) {
	            var dummyCanvas = this.dummyCanvas;
	            var _context = dummyCanvas.getContext('2d');

	            _context.save();

	            _context.font = this._getContextFont();
	            var metrics = _context.measureText(text);

	            _context.restore();

	            return {
	                width: metrics.width,
	                height: parseInt(this.attrs.fontSize, 10)
	            };
	        },
	        _setTextData: function() {

	            var that = this;
	            var size = this._getTextSize(this.attrs.text);
	            this.textWidth = size.width;
	            this.textHeight = size.height;

	            this.glyphInfo = [];

	            var charArr = this.attrs.text.split('');

	            var p0, p1, pathCmd;

	            var pIndex = -1;
	            var currentT = 0;

	            var getNextPathSegment = function() {
	                currentT = 0;
	                var pathData = that.dataArray;

	                for(var i = pIndex + 1; i < pathData.length; i++) {
	                    if(pathData[i].pathLength > 0) {
	                        pIndex = i;

	                        return pathData[i];
	                    }
	                    else if(pathData[i].command == 'M') {
	                        p0 = {
	                            x: pathData[i].points[0],
	                            y: pathData[i].points[1]
	                        };
	                    }
	                }

	                return {};
	            };
	            var findSegmentToFitCharacter = function(c) {

	                var glyphWidth = that._getTextSize(c).width;

	                var currLen = 0;
	                var attempts = 0;

	                p1 = undefined;
	                while(Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 25) {
	                    attempts++;
	                    var cumulativePathLength = currLen;
	                    while(pathCmd === undefined) {
	                        pathCmd = getNextPathSegment();

	                        if(pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {
	                            cumulativePathLength += pathCmd.pathLength;
	                            pathCmd = undefined;
	                        }
	                    }

	                    if(pathCmd === {} || p0 === undefined) {
	                        return undefined;
	                    }

	                    var needNewSegment = false;

	                    switch (pathCmd.command) {
	                        case 'L':
	                            if(Kinetic.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {
	                                p1 = Kinetic.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);
	                            }
	                            else {
	                                pathCmd = undefined;
	                            }
	                            break;
	                        case 'A':

	                            var start = pathCmd.points[4];
	                            // 4 = theta
	                            var dTheta = pathCmd.points[5];
	                            // 5 = dTheta
	                            var end = pathCmd.points[4] + dTheta;

	                            if(currentT === 0){
	                                currentT = start + 0.00000001;
	                            }
	                            // Just in case start is 0
	                            else if(glyphWidth > currLen) {
	                                currentT += (Math.PI / 180.0) * dTheta / Math.abs(dTheta);
	                            }
	                            else {
	                                currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);
	                            }

	                            // Credit for bug fix: @therth https://github.com/ericdrowell/KineticJS/issues/249
	                            // Old code failed to render text along arc of this path: "M 50 50 a 150 50 0 0 1 250 50 l 50 0"
	                            if(dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
	                                currentT = end;
	                                needNewSegment = true;
	                            }
	                            p1 = Kinetic.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);
	                            break;
	                        case 'C':
	                            if(currentT === 0) {
	                                if(glyphWidth > pathCmd.pathLength) {
	                                    currentT = 0.00000001;
	                                }
	                                else {
	                                    currentT = glyphWidth / pathCmd.pathLength;
	                                }
	                            }
	                            else if(glyphWidth > currLen) {
	                                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
	                            }
	                            else {
	                                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
	                            }

	                            if(currentT > 1.0) {
	                                currentT = 1.0;
	                                needNewSegment = true;
	                            }
	                            p1 = Kinetic.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);
	                            break;
	                        case 'Q':
	                            if(currentT === 0) {
	                                currentT = glyphWidth / pathCmd.pathLength;
	                            }
	                            else if(glyphWidth > currLen) {
	                                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
	                            }
	                            else {
	                                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
	                            }

	                            if(currentT > 1.0) {
	                                currentT = 1.0;
	                                needNewSegment = true;
	                            }
	                            p1 = Kinetic.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);
	                            break;

	                    }

	                    if(p1 !== undefined) {
	                        currLen = Kinetic.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
	                    }

	                    if(needNewSegment) {
	                        needNewSegment = false;
	                        pathCmd = undefined;
	                    }
	                }
	            };
	            for(var i = 0; i < charArr.length; i++) {

	                // Find p1 such that line segment between p0 and p1 is approx. width of glyph
	                findSegmentToFitCharacter(charArr[i]);

	                if(p0 === undefined || p1 === undefined) {
	                    break;
	                }

	                var width = Kinetic.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);

	                // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.
	                // Can foresee having a rough pair table built in that the developer can override as needed.

	                var kern = 0;
	                // placeholder for future implementation

	                var midpoint = Kinetic.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);

	                var rotation = Math.atan2((p1.y - p0.y), (p1.x - p0.x));
	                this.glyphInfo.push({
	                    transposeX: midpoint.x,
	                    transposeY: midpoint.y,
	                    text: charArr[i],
	                    rotation: rotation,
	                    p0: p0,
	                    p1: p1
	                });
	                p0 = p1;
	            }
	        }
	    };

	    // map TextPath methods to Text
	    Kinetic.TextPath.prototype._getContextFont = Kinetic.Text.prototype._getContextFont;

	    Kinetic.Util.extend(Kinetic.TextPath, Kinetic.Shape);

	    // add setters and getters
	    Kinetic.Factory.addGetterSetter(Kinetic.TextPath, 'fontFamily', 'Arial');

	    /**
	     * set font family
	     * @name setFontFamily
	     * @method
	     * @memberof Kinetic.TextPath.prototype
	     * @param {String} fontFamily
	     */

	     /**
	     * get font family
	     * @name getFontFamily
	     * @method
	     * @memberof Kinetic.TextPath.prototype
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.TextPath, 'fontSize', 12);

	    /**
	     * set font size
	     * @name setFontSize
	     * @method
	     * @memberof Kinetic.TextPath.prototype
	     * @param {int} fontSize
	     */

	     /**
	     * get font size
	     * @name getFontSize
	     * @method
	     * @memberof Kinetic.TextPath.prototype
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.TextPath, 'fontStyle', NORMAL);

	    /**
	     * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
	     * @name setFontStyle
	     * @method
	     * @memberof Kinetic.TextPath.prototype
	     * @param {String} fontStyle
	     */

	     /**
	     * get font style
	     * @name getFontStyle
	     * @method
	     * @memberof Kinetic.TextPath.prototype
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.TextPath, 'fontVariant', NORMAL);

	    /**
	     * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
	     * @name setFontVariant
	     * @method
	     * @memberof Kinetic.TextPath.prototype
	     * @param {String} fontVariant
	     */

	    /**
	     * @get font variant
	     * @name getFontVariant
	     * @method
	     * @memberof Kinetic.TextPath.prototype
	     */

	    Kinetic.Factory.addGetter(Kinetic.TextPath, 'text', EMPTY_STRING);

	    /**
	     * get text
	     * @name getText
	     * @method
	     * @memberof Kinetic.TextPath.prototype
	     */

	    Kinetic.Collection.mapMethods(Kinetic.TextPath);
	})();
	;(function() {
	    /**
	     * RegularPolygon constructor.&nbsp; Examples include triangles, squares, pentagons, hexagons, etc.
	     * @constructor
	     * @memberof Kinetic
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {Number} config.sides
	     * @param {Number} config.radius
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var hexagon = new Kinetic.RegularPolygon({
	     *   x: 100,
	     *   y: 200,
	     *   sides: 6,
	     *   radius: 70,
	     *   fill: 'red',
	     *   stroke: 'black',
	     *   strokeWidth: 4
	     * });
	     */
	    Kinetic.RegularPolygon = function(config) {
	        this.___init(config);
	    };

	    Kinetic.RegularPolygon.prototype = {
	        ___init: function(config) {
	            // call super constructor
	            Kinetic.Shape.call(this, config);
	            this.className = 'RegularPolygon';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var sides = this.attrs.sides,
	                radius = this.attrs.radius,
	                n, x, y;

	            context.beginPath();
	            context.moveTo(0, 0 - radius);

	            for(n = 1; n < sides; n++) {
	                x = radius * Math.sin(n * 2 * Math.PI / sides);
	                y = -1 * radius * Math.cos(n * 2 * Math.PI / sides);
	                context.lineTo(x, y);
	            }
	            context.closePath();
	            context.fillStrokeShape(this);
	        }
	    };
	    Kinetic.Util.extend(Kinetic.RegularPolygon, Kinetic.Shape);

	    // add getters setters
	    Kinetic.Factory.addGetterSetter(Kinetic.RegularPolygon, 'radius', 0);

	    /**
	     * set radius
	     * @name setRadius
	     * @method
	     * @memberof Kinetic.RegularPolygon.prototype
	     * @param {Number} radius
	     */

	     /**
	     * get radius
	     * @name getRadius
	     * @method
	     * @memberof Kinetic.RegularPolygon.prototype
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.RegularPolygon, 'sides', 0);

	    /**
	     * set number of sides
	     * @name setSides
	     * @method
	     * @memberof Kinetic.RegularPolygon.prototype
	     * @param {int} sides
	     */

	    /**
	     * get number of sides
	     * @name getSides
	     * @method
	     * @memberof Kinetic.RegularPolygon.prototype
	     */

	    Kinetic.Collection.mapMethods(Kinetic.RegularPolygon);
	})();
	;(function() {
	    /**
	     * Star constructor
	     * @constructor
	     * @memberof Kinetic
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {Integer} config.numPoints
	     * @param {Number} config.innerRadius
	     * @param {Number} config.outerRadius
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var star = new Kinetic.Star({
	     *   x: 100,
	     *   y: 200,
	     *   numPoints: 5,
	     *   innerRadius: 70,
	     *   outerRadius: 70,
	     *   fill: 'red',
	     *   stroke: 'black',
	     *   strokeWidth: 4
	     * });
	     */
	    Kinetic.Star = function(config) {
	        this.___init(config);
	    };

	    Kinetic.Star.prototype = {
	        ___init: function(config) {
	            // call super constructor
	            Kinetic.Shape.call(this, config);
	            this.className = 'Star';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var innerRadius = this.innerRadius(),
	                outerRadius = this.outerRadius(),
	                numPoints = this.numPoints();

	            context.beginPath();
	            context.moveTo(0, 0 - outerRadius);

	            for(var n = 1; n < numPoints * 2; n++) {
	                var radius = n % 2 === 0 ? outerRadius : innerRadius;
	                var x = radius * Math.sin(n * Math.PI / numPoints);
	                var y = -1 * radius * Math.cos(n * Math.PI / numPoints);
	                context.lineTo(x, y);
	            }
	            context.closePath();

	            context.fillStrokeShape(this);
	        }
	    };
	    Kinetic.Util.extend(Kinetic.Star, Kinetic.Shape);

	    // add getters setters
	    Kinetic.Factory.addGetterSetter(Kinetic.Star, 'numPoints', 5);

	    /**
	     * set number of points
	     * @name setNumPoints
	     * @method
	     * @memberof Kinetic.Star.prototype
	     * @param {Integer} points
	     */

	     /**
	     * get number of points
	     * @name getNumPoints
	     * @method
	     * @memberof Kinetic.Star.prototype
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Star, 'innerRadius', 0);

	    /**
	     * set inner radius
	     * @name setInnerRadius
	     * @method
	     * @memberof Kinetic.Star.prototype
	     * @param {Number} radius
	     */

	     /**
	     * get inner radius
	     * @name getInnerRadius
	     * @method
	     * @memberof Kinetic.Star.prototype
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Star, 'outerRadius', 0);

	    /**
	     * set outer radius
	     * @name setOuterRadius
	     * @method
	     * @memberof Kinetic.Star.prototype
	     * @param {Number} radius
	     */

	     /**
	     * get outer radius
	     * @name getOuterRadius
	     * @method
	     * @memberof Kinetic.Star.prototype
	     */

	    Kinetic.Collection.mapMethods(Kinetic.Star);
	})();
	;(function() {
	    // constants
	    var ATTR_CHANGE_LIST = ['fontFamily', 'fontSize', 'fontStyle', 'padding', 'lineHeight', 'text'],
	        CHANGE_KINETIC = 'Change.kinetic',
	        NONE = 'none',
	        UP = 'up',
	        RIGHT = 'right',
	        DOWN = 'down',
	        LEFT = 'left',
	        LABEL = 'Label',

	     // cached variables
	     attrChangeListLen = ATTR_CHANGE_LIST.length;

	    /**
	     * Label constructor.&nbsp; Labels are groups that contain a Text and Tag shape
	     * @constructor
	     * @memberof Kinetic
	     * @param {Object} config
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * // create label
	     * var label = new Kinetic.Label({
	     *   x: 100,
	     *   y: 100, 
	     *   draggable: true
	     * });
	     *
	     * // add a tag to the label
	     * label.add(new Kinetic.Tag({
	     *   fill: '#bbb',
	     *   stroke: '#333',
	     *   shadowColor: 'black',
	     *   shadowBlur: 10,
	     *   shadowOffset: [10, 10],
	     *   shadowOpacity: 0.2,
	     *   lineJoin: 'round',
	     *   pointerDirection: 'up',
	     *   pointerWidth: 20,
	     *   pointerHeight: 20,
	     *   cornerRadius: 5
	     * }));
	     *
	     * // add text to the label
	     * label.add(new Kinetic.Text({
	     *   text: 'Hello World!',
	     *   fontSize: 50,
	     *   lineHeight: 1.2,
	     *   padding: 10,
	     *   fill: 'green'
	     *  }));
	     */
	    Kinetic.Label = function(config) {
	        this.____init(config);
	    };

	    Kinetic.Label.prototype = {
	        ____init: function(config) {
	            var that = this;

	            Kinetic.Group.call(this, config);
	            this.className = LABEL;
	            
	            this.on('add.kinetic', function(evt) {
	                that._addListeners(evt.child);
	                that._sync();
	            });
	        },
	        /**
	         * get Text shape for the label.  You need to access the Text shape in order to update
	         * the text properties
	         * @name getText
	         * @method
	         * @memberof Kinetic.Label.prototype
	         */
	        getText: function() {
	            return this.find('Text')[0];
	        },
	        /**
	         * get Tag shape for the label.  You need to access the Tag shape in order to update
	         * the pointer properties and the corner radius
	         * @name getTag
	         * @method
	         * @memberof Kinetic.Label.prototype
	         */
	        getTag: function() {
	            return this.find('Tag')[0];
	        },
	        _addListeners: function(text) {
	            var that = this,
	                n;
	            var func = function(){
	                    that._sync();
	                };

	            // update text data for certain attr changes
	            for(n = 0; n < attrChangeListLen; n++) {
	                text.on(ATTR_CHANGE_LIST[n] + CHANGE_KINETIC, func);
	            }
	        },
	        getWidth: function() {
	            return this.getText().getWidth();
	        },
	        getHeight: function() {
	            return this.getText().getHeight();
	        },
	        _sync: function() {
	            var text = this.getText(),
	                tag = this.getTag(),
	                width, height, pointerDirection, pointerWidth, x, y, pointerHeight;

	            if (text && tag) {
	                width = text.getWidth();
	                height = text.getHeight();
	                pointerDirection = tag.getPointerDirection();
	                pointerWidth = tag.getPointerWidth();
	                pointerHeight = tag.getPointerHeight();
	                x = 0;
	                y = 0;

	                switch(pointerDirection) {
	                    case UP:
	                        x = width / 2;
	                        y = -1 * pointerHeight;
	                        break;
	                    case RIGHT:
	                        x = width + pointerWidth;
	                        y = height / 2;
	                        break;
	                    case DOWN:
	                        x = width / 2;
	                        y = height + pointerHeight;
	                        break;
	                    case LEFT:
	                        x = -1 * pointerWidth;
	                        y = height / 2;
	                        break;
	                }

	                tag.setAttrs({
	                    x: -1 * x,
	                    y: -1 * y,
	                    width: width,
	                    height: height
	                });

	                text.setAttrs({
	                    x: -1 * x,
	                    y: -1 * y
	                });
	            }
	        }
	    };

	    Kinetic.Util.extend(Kinetic.Label, Kinetic.Group);

	    Kinetic.Collection.mapMethods(Kinetic.Label);

	    /**
	     * Tag constructor.&nbsp; A Tag can be configured
	     *  to have a pointer element that points up, right, down, or left
	     * @constructor
	     * @memberof Kinetic
	     * @param {Object} config
	     * @param {String} [config.pointerDirection] can be up, right, down, left, or none; the default
	     *  is none.  When a pointer is present, the positioning of the label is relative to the tip of the pointer.
	     * @param {Number} [config.pointerWidth]
	     * @param {Number} [config.pointerHeight]
	     * @param {Number} [config.cornerRadius]
	     */
	    Kinetic.Tag = function(config) {
	        this.___init(config);
	    };

	    Kinetic.Tag.prototype = {
	        ___init: function(config) {
	            Kinetic.Shape.call(this, config);
	            this.className = 'Tag';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var width = this.getWidth(),
	                height = this.getHeight(),
	                pointerDirection = this.getPointerDirection(),
	                pointerWidth = this.getPointerWidth(),
	                pointerHeight = this.getPointerHeight(),
	                cornerRadius = this.getCornerRadius();

	            context.beginPath();
	            context.moveTo(0,0);

	            if (pointerDirection === UP) {
	                context.lineTo((width - pointerWidth)/2, 0);
	                context.lineTo(width/2, -1 * pointerHeight);
	                context.lineTo((width + pointerWidth)/2, 0);
	            }

	            if(!cornerRadius) {
	                context.lineTo(width, 0);
	            } else {
	                context.lineTo(width - cornerRadius, 0);
	                context.arc(width - cornerRadius, cornerRadius, cornerRadius, Math.PI * 3 / 2, 0, false);
	            }
	            
	            if (pointerDirection === RIGHT) {
	                context.lineTo(width, (height - pointerHeight)/2);
	                context.lineTo(width + pointerWidth, height/2);
	                context.lineTo(width, (height + pointerHeight)/2);
	            }
	            
	            if(!cornerRadius) {
	                context.lineTo(width, height);
	            } else {
	                context.lineTo(width, height - cornerRadius);
	                context.arc(width - cornerRadius, height - cornerRadius, cornerRadius, 0, Math.PI / 2, false);
	            }

	            if (pointerDirection === DOWN) {
	                context.lineTo((width + pointerWidth)/2, height);
	                context.lineTo(width/2, height + pointerHeight);
	                context.lineTo((width - pointerWidth)/2, height);
	            }
	            
	            if(!cornerRadius) {
	                context.lineTo(0, height);
	            } else {
	                context.lineTo(cornerRadius, height);
	                context.arc(cornerRadius, height - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, false);
	            }

	            if (pointerDirection === LEFT) {
	                context.lineTo(0, (height + pointerHeight)/2);
	                context.lineTo(-1 * pointerWidth, height/2);
	                context.lineTo(0, (height - pointerHeight)/2);
	            }
	            
	            if(cornerRadius) {
	                context.lineTo(0, cornerRadius);
	                context.arc(cornerRadius, cornerRadius, cornerRadius, Math.PI, Math.PI * 3 / 2, false);
	            }

	            context.closePath();
	            context.fillStrokeShape(this);
	        }
	    };

	    Kinetic.Util.extend(Kinetic.Tag, Kinetic.Shape);
	    Kinetic.Factory.addGetterSetter(Kinetic.Tag, 'pointerDirection', NONE);

	    /**
	     * set pointer Direction
	     * @name setPointerDirection
	     * @method
	     * @memberof Kinetic.Tag.prototype
	     * @param {String} pointerDirection can be up, right, down, left, or none.  The
	     *  default is none
	     */

	     /**
	     * get pointer Direction
	     * @name getPointerDirection
	     * @method
	     * @memberof Kinetic.Tag.prototype
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Tag, 'pointerWidth', 0);

	    /**
	     * set pointer width
	     * @name setPointerWidth
	     * @method
	     * @memberof Kinetic.Tag.prototype
	     * @param {Number} pointerWidth
	     */

	     /**
	     * get pointer width
	     * @name getPointerWidth
	     * @method
	     * @memberof Kinetic.Tag.prototype
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Tag, 'pointerHeight', 0);

	    /**
	     * set pointer height
	     * @name setPointerHeight
	     * @method
	     * @memberof Kinetic.Tag.prototype
	     * @param {Number} pointerHeight
	     */

	     /**
	     * get pointer height
	     * @name getPointerHeight
	     * @method
	     * @memberof Kinetic.Tag.prototype
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Tag, 'cornerRadius', 0);

	    /**
	     * set corner radius
	     * @name setCornerRadius
	     * @method
	     * @memberof Kinetic.Tag.prototype
	     * @param {Number} corner radius
	     */

	    /**
	     * get corner radius
	     * @name getCornerRadius
	     * @method
	     * @memberof Kinetic.Tag.prototype
	     */

	    Kinetic.Collection.mapMethods(Kinetic.Tag);
	})();
	;(function() {
	    /**
	     * Arrow constructor
	     * @constructor
	     * @memberof Kinetic
	     * @augments Kinetic.Shape
	     * @param {Object} config
	     * @param {Array} config.points
	     * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
	     *   The default is 0
	     * @param {Number} config.pointerLength
	     * @param {Number} config.pointerWidth
	     * @param {String} [config.fill] fill color
	     * @param {Integer} [config.fillRed] set fill red component
	     * @param {Integer} [config.fillGreen] set fill green component
	     * @param {Integer} [config.fillBlue] set fill blue component
	     * @param {Integer} [config.fillAlpha] set fill alpha component
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Integer} [config.strokeRed] set stroke red component
	     * @param {Integer} [config.strokeGreen] set stroke green component
	     * @param {Integer} [config.strokeBlue] set stroke blue component
	     * @param {Integer} [config.strokeAlpha] set stroke alpha component
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Integer} [config.shadowRed] set shadow color red component
	     * @param {Integer} [config.shadowGreen] set shadow color green component
	     * @param {Integer} [config.shadowBlue] set shadow color blue component
	     * @param {Integer} [config.shadowAlpha] set shadow color alpha component
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var line = new Kinetic.Line({
	     *   points: [73, 70, 340, 23, 450, 60, 500, 20],
	     *   stroke: 'red',
	     *   tension: 1,
	     *   pointerLength : 10,
	     *   pointerWidth : 12
	     * });
	     */
	    Kinetic.Arrow = function(config) {
	        this.____init(config);
	    };

	    Kinetic.Arrow.prototype = {
	        ____init : function(config) {
	            // call super constructor
	            Kinetic.Line.call(this, config);
	            this.className = 'Arrow';
	        },
	        _sceneFunc : function(ctx) {
	            var PI2 = Math.PI * 2;
	            var points = this.points();
	            var n = points.length;
	            var dx = points[n-2] - points[n-4];
	            var dy = points[n-1] - points[n-3];
	            var radians = (Math.atan2(dy, dx) + PI2) % PI2;
	            var length = this.pointerLength();
	            var width = this.pointerWidth();

	            ctx.save();
	            ctx.beginPath();
	            ctx.translate(points[n-2], points[n-1]);
	            ctx.rotate(radians);
	            ctx.moveTo(0, 0);
	            ctx.lineTo(-length, width / 2);
	            ctx.lineTo(-length, -width / 2);
	            ctx.closePath();
	            ctx.restore();

	            if (this.pointerAtBeginning()) {
	                ctx.save();
	                ctx.translate(points[0], points[1]);
	                dx = points[2] - points[0];
	                dy = points[3] - points[1];
	                ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
	                ctx.moveTo(0, 0);
	                ctx.lineTo(-10, 6);
	                ctx.lineTo(-10, -6);
	                ctx.closePath();
	                ctx.restore();
	            }

	            ctx.fillStrokeShape(this);
	            Kinetic.Line.prototype._sceneFunc.apply(this, arguments);
	        }
	    };

	    Kinetic.Util.extend(Kinetic.Arrow, Kinetic.Line);
	    /**
	     * get/set pointerLength
	     * @name pointerLength
	     * @method
	     * @memberof Kinetic.Arrow.prototype
	     * @param {Number} Length of pointer of arrow.
	     *   The default is 10.
	     * @returns {Number}
	     * @example
	     * // get tension
	     * var pointerLength = line.pointerLength();
	     *
	     * // set tension
	     * line.pointerLength(15);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Arrow, 'pointerLength', 10);
	    /**
	     * get/set pointerWidth
	     * @name pointerWidth
	     * @method
	     * @memberof Kinetic.Arrow.prototype
	     * @param {Number} Width of pointer of arrow.
	     *   The default is 10.
	     * @returns {Number}
	     * @example
	     * // get tension
	     * var pointerWidth = line.pointerWidth();
	     *
	     * // set tension
	     * line.pointerWidth(15);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Arrow, 'pointerWidth', 10);
	    /**
	     * get/set pointerAtBeginning
	     * @name pointerAtBeginning
	     * @method
	     * @memberof Kinetic.Arrow.prototype
	     * @param {Number} Should pointer displayed at beginning of arrow.
	     *   The default is false.
	     * @returns {Boolean}
	     * @example
	     * // get tension
	     * var pointerAtBeginning = line.pointerAtBeginning();
	     *
	     * // set tension
	     * line.pointerAtBeginning(true);
	     */

	    Kinetic.Factory.addGetterSetter(Kinetic.Arrow, 'pointerAtBeginning', false);
	    Kinetic.Collection.mapMethods(Kinetic.Arrow);

	})();


	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 533 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 534 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 535 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 * Copyright Marc J. Schmidt. See the LICENSE file at the top-level
	 * directory of this distribution and at
	 * https://github.com/marcj/css-element-queries/blob/master/LICENSE.
	 */
	;
	(function (root, factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object") {
	        module.exports = factory();
	    } else {
	        root.ResizeSensor = factory();
	    }
	})(undefined, function () {

	    // Only used for the dirty checking, so the event callback count is limted to max 1 call per fps per sensor.
	    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and
	    // would generate too many unnecessary events.
	    var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
	        return window.setTimeout(fn, 20);
	    };

	    /**
	     * Iterate over each of the provided element(s).
	     *
	     * @param {HTMLElement|HTMLElement[]} elements
	     * @param {Function}                  callback
	     */
	    function forEachElement(elements, callback) {
	        var elementsType = Object.prototype.toString.call(elements);
	        var isCollectionTyped = '[object Array]' === elementsType || '[object NodeList]' === elementsType || '[object HTMLCollection]' === elementsType || 'undefined' !== typeof jQuery && elements instanceof jQuery //jquery
	        || 'undefined' !== typeof Elements && elements instanceof Elements //mootools
	        ;
	        var i = 0,
	            j = elements.length;
	        if (isCollectionTyped) {
	            for (; i < j; i++) {
	                callback(elements[i]);
	            }
	        } else {
	            callback(elements);
	        }
	    }

	    /**
	     * Class for dimension change detection.
	     *
	     * @param {Element|Element[]|Elements|jQuery} element
	     * @param {Function} callback
	     *
	     * @constructor
	     */
	    var ResizeSensor = function ResizeSensor(element, callback) {
	        /**
	         *
	         * @constructor
	         */
	        function EventQueue() {
	            var q = [];
	            this.add = function (ev) {
	                q.push(ev);
	            };

	            var i, j;
	            this.call = function () {
	                for (i = 0, j = q.length; i < j; i++) {
	                    q[i].call();
	                }
	            };

	            this.remove = function (ev) {
	                var newQueue = [];
	                for (i = 0, j = q.length; i < j; i++) {
	                    if (q[i] !== ev) newQueue.push(q[i]);
	                }
	                q = newQueue;
	            };

	            this.length = function () {
	                return q.length;
	            };
	        }

	        /**
	         * @param {HTMLElement} element
	         * @param {String}      prop
	         * @returns {String|Number}
	         */
	        function getComputedStyle(element, prop) {
	            if (element.currentStyle) {
	                return element.currentStyle[prop];
	            } else if (window.getComputedStyle) {
	                return window.getComputedStyle(element, null).getPropertyValue(prop);
	            } else {
	                return element.style[prop];
	            }
	        }

	        /**
	         *
	         * @param {HTMLElement} element
	         * @param {Function}    resized
	         */
	        function attachResizeEvent(element, resized) {
	            if (!element.resizedAttached) {
	                element.resizedAttached = new EventQueue();
	                element.resizedAttached.add(resized);
	            } else if (element.resizedAttached) {
	                element.resizedAttached.add(resized);
	                return;
	            }

	            element.resizeSensor = document.createElement('div');
	            element.resizeSensor.className = 'resize-sensor';
	            var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';
	            var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';

	            element.resizeSensor.style.cssText = style;
	            element.resizeSensor.innerHTML = '<div class="resize-sensor-expand" style="' + style + '">' + '<div style="' + styleChild + '"></div>' + '</div>' + '<div class="resize-sensor-shrink" style="' + style + '">' + '<div style="' + styleChild + ' width: 200%; height: 200%"></div>' + '</div>';
	            element.appendChild(element.resizeSensor);

	            if (getComputedStyle(element, 'position') == 'static') {
	                element.style.position = 'relative';
	            }

	            var expand = element.resizeSensor.childNodes[0];
	            var expandChild = expand.childNodes[0];
	            var shrink = element.resizeSensor.childNodes[1];

	            var reset = function reset() {
	                expandChild.style.width = 100000 + 'px';
	                expandChild.style.height = 100000 + 'px';

	                expand.scrollLeft = 100000;
	                expand.scrollTop = 100000;

	                shrink.scrollLeft = 100000;
	                shrink.scrollTop = 100000;
	            };

	            reset();
	            var dirty = false;

	            var dirtyChecking = function dirtyChecking() {
	                if (!element.resizedAttached) return;

	                if (dirty) {
	                    element.resizedAttached.call();
	                    dirty = false;
	                }

	                requestAnimationFrame(dirtyChecking);
	            };

	            requestAnimationFrame(dirtyChecking);
	            var lastWidth, lastHeight;
	            var cachedWidth, cachedHeight; //useful to not query offsetWidth twice

	            var onScroll = function onScroll() {
	                if ((cachedWidth = element.offsetWidth) != lastWidth || (cachedHeight = element.offsetHeight) != lastHeight) {
	                    dirty = true;

	                    lastWidth = cachedWidth;
	                    lastHeight = cachedHeight;
	                }
	                reset();
	            };

	            var addEvent = function addEvent(el, name, cb) {
	                if (el.attachEvent) {
	                    el.attachEvent('on' + name, cb);
	                } else {
	                    el.addEventListener(name, cb);
	                }
	            };

	            addEvent(expand, 'scroll', onScroll);
	            addEvent(shrink, 'scroll', onScroll);
	        }

	        forEachElement(element, function (elem) {
	            attachResizeEvent(elem, callback);
	        });

	        this.detach = function (ev) {
	            ResizeSensor.detach(element, ev);
	        };
	    };

	    ResizeSensor.detach = function (element, ev) {
	        forEachElement(element, function (elem) {
	            if (elem.resizedAttached && typeof ev == "function") {
	                elem.resizedAttached.remove(ev);
	                if (elem.resizedAttached.length()) return;
	            }
	            if (elem.resizeSensor) {
	                if (elem.contains(elem.resizeSensor)) {
	                    elem.removeChild(elem.resizeSensor);
	                }
	                delete elem.resizeSensor;
	                delete elem.resizedAttached;
	            }
	        });
	    };

	    return ResizeSensor;
	});

/***/ },
/* 536 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var TradingAnalysis = __webpack_require__(508);
	var commonTrading = __webpack_require__(445);
	var chartFrameCleanup = __webpack_require__(509).chartFrameCleanup;
	var displayCurrencies = __webpack_require__(529);
	var Defaults = __webpack_require__(437);
	var TradingEvents = __webpack_require__(537);
	var Price = __webpack_require__(539);
	var Process = __webpack_require__(540);
	var BinarySocket = __webpack_require__(427);
	var ViewPopup = __webpack_require__(435);
	var BinaryPjax = __webpack_require__(467);
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var jpClient = __webpack_require__(425).jpClient;
	var Guide = __webpack_require__(530);

	var TradePage = function () {
	    'use strict';

	    var events_initialized = 0;
	    State.remove('is_trading');

	    var onLoad = function onLoad() {
	        if (jpClient()) {
	            BinaryPjax.load('multi_barriers_trading');
	            return;
	        }
	        State.set('is_trading', true);
	        Price.clearFormId();
	        if (events_initialized === 0) {
	            events_initialized = 1;
	            TradingEvents.init();
	        }

	        BinarySocket.send({ payout_currencies: 1 }).then(function () {
	            displayCurrencies();
	            Process.processActiveSymbols();
	        });

	        if (document.getElementById('websocket_form')) {
	            commonTrading.addEventListenerForm();
	        }

	        // Walk-through Guide
	        Guide.init({
	            script: 'trading'
	        });
	        TradingAnalysis.bindAnalysisTabEvent();
	        $('#tab_portfolio').find('a').text(localize('Portfolio'));
	        $('#tab_graph').find('a').text(localize('Chart'));
	        $('#tab_explanation').find('a').text(localize('Explanation'));
	        $('#tab_last_digit').find('a').text(localize('Last Digit Stats'));

	        ViewPopup.viewButtonOnClick('#contract_confirmation_container');
	    };

	    var reload = function reload() {
	        sessionStorage.removeItem('underlying');
	        window.location.reload();
	    };

	    var onUnload = function onUnload() {
	        State.remove('is_trading');
	        events_initialized = 0;
	        Process.forgetTradingStreams();
	        BinarySocket.clear();
	        Defaults.clear();
	        chartFrameCleanup();
	        commonTrading.clean();
	        BinarySocket.clear('active_symbols');
	    };

	    var onDisconnect = function onDisconnect() {
	        commonTrading.showPriceOverlay();
	        commonTrading.showFormOverlay();
	        chartFrameCleanup();
	        onLoad();
	    };

	    return {
	        onLoad: onLoad,
	        reload: reload,
	        onUnload: onUnload,
	        onDisconnect: onDisconnect
	    };
	}();

	module.exports = TradePage;

/***/ },
/* 537 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var TradingAnalysis = __webpack_require__(508);
	var Barriers = __webpack_require__(442);
	var commonTrading = __webpack_require__(445);
	var chartFrameSource = __webpack_require__(509).chartFrameSource;
	var Defaults = __webpack_require__(437);
	var Durations = __webpack_require__(538);
	var GetTicks = __webpack_require__(441);
	var Notifications = __webpack_require__(446);
	var Price = __webpack_require__(539);
	var Process = __webpack_require__(540);
	var Purchase = __webpack_require__(459);
	var getStartDateNode = __webpack_require__(443).getStartDateNode;
	var Tick = __webpack_require__(448);
	var BinarySocket = __webpack_require__(427);
	var BinaryPjax = __webpack_require__(467);
	var GTM = __webpack_require__(464);
	var dateValueChanged = __webpack_require__(430).dateValueChanged;
	var isVisible = __webpack_require__(430).isVisible;
	var formatMoney = __webpack_require__(433).formatMoney;
	var onlyNumericOnKeypress = __webpack_require__(527);
	var TimePicker = __webpack_require__(528);

	/*
	 * TradingEvents object contains all the event handler function for
	 * websocket trading page
	 *
	 * We need it as object so that we can call TradingEvent.init() only on trading
	 * page for pjax to work else it will fire on all pages
	 *
	 */
	var TradingEvents = function () {
	    'use strict';

	    var initiate = function initiate() {
	        /*
	         * attach event to market list, so when client change market we need to update undelryings
	         * and request for new Contract details to populate the form and request price accordingly
	         */
	        var onMarketChange = function onMarketChange(market) {
	            commonTrading.showPriceOverlay();
	            Defaults.set('market', market);

	            // as different markets have different forms so remove from sessionStorage
	            // it will default to proper one
	            Defaults.remove('formname');
	            Defaults.remove('underlying');
	            Process.processMarket();
	            chartFrameSource();
	        };

	        var market_nav_element = document.getElementById('contract_markets');
	        if (market_nav_element) {
	            market_nav_element.addEventListener('change', function (e) {
	                onMarketChange(e.target.value);
	            });
	        }

	        /*
	         * attach event to form list, so when client click on different form we need to update form
	         * and request for new Contract details to populate the form and request price accordingly
	         */
	        var contractFormEventChange = function contractFormEventChange() {
	            Process.processContractForm();
	            TradingAnalysis.request();
	        };

	        var form_nav_element = document.getElementById('contract_form_name_nav');
	        if (form_nav_element) {
	            form_nav_element.addEventListener('click', function (e) {
	                var clicked_form = e.target;
	                if (clicked_form && clicked_form.getAttribute('menuitem')) {
	                    var is_form_active = clicked_form.classList.contains('active') || clicked_form.parentElement.classList.contains('active');
	                    Defaults.set('formname', clicked_form.getAttribute('menuitem'));

	                    // if form is already active then no need to send same request again
	                    commonTrading.toggleActiveCatMenuElement(form_nav_element, e.target.getAttribute('menuitem'));

	                    if (!is_form_active) {
	                        contractFormEventChange();
	                    }
	                }
	            });
	        }

	        /*
	         * attach event to underlying change, event need to request new contract details and price
	         */
	        var underlying_element = document.getElementById('underlying');
	        if (underlying_element) {
	            underlying_element.addEventListener('change', function (e) {
	                if (e.target) {
	                    chartFrameSource();
	                    commonTrading.showFormOverlay();
	                    commonTrading.showPriceOverlay();
	                    if (e.target.selectedIndex < 0) {
	                        e.target.selectedIndex = 0;
	                    }
	                    var underlying = e.target.value;
	                    Defaults.remove('barrier', 'barrier_high', 'barrier_low');
	                    Defaults.set('underlying', underlying);
	                    TradingAnalysis.request();

	                    Tick.clean();

	                    commonTrading.updateWarmChart();

	                    getContracts(underlying);

	                    // get ticks for current underlying
	                    GetTicks.request(underlying);
	                    commonTrading.displayTooltip(Defaults.get('market'), underlying);
	                }
	            });
	        }

	        var getContracts = function getContracts(underlying) {
	            BinarySocket.send({ contracts_for: underlying }).then(function (response) {
	                Notifications.hide('CONNECTION_ERROR');
	                Process.processContract(response);
	            });
	        };

	        /*
	         * bind event to change in duration amount, request new price
	         */
	        var triggerOnDurationChange = function triggerOnDurationChange(e) {
	            if (e.target.value % 1 !== 0) {
	                e.target.value = Math.floor(e.target.value);
	            }
	            Defaults.set('duration_amount', e.target.value);
	            Durations.selectAmount(e.target.value);
	            Price.processPriceRequest();
	            commonTrading.submitForm(document.getElementById('websocket_form'));
	        };
	        var duration_amount_element = document.getElementById('duration_amount');
	        var input_event_triggered = false; // For triggering one of the two events.
	        if (duration_amount_element) {
	            duration_amount_element.addEventListener('keypress', onlyNumericOnKeypress);
	            // jquery needed for datepicker
	            $('#duration_amount').on('input', commonTrading.debounce(function (e) {
	                triggerOnDurationChange(e);
	                Durations.validateMinDurationAmount();
	                input_event_triggered = true;
	            })).on('change', commonTrading.debounce(function (e) {
	                // using Defaults, to update the value by datepicker if it was emptied by keyboard (delete)
	                Durations.validateMinDurationAmount();
	                if (input_event_triggered === false || !Defaults.get('duration_amount')) {
	                    triggerOnDurationChange(e);
	                } else {
	                    input_event_triggered = false;
	                }
	            }));
	        }

	        /*
	         * attach event to expiry time change, event need to populate duration
	         * and request new price
	         */
	        var expiry_type_element = document.getElementById('expiry_type');
	        if (expiry_type_element) {
	            expiry_type_element.addEventListener('change', function (e) {
	                Defaults.set('expiry_type', e.target.value);
	                Process.onExpiryTypeChange(e.target.value);
	                if (expiry_type_element.value !== 'endtime') Price.processPriceRequest();
	            });
	        }

	        /*
	         * bind event to change in duration units, populate duration and request price
	         */
	        var duration_unit_element = document.getElementById('duration_units');
	        if (duration_unit_element) {
	            duration_unit_element.addEventListener('change', function (e) {
	                Defaults.remove('barrier', 'barrier_high', 'barrier_low');
	                Process.onDurationUnitChange(e.target.value);
	                Price.processPriceRequest();
	            });
	        }

	        /*
	         * bind event to change in endtime date and time
	         */
	        var end_date_element = document.getElementById('expiry_date');
	        if (end_date_element) {
	            // need to use jquery as datepicker is used, if we switch to some other
	            // datepicker we can move back to javascript
	            $('#expiry_date').on('change input', function () {
	                if (!dateValueChanged(this, 'date')) {
	                    return false;
	                }
	                if (commonTrading.timeIsValid($('#expiry_date'))) {
	                    Durations.selectEndDate(moment(this.getAttribute('data-value')));
	                }
	                return true;
	            });
	        }

	        var end_time_element = document.getElementById('expiry_time');
	        if (end_time_element) {
	            /*
	             * attach datepicker and timepicker to end time durations
	             * have to use jquery
	             */
	            attachTimePicker();
	            $('#expiry_time').on('focus click', attachTimePicker).on('keypress', function (ev) {
	                onlyNumericOnKeypress(ev, [58]);
	            }).on('change input blur', function () {
	                if (!dateValueChanged(this, 'time')) {
	                    return false;
	                }
	                if (commonTrading.timeIsValid($('#expiry_time'))) {
	                    Durations.setTime(end_time_element.value);
	                    Price.processPriceRequest();
	                }
	                return true;
	            });
	        }

	        /*
	         * attach event to change in amount, request new price only
	         */
	        var amount_element = document.getElementById('amount');
	        if (amount_element) {
	            amount_element.addEventListener('keypress', onlyNumericOnKeypress);

	            amount_element.addEventListener('input', commonTrading.debounce(function (e) {
	                e.target.value = e.target.value.replace(/[^0-9.]/g, '');
	                if (isStandardFloat(e.target.value)) {
	                    e.target.value = formatMoney(Defaults.get('currency'), parseFloat(e.target.value), 1);
	                }
	                Defaults.set('amount', e.target.value);
	                Price.processPriceRequest();
	                commonTrading.submitForm(document.getElementById('websocket_form'));
	            }));
	        }

	        /*
	         * attach event to start time, display duration based on
	         * whether start time is forward starting or not and request
	         * new price
	         */
	        var date_start_element = getStartDateNode();
	        if (date_start_element) {
	            date_start_element.addEventListener('change', function (e) {
	                Defaults.set('date_start', e.target.value);
	                var r = Durations.onStartDateChange(e.target.value);
	                if (r >= 0) {
	                    Price.processPriceRequest();
	                }
	            });
	        }

	        /*
	         * attach event to change in amount type that is whether its
	         * payout or stake and request new price
	         */
	        var amount_type_element = document.getElementById('amount_type');
	        if (amount_type_element) {
	            amount_type_element.addEventListener('change', function (e) {
	                Defaults.set('amount_type', e.target.value);
	                Price.processPriceRequest();
	            });
	        }

	        /*
	         * attach event to change in submarkets. We need to disable
	         * underlyings that are not in selected seubmarkets
	         */
	        var submarket_element = document.getElementById('submarket');
	        if (submarket_element) {
	            submarket_element.addEventListener('change', function (e) {
	                if (e.target) {
	                    var elem = document.getElementById('underlying');
	                    var underlyings = elem.children;

	                    for (var i = 0, len = underlyings.length; i < len; i++) {
	                        underlyings[i].disabled = e.target.value !== 'all' && e.target.value !== underlyings[i].className;
	                    }

	                    // as submarket change has modified the underlying list so we need to manually
	                    // fire change event for underlying
	                    document.querySelectorAll('#underlying option:enabled')[0].selected = 'selected';
	                    var event = new Event('change');
	                    elem.dispatchEvent(event);
	                }
	            });
	        }

	        /*
	         * attach an event to change in currency
	         */
	        var currency_element = document.getElementById('currency');
	        if (currency_element) {
	            currency_element.addEventListener('change', function (e) {
	                Defaults.set('currency', e.target.value);
	                Price.processPriceRequest();
	            });
	        }

	        /*
	         * attach event to purchase buttons to buy the current contract
	         */
	        $('.purchase_button').on('click dblclick', function () {
	            if (!isVisible(document.getElementById('confirmation_message_container'))) {
	                var id = this.getAttribute('data-purchase-id');
	                var ask_price = this.getAttribute('data-ask-price');

	                var params = { buy: id, price: ask_price, passthrough: {} };
	                Object.keys(this.attributes).forEach(function (attr) {
	                    if (attr && this.attributes[attr] && this.attributes[attr].name && !/data\-balloon/.test(this.attributes[attr].name)) {
	                        // do not send tooltip data
	                        var m = this.attributes[attr].name.match(/data\-(.+)/);

	                        if (m && m[1] && m[1] !== 'purchase-id' && m[1] !== 'passthrough') {
	                            params.passthrough[m[1]] = this.attributes[attr].value;
	                        }
	                    }
	                }, this);
	                if (id && ask_price) {
	                    $('.purchase_button').css('visibility', 'hidden');
	                    BinarySocket.send(params).then(function (response) {
	                        Purchase.display(response);
	                        GTM.pushPurchaseData(response);
	                    });
	                    Price.incrFormId();
	                    Price.processForgetProposals();
	                }
	            }
	        });

	        /*
	         * attach event to close icon for purchase container
	         */
	        $('#close_confirmation_container').on('click dblclick', function (e) {
	            if (e.target && isVisible(document.getElementById('confirmation_message_container'))) {
	                e.preventDefault();
	                commonTrading.hideOverlayContainer();
	                Price.processPriceRequest();
	            }
	        });

	        /*
	         * attach an event to change in barrier
	         */
	        var barrier_element = document.getElementById('barrier');
	        if (barrier_element) {
	            $('#barrier').on('keypress', function (ev) {
	                onlyNumericOnKeypress(ev, [43, 45, 46]);
	            }).on('input', commonTrading.debounce(function (e) {
	                Barriers.validateBarrier();
	                Defaults.set('barrier', e.target.value);
	                Price.processPriceRequest();
	                commonTrading.submitForm(document.getElementById('websocket_form'));
	            }, 1000));
	        }

	        /*
	         * attach an event to change in low barrier
	         */
	        var low_barrier_element = document.getElementById('barrier_low');
	        if (low_barrier_element) {
	            low_barrier_element.addEventListener('input', commonTrading.debounce(function (e) {
	                Defaults.set('barrier_low', e.target.value);
	                Price.processPriceRequest();
	                commonTrading.submitForm(document.getElementById('websocket_form'));
	            }));
	            low_barrier_element.addEventListener('keypress', function (ev) {
	                onlyNumericOnKeypress(ev, [43, 45, 46]);
	            });
	        }

	        /*
	         * attach an event to change in high barrier
	         */
	        var high_barrier_element = document.getElementById('barrier_high');
	        if (high_barrier_element) {
	            high_barrier_element.addEventListener('input', commonTrading.debounce(function (e) {
	                Defaults.set('barrier_high', e.target.value);
	                Price.processPriceRequest();
	                commonTrading.submitForm(document.getElementById('websocket_form'));
	            }));
	            high_barrier_element.addEventListener('keypress', function (ev) {
	                onlyNumericOnKeypress(ev, [43, 45, 46]);
	            });
	        }

	        /*
	         * attach an event to change in digit prediction input
	         */
	        var prediction_element = document.getElementById('prediction');
	        if (prediction_element) {
	            prediction_element.addEventListener('change', commonTrading.debounce(function (e) {
	                Defaults.set('prediction', e.target.value);
	                Price.processPriceRequest();
	                commonTrading.submitForm(document.getElementById('websocket_form'));
	            }));
	        }

	        // For verifying there are 2 digits after decimal
	        var isStandardFloat = function isStandardFloat(value) {
	            return !isNaN(value) && value % 1 !== 0 && (+parseFloat(value)).toFixed(10).replace(/^-?\d*\.?|0+$/g, '').length > 2;
	        };

	        var init_logo = document.getElementById('trading_init_progress');
	        if (init_logo) {
	            init_logo.addEventListener('click', commonTrading.debounce(function () {
	                commonTrading.reloadPage();
	            }));
	        }

	        var tip = document.getElementById('symbol_tip');
	        if (tip) {
	            tip.addEventListener('click', commonTrading.debounce(function (e) {
	                BinaryPjax.load(e.target.getAttribute('target'));
	            }));
	        }
	    };

	    var attachTimePicker = function attachTimePicker() {
	        var date_start = document.getElementById('date_start').value;
	        var now = !date_start || date_start === 'now';
	        var current_moment = now ? window.time ? window.time : moment.utc() : parseInt(date_start) * 1000;
	        TimePicker.init({
	            selector: '#expiry_time',
	            minTime: current_moment
	        });
	    };

	    return {
	        init: initiate
	    };
	}();

	module.exports = TradingEvents;

/***/ },
/* 538 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var Barriers = __webpack_require__(442);
	var commonTrading = __webpack_require__(445);
	var commonIndependent = __webpack_require__(443);
	var Contract = __webpack_require__(444);
	var Defaults = __webpack_require__(437);
	var Price = __webpack_require__(539);
	var BinarySocket = __webpack_require__(427);
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var elementTextContent = __webpack_require__(430).elementTextContent;
	var isVisible = __webpack_require__(430).isVisible;
	var toISOFormat = __webpack_require__(449).toISOFormat;
	var toReadableFormat = __webpack_require__(449).toReadableFormat;
	var DatePicker = __webpack_require__(519);

	/*
	 * Handles duration processing display
	 *
	 * It process `Contract.durations()` and display them according to
	 * the current `Contract.form()` and `Contract.barriers()`
	 *
	 * It also populate expiry type select box i.e Durations and Endtime select
	 *
	 */

	var Durations = function () {
	    'use strict';

	    var selected_duration = {},
	        has_end_date = 0;

	    var displayDurations = function displayDurations() {
	        var start_type = void 0;
	        if (Defaults.get('date_start') !== 'now' && State.get('is_start_dates_displayed') && moment(Defaults.get('date_start') * 1000).isAfter(moment())) {
	            start_type = 'forward';
	        } else {
	            start_type = 'spot';
	        }

	        var durations = Contract.durations();
	        if (durations === false) {
	            document.getElementById('expiry_row').style.display = 'none';
	            Defaults.remove('expiry_type', 'duration_amount', 'duration_units', 'expiry_date', 'expiry_time');
	            return;
	        }

	        var target = document.getElementById('duration_units');
	        var form_name = Contract.form();
	        var barrier_category = Contract.barrier();
	        var duration_container = {};

	        while (target && target.firstChild) {
	            target.removeChild(target.firstChild);
	        }

	        Object.keys(durations).forEach(function (key) {
	            Object.keys(durations[key][form_name]).forEach(function (form) {
	                var obj = {};
	                if (barrier_category) {
	                    obj = durations[key][form_name][barrier_category];
	                } else {
	                    obj = durations[key][form_name][form];
	                }
	                Object.keys(obj).forEach(function (type) {
	                    if (start_type) {
	                        if (start_type === type) {
	                            if (!duration_container.hasOwnProperty(start_type)) {
	                                duration_container[key] = obj[start_type];
	                            }
	                        }
	                    } else if (!duration_container.hasOwnProperty(type)) {
	                        duration_container[key] = obj[type];
	                    }
	                });
	            });
	        });

	        var duration_list = {};
	        Object.keys(duration_container).forEach(function (duration) {
	            var text_mapping_min = durationTextValueMappings(duration_container[duration].min_contract_duration);
	            var text_mapping_max = durationTextValueMappings(duration_container[duration].max_contract_duration);
	            var min_unit = text_mapping_min.unit;

	            if (duration === 'intraday') {
	                switch (min_unit) {
	                    case 's':
	                        duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max);
	                        duration_list.m = makeDurationOption(durationTextValueMappings('1m'), text_mapping_max, true);
	                        duration_list.h = makeDurationOption(durationTextValueMappings('1h'), text_mapping_max);
	                        break;
	                    case 'm':
	                        duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max, true);
	                        duration_list.h = makeDurationOption(durationTextValueMappings('1h'), text_mapping_max);
	                        break;
	                    case 'h':
	                        duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max);
	                        break;
	                    default:
	                        duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max);
	                        break;
	                }
	            } else if (duration === 'daily' || duration === 'tick') {
	                duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max);
	            }
	        });
	        var list = Object.keys(duration_list).sort(function (a, b) {
	            return commonTrading.durationOrder(a) > commonTrading.durationOrder(b) ? 1 : -1;
	        });
	        has_end_date = 0;
	        for (var k = 0; k < list.length; k++) {
	            var d = list[k];
	            if (d !== 't') {
	                has_end_date = 1;
	            }
	            if (duration_list.hasOwnProperty(d)) {
	                target.appendChild(duration_list[d]);
	            }
	        }

	        if (selected_duration.unit) {
	            if (!commonTrading.selectOption(selected_duration.unit, target)) {
	                selected_duration = {};
	            }
	        }

	        durationPopulate();
	    };

	    var makeDurationOption = function makeDurationOption(map_min, map_max, is_selected) {
	        var option = document.createElement('option');
	        var content = document.createTextNode(map_min.text);
	        option.setAttribute('value', map_min.unit);
	        option.setAttribute('data-minimum', map_min.value);
	        if (map_max.value && map_max.unit) {
	            var max = convertDurationUnit(map_max.value, map_max.unit, map_min.unit);
	            if (max) {
	                option.setAttribute('data-maximum', max);
	            }
	        }
	        if (is_selected) {
	            option.setAttribute('selected', 'selected');
	        }
	        option.appendChild(content);
	        return option;
	    };

	    var convertDurationUnit = function convertDurationUnit(value, from_unit, to_unit) {
	        if (!value || !from_unit || !to_unit) return null;
	        if (from_unit === to_unit) return value;
	        var seconds = {
	            s: 1,
	            m: 60,
	            h: 3600,
	            d: 3600 * 24
	        };
	        return value * seconds[from_unit] / seconds[to_unit];
	    };

	    var displayEndTime = function displayEndTime() {
	        var date_start = document.getElementById('date_start').value;
	        var now = !date_start || date_start === 'now';
	        var current_moment = moment(now ? window.time : parseInt(date_start) * 1000).add(5, 'minutes').utc();
	        var expiry_date = Defaults.get('expiry_date') ? moment(Defaults.get('expiry_date')) : current_moment,
	            expiry_time = Defaults.get('expiry_time') || current_moment.format('HH:mm'),
	            expiry_date_iso = toISOFormat(expiry_date);

	        if (moment(expiry_date_iso + ' ' + expiry_time).valueOf() < current_moment.valueOf()) {
	            expiry_date = current_moment;
	            expiry_date_iso = toISOFormat(expiry_date);
	            expiry_time = current_moment.format('HH:mm');
	        }

	        var expiry_date_el = document.getElementById('expiry_date');
	        var expiry_time_el = document.getElementById('expiry_time');

	        expiry_date_el.value = toReadableFormat(expiry_date);
	        expiry_date_el.setAttribute('data-value', expiry_date_iso);
	        expiry_time_el.value = expiry_time;
	        expiry_time_el.setAttribute('data-value', expiry_time);
	        Defaults.set('expiry_date', expiry_date_iso);
	        Defaults.set('expiry_time', expiry_time);
	        Durations.setTime(expiry_time);

	        durationPopulate();
	    };

	    var durationTextValueMappings = function durationTextValueMappings(str) {
	        var mapping = {
	            s: localize('seconds'),
	            m: localize('minutes'),
	            h: localize('hours'),
	            d: localize('days'),
	            t: localize('ticks')
	        };

	        var arry = str ? str.toString().match(/[a-zA-Z]+|[0-9]+/g) : [];
	        var obj = {};

	        if (arry.length > 1) {
	            obj.unit = arry[1];
	            obj.text = mapping[arry[1]];
	            obj.value = arry[0];
	        } else {
	            obj.unit = 't';
	            obj.text = mapping.t;
	            obj.value = arry[0];
	        }

	        return obj;
	    };

	    var durationPopulate = function durationPopulate() {
	        var unit = document.getElementById('duration_units');
	        if (!unit.options[unit.selectedIndex]) return;
	        var unit_min_value = unit.options[unit.selectedIndex].getAttribute('data-minimum');
	        var unit_max_value = unit.options[unit.selectedIndex].getAttribute('data-maximum');
	        var unit_value = Defaults.get('duration_amount') || unit_min_value;
	        unit.value = Defaults.get('duration_units') && document.querySelectorAll('select[id="duration_units"] [value="' + Defaults.get('duration_units') + '"]').length ? Defaults.get('duration_units') : unit.value;
	        elementTextContent(document.getElementById('duration_minimum'), unit_min_value);
	        elementTextContent(document.getElementById('duration_maximum'), unit_max_value);
	        if (selected_duration.amount && selected_duration.unit > unit_value) {
	            unit_value = selected_duration.amount;
	        }
	        document.getElementById('duration_amount').value = unit_value;
	        Defaults.set('duration_amount', unit_value);
	        displayExpiryType();
	        Defaults.set('duration_units', unit.value);

	        // jquery for datepicker
	        var amount_element = $('#duration_amount');
	        var duration_id = '#duration_amount';
	        if (unit.value === 'd') {
	            var tomorrow = window.time ? new Date(window.time.valueOf()) : new Date();
	            tomorrow.setDate(tomorrow.getDate() + 1);
	            DatePicker.init({
	                selector: duration_id,
	                type: 'diff',
	                minDate: 1,
	                maxDate: 364,
	                native: false
	            });
	            amount_element.change(function (value) {
	                var day_diff = void 0;
	                var $duration_amount_val = $('#duration_amount').val();
	                if ($duration_amount_val) {
	                    day_diff = $duration_amount_val;
	                } else {
	                    value = value.target.getAttribute('data-value');
	                    var date = value ? new Date(value) : new Date();
	                    var today = window.time ? window.time.valueOf() : new Date();
	                    day_diff = Math.ceil((date - today) / (1000 * 60 * 60 * 24));
	                }
	                amount_element.val(day_diff);
	            });
	        } else {
	            DatePicker.hide(duration_id);
	        }

	        if ($('#expiry_date').is(':visible')) {
	            DatePicker.init({
	                selector: '#expiry_date',
	                minDate: 0,
	                maxDate: 364
	            });
	        }

	        validateMinDurationAmount();
	        // we need to call it here as for days we need to show absolute barriers
	        Barriers.display();
	    };

	    var displayExpiryType = function displayExpiryType() {
	        var target = document.getElementById('expiry_type');
	        var fragment = document.createDocumentFragment();

	        // in case of having endtime as expiry_type and change the form to contract types
	        // which only have duration and do not support endtime, it should change the Default value
	        // to get corrected based on contract situations
	        if ($('#expiry_type').find('option[value=' + Defaults.get('expiry_type') + ']').length === 0 && target.value) {
	            Defaults.set('expiry_type', target.value);
	        }
	        var current_selected = Defaults.get('expiry_type') || target.value || 'duration';
	        var id = current_selected,
	            hide_id = current_selected === 'duration' ? 'endtime' : 'duration';

	        id = document.getElementById('expiry_type_' + id);
	        if (id) {
	            id.style.display = 'flex';
	        }
	        // need to hide the non selected one
	        hide_id = document.getElementById('expiry_type_' + hide_id);
	        if (hide_id) {
	            hide_id.style.display = 'none';
	        }

	        while (target && target.firstChild) {
	            target.removeChild(target.firstChild);
	        }

	        var option = document.createElement('option'),
	            content = document.createTextNode(localize('Duration'));

	        option.setAttribute('value', 'duration');
	        if (current_selected === 'duration') {
	            option.setAttribute('selected', 'selected');
	        }
	        option.appendChild(content);
	        fragment.appendChild(option);

	        if (has_end_date) {
	            option = document.createElement('option');
	            content = document.createTextNode(localize('End Time'));
	            option.setAttribute('value', 'endtime');
	            if (current_selected === 'endtime') {
	                option.setAttribute('selected', 'selected');
	            }
	            option.appendChild(content);
	            fragment.appendChild(option);
	        }
	        target.appendChild(fragment);
	    };

	    var selectEndDate = function selectEndDate(end_date) {
	        var expiry_time = document.getElementById('expiry_time');
	        var date_start = document.getElementById('date_start');
	        var end_date_readable = toReadableFormat(end_date);
	        var end_date_iso = toISOFormat(end_date);
	        $('#expiry_date').val(end_date_readable).attr('data-value', end_date_iso);
	        Defaults.set('expiry_date', end_date_iso);
	        if (end_date.isAfter(window.time.format('YYYY-MM-DD HH:mm'), 'day')) {
	            Durations.setTime('');
	            Defaults.remove('expiry_time');
	            setNow(); // start time
	            date_start.setAttribute('disabled', 'disabled');
	            expiry_time.hide();
	            Barriers.display();
	            processTradingTimesRequest(end_date_iso);
	        } else {
	            date_start.removeAttribute('disabled');
	            if (!expiry_time.value) {
	                var new_time = moment(window.time).add(5, 'minutes').utc().format('HH:mm');
	                expiry_time.value = new_time;
	                expiry_time.setAttribute('data-value', new_time);
	            }
	            Durations.setTime(expiry_time.value);
	            Defaults.set('expiry_time', Defaults.get('expiry_time') || expiry_time.value);
	            expiry_time.show();
	            Barriers.display();
	            Price.processPriceRequest();
	        }
	    };

	    var processTradingTimesRequest = function processTradingTimesRequest(date) {
	        var trading_times = commonIndependent.getTradingTimes();
	        if (trading_times.hasOwnProperty(date)) {
	            Price.processPriceRequest();
	        } else {
	            commonTrading.showPriceOverlay();
	            BinarySocket.send({ trading_times: date }).then(function (response) {
	                commonIndependent.processTradingTimesAnswer(response);
	                Price.processPriceRequest();
	            });
	        }
	    };

	    var validateMinDurationAmount = function validateMinDurationAmount() {
	        var duration_amount_element = document.getElementById('duration_amount');
	        var duration_min_element = document.getElementById('duration_minimum');
	        var duration_max_element = document.getElementById('duration_maximum');
	        if (!isVisible(duration_amount_element) || !isVisible(duration_min_element)) return;
	        if (+duration_amount_element.value < +duration_min_element.textContent || +duration_max_element.textContent && +duration_amount_element.value > +duration_max_element.textContent) {
	            duration_amount_element.classList.add('error-field');
	        } else {
	            duration_amount_element.classList.remove('error-field');
	        }
	    };

	    var onStartDateChange = function onStartDateChange(value) {
	        var $date_start_select = $('#date_start');
	        if (!value || !$date_start_select.find('option[value=' + value + ']').length) {
	            return 0;
	        }

	        var yellow_border = 'light-yellow-background';
	        if (value !== 'now') {
	            $date_start_select.addClass(yellow_border);
	        } else {
	            $date_start_select.removeClass(yellow_border);
	        }

	        $date_start_select.val(value);

	        var make_price_request = 1;
	        var $expiry_time = $('#expiry_time');
	        if (value !== 'now' && Defaults.get('expiry_type') === 'endtime') {
	            make_price_request = -1;
	            var end_time = moment(parseInt(value) * 1000).add(5, 'minutes').utc();
	            Durations.setTime(commonTrading.timeIsValid($expiry_time) && Defaults.get('expiry_time') ? Defaults.get('expiry_time') : end_time.format('HH:mm'));
	            Durations.selectEndDate(commonTrading.timeIsValid($expiry_time) && (Defaults.get('expiry_date') ? moment(Defaults.get('expiry_date')) : end_time));
	        }
	        commonTrading.timeIsValid($expiry_time);
	        Durations.display();
	        return make_price_request;
	    };

	    var setNow = function setNow() {
	        var $date_start = $('#date_start');
	        if ($date_start.find('option[value="now"]').length) {
	            $date_start.val('now').removeClass('light-yellow-background');
	            Defaults.set('date_start', 'now');
	        }
	    };

	    return {
	        display: displayDurations,
	        displayEndTime: displayEndTime,
	        populate: durationPopulate,
	        selectEndDate: selectEndDate,
	        validateMinDurationAmount: validateMinDurationAmount,
	        onStartDateChange: onStartDateChange,
	        setTime: function setTime(time) {
	            $('#expiry_time').val(time);Defaults.set('expiry_time', time);
	        },
	        selectAmount: function selectAmount(a) {
	            selected_duration.amount = a;
	        },
	        selectUnit: function selectUnit(u) {
	            selected_duration.unit = u;
	        }
	    };
	}();

	module.exports = Durations;

/***/ },
/* 539 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var moment = __webpack_require__(305);
	var getStartDateNode = __webpack_require__(443).getStartDateNode;
	var commonTrading = __webpack_require__(445);
	var displayPriceMovement = __webpack_require__(443).displayPriceMovement;
	var getTradingTimes = __webpack_require__(443).getTradingTimes;
	var Contract = __webpack_require__(444);
	var Defaults = __webpack_require__(437);
	var BinarySocket = __webpack_require__(427);
	var localize = __webpack_require__(428).localize;
	var elementTextContent = __webpack_require__(430).elementTextContent;
	var isVisible = __webpack_require__(430).isVisible;
	var formatMoney = __webpack_require__(433).formatMoney;

	/*
	 * Price object handles all the functions we need to display prices
	 *
	 * We create Price proposal that we need to send to server to get price,
	 * longcode and all other information that we need to get the price for
	 * current contract
	 *
	 *
	 * Usage:
	 *
	 * `socket.send(Price.proposal())` to send price proposal to sever
	 * `Price.display()` to display the price details returned from server
	 */
	var Price = function () {
	    'use strict';

	    var type_display_id_mapping = {},
	        form_id = 0;

	    var createProposal = function createProposal(type_of_contract) {
	        var proposal = {
	            proposal: 1,
	            subscribe: 1
	        };
	        var contract_type = type_of_contract;
	        var start_time = getStartDateNode();
	        var underlying = document.getElementById('underlying');
	        var amount_type = document.getElementById('amount_type');
	        var currency = document.getElementById('currency');
	        var payout = document.getElementById('amount');
	        var expiry_type = document.getElementById('expiry_type');
	        var duration = document.getElementById('duration_amount');
	        var duration_unit = document.getElementById('duration_units');
	        var end_date = document.getElementById('expiry_date');
	        var barrier = document.getElementById('barrier');
	        var high_barrier = document.getElementById('barrier_high');
	        var low_barrier = document.getElementById('barrier_low');
	        var prediction = document.getElementById('prediction');

	        if (payout && isVisible(payout) && payout.value) {
	            proposal.amount = parseFloat(payout.value);
	        }

	        if (amount_type && isVisible(amount_type) && amount_type.value) {
	            proposal.basis = amount_type.value;
	        }

	        if (contract_type) {
	            proposal.contract_type = type_of_contract;
	        }

	        if (currency && (currency.value || currency.getAttribute('value'))) {
	            proposal.currency = currency.value || currency.getAttribute('value');
	        }

	        if (underlying && underlying.value) {
	            proposal.symbol = underlying.value;
	        }

	        if (start_time && isVisible(start_time) && start_time.value !== 'now') {
	            proposal.date_start = start_time.value;
	        }

	        if (expiry_type && isVisible(expiry_type) && expiry_type.value === 'duration') {
	            proposal.duration = parseInt(duration.value);
	            proposal.duration_unit = duration_unit.value;
	        } else if (expiry_type && isVisible(expiry_type) && expiry_type.value === 'endtime') {
	            var end_date2 = end_date.getAttribute('data-value');
	            var end_time2 = Defaults.get('expiry_time');
	            if (!end_time2) {
	                var trading_times = getTradingTimes();
	                if (trading_times.hasOwnProperty(end_date2) && _typeof(trading_times[end_date2][underlying.value]) === 'object' && trading_times[end_date2][underlying.value].length && trading_times[end_date2][underlying.value][0] !== '--') {
	                    if (trading_times[end_date2][underlying.value].length > 1) {
	                        end_time2 = trading_times[end_date2][underlying.value][1];
	                    } else {
	                        end_time2 = trading_times[end_date2][underlying.value];
	                    }
	                }
	            }

	            proposal.date_expiry = moment.utc(end_date2 + ' ' + (end_time2 || '23:59:59')).unix();
	            // For stopping tick trade behaviour
	            proposal.duration_unit = 'm';
	        }

	        if (barrier && isVisible(barrier) && barrier.value) {
	            proposal.barrier = barrier.value;
	        }

	        if (high_barrier && isVisible(high_barrier) && high_barrier.value) {
	            proposal.barrier = high_barrier.value;
	        }

	        if (low_barrier && isVisible(low_barrier) && low_barrier.value) {
	            proposal.barrier2 = low_barrier.value;
	        }

	        if (prediction && isVisible(prediction)) {
	            proposal.barrier = parseInt(prediction.value);
	        }

	        if (contract_type) {
	            proposal.contract_type = type_of_contract;
	        }

	        proposal.passthrough = {
	            form_id: form_id
	        };

	        commonTrading.resetPriceMovement();

	        return proposal;
	    };

	    var display = function display(details, contract_type) {
	        var proposal = details.proposal;
	        var id = proposal ? proposal.id : '';
	        var params = details.echo_req;

	        var type = params.contract_type;
	        if (id && !type) {
	            type = type_display_id_mapping[id];
	        }

	        if (params && id && Object.getOwnPropertyNames(params).length > 0) {
	            type_display_id_mapping[id] = type;
	        }

	        var position = commonTrading.contractTypeDisplayMapping(type);

	        if (!position) {
	            return;
	        }

	        var container = document.getElementById('price_container_' + position);
	        if (!container) return;
	        if (!$(container).is(':visible')) {
	            $(container).fadeIn(200);
	        }

	        var h4 = container.getElementsByClassName('contract_heading')[0];
	        var amount = container.getElementsByClassName('contract_amount')[0];
	        var payout_amount = container.getElementsByClassName('contract_payout')[0];
	        var stake = container.getElementsByClassName('stake')[0];
	        var payout = container.getElementsByClassName('payout')[0];
	        var purchase = container.getElementsByClassName('purchase_button')[0];
	        var description = container.getElementsByClassName('contract_description')[0];
	        var comment = container.getElementsByClassName('price_comment')[0];
	        var error = container.getElementsByClassName('contract_error')[0];
	        var currency = document.getElementById('currency');

	        var display_text = type && contract_type ? contract_type[type] : '';
	        if (display_text) {
	            h4.setAttribute('class', 'contract_heading ' + type);
	            elementTextContent(h4, display_text);
	        }

	        var setData = function setData(data) {
	            if (!data) return;
	            if (data.display_value) {
	                $('.stake:hidden').show();
	                elementTextContent(stake, localize('Stake') + ': ');
	                elementTextContent(amount, formatMoney(currency.value || currency.getAttribute('value'), data.display_value));
	                $('.stake_wrapper:hidden').show();
	            } else {
	                $('.stake_wrapper:visible').hide();
	            }

	            if (data.payout) {
	                elementTextContent(payout, localize('Payout') + ': ');
	                elementTextContent(payout_amount, formatMoney(currency.value || currency.getAttribute('value'), data.payout));
	                $('.payout_wrapper:hidden').show();
	            } else {
	                $('.payout_wrapper:visible').hide();
	            }

	            if (data.longcode && window.innerWidth > 500) {
	                description.setAttribute('data-balloon', data.longcode);
	            } else {
	                description.removeAttribute('data-balloon');
	            }
	        };

	        if (details.error) {
	            purchase.hide();
	            comment.hide();
	            setData(details.error.details);
	            error.show();
	            elementTextContent(error, details.error.message);
	        } else {
	            setData(proposal);
	            if ($('#websocket_form').find('.error-field:visible').length > 0) {
	                purchase.hide();
	            } else {
	                purchase.show();
	            }
	            comment.show();
	            error.hide();
	            commonTrading.displayCommentPrice(comment, currency.value || currency.getAttribute('value'), proposal.ask_price, proposal.payout);
	            var old_price = purchase.getAttribute('data-display_value');
	            var old_payout = purchase.getAttribute('data-payout');
	            displayPriceMovement(amount, old_price, proposal.display_value);
	            displayPriceMovement(payout_amount, old_payout, proposal.payout);
	            purchase.setAttribute('data-purchase-id', id);
	            purchase.setAttribute('data-ask-price', proposal.ask_price);
	            purchase.setAttribute('data-display_value', proposal.display_value);
	            purchase.setAttribute('data-payout', proposal.payout);
	            purchase.setAttribute('data-symbol', id);
	            Object.keys(params).forEach(function (key) {
	                if (key && key !== 'proposal') {
	                    purchase.setAttribute('data-' + key, params[key]);
	                }
	            });
	        }
	    };

	    var clearMapping = function clearMapping() {
	        type_display_id_mapping = {};
	    };

	    var clearFormId = function clearFormId() {
	        form_id = 0;
	    };

	    /*
	     * Function to request for cancelling the current price proposal
	     */
	    var processForgetProposals = function processForgetProposals() {
	        commonTrading.showPriceOverlay();
	        BinarySocket.send({
	            forget_all: 'proposal'
	        });
	        Price.clearMapping();
	    };

	    /*
	     * Function to process and calculate price based on current form
	     * parameters or change in form parameters
	     */
	    var processPriceRequest = function processPriceRequest() {
	        Price.incrFormId();
	        processForgetProposals();
	        commonTrading.showPriceOverlay();
	        var types = Contract.contractType()[Contract.form()];
	        if (Contract.form() === 'digits') {
	            switch (sessionStorage.getItem('formname')) {
	                case 'matchdiff':
	                    types = {
	                        DIGITMATCH: 1,
	                        DIGITDIFF: 1
	                    };
	                    break;
	                case 'evenodd':
	                    types = {
	                        DIGITEVEN: 1,
	                        DIGITODD: 1
	                    };
	                    break;
	                case 'overunder':
	                    types = {
	                        DIGITOVER: 1,
	                        DIGITUNDER: 1
	                    };
	                    break;
	                default:
	                    break;
	            }
	        }
	        Object.keys(types).forEach(function (type_of_contract) {
	            BinarySocket.send(Price.proposal(type_of_contract), { callback: function callback(response) {
	                    if (response.echo_req && response.echo_req !== null && response.echo_req.passthrough && response.echo_req.passthrough.form_id === form_id) {
	                        commonTrading.hideOverlayContainer();
	                        Price.display(response, Contract.contractType()[Contract.form()]);
	                        commonTrading.hidePriceOverlay();
	                    }
	                } });
	        });
	    };

	    return {
	        proposal: createProposal,
	        display: display,
	        clearMapping: clearMapping,
	        clearFormId: clearFormId,
	        idDisplayMapping: function idDisplayMapping() {
	            return type_display_id_mapping;
	        },
	        incrFormId: function incrFormId() {
	            form_id++;
	        },

	        processForgetProposals: processForgetProposals,
	        processPriceRequest: processPriceRequest
	    };
	}();

	module.exports = Price;

/***/ },
/* 540 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var moment = __webpack_require__(305);
	var TradingAnalysis = __webpack_require__(508);
	var commonTrading = __webpack_require__(445);
	var processTradingTimesAnswer = __webpack_require__(443).processTradingTimesAnswer;
	var Contract = __webpack_require__(444);
	var Defaults = __webpack_require__(437);
	var Durations = __webpack_require__(538);
	var GetTicks = __webpack_require__(441);
	var Notifications = __webpack_require__(446);
	var Price = __webpack_require__(539);
	var StartDates = __webpack_require__(541).StartDates;
	var Symbols = __webpack_require__(447);
	var Tick = __webpack_require__(448);
	var BinarySocket = __webpack_require__(427);
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var elementInnerHtml = __webpack_require__(430).elementInnerHtml;

	var Process = function () {
	    'use strict';

	    /*
	     * This function process the active symbols to get markets
	     * and underlying list
	     */

	    var processActiveSymbols = function processActiveSymbols() {
	        BinarySocket.send({ active_symbols: 'brief' }).then(function (response) {
	            // populate the Symbols object
	            Symbols.details(response);

	            var market = commonTrading.getDefaultMarket();

	            // store the market
	            Defaults.set('market', market);

	            commonTrading.displayMarkets('contract_markets', Symbols.markets(), market);
	            processMarket();
	        });
	    };

	    /*
	     * Function to call when market has changed
	     */
	    var processMarket = function processMarket() {
	        // we can get market from sessionStorage as allowed market
	        // is already set when this is called
	        var market = Defaults.get('market'),
	            symbol = Defaults.get('underlying');

	        // change to default market if query string contains an invalid market
	        if (!market || !Symbols.underlyings()[market]) {
	            market = commonTrading.getDefaultMarket();
	            Defaults.set('market', market);
	        }
	        if (!symbol || !Symbols.underlyings()[market][symbol]) {
	            symbol = undefined;
	        }
	        commonTrading.displayUnderlyings('underlying', Symbols.underlyings()[market], symbol);

	        processMarketUnderlying();
	    };

	    /*
	     * Function to call when underlying has changed
	     */
	    var processMarketUnderlying = function processMarketUnderlying() {
	        var underlying_element = document.getElementById('underlying');
	        if (!underlying_element) {
	            return;
	        }

	        if (underlying_element.selectedIndex < 0) {
	            underlying_element.selectedIndex = 0;
	        }
	        var underlying = underlying_element.value;
	        Defaults.set('underlying', underlying);

	        commonTrading.showFormOverlay();

	        // get ticks for current underlying
	        GetTicks.request(underlying);

	        Tick.clean();

	        commonTrading.updateWarmChart();

	        BinarySocket.clearTimeouts();

	        getContracts(underlying);

	        commonTrading.displayTooltip(Defaults.get('market'), underlying);
	    };

	    var getContracts = function getContracts(underlying) {
	        BinarySocket.send({ contracts_for: underlying }).then(function (response) {
	            Notifications.hide('CONNECTION_ERROR');
	            processContract(response);
	        });
	    };

	    /*
	     * Function to display contract form for current underlying
	     */
	    var processContract = function processContract(contracts) {
	        if (contracts.hasOwnProperty('error') && contracts.error.code === 'InvalidSymbol') {
	            Price.processForgetProposals();
	            var container = document.getElementById('contract_confirmation_container');
	            var message_container = document.getElementById('confirmation_message');
	            var confirmation_error = document.getElementById('confirmation_error');
	            var contracts_list = document.getElementById('contracts_list');
	            container.style.display = 'block';
	            contracts_list.style.display = 'none';
	            message_container.hide();
	            confirmation_error.show();
	            elementInnerHtml(confirmation_error, contracts.error.message + ' <a href="javascript:;" onclick="sessionStorage.removeItem(\'underlying\'); window.location.reload();">' + localize('Please reload the page') + '</a>');
	            return;
	        }

	        State.set('is_chart_allowed', !(contracts.contracts_for && contracts.contracts_for.feed_license && contracts.contracts_for.feed_license === 'chartonly'));

	        document.getElementById('trading_socket_container').classList.add('show');
	        var init_logo = document.getElementById('trading_init_progress');
	        if (init_logo.style.display !== 'none') {
	            init_logo.style.display = 'none';
	            Defaults.update();
	        }

	        Contract.setContracts(contracts);

	        var contract_categories = Contract.contractForms();
	        var formname = void 0;
	        if (Defaults.get('formname') && contract_categories && contract_categories[Defaults.get('formname')]) {
	            formname = Defaults.get('formname');
	        } else {
	            var tree = commonTrading.getContractCategoryTree(contract_categories);
	            if (tree[0]) {
	                if (_typeof(tree[0]) === 'object') {
	                    formname = tree[0][1][0];
	                } else {
	                    formname = tree[0];
	                }
	            }
	        }

	        // set form to session storage
	        Defaults.set('formname', formname);

	        commonTrading.displayContractForms('contract_form_name_nav', contract_categories, formname);

	        processContractForm();

	        TradingAnalysis.request();

	        commonTrading.hideFormOverlay();
	    };

	    var processContractForm = function processContractForm() {
	        Contract.details(sessionStorage.getItem('formname'));

	        StartDates.display();

	        displayPrediction();

	        var r1 = void 0;
	        if (State.get('is_start_dates_displayed') && Defaults.get('date_start') && Defaults.get('date_start') !== 'now') {
	            r1 = Durations.onStartDateChange(Defaults.get('date_start'));
	            if (!r1 || Defaults.get('expiry_type') === 'endtime') Durations.display();
	        } else {
	            Durations.display();
	        }

	        if (Defaults.get('amount')) $('#amount').val(Defaults.get('amount'));else Defaults.set('amount', document.getElementById('amount').value);
	        if (Defaults.get('amount_type')) commonTrading.selectOption(Defaults.get('amount_type'), document.getElementById('amount_type'));else Defaults.set('amount_type', document.getElementById('amount_type').value);
	        if (Defaults.get('currency')) commonTrading.selectOption(Defaults.get('currency'), document.getElementById('currency'));

	        var expiry_type = Defaults.get('expiry_type') || 'duration';
	        var make_price_request = onExpiryTypeChange(expiry_type);

	        if (make_price_request >= 0) {
	            Price.processPriceRequest();
	        }
	    };

	    var displayPrediction = function displayPrediction() {
	        var prediction_element = document.getElementById('prediction_row');
	        if (Contract.form() === 'digits' && sessionStorage.getItem('formname') !== 'evenodd') {
	            prediction_element.show();
	            if (Defaults.get('prediction')) {
	                commonTrading.selectOption(Defaults.get('prediction'), document.getElementById('prediction'));
	            } else {
	                Defaults.set('prediction', document.getElementById('prediction').value);
	            }
	        } else {
	            prediction_element.hide();
	            Defaults.remove('prediction');
	        }
	    };

	    var forgetTradingStreams = function forgetTradingStreams() {
	        Price.processForgetProposals();
	        processForgetTicks();
	    };

	    /*
	     * cancel the current tick stream
	     * this need to be invoked before makin
	     */
	    var processForgetTicks = function processForgetTicks() {
	        BinarySocket.send({
	            forget_all: 'ticks'
	        });
	    };

	    var processTradingTimes = function processTradingTimes(response) {
	        processTradingTimesAnswer(response);
	        Price.processPriceRequest();
	    };

	    var onExpiryTypeChange = function onExpiryTypeChange(value) {
	        var $expiry_type = $('#expiry_type');
	        if (!value || !$expiry_type.find('option[value=' + value + ']').length) {
	            value = 'duration';
	        }
	        $expiry_type.val(value);

	        var make_price_request = 0;
	        if (value === 'endtime') {
	            Durations.displayEndTime();
	            if (Defaults.get('expiry_date')) {
	                Durations.selectEndDate(moment(Defaults.get('expiry_date')));
	                make_price_request = -1;
	            }
	            Defaults.remove('duration_units', 'duration_amount');
	        } else {
	            StartDates.enable();
	            Durations.display();
	            if (Defaults.get('duration_units')) {
	                onDurationUnitChange(Defaults.get('duration_units'));
	            }
	            var duration_amount = Defaults.get('duration_amount');
	            if (duration_amount && duration_amount > $('#duration_minimum').text()) {
	                $('#duration_amount').val(duration_amount);
	            }
	            make_price_request = 1;
	            Defaults.remove('expiry_date', 'expiry_time', 'end_date');
	            Durations.validateMinDurationAmount();
	        }

	        return make_price_request;
	    };

	    var onDurationUnitChange = function onDurationUnitChange(value) {
	        var $duration_units = $('#duration_units');
	        if (!value || !$duration_units.find('option[value=' + value + ']').length) {
	            return 0;
	        }

	        $duration_units.val(value);
	        Defaults.set('duration_units', value);

	        Durations.selectUnit(value);
	        Durations.populate();

	        return 1;
	    };

	    return {
	        processActiveSymbols: processActiveSymbols,
	        processMarket: processMarket,
	        processContract: processContract,
	        processContractForm: processContractForm,
	        forgetTradingStreams: forgetTradingStreams,
	        processForgetTicks: processForgetTicks,
	        processTradingTimes: processTradingTimes,
	        onExpiryTypeChange: onExpiryTypeChange,
	        onDurationUnitChange: onDurationUnitChange
	    };
	}();

	module.exports = Process;

/***/ },
/* 541 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var getStartDateNode = __webpack_require__(443).getStartDateNode;
	var Contract = __webpack_require__(444);
	var Defaults = __webpack_require__(437);
	var Durations = __webpack_require__(538);
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;

	/*
	 * Handles start time display
	 *
	 * It process `Contract.startDates` in case of forward
	 * starting contracts and populate the start time select
	 * box
	 */

	var StartDates = function () {
	    'use strict';

	    var has_now = 0;
	    State.remove('is_start_dates_displayed');

	    var compareStartDate = function compareStartDate(a, b) {
	        return a.date < b.date ? -1 : a.date > b.date ? 1 : 0;
	    };

	    var displayStartDates = function displayStartDates() {
	        var start_dates = Contract.startDates();

	        if (start_dates && start_dates.list && start_dates.list.length) {
	            var target = getStartDateNode();
	            var fragment = document.createDocumentFragment();
	            var row = document.getElementById('date_start_row');
	            var option = void 0,
	                content = void 0;

	            row.style.display = 'flex';

	            while (target && target.firstChild) {
	                target.removeChild(target.firstChild);
	            }

	            if (start_dates.has_spot) {
	                option = document.createElement('option');
	                content = document.createTextNode(localize('Now'));
	                option.setAttribute('value', 'now');
	                $('#date_start').removeClass('light-yellow-background');
	                option.appendChild(content);
	                fragment.appendChild(option);
	                has_now = 1;
	            } else {
	                has_now = 0;
	            }

	            start_dates.list.sort(compareStartDate);

	            var first = void 0;
	            start_dates.list.forEach(function (start_date) {
	                var a = moment.unix(start_date.open).utc();
	                var b = moment.unix(start_date.close).utc();

	                var rounding = 5 * 60 * 1000;
	                var start = moment.utc();

	                if (moment(start).isAfter(moment(a))) {
	                    a = start;
	                }

	                a = moment(Math.ceil(+a / rounding) * rounding).utc();

	                while (a.isBefore(b)) {
	                    if (a.unix() - start.unix() > 5 * 60) {
	                        option = document.createElement('option');
	                        option.setAttribute('value', a.utc().unix());
	                        if (typeof first === 'undefined' && !has_now) {
	                            first = a.utc().unix();
	                        }
	                        content = document.createTextNode(a.format('HH:mm ddd').replace(' ', ' GMT, '));
	                        if (option.value === Defaults.get('date_start')) {
	                            option.setAttribute('selected', 'selected');
	                        }
	                        option.appendChild(content);
	                        fragment.appendChild(option);
	                    }
	                    a.add(5, 'minutes');
	                }
	            });
	            target.appendChild(fragment);
	            Defaults.set('date_start', target.value);
	            State.set('is_start_dates_displayed', true);
	            if (first) {
	                Durations.onStartDateChange(first);
	            }
	        } else {
	            State.remove('is_start_dates_displayed');
	            document.getElementById('date_start_row').style.display = 'none';
	            Defaults.remove('date_start');
	        }
	    };

	    return {
	        display: displayStartDates,
	        disable: function disable() {
	            getStartDateNode().setAttribute('disabled', 'disabled');
	        },
	        enable: function enable() {
	            getStartDateNode().removeAttribute('disabled');
	        }
	    };
	}();

	module.exports = {
	    StartDates: StartDates
	};

/***/ },
/* 542 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);

	var Authenticate = function () {
	    'use strict';

	    var onLoad = function onLoad() {
	        BinarySocket.send({ get_account_status: 1 }).then(function (response) {
	            if (response.error) {
	                $('#error_message').setVisibility(1).text(response.error.message);
	            } else {
	                var status = response.get_account_status.status;
	                var authenticated = /authenticated/.test(status);
	                var age_verified = /age_verification/.test(status);
	                if (authenticated && age_verified) {
	                    $('#fully_authenticated').setVisibility(1);
	                } else if (!authenticated) {
	                    $('#not_authenticated').setVisibility(1);
	                } else if (!age_verified) {
	                    $('#needs_age_verification').setVisibility(1);
	                }
	            }
	        });
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = Authenticate;

/***/ },
/* 543 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var BinaryPjax = __webpack_require__(467);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var FormManager = __webpack_require__(483);

	var ChangePassword = function () {
	    'use strict';

	    var form_id = '#frm_change_password';

	    var init = function init() {
	        FormManager.init(form_id, [{ selector: '#old_password', validations: ['req', ['length', { min: 6, max: 25 }]] }, { selector: '#new_password', validations: ['req', 'password', ['not_equal', { to: '#old_password', name1: 'Current password', name2: 'New password' }]], re_check_field: '#repeat_password' }, { selector: '#repeat_password', validations: ['req', ['compare', { to: '#new_password' }]], exclude_request: 1 }, { request_field: 'change_password', value: 1 }]);
	        FormManager.handleSubmit({
	            form_selector: form_id,
	            fnc_response_handler: handler
	        });
	    };

	    var handler = function handler(response) {
	        if ('error' in response) {
	            $('#form_error').text(localize(response.error.message)).setVisibility(1);
	        } else {
	            $(form_id).setVisibility(0);
	            $('#msg_success').setVisibility(1);
	            setTimeout(function () {
	                Client.sendLogoutRequest(true);
	            }, 5000);
	        }
	    };

	    var onLoad = function onLoad() {
	        BinarySocket.wait('get_account_status').then(function (response) {
	            if (/has_password/.test(response.get_account_status.status)) {
	                init();
	            } else {
	                BinaryPjax.load('user/settingsws');
	            }
	        });
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = ChangePassword;

/***/ },
/* 544 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var PaymentAgentTransferUI = __webpack_require__(545);
	var BinarySocket = __webpack_require__(427);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var FormManager = __webpack_require__(483);

	var PaymentAgentTransfer = function () {
	    'use strict';

	    var balance = void 0,
	        is_authenticated_payment_agent = void 0,
	        common_request_fields = void 0,
	        $form_error = void 0;

	    var onLoad = function onLoad() {
	        PaymentAgentTransferUI.initValues();
	        BinarySocket.wait('get_settings', 'balance').then(function () {
	            is_authenticated_payment_agent = State.get(['response', 'get_settings', 'get_settings', 'is_authenticated_payment_agent']);
	            if (is_authenticated_payment_agent) {
	                init();
	            } else {
	                setFormVisibility(false);
	            }
	        });
	    };

	    var init = function init() {
	        var form_id = '#frm_paymentagent_transfer';
	        var $no_bal_err = $('#no_balance_error');
	        var currency = Client.get('currency');
	        balance = State.get(['response', 'balance', 'balance', 'balance']);
	        $form_error = $('#form_error');

	        if (!currency || +balance === 0) {
	            $('#pa_transfer_loading').remove();
	            $no_bal_err.setVisibility(1);
	            return;
	        }

	        $no_bal_err.setVisibility(0);
	        setFormVisibility(true);
	        PaymentAgentTransferUI.updateFormView(currency);

	        common_request_fields = [{ request_field: 'paymentagent_transfer', value: 1 }, { request_field: 'currency', value: currency }];

	        FormManager.init(form_id, [{ selector: '#client_id', validations: ['req', ['regular', { regex: /^\w+\d+$/, message: 'Please enter a valid Login ID.' }]], request_field: 'transfer_to' }, { selector: '#amount', validations: ['req', ['number', { type: 'float', decimals: '1, 2', min: 10, max: 2000 }]] }, { request_field: 'dry_run', value: 1 }].concat(common_request_fields));

	        FormManager.handleSubmit({
	            form_selector: form_id,
	            fnc_response_handler: responseHandler,
	            fnc_additional_check: additionalCheck
	        });

	        $('#amount').on('input change', function () {
	            checkBalance($(this).val());
	        });
	    };

	    var checkBalance = function checkBalance(amount) {
	        if (+amount > +balance) {
	            $form_error.text(localize('Insufficient balance.')).setVisibility(1);
	            return false;
	        }
	        $form_error.setVisibility(0);
	        return true;
	    };

	    var additionalCheck = function additionalCheck(req) {
	        return checkBalance(req.amount);
	    };

	    var setFormVisibility = function setFormVisibility(is_visible) {
	        if (is_visible) {
	            $('#pa_transfer_loading').remove();
	            PaymentAgentTransferUI.showForm();
	            PaymentAgentTransferUI.showNotes();
	        } else {
	            PaymentAgentTransferUI.hideForm();
	            PaymentAgentTransferUI.hideNotes();
	            if (!is_authenticated_payment_agent) {
	                $('#pa_transfer_loading').remove();
	                $('#not_pa_error').setVisibility(1);
	            }
	        }
	    };

	    var responseHandler = function responseHandler(response) {
	        var req = response.echo_req;
	        var error = response.error;

	        if (error) {
	            if (req.dry_run === 1) {
	                $form_error.text(error.message).setVisibility(1);
	                return;
	            }
	            PaymentAgentTransferUI.showTransferError(error.message);
	            return;
	        }

	        if (response.paymentagent_transfer === 2) {
	            PaymentAgentTransferUI.hideFirstForm();
	            PaymentAgentTransferUI.showConfirmation();
	            PaymentAgentTransferUI.updateConfirmView(response.client_to_full_name, req.transfer_to.toUpperCase(), req.amount, req.currency);
	            initConfirm(req);
	            return;
	        }

	        if (response.paymentagent_transfer === 1) {
	            PaymentAgentTransferUI.hideFirstForm();
	            PaymentAgentTransferUI.showDone();
	            PaymentAgentTransferUI.updateDoneView(Client.get('loginid'), req.transfer_to.toUpperCase(), req.amount, req.currency);
	        }
	    };

	    var initConfirm = function initConfirm(req) {
	        var confirm_form_id = '#frm_confirm_transfer';

	        FormManager.init(confirm_form_id, [{ request_field: 'transfer_to', value: req.transfer_to }, { request_field: 'amount', value: req.amount }].concat(common_request_fields));

	        FormManager.handleSubmit({
	            form_selector: confirm_form_id,
	            fnc_response_handler: responseHandler
	        });

	        $('#back_transfer').off('click').click(function () {
	            PaymentAgentTransferUI.showForm();
	            PaymentAgentTransferUI.showNotes();
	            PaymentAgentTransferUI.hideConfirmation();
	            PaymentAgentTransferUI.hideDone();
	            $form_error.setVisibility(0);
	        });
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = PaymentAgentTransfer;

/***/ },
/* 545 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var localize = __webpack_require__(428).localize;

	var PaymentAgentTransferUI = function () {
	    'use strict';

	    var $paymentagent_transfer = void 0,
	        $confirm_transfer = void 0,
	        $done_transfer = void 0,
	        $notes_transfer = void 0;

	    var initValues = function initValues() {
	        $paymentagent_transfer = $('#frm_paymentagent_transfer');
	        $confirm_transfer = $('#frm_confirm_transfer');
	        $done_transfer = $('#pa_transfer_done');
	        $notes_transfer = $('#paymentagent_transfer_notes');
	    };

	    var hideForm = function hideForm() {
	        $paymentagent_transfer.setVisibility(0);
	    };

	    var showForm = function showForm() {
	        $paymentagent_transfer.setVisibility(1);
	    };

	    var hideConfirmation = function hideConfirmation() {
	        $confirm_transfer.setVisibility(0);
	    };

	    var showConfirmation = function showConfirmation() {
	        $confirm_transfer.find('.errorfield').setVisibility(0).end().setVisibility(1);
	    };

	    var hideDone = function hideDone() {
	        $done_transfer.setVisibility(0);
	    };

	    var showDone = function showDone() {
	        $done_transfer.setVisibility(1);
	    };

	    var hideNotes = function hideNotes() {
	        $notes_transfer.setVisibility(0);
	    };

	    var showNotes = function showNotes() {
	        $notes_transfer.setVisibility(1);
	    };

	    var showTransferError = function showTransferError(err) {
	        $confirm_transfer.find('.errorfield').text(localize(err)).setVisibility(1);
	    };

	    var updateFormView = function updateFormView(currency) {
	        $paymentagent_transfer.find('label[for="amount"]').text(localize('Amount') + ' ' + currency);
	    };

	    var updateConfirmView = function updateConfirmView(username, loginid, amount, currency) {
	        $confirm_transfer.find('#user_name').empty().text(username).end().find('#loginid').empty().text(loginid).end().find('#confirm_amount').empty().text(currency + ' ' + amount);
	    };

	    var updateDoneView = function updateDoneView(from_id, to_id, amount, currency) {
	        var template_string = 'Your request to transfer [_1] [_2] from [_3] to [_4] has been successfully processed.';
	        var confirm_msg = localize(template_string, [amount, currency, from_id, to_id]);
	        $done_transfer.find(' > #confirm_msg').text(confirm_msg).setVisibility(1);
	    };

	    var hideFirstForm = function hideFirstForm() {
	        hideForm();
	        hideConfirmation();
	        hideNotes();
	    };

	    return {
	        initValues: initValues,
	        hideForm: hideForm,
	        showForm: showForm,
	        hideConfirmation: hideConfirmation,
	        showConfirmation: showConfirmation,
	        hideDone: hideDone,
	        showDone: showDone,
	        hideNotes: hideNotes,
	        showNotes: showNotes,
	        showTransferError: showTransferError,
	        updateFormView: updateFormView,
	        updateConfirmView: updateConfirmView,
	        updateDoneView: updateDoneView,
	        hideFirstForm: hideFirstForm
	    };
	}();

	module.exports = PaymentAgentTransferUI;

/***/ },
/* 546 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ProfitTableUI = __webpack_require__(547);
	var ViewPopup = __webpack_require__(435);
	var BinarySocket = __webpack_require__(427);
	var localize = __webpack_require__(428).localize;
	var showLocalTimeOnHover = __webpack_require__(463).showLocalTimeOnHover;
	var addTooltip = __webpack_require__(513).addTooltip;
	var buildOauthApps = __webpack_require__(513).buildOauthApps;

	var ProfitTableInit = function () {
	    var batch_size = void 0,
	        chunk_size = void 0,
	        transactions_received = void 0,
	        transaction_consumed = void 0,
	        no_more_data = void 0,
	        pending = void 0,
	        current_batch = void 0;

	    var tableExist = function tableExist() {
	        return document.getElementById('profit-table');
	    };

	    var finishedConsumed = function finishedConsumed() {
	        return transaction_consumed === transactions_received;
	    };

	    var onUnload = function onUnload() {
	        current_batch = [];
	        transaction_consumed = 0;
	        transactions_received = 0;
	        pending = false;

	        ProfitTableUI.errorMessage(null);

	        if (tableExist()) {
	            ProfitTableUI.cleanTableContent();
	        }
	    };

	    var getNextBatchTransactions = function getNextBatchTransactions() {
	        getProfitTable({ offset: transactions_received, limit: batch_size });
	        pending = true;
	    };

	    var getNextChunk = function getNextChunk() {
	        var chunk = current_batch.splice(0, chunk_size);
	        transaction_consumed += chunk.length;
	        return chunk;
	    };

	    var profitTableHandler = function profitTableHandler(response) {
	        if (response.error) {
	            ProfitTableUI.errorMessage(response.error.message);
	            return;
	        }

	        pending = false;
	        var profit_table = response.profit_table;
	        current_batch = profit_table.transactions;
	        transactions_received += current_batch.length;

	        if (current_batch.length < batch_size) {
	            no_more_data = true;
	        }

	        if (!tableExist()) {
	            ProfitTableUI.createEmptyTable().appendTo('#profit-table-container');
	            ProfitTableUI.updateProfitTable(getNextChunk());

	            // Show a message when the table is empty
	            if (transactions_received === 0 && current_batch.length === 0) {
	                $('#profit-table').find('tbody').append($('<tr/>', { class: 'flex-tr' }).append($('<td/>', { colspan: 8 }).append($('<p/>', { class: 'notice-msg center-text', text: localize('Your account has no trading activity.') }))));
	            }
	        }
	    };

	    var onScrollLoad = function onScrollLoad() {
	        $(document).scroll(function () {
	            var hidableHeight = function hidableHeight(percentage) {
	                var total_hidable = $(document).height() - $(window).height();
	                return Math.floor(total_hidable * percentage / 100);
	            };

	            var p_from_top = $(document).scrollTop();

	            if (!tableExist() || p_from_top < hidableHeight(50)) {
	                return;
	            }

	            if (finishedConsumed() && !no_more_data && !pending) {
	                getNextBatchTransactions();
	                return;
	            }

	            if (!finishedConsumed()) {
	                ProfitTableUI.updateProfitTable(getNextChunk());
	            }
	        });
	    };

	    var getProfitTable = function getProfitTable(opts) {
	        var req = { profit_table: 1, description: 1 };

	        if (opts) $.extend(true, req, opts);

	        BinarySocket.send(req).then(function (response) {
	            profitTableHandler(response);
	            showLocalTimeOnHover('td.buy-date,td.sell-date');
	            $('.barspinner').setVisibility(0);
	        });
	    };

	    var onLoad = function onLoad() {
	        batch_size = 100;
	        chunk_size = batch_size / 2;
	        transactions_received = 0;
	        transaction_consumed = 0;
	        no_more_data = false;
	        pending = false;
	        current_batch = [];

	        BinarySocket.send({ oauth_apps: 1 }).then(function (response) {
	            addTooltip(ProfitTableUI.setOauthApps(buildOauthApps(response)));
	        });
	        getNextBatchTransactions();
	        onScrollLoad();
	        ViewPopup.viewOnClick('#profit-table-container');
	    };

	    return {
	        profitTableHandler: profitTableHandler,
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = ProfitTableInit;

/***/ },
/* 547 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ProfitTable = __webpack_require__(548);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var toJapanTimeIfNeeded = __webpack_require__(463).toJapanTimeIfNeeded;
	var elementTextContent = __webpack_require__(430).elementTextContent;
	var jpClient = __webpack_require__(425).jpClient;
	var formatMoney = __webpack_require__(433).formatMoney;
	var showTooltip = __webpack_require__(513).showTooltip;
	var Table = __webpack_require__(516);

	var ProfitTableUI = function () {
	    'use strict';

	    var oauth_apps = {},
	        currency = void 0;

	    var profit_table_id = 'profit-table';
	    var cols = ['buy-date', 'ref', 'payout', 'contract', 'buy-price', 'sell-date', 'sell-price', 'pl', 'details'];

	    var createEmptyTable = function createEmptyTable() {
	        var header = [localize('Date'), localize('Ref.'), localize('Potential Payout'), localize('Contract'), localize('Purchase Price'), localize('Sale Date'), localize('Sale Price'), localize('Profit/Loss'), localize('Details')];

	        var jp_client = jpClient();
	        currency = Client.get('currency');

	        header[7] += jp_client ? '' : currency ? ' (' + currency + ')' : '';

	        var footer = [localize('Total Profit/Loss'), '', '', '', '', '', '', '', ''];

	        var data = [];
	        var metadata = {
	            cols: cols,
	            id: profit_table_id
	        };
	        var $table_container = Table.createFlexTable(data, metadata, header, footer);

	        $table_container.children('table').children('tfoot').children('tr').attr('id', 'pl-day-total');

	        return $table_container;
	    };

	    var updateFooter = function updateFooter(transactions) {
	        var acc_total = elementTextContent(document.querySelector('#pl-day-total > .pl'));
	        acc_total = parseFloat(acc_total.replace(/,/g, ''));
	        if (!acc_total || isNaN(acc_total)) {
	            acc_total = 0;
	        }

	        var current_total = transactions.reduce(function (previous, current) {
	            var buy_price = Number(parseFloat(current.buy_price));
	            var sell_price = Number(parseFloat(current.sell_price));
	            var pl = sell_price - buy_price;
	            return previous + pl;
	        }, 0);

	        var total = acc_total + current_total;
	        var jp_client = jpClient();
	        var sub_total_type = total >= 0 ? 'profit' : 'loss';

	        $('#pl-day-total').find(' > .pl').text(formatMoney(currency, Number(total), !jp_client)).removeClass('profit loss').addClass(sub_total_type);
	    };

	    var createProfitTableRow = function createProfitTableRow(transaction) {
	        var profit_table_data = ProfitTable.getProfitTabletData(transaction);
	        var pl_type = transaction.pl >= 0 ? 'profit' : 'loss';

	        var jp_client = jpClient();

	        var data = [jp_client ? toJapanTimeIfNeeded(transaction.purchase_time) : profit_table_data.buyDate, '<span ' + showTooltip(profit_table_data.app_id, oauth_apps[profit_table_data.app_id]) + '>' + profit_table_data.ref + '</span>', profit_table_data.payout, '', profit_table_data.buyPrice, jp_client ? toJapanTimeIfNeeded(transaction.sell_time) : profit_table_data.sellDate, profit_table_data.sellPrice, profit_table_data.pl, ''];
	        var $row = Table.createFlexTableRow(data, cols, 'data');

	        $row.children('.pl').addClass(pl_type);
	        $row.children('.contract').html(profit_table_data.desc + '<br>');
	        $row.children('.buy-date, .sell-date').each(function () {
	            $(this).wrapInner('<div class="new-width"></div>');
	        });

	        $row.attr('class', 'open_contract_details');
	        $row.attr('contract_id', profit_table_data.id);
	        $row.hover(function () {
	            $(this).css('background-color', '#E98024');
	        }, function () {
	            $(this).css('background-color', 'white');
	        });

	        return $row[0];
	    };

	    var updateProfitTable = function updateProfitTable(transactions) {
	        Table.appendTableBody(profit_table_id, transactions, createProfitTableRow);
	        updateFooter(transactions);
	    };

	    var clearTableContent = function clearTableContent() {
	        Table.clearTableBody(profit_table_id);
	        $('#' + profit_table_id).find('> tfoot').hide();
	    };

	    var errorMessage = function errorMessage(msg) {
	        var $err = $('#profit-table-container').find('#error-msg');
	        if (msg) {
	            $err.setVisibility(1).text(msg);
	        } else {
	            $err.setVisibility(0).text('');
	        }
	    };

	    return {
	        createEmptyTable: createEmptyTable,
	        updateProfitTable: updateProfitTable,
	        cleanTableContent: clearTableContent,
	        errorMessage: errorMessage,
	        setOauthApps: function setOauthApps(values) {
	            return oauth_apps = values;
	        }
	    };
	}();

	module.exports = ProfitTableUI;

/***/ },
/* 548 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var Client = __webpack_require__(420);
	var jpClient = __webpack_require__(425).jpClient;
	var formatMoney = __webpack_require__(433).formatMoney;

	var ProfitTable = function () {
	    'use strict';

	    var getProfitTabletData = function getProfitTabletData(transaction) {
	        var currency = Client.get('currency');
	        var is_jp_client = jpClient();
	        var buy_moment = moment.utc(transaction.purchase_time * 1000);
	        var sell_moment = moment.utc(transaction.sell_time * 1000);
	        var buy_price = parseFloat(transaction.buy_price);
	        var sell_price = parseFloat(transaction.sell_price);

	        return {
	            buyDate: buy_moment.format('YYYY-MM-DD') + '\n' + buy_moment.format('HH:mm:ss') + ' GMT',
	            ref: transaction.transaction_id,
	            payout: formatMoney(currency, parseFloat(transaction.payout), !is_jp_client),
	            buyPrice: formatMoney(currency, buy_price, !is_jp_client),
	            sellDate: sell_moment.format('YYYY-MM-DD') + '\n' + sell_moment.format('HH:mm:ss') + ' GMT',
	            sellPrice: formatMoney(currency, sell_price, !is_jp_client),
	            pl: formatMoney(currency, Number(sell_price - buy_price), !is_jp_client),
	            desc: transaction.longcode,
	            id: transaction.contract_id,
	            app_id: transaction.app_id
	        };
	    };

	    return {
	        getProfitTabletData: getProfitTabletData
	    };
	}();

	module.exports = ProfitTable;

/***/ },
/* 549 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var BinaryPjax = __webpack_require__(467);
	var showLocalTimeOnHover = __webpack_require__(463).showLocalTimeOnHover;
	var localize = __webpack_require__(428).localize;
	var FlexTableUI = __webpack_require__(550);
	var jpClient = __webpack_require__(425).jpClient;
	var FormManager = __webpack_require__(483);
	var toTitleCase = __webpack_require__(449).toTitleCase;

	var APIToken = function () {
	    'use strict';

	    var error_class = 'errorfield';
	    var form_id = '#token_form';
	    var max_tokens = 30;

	    var $table_container = void 0,
	        $form = void 0;

	    var onLoad = function onLoad() {
	        if (jpClient()) {
	            BinaryPjax.load('user/settingsws');
	            return;
	        }

	        $table_container = $('#tokens_list');
	        $form = $(form_id);

	        BinarySocket.send({ api_token: 1 }).then(populateTokensList);

	        var regex_msg = localize('Only [_1] are allowed.', [['letters', 'numbers', 'space', '_'].join(', ')]);
	        FormManager.init(form_id, [{ selector: '#txt_name', request_field: 'new_token', validations: ['req', ['regular', { regex: /^[\w\s]+$/, message: regex_msg }], ['length', { min: 2, max: 32 }]] }, { selector: '[id*="chk_scopes_"]', request_field: 'new_token_scopes', validations: [['req', { message: localize('Please select at least one scope') }]], value: getScopes }, { request_field: 'api_token', value: 1 }]);
	        FormManager.handleSubmit({
	            form_selector: form_id,
	            fnc_response_handler: newTokenResponse,
	            enable_button: true
	        });
	    };

	    var newTokenResponse = function newTokenResponse(response) {
	        if (response.error) {
	            showFormMessage(response.error.message, false);
	            return;
	        }
	        showFormMessage('New token created.', true);
	        $('#txt_name').val('');

	        populateTokensList(response);
	    };

	    var getScopes = function getScopes() {
	        return $form.find('[id*="chk_scopes_"]:checked').map(function () {
	            return $(this).val();
	        }).get();
	    };

	    // -----------------------
	    // ----- Tokens List -----
	    // -----------------------
	    var populateTokensList = function populateTokensList(response) {
	        if ('error' in response) {
	            showErrorMessage(response.error.message);
	            return;
	        }

	        clearMessages();

	        var tokens = response.api_token.tokens;
	        if (tokens.length === 0) {
	            $table_container.setVisibility(0);
	            return;
	        } else if (tokens.length >= max_tokens) {
	            $form.setVisibility(0);
	            showErrorMessage(localize('The maximum number of tokens ([_1]) has been reached.', [max_tokens]));
	        } else {
	            $form.setVisibility(1);
	        }

	        $table_container.setVisibility(1).empty();

	        var headers = ['Name', 'Token', 'Scopes', 'Last Used', 'Action'];
	        FlexTableUI.init({
	            id: 'tokens_table',
	            container: $table_container,
	            header: headers.map(localize),
	            cols: headers.map(function (title) {
	                return title.toLowerCase().replace(/\s/g, '-');
	            }),
	            data: tokens,
	            formatter: formatToken,
	            style: function style($row, token) {
	                if (token.display_name === response.echo_req.new_token) {
	                    $row.addClass('new');
	                }
	                $row.attr('id', token.token);
	                createDeleteButton($row, token);
	            }
	        });
	        showLocalTimeOnHover('td.last-used');
	    };

	    var createDeleteButton = function createDeleteButton($row, token) {
	        var message = localize('Are you sure that you want to permanently delete token');
	        var $button = $('<button/>', { class: 'button btn_delete', text: localize('Delete') });
	        $button.click(function (e) {
	            e.preventDefault();
	            e.stopPropagation();
	            if (!window.confirm(message + ': "' + token.display_name + '"?')) {
	                return;
	            }
	            deleteToken(token.token);
	        });
	        $row.children('.action').html($button);
	    };

	    var formatToken = function formatToken(token) {
	        var last_used = token.last_used ? token.last_used + ' GMT' : localize('Never Used');
	        var scopes = token.scopes.map(function (scope) {
	            return localize(toTitleCase(scope));
	        }).join(', ');
	        return [token.display_name, token.token, scopes, last_used, ''];
	    };

	    var deleteToken = function deleteToken(token) {
	        BinarySocket.send({
	            api_token: 1,
	            delete_token: token
	        }).then(function (response) {
	            $('#' + response.echo_req.delete_token).removeClass('new').addClass('deleting').fadeOut(700, function () {
	                $(this).remove();
	                populateTokensList(response);
	            });
	        });
	    };

	    // -----------------------------
	    // ----- Message Functions -----
	    // -----------------------------
	    var showErrorMessage = function showErrorMessage(msg) {
	        $('#token_message').setVisibility(1).find('p').attr('class', error_class).html(localize(msg));
	    };

	    var showFormMessage = function showFormMessage(msg, is_success) {
	        $('#msg_form').attr('class', is_success ? 'success-msg' : error_class).html(is_success ? '<ul class="checked"><li>' + localize(msg) + '</li></ul>' : localize(msg)).css('display', 'block').delay(3000).fadeOut(1000);
	    };

	    var clearMessages = function clearMessages() {
	        $('#token_message').setVisibility(0);
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = APIToken;

/***/ },
/* 550 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Table = __webpack_require__(516);

	var FlexTableUI = function () {
	    'use strict';

	    var config = void 0;

	    var init = function init(conf) {
	        config = conf;
	        var $tableContainer = Table.createFlexTable([], getMetadata(), config.header, config.footer);
	        // Table.appendTablebody expects the table to already
	        // exist in the DOM, so we need to append first
	        $tableContainer.appendTo(config.container);
	        extend(config.data);
	    };

	    var getMetadata = function getMetadata() {
	        return {
	            id: config.id,
	            tableClass: config.class,
	            cols: config.cols
	        };
	    };

	    var extend = function extend(data) {
	        var cols = config.cols;
	        var formatter = config.formatter;
	        var style = config.style;
	        Table.appendTableBody(config.id, data, function (datum) {
	            var $row = Table.createFlexTableRow(formatter(datum), cols, 'data');
	            if (style) {
	                style($row, datum);
	            }
	            return $row[0];
	        });
	    };

	    var displayError = function displayError(message, colspan) {
	        var $tr = $('<tr/>', { class: 'flex-tr' });
	        var $td = $('<td/>', { colspan: colspan });
	        var $p = $('<p/>', { class: 'notice-msg center-text', text: message });
	        return $('#' + config.id + ' tbody').append($tr.append($td.append($p)));
	    };

	    var replace = function replace(data) {
	        if (config) {
	            Table.clearTableBody(config.id);
	            extend(data);
	        }
	    };

	    var clear = function clear() {
	        if (config) {
	            replace([]);
	            $('#' + config.id + ' > tfoot').hide();
	        }
	    };

	    return {
	        init: init,
	        displayError: displayError,
	        replace: replace,
	        clear: clear
	    };
	}();

	module.exports = FlexTableUI;

/***/ },
/* 551 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ApplicationsInit = __webpack_require__(552);
	var BinaryPjax = __webpack_require__(467);
	var jpClient = __webpack_require__(425).jpClient;

	var AuthorisedApps = function () {
	    var onLoad = function onLoad() {
	        if (jpClient()) {
	            BinaryPjax.load('user/settingsws');
	        }
	        ApplicationsInit.init();
	    };

	    var onUnload = function onUnload() {
	        ApplicationsInit.clean();
	    };

	    return {
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = AuthorisedApps;

/***/ },
/* 552 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ApplicationsData = __webpack_require__(553);
	var ApplicationsUI = __webpack_require__(554);
	var BinarySocket = __webpack_require__(427);

	var ApplicationsInit = function () {
	    'use strict';

	    var init = function init() {
	        ApplicationsUI.init();
	        BinarySocket.send({ oauth_apps: 1 }).then(function (response) {
	            if (response.error) {
	                ApplicationsUI.displayError(response.error.message);
	            } else {
	                ApplicationsUI.update(response.oauth_apps.map(ApplicationsData.parse));
	            }
	        });
	    };

	    var clean = function clean() {
	        ApplicationsUI.clean();
	    };

	    return {
	        init: init,
	        clean: clean
	    };
	}();

	module.exports = ApplicationsInit;

/***/ },
/* 553 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);

	var ApplicationsData = function () {
	    'use strict';

	    var parse = function parse(app) {
	        var last = app.last_used ? moment.utc(app.last_used) : null;
	        return {
	            name: app.name,
	            scopes: app.scopes,
	            last_used: last,
	            id: app.app_id
	        };
	    };

	    return {
	        parse: parse
	    };
	}();

	module.exports = ApplicationsData;

/***/ },
/* 554 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ApplicationsData = __webpack_require__(553);
	var BinarySocket = __webpack_require__(427);
	var showLocalTimeOnHover = __webpack_require__(463).showLocalTimeOnHover;
	var localize = __webpack_require__(428).localize;
	var showLoadingImage = __webpack_require__(417).showLoadingImage;
	var FlexTableUI = __webpack_require__(550);
	var toTitleCase = __webpack_require__(449).toTitleCase;

	var ApplicationsUI = function () {
	    'use strict';

	    var container_selector = '#applications-container';
	    var messages = {
	        no_apps: 'You have not granted access to any applications.',
	        revoke_confirm: 'Are you sure that you want to permanently revoke access to application',
	        revoke_access: 'Revoke access'
	    };

	    var formatApp = function formatApp(app) {
	        var last_used = app.last_used ? app.last_used.format('YYYY-MM-DD HH:mm:ss') : localize('Never');
	        var scopes = app.scopes.map(function (scope) {
	            return localize(toTitleCase(scope));
	        }).join(', ');
	        return [app.name, scopes, last_used, ''];
	    };

	    var createRevokeButton = function createRevokeButton(container, app) {
	        var $button = $('<button/>', { class: 'button', text: localize(messages.revoke_access) });
	        $button.on('click', function () {
	            if (window.confirm(localize(messages.revoke_confirm) + ': \'' + app.name + '\'?')) {
	                BinarySocket.send({ oauth_apps: 1, revoke_app: app.id }).then(function (response) {
	                    if (response.error) {
	                        displayError(response.error.message);
	                    } else {
	                        update(response.oauth_apps.map(ApplicationsData.parse));
	                    }
	                });
	                container.css({ opacity: 0.5 });
	            }
	        });
	        return $button;
	    };

	    var createTable = function createTable(data) {
	        if ($('#applications-table').length) {
	            return FlexTableUI.replace(data);
	        }
	        var headers = ['Name', 'Permissions', 'Last Used', 'Action'];
	        var columns = ['name', 'permissions', 'last_used', 'action'];
	        FlexTableUI.init({
	            container: container_selector,
	            header: headers.map(function (s) {
	                return localize(s);
	            }),
	            id: 'applications-table',
	            cols: columns,
	            data: data,
	            style: function style($row, app) {
	                $row.children('.action').first().append(createRevokeButton($row, app));
	            },
	            formatter: formatApp
	        });
	        return showLocalTimeOnHover('td.last_used');
	    };

	    var update = function update(apps) {
	        $('#loading').remove();
	        createTable(apps);
	        if (!apps.length) {
	            FlexTableUI.displayError(localize(messages.no_apps), 7);
	        }
	    };

	    var displayError = function displayError(message) {
	        $(container_selector).find('.error-msg').text(message);
	    };

	    var init = function init() {
	        showLoadingImage($('<div/>', { id: 'loading' }).insertAfter('#applications-title'));
	    };

	    var clean = function clean() {
	        $(container_selector).find('.error-msg').text('');
	        FlexTableUI.clear();
	    };

	    return {
	        init: init,
	        clean: clean,
	        update: update,
	        displayError: displayError
	    };
	}();

	module.exports = ApplicationsUI;

/***/ },
/* 555 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var BinaryPjax = __webpack_require__(467);
	var localize = __webpack_require__(428).localize;
	var FormManager = __webpack_require__(483);

	var CashierPassword = function () {
	    'use strict';

	    var $form = void 0,
	        redirect_url = void 0;
	    var form_id = '#frm_cashier_password';

	    var onLoad = function onLoad() {
	        $form = $(form_id);

	        BinarySocket.wait('authorize').then(function () {
	            BinarySocket.send({ cashier_password: 1 }).then(function (response) {
	                return init(response);
	            });
	        });
	    };

	    var updatePage = function updatePage(config) {
	        $('legend').text(localize(config.legend));
	        $('#lockInfo').text(localize(config.info));
	        $form.find('button').html(localize(config.button));
	    };

	    var init = function init(response) {
	        var locked = response.cashier_password;
	        if (locked) {
	            updatePage({
	                legend: 'Unlock Cashier',
	                info: 'Your cashier is locked as per your request - to unlock it, please enter the password.',
	                button: 'Unlock Cashier'
	            });
	            $('#repeat_password_row').setVisibility(0);
	        } else {
	            updatePage({
	                legend: 'Lock Cashier',
	                info: 'An additional password can be used to restrict access to the cashier.',
	                button: 'Update'
	            });
	            $('#repeat_password_row').setVisibility(1);
	        }
	        $form.setVisibility(1);
	        FormManager.init(form_id, [{ selector: '#cashier_password', validations: ['req', locked ? ['length', { min: 6, max: 25 }] : 'password'], request_field: locked ? 'unlock_password' : 'lock_password', re_check_field: locked ? null : '#repeat_cashier_password' }, { selector: '#repeat_cashier_password', validations: ['req', ['compare', { to: '#cashier_password' }]], exclude_request: 1 }, { request_field: 'cashier_password', value: 1 }]);
	        FormManager.handleSubmit({
	            form_selector: form_id,
	            fnc_response_handler: handleResponse
	        });
	    };

	    var handleResponse = function handleResponse(response) {
	        var $form_error = $('#form_error');
	        var $form_message = $('#form_message');
	        $form_message.text('');
	        $form_error.text('');
	        if (response.error) {
	            var message = response.error.message;
	            if (response.error.code === 'InputValidationFailed') {
	                message = 'Sorry, you have entered an incorrect cashier password';
	            }
	            $form_error.text(localize(message));
	            return;
	        }
	        redirect_url = sessionStorage.getItem('cashier_lock_redirect') || '';
	        $form.setVisibility(0);
	        $form_message.text(localize('Your settings have been updated successfully.'));
	        setTimeout(redirect, 2000);
	    };

	    var redirect = function redirect() {
	        if (redirect_url) {
	            sessionStorage.removeItem('cashier_lock_redirect');
	            BinaryPjax.load(redirect_url);
	        }
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = CashierPassword;

/***/ },
/* 556 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var BinaryPjax = __webpack_require__(467);
	var Header = __webpack_require__(494);
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var isEmptyObject = __webpack_require__(417).isEmptyObject;
	var showLoadingImage = __webpack_require__(417).showLoadingImage;
	var jpClient = __webpack_require__(425).jpClient;
	var Validation = __webpack_require__(484);

	var FinancialAssessment = function () {
	    'use strict';

	    var financial_assessment = {},
	        arr_validation = [];

	    var form_selector = '#frm_assessment';

	    var onLoad = function onLoad() {
	        if (jpClient()) {
	            BinaryPjax.load('user/settingsws');
	        }

	        $(form_selector).on('submit', function (event) {
	            event.preventDefault();
	            submitForm();
	        });

	        BinarySocket.wait('get_financial_assessment').then(function (response) {
	            handleForm(response);
	        });
	    };

	    var handleForm = function handleForm(response) {
	        if (!response) {
	            response = State.get(['response', 'get_financial_assessment']);
	        }
	        hideLoadingImg(true);

	        financial_assessment = $.extend({}, response.get_financial_assessment);

	        if (isEmptyObject(financial_assessment)) {
	            BinarySocket.wait('get_account_status').then(function (data) {
	                if (data.get_account_status.risk_classification === 'high') {
	                    $('#high_risk_classification').setVisibility(1);
	                }
	            });
	        }

	        Object.keys(financial_assessment).forEach(function (key) {
	            var val = financial_assessment[key];
	            $('#' + key).val(val);
	        });

	        arr_validation = [];
	        $(form_selector).find('select').map(function () {
	            var id = $(this).attr('id');
	            arr_validation.push({ selector: '#' + id, validations: ['req'] });
	            if (financial_assessment[id] === undefined) {
	                // handle fields not previously set by client
	                financial_assessment[id] = '';
	            }
	        });
	        Validation.init(form_selector, arr_validation);
	    };

	    var submitForm = function submitForm() {
	        var $btn_submit = $(form_selector + ' #btn_submit');
	        $btn_submit.attr('disabled', 'disabled');

	        if (Validation.validate(form_selector)) {
	            var has_changed = false;
	            Object.keys(financial_assessment).forEach(function (key) {
	                var $key = $('#' + key);
	                if ($key.length && $key.val() !== financial_assessment[key]) {
	                    has_changed = true;
	                }
	            });
	            if (Object.keys(financial_assessment).length === 0) has_changed = true;
	            if (!has_changed) {
	                showFormMessage('You did not change anything.', false);
	                setTimeout(function () {
	                    $btn_submit.removeAttr('disabled');
	                }, 1000);
	                return;
	            }

	            var data = { set_financial_assessment: 1 };
	            showLoadingImage($('#msg_form'));
	            $(form_selector).find('select').each(function () {
	                financial_assessment[$(this).attr('id')] = data[$(this).attr('id')] = $(this).val();
	            });
	            BinarySocket.send(data).then(function (response) {
	                $btn_submit.removeAttr('disabled');
	                if (response.error) {
	                    showFormMessage('Sorry, an error occurred while processing your request.', false);
	                } else {
	                    showFormMessage('Your changes have been updated successfully.', true);
	                    BinarySocket.send({ get_financial_assessment: 1 }).then(function () {
	                        Header.displayAccountStatus();
	                    });
	                }
	            });
	        } else {
	            setTimeout(function () {
	                $btn_submit.removeAttr('disabled');
	            }, 1000);
	        }
	    };

	    var hideLoadingImg = function hideLoadingImg(show_form) {
	        $('#assessment_loading').remove();
	        if (show_form) {
	            $(form_selector).setVisibility(1);
	        }
	    };

	    var showFormMessage = function showFormMessage(msg, is_success) {
	        var redirect_url = localStorage.getItem('financial_assessment_redirect');
	        if (is_success && /metatrader/i.test(redirect_url)) {
	            localStorage.removeItem('financial_assessment_redirect');
	            $.scrollTo($('h1#heading'), 500, { offset: -10 });
	            $(form_selector).setVisibility(0);
	            $('#msg_main').setVisibility(1);
	            BinarySocket.send({ get_account_status: 1 }).then(function (response_status) {
	                if ($.inArray('authenticated', response_status.get_account_status.status) === -1) {
	                    $('#msg_authenticate').setVisibility(1);
	                }
	            });
	        } else {
	            $('#msg_form').attr('class', is_success ? 'success-msg' : 'errorfield').html(is_success ? $('<ul/>', { class: 'checked', style: 'display: inline-block;' }).append($('<li/>', { text: localize(msg) })) : localize(msg)).css('display', 'block').delay(5000).fadeOut(1000);
	        }
	    };

	    return {
	        onLoad: onLoad,
	        handleForm: handleForm,
	        submitForm: submitForm
	    };
	}();

	module.exports = FinancialAssessment;

/***/ },
/* 557 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var IPHistoryInit = __webpack_require__(558);
	var BinaryPjax = __webpack_require__(467);
	var jpClient = __webpack_require__(425).jpClient;

	var IPHistory = function () {
	    var onLoad = function onLoad() {
	        if (jpClient()) {
	            BinaryPjax.load('user/settingsws');
	        }
	        IPHistoryInit.init();
	    };

	    var onUnload = function onUnload() {
	        IPHistoryInit.clean();
	    };

	    return {
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = IPHistory;

/***/ },
/* 558 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var IPHistoryData = __webpack_require__(559);
	var IPHistoryUI = __webpack_require__(560);
	var BinarySocket = __webpack_require__(427);

	var IPHistoryInit = function () {
	    'use strict';

	    var responseHandler = function responseHandler(response) {
	        if (response.error && response.error.message) {
	            return IPHistoryUI.displayError(response.error.message);
	        }
	        var parsed = response.login_history.map(IPHistoryData.parse);
	        return IPHistoryUI.update(parsed);
	    };

	    var init = function init() {
	        IPHistoryUI.init();
	        var req = {
	            login_history: '1',
	            limit: 50
	        };
	        BinarySocket.send(req).then(function (response) {
	            responseHandler(response);
	        });
	    };

	    var clean = function clean() {
	        IPHistoryUI.clean();
	    };

	    return {
	        init: init,
	        clean: clean
	    };
	}();

	module.exports = IPHistoryInit;

/***/ },
/* 559 */
/***/ function(module, exports) {

	'use strict';

	var IPHistoryData = function () {
	    var parseUA = function parseUA(user_agent) {
	        // Table of UA-values (and precedences) from:
	        //  https://developer.mozilla.org/en-US/docs/Browser_detection_using_the_user_agent
	        // Regexes stolen from:
	        //  https://github.com/biggora/express-useragent/blob/master/lib/express-useragent.js
	        var lookup = [{ name: 'Edge', regex: /Edge\/([\d\w\.\-]+)/i }, { name: 'SeaMonkey', regex: /seamonkey\/([\d\w\.\-]+)/i }, { name: 'Opera', regex: /(?:opera|opr)\/([\d\w\.\-]+)/i }, { name: 'Chromium', regex: /(?:chromium|crios)\/([\d\w\.\-]+)/i }, { name: 'Chrome', regex: /chrome\/([\d\w\.\-]+)/i }, { name: 'Safari', regex: /version\/([\d\w\.\-]+)/i }, { name: 'IE', regex: /msie\s([\d\.]+[\d])/i }, { name: 'IE', regex: /trident\/\d+\.\d+;.*[rv:]+(\d+\.\d)/i }, { name: 'Firefox', regex: /firefox\/([\d\w\.\-]+)/i }];
	        for (var i = 0; i < lookup.length; i++) {
	            var info = lookup[i];
	            var match = user_agent.match(info.regex);
	            if (match !== null) {
	                return {
	                    name: info.name,
	                    version: match[1]
	                };
	            }
	        }
	        return null;
	    };

	    var parse = function parse(activity) {
	        var environ = activity.environment;
	        var ip_addr = environ.split(' ')[2].split('=')[1];
	        var user_agent = environ.match('User_AGENT=(.+) LANG')[1];
	        return {
	            time: activity.time,
	            action: activity.action,
	            success: activity.status === 1,
	            browser: parseUA(user_agent),
	            ip_addr: ip_addr
	        };
	    };

	    return {
	        parse: parse,
	        parseUserAgent: parseUA
	    };
	}();

	module.exports = IPHistoryData;

/***/ },
/* 560 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var showLocalTimeOnHover = __webpack_require__(463).showLocalTimeOnHover;
	var localize = __webpack_require__(428).localize;
	var FlexTableUI = __webpack_require__(550);

	var IPHistoryUI = function () {
	    'use strict';

	    var container_selector = '#login-history-container';
	    var no_messages_error = 'Your account has no Login/Logout activity.';

	    var init = function init() {
	        var $title = $('#login_history-title').children().first();
	        $title.text(localize($title.text()));
	    };

	    var formatRow = function formatRow(data) {
	        var timestamp = moment.unix(data.time).utc().format('YYYY-MM-DD HH:mm:ss').replace(' ', '\n') + ' GMT';
	        var status = localize(data.success ? 'Successful' : 'Failed');
	        var action = localize(data.action);
	        var browser = data.browser;
	        var browser_string = browser ? browser.name + ' v' + browser.version : 'Unknown';
	        var patt = /^(opera|chrome|safari|firefox|IE|Edge|SeaMonkey|Chromium) v[0-9.]+$/i;
	        if (!patt.test(browser_string) && browser_string !== 'Unknown') {
	            browser_string = 'Error';
	        }
	        return [timestamp, action, browser_string, data.ip_addr, status];
	    };

	    var update = function update(history) {
	        var headers = ['Date and Time', 'Action', 'Browser', 'IP Address', 'Status'];
	        var columns = ['timestamp', 'action', 'browser', 'ip', 'status'];
	        FlexTableUI.init({
	            id: 'login-history-table',
	            container: container_selector,
	            header: headers.map(function (s) {
	                return localize(s);
	            }),
	            cols: columns,
	            data: history,
	            formatter: formatRow,
	            style: function style($row) {
	                $row.children('.timestamp').addClass('pre');
	            }
	        });
	        if (!history.length) {
	            return FlexTableUI.displayError(localize(no_messages_error), 6);
	        }
	        return showLocalTimeOnHover('td.timestamp');
	    };

	    var clean = function clean() {
	        $(container_selector).find('.error-msg').text('');
	        FlexTableUI.clear();
	    };

	    var displayError = function displayError(error) {
	        $('#err').text(error);
	    };

	    return {
	        init: init,
	        clean: clean,
	        update: update,
	        displayError: displayError
	    };
	}();

	module.exports = IPHistoryUI;

/***/ },
/* 561 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var LimitsInit = __webpack_require__(562);

	var Limits = function () {
	    var onLoad = function onLoad() {
	        BinarySocket.send({ get_limits: 1 }).then(function (response) {
	            if (response.error) {
	                LimitsInit.limitsError(response.error);
	            } else {
	                LimitsInit.limitsHandler(response);
	            }
	        });
	    };

	    var onUnload = function onUnload() {
	        LimitsInit.clean();
	    };

	    return {
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = Limits;

/***/ },
/* 562 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var LimitsUI = __webpack_require__(563);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var elementTextContent = __webpack_require__(430).elementTextContent;
	var formatMoney = __webpack_require__(433).formatMoney;

	var LimitsInit = function () {
	    'use strict';

	    var limitsHandler = function limitsHandler(response) {
	        var limits = response.get_limits;
	        LimitsUI.fillLimitsTable(limits);

	        var el_withdraw_limit = document.getElementById('withdrawal-limit');
	        var el_withdrawn = document.getElementById('already-withdraw');
	        var el_withdraw_limit_agg = document.getElementById('withdrawal-limit-aggregate');

	        if (limits.lifetime_limit === 99999999 && limits.num_of_days_limit === 99999999) {
	            elementTextContent(el_withdraw_limit, localize('Your account is fully authenticated and your withdrawal limits have been lifted.'));
	        } else {
	            var txt_withdraw_lim = 'Your withdrawal limit is [_1] [_2] (or equivalent in other currency).',
	                txt_withdraw_amt = 'You have already withdrawn the equivalent of [_1] [_2].',
	                txt_current_max_withdrawal = 'Therefore your current immediate maximum withdrawal (subject to your account having sufficient funds) is [_1] [_2] (or equivalent in other currency).',
	                currency = 'EUR';
	            var days_limit = formatMoney(currency, limits.num_of_days_limit, 1);
	            // no need for formatMoney since it is already string like "1,000"
	            var withdrawn = limits.withdrawal_since_inception_monetary;
	            var remainder = formatMoney(currency, limits.remainder, 1);

	            if (/^(iom)$/i.test(Client.get('landing_company_name'))) {
	                // MX
	                txt_withdraw_lim = 'Your [_1] day withdrawal limit is currently [_2] [_3] (or equivalent in other currency).';
	                txt_withdraw_amt = 'You have already withdrawn the equivalent of [_1] [_2] in aggregate over the last [_3] days.';
	                elementTextContent(el_withdraw_limit, localize(txt_withdraw_lim, [limits.num_of_days, currency, days_limit]));
	                elementTextContent(el_withdrawn, localize(txt_withdraw_amt, [currency, withdrawn, limits.num_of_days]));
	            } else {
	                if (/^(costarica|japan)$/i.test(Client.get('landing_company_name'))) {
	                    // CR , JP
	                    txt_withdraw_lim = 'Your withdrawal limit is [_1] [_2].';
	                    txt_withdraw_amt = 'You have already withdrawn [_1] [_2].';
	                    txt_current_max_withdrawal = 'Therefore your current immediate maximum withdrawal (subject to your account having sufficient funds) is [_1] [_2].';
	                    currency = Client.get('currency') || Client.get('default_currency');
	                }
	                elementTextContent(el_withdraw_limit, localize(txt_withdraw_lim, [currency, days_limit]));
	                elementTextContent(el_withdrawn, localize(txt_withdraw_amt, [currency, withdrawn]));
	            }
	            elementTextContent(el_withdraw_limit_agg, localize(txt_current_max_withdrawal, [currency, remainder]));
	        }
	    };

	    var limitsError = function limitsError(error) {
	        document.getElementById('withdrawal-title').setAttribute('style', 'display:none');
	        document.getElementById('limits-title').setAttribute('style', 'display:none');
	        $('#limits_error').append($('<p/>', { class: 'center-text notice-msg', text: error && error.message ? error.message : localize('Sorry, an error occurred while processing your request.') }));
	    };

	    var initTable = function initTable() {
	        LimitsUI.clearTableContent();
	    };

	    return {
	        limitsHandler: limitsHandler,
	        limitsError: limitsError,
	        clean: initTable
	    };
	}();

	module.exports = LimitsInit;

/***/ },
/* 563 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Table = __webpack_require__(516);
	var localize = __webpack_require__(428).localize;
	var Client = __webpack_require__(420);
	var elementTextContent = __webpack_require__(430).elementTextContent;
	var formatMoney = __webpack_require__(433).formatMoney;

	var LimitsUI = function () {
	    'use strict';

	    var client_limits = '';

	    var appendRowTable = function appendRowTable(name, turnover_limit, padding, font_weight) {
	        client_limits.append($('<tr/>', { class: 'flex-tr' }).append($('<td/>', { class: 'flex-tr-child', style: 'padding-left: ' + padding + '; font-weight: ' + font_weight + ';', text: localize(name) })).append($('<td/>', { text: turnover_limit })));
	    };

	    var fillLimitsTable = function fillLimitsTable(limits) {
	        var currency = Client.get('currency');

	        if (currency) {
	            $('.limit').append(' (' + currency + ')');
	        }

	        var open_position = document.getElementById('open-positions');
	        var account_balance = document.getElementById('account-balance');
	        var payout = document.getElementById('payout');
	        var payout_per = document.getElementById('payout-per-symbol-and-contract-type');

	        elementTextContent(open_position, formatMoney(currency, limits.open_positions, 1));
	        elementTextContent(account_balance, formatMoney(currency, limits.account_balance, 1));
	        elementTextContent(payout, formatMoney(currency, limits.payout, 1));
	        elementTextContent(payout_per, formatMoney(currency, limits.payout_per_symbol_and_contract_type, 1));

	        var market_specific = limits.market_specific;
	        client_limits = $('#client-limits');
	        Object.keys(market_specific).forEach(function (key) {
	            var object = market_specific[key];
	            if (object.length && object.length > 0) {
	                appendRowTable(localize(key.charAt(0).toUpperCase() + key.slice(1)), '', 'auto', 'bold');
	                Object.keys(object).forEach(function (c) {
	                    if (Client.get('residence') !== 'jp' || /Major Pairs/.test(object[c].name)) {
	                        appendRowTable(object[c].name, object[c].turnover_limit !== 'null' ? formatMoney(currency, object[c].turnover_limit, 1) : 0, '25px', 'normal');
	                    }
	                });
	            } else {
	                appendRowTable(object.name, object.turnover_limit !== 'null' ? formatMoney(currency, object.turnover_limit, 1) : 0, 'auto', 'bold');
	            }
	        });
	        var login_id = Client.get('loginid');
	        if (login_id) {
	            $('#trading-limits').prepend(login_id + ' - ');
	            $('#withdrawal-title').prepend(login_id + ' - ');
	        }
	        $('#withdrawal-limits, #limits-title').setVisibility(1);
	    };

	    var clearTableContent = function clearTableContent() {
	        Table.clearTableBody('client-limits');
	    };

	    return {
	        clearTableContent: clearTableContent,
	        fillLimitsTable: fillLimitsTable
	    };
	}();

	module.exports = LimitsUI;

/***/ },
/* 564 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var Client = __webpack_require__(420);
	var jpClient = __webpack_require__(425).jpClient;

	var Settings = function () {
	    'use strict';

	    var onLoad = function onLoad() {
	        BinarySocket.wait('get_account_status').then(function (response) {
	            var class_hidden = 'invisible';
	            var class_real = '.real';

	            if (Client.get('is_virtual')) {
	                $(class_real).addClass(class_hidden);
	            } else {
	                $(class_real).not(jpClient() ? '.ja-hide' : '').removeClass(class_hidden);
	            }

	            if (/has_password/.test(response.get_account_status.status)) {
	                $('#change_password').removeClass(class_hidden);
	            }

	            $('#settings_container').removeClass(class_hidden);
	        });
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = Settings;

/***/ },
/* 565 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var BinarySocket = __webpack_require__(427);
	var Client = __webpack_require__(420);
	var Header = __webpack_require__(494);
	var localize = __webpack_require__(428).localize;
	var dateValueChanged = __webpack_require__(430).dateValueChanged;
	var FormManager = __webpack_require__(483);
	var scrollToHashSection = __webpack_require__(491).scrollToHashSection;
	var DatePicker = __webpack_require__(519);
	var TimePicker = __webpack_require__(528);

	var SelfExclusion = function () {
	    'use strict';

	    var $form = void 0,
	        fields = void 0,
	        self_exclusion_data = void 0;

	    var form_id = '#frm_self_exclusion';
	    var timeout_date_id = '#timeout_until_date';
	    var timeout_time_id = '#timeout_until_time';
	    var exclude_until_id = '#exclude_until';
	    var error_class = 'errorfield';

	    var onLoad = function onLoad() {
	        $form = $(form_id);

	        fields = {};
	        $form.find('input').each(function () {
	            fields[this.name] = '';
	        });

	        initDatePicker();
	        getData(true);
	    };

	    var getData = function getData(scroll) {
	        BinarySocket.send({ get_self_exclusion: 1 }).then(function (response) {
	            if (response.error) {
	                if (response.error.code === 'ClientSelfExclusion') {
	                    Client.sendLogoutRequest();
	                }
	                if (response.error.message) {
	                    $('#msg_error').html(response.error.message).setVisibility(1);
	                    $form.setVisibility(0);
	                }
	                return;
	            }

	            $('#loading').setVisibility(0);
	            $form.setVisibility(1);
	            self_exclusion_data = response.get_self_exclusion;
	            $.each(self_exclusion_data, function (key, value) {
	                fields[key] = value.toString();
	                $form.find('#' + key).val(value);
	            });
	            bindValidation();
	            if (scroll) scrollToHashSection();
	        });
	    };

	    var bindValidation = function bindValidation() {
	        var validations = [{ request_field: 'set_self_exclusion', value: 1 }];

	        $form.find('input[type="text"]').each(function () {
	            var id = $(this).attr('id');

	            if (/(timeout_until|exclude_until)/.test(id)) return;

	            var checks = [];
	            var options = { min: 0 };
	            if (id in self_exclusion_data) {
	                checks.push('req');
	                options.max = self_exclusion_data[id];
	            } else {
	                options.allow_empty = true;
	            }
	            checks.push(['number', options]);

	            if (id === 'session_duration_limit') {
	                checks.push(['custom', { func: validSessionDuration, message: 'Session duration limit cannot be more than 6 weeks.' }]);
	            }

	            validations.push({
	                selector: '#' + id,
	                validations: checks,
	                exclude_if_empty: 1
	            });
	        });

	        validations.push({
	            selector: timeout_date_id,
	            request_field: 'timeout_until',
	            re_check_field: timeout_time_id,
	            exclude_if_empty: 1,
	            value: getTimeout,
	            validations: [['custom', { func: function func() {
	                    return $(timeout_time_id).val() ? $(timeout_date_id).val().length : true;
	                }, message: 'This field is required.' }], ['custom', { func: function func(value) {
	                    return !value.length || getMoment(timeout_date_id).isAfter(moment().subtract(1, 'days'), 'day');
	                }, message: 'Time out must be after today.' }], ['custom', { func: function func(value) {
	                    return !value.length || getMoment(timeout_date_id).isBefore(moment().add(6, 'weeks'));
	                }, message: 'Time out cannot be more than 6 weeks.' }]]
	        }, {
	            selector: timeout_time_id,
	            exclude_request: 1,
	            re_check_field: timeout_date_id,
	            validations: [['custom', { func: function func() {
	                    return $(timeout_date_id).val() && getMoment(timeout_date_id).isSame(moment(), 'day') ? $(timeout_time_id).val().length : true;
	                }, message: 'This field is required.' }], ['custom', { func: function func(value) {
	                    return !value.length || !$(timeout_date_id).attr('data-value') || getTimeout() > moment().valueOf() / 1000;
	                }, message: 'Time out cannot be in the past.' }], ['custom', { func: validTime, message: 'Please select a valid time.' }]]
	        }, {
	            selector: exclude_until_id,
	            exclude_if_empty: 1,
	            value: function value() {
	                return getDate(exclude_until_id);
	            },
	            validations: [['custom', { func: function func(value) {
	                    return !value.length || getMoment(exclude_until_id).isAfter(moment().add(6, 'months'));
	                }, message: 'Exclude time cannot be less than 6 months.' }], ['custom', { func: function func(value) {
	                    return !value.length || getMoment(exclude_until_id).isBefore(moment().add(5, 'years'));
	                }, message: 'Exclude time cannot be for more than 5 years.' }]]
	        });

	        FormManager.init(form_id, validations);
	        FormManager.handleSubmit({
	            form_selector: form_id,
	            fnc_response_handler: setExclusionResponse,
	            fnc_additional_check: additionalCheck,
	            enable_button: true
	        });
	    };

	    var validSessionDuration = function validSessionDuration(value) {
	        return +value <= moment.duration(6, 'weeks').as('minutes');
	    };
	    var validTime = function validTime(value) {
	        return !value.length || moment(value, 'HH:mm', true).isValid();
	    };

	    var getDate = function getDate(elm_id) {
	        var $elm = $(elm_id);
	        return !isNaN(new Date($elm.val()).getTime()) ? $elm.val() : $elm.attr('data-value');
	    };
	    var getMoment = function getMoment(elm_id) {
	        return moment(new Date(getDate(elm_id)));
	    };
	    var getTimeout = function getTimeout() {
	        return $(timeout_date_id).attr('data-value') ? moment(new Date(getDate(timeout_date_id) + ' ' + $(timeout_time_id).val())) : '';
	    };

	    var initDatePicker = function initDatePicker() {
	        // timeout_until
	        TimePicker.init({ selector: timeout_time_id });
	        DatePicker.init({
	            selector: timeout_date_id,
	            minDate: 0,
	            maxDate: 6 * 7 });

	        // exclude_until
	        DatePicker.init({
	            selector: exclude_until_id,
	            minDate: moment().add(6, 'months').add(1, 'day').toDate(),
	            maxDate: 5 * 365 });

	        $(timeout_date_id + ', ' + exclude_until_id).change(function () {
	            dateValueChanged(this, 'date');
	        });
	    };

	    var additionalCheck = function additionalCheck(data) {
	        var is_changed = Object.keys(data).some(function (key) {
	            return (// using != in next line since response types is inconsistent
	                key !== 'set_self_exclusion' && (!(key in self_exclusion_data) || self_exclusion_data[key] != data[key]) // eslint-disable-line eqeqeq

	            );
	        });
	        if (!is_changed) {
	            showFormMessage('You did not change anything.', false);
	        }

	        var is_confirmed = true;
	        if ('timeout_until' in data || 'exclude_until' in data) {
	            is_confirmed = window.confirm(localize('When you click "OK" you will be excluded from trading on the site until the selected date.'));
	        }

	        return is_changed && is_confirmed;
	    };

	    var setExclusionResponse = function setExclusionResponse(response) {
	        if (response.error) {
	            var error_msg = response.error.message;
	            var error_fld = response.error.field;
	            if (error_fld) {
	                $('#' + error_fld).siblings('.error-msg').setVisibility(1).html(error_msg);
	            } else {
	                showFormMessage(localize(error_msg), false);
	            }
	            return;
	        }
	        showFormMessage('Your changes have been updated.', true);
	        Client.set('session_start', moment().unix()); // used to handle session duration limit
	        getData();
	        BinarySocket.send({ get_account_status: 1 }).then(function () {
	            Header.displayAccountStatus();
	        });
	    };

	    var showFormMessage = function showFormMessage(msg, is_success) {
	        $('#msg_form').attr('class', is_success ? 'success-msg' : error_class).html(is_success ? $('<ul/>', { class: 'checked' }).append($('<li/>', { text: localize(msg) })) : localize(msg)).css('display', 'block').delay(5000).fadeOut(1000);
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = SelfExclusion;

/***/ },
/* 566 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var localize = __webpack_require__(428).localize;
	var Client = __webpack_require__(420);
	var Header = __webpack_require__(494);
	var State = __webpack_require__(421).State;
	var detectHedging = __webpack_require__(430).detectHedging;
	var makeOption = __webpack_require__(430).makeOption;
	var FormManager = __webpack_require__(483);
	var moment = __webpack_require__(305);
	__webpack_require__(567);

	var PersonalDetails = function () {
	    'use strict';

	    var form_id = '#frmPersonalDetails';
	    var real_acc_elements = '.RealAcc';
	    var editable_fields = void 0,
	        is_jp = void 0,
	        is_virtual = void 0,
	        residence = void 0,
	        get_settings_data = void 0;

	    var init = function init() {
	        editable_fields = {};
	        get_settings_data = {};
	        is_virtual = Client.get('is_virtual');
	        residence = Client.get('residence');
	        is_jp = residence === 'jp';
	        if (is_jp && !is_virtual) {
	            $('#fieldset_email_consent').setVisibility(1);
	        }
	        showHideTaxMessage();
	    };

	    var showHideTaxMessage = function showHideTaxMessage() {
	        if (Client.shouldCompleteTax()) {
	            $('#tax_information_notice').setVisibility(1);
	        } else {
	            $('#tax_information_notice').setVisibility(0);
	        }
	    };

	    var getDetailsResponse = function getDetailsResponse(data) {
	        var get_settings = $.extend({}, data);
	        get_settings.date_of_birth = get_settings.date_of_birth ? moment.utc(new Date(get_settings.date_of_birth * 1000)).format('YYYY-MM-DD') : '';
	        get_settings.name = is_jp ? get_settings.last_name : (get_settings.salutation || '') + ' ' + (get_settings.first_name || '') + ' ' + (get_settings.last_name || '');

	        displayGetSettingsData(get_settings);

	        if (is_virtual) {
	            $(real_acc_elements).remove();
	        } else if (is_jp) {
	            var jp_settings = get_settings.jp_settings;
	            switch (jp_settings.gender) {
	                case 'f':
	                    jp_settings.gender = localize('Female');
	                    break;
	                case 'm':
	                    jp_settings.gender = localize('Male');
	                    break;
	                default:
	                    break;
	            }
	            displayGetSettingsData(jp_settings);
	            if (jp_settings.hedge_asset !== null && jp_settings.hedge_asset_amount !== null) {
	                $('.hedge').setVisibility(1);
	            }
	            $('.JpAcc').setVisibility(1);
	        } else {
	            $(real_acc_elements).setVisibility(1);
	        }
	        $(form_id).setVisibility(1);
	        FormManager.handleSubmit({
	            form_selector: form_id,
	            obj_request: { set_settings: 1 },
	            fnc_response_handler: setDetailsResponse,
	            fnc_additional_check: additionalCheck,
	            enable_button: true
	        });
	    };

	    var displayGetSettingsData = function displayGetSettingsData(data) {
	        var populate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	        var $key = void 0,
	            $lbl_key = void 0,
	            data_key = void 0,
	            has_key = void 0,
	            has_lbl_key = void 0;
	        Object.keys(data).forEach(function (key) {
	            $key = $('#' + key);
	            $lbl_key = $('#lbl_' + key);
	            has_key = $key.length > 0;
	            has_lbl_key = $lbl_key.length > 0;
	            // prioritise labels for japan account
	            $key = has_key && has_lbl_key ? is_jp ? $lbl_key : $key : has_key ? $key : $lbl_key;
	            if ($key.length > 0) {
	                data_key = data[key] === null ? '' : data[key];
	                editable_fields[key] = data_key;
	                if (populate) {
	                    if ($key.is(':checkbox')) {
	                        $key.prop('checked', !!data_key);
	                    } else if (/(SELECT|INPUT)/.test($key.prop('nodeName'))) {
	                        $key.val(data_key.split(',')).trigger('change');
	                    } else if (key !== 'country') {
	                        $key.text(data_key ? localize(data_key) : '-');
	                    }
	                }
	            }
	        });
	        if (data.country) {
	            $('#residence').replaceWith($('<label/>').append($('<strong/>', { id: 'lbl_country' })));
	            $('#lbl_country').text(data.country);
	            if (is_virtual) $('#btn_update').setVisibility(0);
	        }
	    };

	    var additionalCheck = function additionalCheck(data) {
	        if (!isChanged(data) && (!data.jp_settings || !isChanged(data.jp_settings))) {
	            showFormMessage('You did not change anything.', false);
	            return false;
	        }
	        return true;
	    };

	    var isChanged = function isChanged(data) {
	        var compare_data = $.extend({}, data);
	        return Object.keys(compare_data).some(function (key) {
	            return key !== 'set_settings' && key !== 'jp_settings' && editable_fields[key] !== compare_data[key];
	        });
	    };

	    var getValidations = function getValidations(data) {
	        var validations = void 0;
	        if (is_jp) {
	            validations = [{ request_field: 'address_line_1', value: data.address_line_1 }, { request_field: 'address_line_2', value: data.address_line_2 }, { request_field: 'address_city', value: data.address_city }, { request_field: 'address_state', value: data.address_state }, { request_field: 'address_postcode', value: data.address_postcode }, { request_field: 'phone', value: data.phone }, { selector: '#email_consent' }, { selector: '#hedge_asset_amount', validations: ['req', 'number'], parent_node: 'jp_settings' }, { selector: '#hedge_asset', validations: ['req'], parent_node: 'jp_settings' }];
	            $(form_id).find('select').each(function () {
	                validations.push({ selector: '#' + $(this).attr('id'), validations: ['req'], parent_node: 'jp_settings' });
	            });
	        } else if (is_virtual) {
	            validations = [{ selector: '#residence', validations: ['req'] }];
	        } else {
	            validations = [{ selector: '#address_line_1', validations: ['req', 'address'] }, { selector: '#address_line_2', validations: ['address'] }, { selector: '#address_city', validations: ['req', 'letter_symbol'] }, { selector: '#address_state', validations: $('#address_state').prop('nodeName') === 'SELECT' ? '' : ['letter_symbol'] }, { selector: '#address_postcode', validations: [Client.get('residence') === 'gb' ? 'req' : '', 'postcode', ['length', { min: 0, max: 20 }]] }, { selector: '#phone', validations: ['req', 'phone', ['length', { min: 6, max: 35 }]] }, { selector: '#place_of_birth', validations: Client.isFinancial() ? ['req'] : '' }, { selector: '#tax_residence', validations: Client.isFinancial() ? ['req'] : '' }];
	            var tax_id_validation = { selector: '#tax_identification_number', validations: ['postcode', ['length', { min: 0, max: 20 }]] };
	            if (Client.isFinancial()) {
	                tax_id_validation.validations[1][1].min = 1;
	                tax_id_validation.validations.unshift('req');
	            }
	            validations.push(tax_id_validation);
	        }
	        return validations;
	    };

	    var setDetailsResponse = function setDetailsResponse(response) {
	        // allow user to resubmit the form on error.
	        var is_error = response.set_settings !== 1;
	        if (!is_error) {
	            // to update tax information message for financial clients
	            BinarySocket.send({ get_account_status: 1 }, { forced: true }).then(function () {
	                showHideTaxMessage();
	                Header.displayAccountStatus();
	            });
	            // to update the State with latest get_settings data
	            BinarySocket.send({ get_settings: 1 }, { forced: true }).then(function (data) {
	                getDetailsResponse(data.get_settings);
	            });
	        }
	        showFormMessage(is_error ? 'Sorry, an error occurred while processing your account.' : 'Your settings have been updated successfully.', !is_error);
	    };

	    var showFormMessage = function showFormMessage(msg, is_success) {
	        $('#formMessage').attr('class', is_success ? 'success-msg' : 'errorfield').html(is_success ? $('<ul/>', { class: 'checked' }).append($('<li/>', { text: localize(msg) })) : localize(msg)).css('display', 'block').delay(5000).fadeOut(1000);
	    };

	    var populateResidence = function populateResidence(response) {
	        var residence_list = response.residence_list;
	        var $place_of_birth = $('#place_of_birth');
	        var $tax_residence = $('#tax_residence');
	        if (residence_list.length > 0) {
	            var $options = $('<div/>');
	            var $options_with_disabled = $('<div/>');
	            residence_list.forEach(function (res) {
	                $options.append(makeOption(res.text, res.value));
	                $options_with_disabled.append(makeOption(res.text, res.value, res.disabled));
	            });

	            if (residence) {
	                var tax_residence = get_settings_data.tax_residence;
	                $place_of_birth.html($options.html());
	                $tax_residence.html($options.html()).promise().done(function () {
	                    setTimeout(function () {
	                        $tax_residence.select2().val(tax_residence ? tax_residence.split(',') : '').trigger('change').setVisibility(1);
	                    }, 500);
	                });
	                $place_of_birth.val(get_settings_data.place_of_birth || residence);
	            } else {
	                $('#lbl_country').parent().replaceWith($('<select/>', { id: 'residence' }));
	                var $residence = $('#residence');
	                $options_with_disabled.prepend($('<option/>', { text: localize('Please select a value'), value: '' }));
	                $residence.html($options_with_disabled.html());
	                initFormManager();
	            }
	        }
	    };

	    var populateStates = function populateStates(response) {
	        var states = response.states_list;

	        if (is_jp) {
	            var state_text = (states.filter(function (state) {
	                return state.value === get_settings_data.address_state;
	            })[0] || {}).text;
	            $('#lbl_address_state').text(state_text || get_settings_data.address_state);
	        } else {
	            var address_state = '#address_state';
	            var $field = $(address_state);

	            $field.empty();

	            if (states && states.length > 0) {
	                $field.append($('<option/>', { value: '', text: localize('Please select') }));
	                states.forEach(function (state) {
	                    $field.append($('<option/>', { value: state.value, text: state.text }));
	                });
	            } else {
	                $field.replaceWith($('<input/>', { id: address_state.replace('#', ''), name: 'address_state', type: 'text', maxlength: '35' }));
	                $field = $(address_state);
	            }
	            $field.val(get_settings_data.address_state);
	        }

	        initFormManager();
	        if (is_jp && !is_virtual) {
	            // detect hedging needs to be called after FormManager.init
	            // or all previously bound event listeners on form elements will be removed
	            detectHedging($('#trading_purpose'), $('.hedge'));
	        }
	    };

	    var initFormManager = function initFormManager() {
	        FormManager.init(form_id, getValidations(get_settings_data));
	    };

	    var onLoad = function onLoad() {
	        BinarySocket.wait('get_account_status', 'get_settings').then(function () {
	            init();
	            get_settings_data = State.get(['response', 'get_settings', 'get_settings']);
	            getDetailsResponse(get_settings_data);
	            if (!is_virtual || !residence) {
	                $('#btn_update').setVisibility(1);
	                if (!is_jp) {
	                    BinarySocket.send({ residence_list: 1 }).then(function (response) {
	                        return populateResidence(response);
	                    });
	                }
	                if (residence) {
	                    BinarySocket.send({ states_list: residence }).then(function (response) {
	                        return populateStates(response);
	                    });
	                }
	            } else {
	                $('#btn_update').setVisibility(0);
	            }
	        });
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = PersonalDetails;

/***/ },
/* 567 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;/*!
	 * Select2 4.0.3
	 * https://select2.github.io
	 *
	 * Released under the MIT license
	 * https://github.com/select2/select2/blob/master/LICENSE.md
	 */
	(function (factory) {
	  if (true) {
	    // AMD. Register as an anonymous module.
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    // Node/CommonJS
	    factory(require('jquery'));
	  } else {
	    // Browser globals
	    factory(jQuery);
	  }
	}(function (jQuery) {
	  // This is needed so we can catch the AMD loader configuration and use it
	  // The inner file should be wrapped (by `banner.start.js`) in a function that
	  // returns the AMD loader references.
	  var S2 =
	(function () {
	  // Restore the Select2 AMD loader so it can be used
	  // Needed mostly in the language files, where the loader is not inserted
	  if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
	    var S2 = jQuery.fn.select2.amd;
	  }
	var S2;(function () { if (!S2 || !S2.requirejs) {
	if (!S2) { S2 = {}; } else { require = S2; }
	/**
	 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
	 * Available via the MIT or new BSD license.
	 * see: http://github.com/jrburke/almond for details
	 */
	//Going sloppy to avoid 'use strict' string cost, but strict practices should
	//be followed.
	/*jslint sloppy: true */
	/*global setTimeout: false */

	var requirejs, require, define;
	(function (undef) {
	    var main, req, makeMap, handlers,
	        defined = {},
	        waiting = {},
	        config = {},
	        defining = {},
	        hasOwn = Object.prototype.hasOwnProperty,
	        aps = [].slice,
	        jsSuffixRegExp = /\.js$/;

	    function hasProp(obj, prop) {
	        return hasOwn.call(obj, prop);
	    }

	    /**
	     * Given a relative module name, like ./something, normalize it to
	     * a real name that can be mapped to a path.
	     * @param {String} name the relative name
	     * @param {String} baseName a real name that the name arg is relative
	     * to.
	     * @returns {String} normalized name
	     */
	    function normalize(name, baseName) {
	        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
	            foundI, foundStarMap, starI, i, j, part,
	            baseParts = baseName && baseName.split("/"),
	            map = config.map,
	            starMap = (map && map['*']) || {};

	        //Adjust any relative paths.
	        if (name && name.charAt(0) === ".") {
	            //If have a base name, try to normalize against it,
	            //otherwise, assume it is a top-level require that will
	            //be relative to baseUrl in the end.
	            if (baseName) {
	                name = name.split('/');
	                lastIndex = name.length - 1;

	                // Node .js allowance:
	                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
	                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
	                }

	                //Lop off the last part of baseParts, so that . matches the
	                //"directory" and not name of the baseName's module. For instance,
	                //baseName of "one/two/three", maps to "one/two/three.js", but we
	                //want the directory, "one/two" for this normalization.
	                name = baseParts.slice(0, baseParts.length - 1).concat(name);

	                //start trimDots
	                for (i = 0; i < name.length; i += 1) {
	                    part = name[i];
	                    if (part === ".") {
	                        name.splice(i, 1);
	                        i -= 1;
	                    } else if (part === "..") {
	                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
	                            //End of the line. Keep at least one non-dot
	                            //path segment at the front so it can be mapped
	                            //correctly to disk. Otherwise, there is likely
	                            //no path mapping for a path starting with '..'.
	                            //This can still fail, but catches the most reasonable
	                            //uses of ..
	                            break;
	                        } else if (i > 0) {
	                            name.splice(i - 1, 2);
	                            i -= 2;
	                        }
	                    }
	                }
	                //end trimDots

	                name = name.join("/");
	            } else if (name.indexOf('./') === 0) {
	                // No baseName, so this is ID is resolved relative
	                // to baseUrl, pull off the leading dot.
	                name = name.substring(2);
	            }
	        }

	        //Apply map config if available.
	        if ((baseParts || starMap) && map) {
	            nameParts = name.split('/');

	            for (i = nameParts.length; i > 0; i -= 1) {
	                nameSegment = nameParts.slice(0, i).join("/");

	                if (baseParts) {
	                    //Find the longest baseName segment match in the config.
	                    //So, do joins on the biggest to smallest lengths of baseParts.
	                    for (j = baseParts.length; j > 0; j -= 1) {
	                        mapValue = map[baseParts.slice(0, j).join('/')];

	                        //baseName segment has  config, find if it has one for
	                        //this name.
	                        if (mapValue) {
	                            mapValue = mapValue[nameSegment];
	                            if (mapValue) {
	                                //Match, update name to the new value.
	                                foundMap = mapValue;
	                                foundI = i;
	                                break;
	                            }
	                        }
	                    }
	                }

	                if (foundMap) {
	                    break;
	                }

	                //Check for a star map match, but just hold on to it,
	                //if there is a shorter segment match later in a matching
	                //config, then favor over this star map.
	                if (!foundStarMap && starMap && starMap[nameSegment]) {
	                    foundStarMap = starMap[nameSegment];
	                    starI = i;
	                }
	            }

	            if (!foundMap && foundStarMap) {
	                foundMap = foundStarMap;
	                foundI = starI;
	            }

	            if (foundMap) {
	                nameParts.splice(0, foundI, foundMap);
	                name = nameParts.join('/');
	            }
	        }

	        return name;
	    }

	    function makeRequire(relName, forceSync) {
	        return function () {
	            //A version of a require function that passes a moduleName
	            //value for items that may need to
	            //look up paths relative to the moduleName
	            var args = aps.call(arguments, 0);

	            //If first arg is not require('string'), and there is only
	            //one arg, it is the array form without a callback. Insert
	            //a null so that the following concat is correct.
	            if (typeof args[0] !== 'string' && args.length === 1) {
	                args.push(null);
	            }
	            return req.apply(undef, args.concat([relName, forceSync]));
	        };
	    }

	    function makeNormalize(relName) {
	        return function (name) {
	            return normalize(name, relName);
	        };
	    }

	    function makeLoad(depName) {
	        return function (value) {
	            defined[depName] = value;
	        };
	    }

	    function callDep(name) {
	        if (hasProp(waiting, name)) {
	            var args = waiting[name];
	            delete waiting[name];
	            defining[name] = true;
	            main.apply(undef, args);
	        }

	        if (!hasProp(defined, name) && !hasProp(defining, name)) {
	            throw new Error('No ' + name);
	        }
	        return defined[name];
	    }

	    //Turns a plugin!resource to [plugin, resource]
	    //with the plugin being undefined if the name
	    //did not have a plugin prefix.
	    function splitPrefix(name) {
	        var prefix,
	            index = name ? name.indexOf('!') : -1;
	        if (index > -1) {
	            prefix = name.substring(0, index);
	            name = name.substring(index + 1, name.length);
	        }
	        return [prefix, name];
	    }

	    /**
	     * Makes a name map, normalizing the name, and using a plugin
	     * for normalization if necessary. Grabs a ref to plugin
	     * too, as an optimization.
	     */
	    makeMap = function (name, relName) {
	        var plugin,
	            parts = splitPrefix(name),
	            prefix = parts[0];

	        name = parts[1];

	        if (prefix) {
	            prefix = normalize(prefix, relName);
	            plugin = callDep(prefix);
	        }

	        //Normalize according
	        if (prefix) {
	            if (plugin && plugin.normalize) {
	                name = plugin.normalize(name, makeNormalize(relName));
	            } else {
	                name = normalize(name, relName);
	            }
	        } else {
	            name = normalize(name, relName);
	            parts = splitPrefix(name);
	            prefix = parts[0];
	            name = parts[1];
	            if (prefix) {
	                plugin = callDep(prefix);
	            }
	        }

	        //Using ridiculous property names for space reasons
	        return {
	            f: prefix ? prefix + '!' + name : name, //fullName
	            n: name,
	            pr: prefix,
	            p: plugin
	        };
	    };

	    function makeConfig(name) {
	        return function () {
	            return (config && config.config && config.config[name]) || {};
	        };
	    }

	    handlers = {
	        require: function (name) {
	            return makeRequire(name);
	        },
	        exports: function (name) {
	            var e = defined[name];
	            if (typeof e !== 'undefined') {
	                return e;
	            } else {
	                return (defined[name] = {});
	            }
	        },
	        module: function (name) {
	            return {
	                id: name,
	                uri: '',
	                exports: defined[name],
	                config: makeConfig(name)
	            };
	        }
	    };

	    main = function (name, deps, callback, relName) {
	        var cjsModule, depName, ret, map, i,
	            args = [],
	            callbackType = typeof callback,
	            usingExports;

	        //Use name if no relName
	        relName = relName || name;

	        //Call the callback to define the module, if necessary.
	        if (callbackType === 'undefined' || callbackType === 'function') {
	            //Pull out the defined dependencies and pass the ordered
	            //values to the callback.
	            //Default to [require, exports, module] if no deps
	            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
	            for (i = 0; i < deps.length; i += 1) {
	                map = makeMap(deps[i], relName);
	                depName = map.f;

	                //Fast path CommonJS standard dependencies.
	                if (depName === "require") {
	                    args[i] = handlers.require(name);
	                } else if (depName === "exports") {
	                    //CommonJS module spec 1.1
	                    args[i] = handlers.exports(name);
	                    usingExports = true;
	                } else if (depName === "module") {
	                    //CommonJS module spec 1.1
	                    cjsModule = args[i] = handlers.module(name);
	                } else if (hasProp(defined, depName) ||
	                           hasProp(waiting, depName) ||
	                           hasProp(defining, depName)) {
	                    args[i] = callDep(depName);
	                } else if (map.p) {
	                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
	                    args[i] = defined[depName];
	                } else {
	                    throw new Error(name + ' missing ' + depName);
	                }
	            }

	            ret = callback ? callback.apply(defined[name], args) : undefined;

	            if (name) {
	                //If setting exports via "module" is in play,
	                //favor that over return value and exports. After that,
	                //favor a non-undefined return value over exports use.
	                if (cjsModule && cjsModule.exports !== undef &&
	                        cjsModule.exports !== defined[name]) {
	                    defined[name] = cjsModule.exports;
	                } else if (ret !== undef || !usingExports) {
	                    //Use the return value from the function.
	                    defined[name] = ret;
	                }
	            }
	        } else if (name) {
	            //May just be an object definition for the module. Only
	            //worry about defining if have a module name.
	            defined[name] = callback;
	        }
	    };

	    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
	        if (typeof deps === "string") {
	            if (handlers[deps]) {
	                //callback in this case is really relName
	                return handlers[deps](callback);
	            }
	            //Just return the module wanted. In this scenario, the
	            //deps arg is the module name, and second arg (if passed)
	            //is just the relName.
	            //Normalize module name, if it contains . or ..
	            return callDep(makeMap(deps, callback).f);
	        } else if (!deps.splice) {
	            //deps is a config object, not an array.
	            config = deps;
	            if (config.deps) {
	                req(config.deps, config.callback);
	            }
	            if (!callback) {
	                return;
	            }

	            if (callback.splice) {
	                //callback is an array, which means it is a dependency list.
	                //Adjust args if there are dependencies
	                deps = callback;
	                callback = relName;
	                relName = null;
	            } else {
	                deps = undef;
	            }
	        }

	        //Support require(['a'])
	        callback = callback || function () {};

	        //If relName is a function, it is an errback handler,
	        //so remove it.
	        if (typeof relName === 'function') {
	            relName = forceSync;
	            forceSync = alt;
	        }

	        //Simulate async callback;
	        if (forceSync) {
	            main(undef, deps, callback, relName);
	        } else {
	            //Using a non-zero value because of concern for what old browsers
	            //do, and latest browsers "upgrade" to 4 if lower value is used:
	            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
	            //If want a value immediately, use require('id') instead -- something
	            //that works in almond on the global level, but not guaranteed and
	            //unlikely to work in other AMD implementations.
	            setTimeout(function () {
	                main(undef, deps, callback, relName);
	            }, 4);
	        }

	        return req;
	    };

	    /**
	     * Just drops the config on the floor, but returns req in case
	     * the config return value is used.
	     */
	    req.config = function (cfg) {
	        return req(cfg);
	    };

	    /**
	     * Expose module registry for debugging and tooling
	     */
	    requirejs._defined = defined;

	    define = function (name, deps, callback) {
	        if (typeof name !== 'string') {
	            throw new Error('See almond README: incorrect module build, no module name');
	        }

	        //This module may not have dependencies
	        if (!deps.splice) {
	            //deps is not an array, so probably means
	            //an object literal or factory function for
	            //the value. Adjust args.
	            callback = deps;
	            deps = [];
	        }

	        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
	            waiting[name] = [name, deps, callback];
	        }
	    };

	    define.amd = {
	        jQuery: true
	    };
	}());

	S2.requirejs = requirejs;S2.require = require;S2.define = define;
	}
	}());
	S2.define("almond", function(){});

	/* global jQuery:false, $:false */
	S2.define('jquery',[],function () {
	  var _$ = jQuery || $;

	  if (_$ == null && console && console.error) {
	    console.error(
	      'Select2: An instance of jQuery or a jQuery-compatible library was not ' +
	      'found. Make sure that you are including jQuery before Select2 on your ' +
	      'web page.'
	    );
	  }

	  return _$;
	});

	S2.define('select2/utils',[
	  'jquery'
	], function ($) {
	  var Utils = {};

	  Utils.Extend = function (ChildClass, SuperClass) {
	    var __hasProp = {}.hasOwnProperty;

	    function BaseConstructor () {
	      this.constructor = ChildClass;
	    }

	    for (var key in SuperClass) {
	      if (__hasProp.call(SuperClass, key)) {
	        ChildClass[key] = SuperClass[key];
	      }
	    }

	    BaseConstructor.prototype = SuperClass.prototype;
	    ChildClass.prototype = new BaseConstructor();
	    ChildClass.__super__ = SuperClass.prototype;

	    return ChildClass;
	  };

	  function getMethods (theClass) {
	    var proto = theClass.prototype;

	    var methods = [];

	    for (var methodName in proto) {
	      var m = proto[methodName];

	      if (typeof m !== 'function') {
	        continue;
	      }

	      if (methodName === 'constructor') {
	        continue;
	      }

	      methods.push(methodName);
	    }

	    return methods;
	  }

	  Utils.Decorate = function (SuperClass, DecoratorClass) {
	    var decoratedMethods = getMethods(DecoratorClass);
	    var superMethods = getMethods(SuperClass);

	    function DecoratedClass () {
	      var unshift = Array.prototype.unshift;

	      var argCount = DecoratorClass.prototype.constructor.length;

	      var calledConstructor = SuperClass.prototype.constructor;

	      if (argCount > 0) {
	        unshift.call(arguments, SuperClass.prototype.constructor);

	        calledConstructor = DecoratorClass.prototype.constructor;
	      }

	      calledConstructor.apply(this, arguments);
	    }

	    DecoratorClass.displayName = SuperClass.displayName;

	    function ctr () {
	      this.constructor = DecoratedClass;
	    }

	    DecoratedClass.prototype = new ctr();

	    for (var m = 0; m < superMethods.length; m++) {
	        var superMethod = superMethods[m];

	        DecoratedClass.prototype[superMethod] =
	          SuperClass.prototype[superMethod];
	    }

	    var calledMethod = function (methodName) {
	      // Stub out the original method if it's not decorating an actual method
	      var originalMethod = function () {};

	      if (methodName in DecoratedClass.prototype) {
	        originalMethod = DecoratedClass.prototype[methodName];
	      }

	      var decoratedMethod = DecoratorClass.prototype[methodName];

	      return function () {
	        var unshift = Array.prototype.unshift;

	        unshift.call(arguments, originalMethod);

	        return decoratedMethod.apply(this, arguments);
	      };
	    };

	    for (var d = 0; d < decoratedMethods.length; d++) {
	      var decoratedMethod = decoratedMethods[d];

	      DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
	    }

	    return DecoratedClass;
	  };

	  var Observable = function () {
	    this.listeners = {};
	  };

	  Observable.prototype.on = function (event, callback) {
	    this.listeners = this.listeners || {};

	    if (event in this.listeners) {
	      this.listeners[event].push(callback);
	    } else {
	      this.listeners[event] = [callback];
	    }
	  };

	  Observable.prototype.trigger = function (event) {
	    var slice = Array.prototype.slice;
	    var params = slice.call(arguments, 1);

	    this.listeners = this.listeners || {};

	    // Params should always come in as an array
	    if (params == null) {
	      params = [];
	    }

	    // If there are no arguments to the event, use a temporary object
	    if (params.length === 0) {
	      params.push({});
	    }

	    // Set the `_type` of the first object to the event
	    params[0]._type = event;

	    if (event in this.listeners) {
	      this.invoke(this.listeners[event], slice.call(arguments, 1));
	    }

	    if ('*' in this.listeners) {
	      this.invoke(this.listeners['*'], arguments);
	    }
	  };

	  Observable.prototype.invoke = function (listeners, params) {
	    for (var i = 0, len = listeners.length; i < len; i++) {
	      listeners[i].apply(this, params);
	    }
	  };

	  Utils.Observable = Observable;

	  Utils.generateChars = function (length) {
	    var chars = '';

	    for (var i = 0; i < length; i++) {
	      var randomChar = Math.floor(Math.random() * 36);
	      chars += randomChar.toString(36);
	    }

	    return chars;
	  };

	  Utils.bind = function (func, context) {
	    return function () {
	      func.apply(context, arguments);
	    };
	  };

	  Utils._convertData = function (data) {
	    for (var originalKey in data) {
	      var keys = originalKey.split('-');

	      var dataLevel = data;

	      if (keys.length === 1) {
	        continue;
	      }

	      for (var k = 0; k < keys.length; k++) {
	        var key = keys[k];

	        // Lowercase the first letter
	        // By default, dash-separated becomes camelCase
	        key = key.substring(0, 1).toLowerCase() + key.substring(1);

	        if (!(key in dataLevel)) {
	          dataLevel[key] = {};
	        }

	        if (k == keys.length - 1) {
	          dataLevel[key] = data[originalKey];
	        }

	        dataLevel = dataLevel[key];
	      }

	      delete data[originalKey];
	    }

	    return data;
	  };

	  Utils.hasScroll = function (index, el) {
	    // Adapted from the function created by @ShadowScripter
	    // and adapted by @BillBarry on the Stack Exchange Code Review website.
	    // The original code can be found at
	    // http://codereview.stackexchange.com/q/13338
	    // and was designed to be used with the Sizzle selector engine.

	    var $el = $(el);
	    var overflowX = el.style.overflowX;
	    var overflowY = el.style.overflowY;

	    //Check both x and y declarations
	    if (overflowX === overflowY &&
	        (overflowY === 'hidden' || overflowY === 'visible')) {
	      return false;
	    }

	    if (overflowX === 'scroll' || overflowY === 'scroll') {
	      return true;
	    }

	    return ($el.innerHeight() < el.scrollHeight ||
	      $el.innerWidth() < el.scrollWidth);
	  };

	  Utils.escapeMarkup = function (markup) {
	    var replaceMap = {
	      '\\': '&#92;',
	      '&': '&amp;',
	      '<': '&lt;',
	      '>': '&gt;',
	      '"': '&quot;',
	      '\'': '&#39;',
	      '/': '&#47;'
	    };

	    // Do not try to escape the markup if it's not a string
	    if (typeof markup !== 'string') {
	      return markup;
	    }

	    return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
	      return replaceMap[match];
	    });
	  };

	  // Append an array of jQuery nodes to a given element.
	  Utils.appendMany = function ($element, $nodes) {
	    // jQuery 1.7.x does not support $.fn.append() with an array
	    // Fall back to a jQuery object collection using $.fn.add()
	    if ($.fn.jquery.substr(0, 3) === '1.7') {
	      var $jqNodes = $();

	      $.map($nodes, function (node) {
	        $jqNodes = $jqNodes.add(node);
	      });

	      $nodes = $jqNodes;
	    }

	    $element.append($nodes);
	  };

	  return Utils;
	});

	S2.define('select2/results',[
	  'jquery',
	  './utils'
	], function ($, Utils) {
	  function Results ($element, options, dataAdapter) {
	    this.$element = $element;
	    this.data = dataAdapter;
	    this.options = options;

	    Results.__super__.constructor.call(this);
	  }

	  Utils.Extend(Results, Utils.Observable);

	  Results.prototype.render = function () {
	    var $results = $(
	      '<ul class="select2-results__options" role="tree"></ul>'
	    );

	    if (this.options.get('multiple')) {
	      $results.attr('aria-multiselectable', 'true');
	    }

	    this.$results = $results;

	    return $results;
	  };

	  Results.prototype.clear = function () {
	    this.$results.empty();
	  };

	  Results.prototype.displayMessage = function (params) {
	    var escapeMarkup = this.options.get('escapeMarkup');

	    this.clear();
	    this.hideLoading();

	    var $message = $(
	      '<li role="treeitem" aria-live="assertive"' +
	      ' class="select2-results__option"></li>'
	    );

	    var message = this.options.get('translations').get(params.message);

	    $message.append(
	      escapeMarkup(
	        message(params.args)
	      )
	    );

	    $message[0].className += ' select2-results__message';

	    this.$results.append($message);
	  };

	  Results.prototype.hideMessages = function () {
	    this.$results.find('.select2-results__message').remove();
	  };

	  Results.prototype.append = function (data) {
	    this.hideLoading();

	    var $options = [];

	    if (data.results == null || data.results.length === 0) {
	      if (this.$results.children().length === 0) {
	        this.trigger('results:message', {
	          message: 'noResults'
	        });
	      }

	      return;
	    }

	    data.results = this.sort(data.results);

	    for (var d = 0; d < data.results.length; d++) {
	      var item = data.results[d];

	      var $option = this.option(item);

	      $options.push($option);
	    }

	    this.$results.append($options);
	  };

	  Results.prototype.position = function ($results, $dropdown) {
	    var $resultsContainer = $dropdown.find('.select2-results');
	    $resultsContainer.append($results);
	  };

	  Results.prototype.sort = function (data) {
	    var sorter = this.options.get('sorter');

	    return sorter(data);
	  };

	  Results.prototype.highlightFirstItem = function () {
	    var $options = this.$results
	      .find('.select2-results__option[aria-selected]');

	    var $selected = $options.filter('[aria-selected=true]');

	    // Check if there are any selected options
	    if ($selected.length > 0) {
	      // If there are selected options, highlight the first
	      $selected.first().trigger('mouseenter');
	    } else {
	      // If there are no selected options, highlight the first option
	      // in the dropdown
	      $options.first().trigger('mouseenter');
	    }

	    this.ensureHighlightVisible();
	  };

	  Results.prototype.setClasses = function () {
	    var self = this;

	    this.data.current(function (selected) {
	      var selectedIds = $.map(selected, function (s) {
	        return s.id.toString();
	      });

	      var $options = self.$results
	        .find('.select2-results__option[aria-selected]');

	      $options.each(function () {
	        var $option = $(this);

	        var item = $.data(this, 'data');

	        // id needs to be converted to a string when comparing
	        var id = '' + item.id;

	        if ((item.element != null && item.element.selected) ||
	            (item.element == null && $.inArray(id, selectedIds) > -1)) {
	          $option.attr('aria-selected', 'true');
	        } else {
	          $option.attr('aria-selected', 'false');
	        }
	      });

	    });
	  };

	  Results.prototype.showLoading = function (params) {
	    this.hideLoading();

	    var loadingMore = this.options.get('translations').get('searching');

	    var loading = {
	      disabled: true,
	      loading: true,
	      text: loadingMore(params)
	    };
	    var $loading = this.option(loading);
	    $loading.className += ' loading-results';

	    this.$results.prepend($loading);
	  };

	  Results.prototype.hideLoading = function () {
	    this.$results.find('.loading-results').remove();
	  };

	  Results.prototype.option = function (data) {
	    var option = document.createElement('li');
	    option.className = 'select2-results__option';

	    var attrs = {
	      'role': 'treeitem',
	      'aria-selected': 'false'
	    };

	    if (data.disabled) {
	      delete attrs['aria-selected'];
	      attrs['aria-disabled'] = 'true';
	    }

	    if (data.id == null) {
	      delete attrs['aria-selected'];
	    }

	    if (data._resultId != null) {
	      option.id = data._resultId;
	    }

	    if (data.title) {
	      option.title = data.title;
	    }

	    if (data.children) {
	      attrs.role = 'group';
	      attrs['aria-label'] = data.text;
	      delete attrs['aria-selected'];
	    }

	    for (var attr in attrs) {
	      var val = attrs[attr];

	      option.setAttribute(attr, val);
	    }

	    if (data.children) {
	      var $option = $(option);

	      var label = document.createElement('strong');
	      label.className = 'select2-results__group';

	      var $label = $(label);
	      this.template(data, label);

	      var $children = [];

	      for (var c = 0; c < data.children.length; c++) {
	        var child = data.children[c];

	        var $child = this.option(child);

	        $children.push($child);
	      }

	      var $childrenContainer = $('<ul></ul>', {
	        'class': 'select2-results__options select2-results__options--nested'
	      });

	      $childrenContainer.append($children);

	      $option.append(label);
	      $option.append($childrenContainer);
	    } else {
	      this.template(data, option);
	    }

	    $.data(option, 'data', data);

	    return option;
	  };

	  Results.prototype.bind = function (container, $container) {
	    var self = this;

	    var id = container.id + '-results';

	    this.$results.attr('id', id);

	    container.on('results:all', function (params) {
	      self.clear();
	      self.append(params.data);

	      if (container.isOpen()) {
	        self.setClasses();
	        self.highlightFirstItem();
	      }
	    });

	    container.on('results:append', function (params) {
	      self.append(params.data);

	      if (container.isOpen()) {
	        self.setClasses();
	      }
	    });

	    container.on('query', function (params) {
	      self.hideMessages();
	      self.showLoading(params);
	    });

	    container.on('select', function () {
	      if (!container.isOpen()) {
	        return;
	      }

	      self.setClasses();
	      self.highlightFirstItem();
	    });

	    container.on('unselect', function () {
	      if (!container.isOpen()) {
	        return;
	      }

	      self.setClasses();
	      self.highlightFirstItem();
	    });

	    container.on('open', function () {
	      // When the dropdown is open, aria-expended="true"
	      self.$results.attr('aria-expanded', 'true');
	      self.$results.attr('aria-hidden', 'false');

	      self.setClasses();
	      self.ensureHighlightVisible();
	    });

	    container.on('close', function () {
	      // When the dropdown is closed, aria-expended="false"
	      self.$results.attr('aria-expanded', 'false');
	      self.$results.attr('aria-hidden', 'true');
	      self.$results.removeAttr('aria-activedescendant');
	    });

	    container.on('results:toggle', function () {
	      var $highlighted = self.getHighlightedResults();

	      if ($highlighted.length === 0) {
	        return;
	      }

	      $highlighted.trigger('mouseup');
	    });

	    container.on('results:select', function () {
	      var $highlighted = self.getHighlightedResults();

	      if ($highlighted.length === 0) {
	        return;
	      }

	      var data = $highlighted.data('data');

	      if ($highlighted.attr('aria-selected') == 'true') {
	        self.trigger('close', {});
	      } else {
	        self.trigger('select', {
	          data: data
	        });
	      }
	    });

	    container.on('results:previous', function () {
	      var $highlighted = self.getHighlightedResults();

	      var $options = self.$results.find('[aria-selected]');

	      var currentIndex = $options.index($highlighted);

	      // If we are already at te top, don't move further
	      if (currentIndex === 0) {
	        return;
	      }

	      var nextIndex = currentIndex - 1;

	      // If none are highlighted, highlight the first
	      if ($highlighted.length === 0) {
	        nextIndex = 0;
	      }

	      var $next = $options.eq(nextIndex);

	      $next.trigger('mouseenter');

	      var currentOffset = self.$results.offset().top;
	      var nextTop = $next.offset().top;
	      var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);

	      if (nextIndex === 0) {
	        self.$results.scrollTop(0);
	      } else if (nextTop - currentOffset < 0) {
	        self.$results.scrollTop(nextOffset);
	      }
	    });

	    container.on('results:next', function () {
	      var $highlighted = self.getHighlightedResults();

	      var $options = self.$results.find('[aria-selected]');

	      var currentIndex = $options.index($highlighted);

	      var nextIndex = currentIndex + 1;

	      // If we are at the last option, stay there
	      if (nextIndex >= $options.length) {
	        return;
	      }

	      var $next = $options.eq(nextIndex);

	      $next.trigger('mouseenter');

	      var currentOffset = self.$results.offset().top +
	        self.$results.outerHeight(false);
	      var nextBottom = $next.offset().top + $next.outerHeight(false);
	      var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;

	      if (nextIndex === 0) {
	        self.$results.scrollTop(0);
	      } else if (nextBottom > currentOffset) {
	        self.$results.scrollTop(nextOffset);
	      }
	    });

	    container.on('results:focus', function (params) {
	      params.element.addClass('select2-results__option--highlighted');
	    });

	    container.on('results:message', function (params) {
	      self.displayMessage(params);
	    });

	    if ($.fn.mousewheel) {
	      this.$results.on('mousewheel', function (e) {
	        var top = self.$results.scrollTop();

	        var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;

	        var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
	        var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();

	        if (isAtTop) {
	          self.$results.scrollTop(0);

	          e.preventDefault();
	          e.stopPropagation();
	        } else if (isAtBottom) {
	          self.$results.scrollTop(
	            self.$results.get(0).scrollHeight - self.$results.height()
	          );

	          e.preventDefault();
	          e.stopPropagation();
	        }
	      });
	    }

	    this.$results.on('mouseup', '.select2-results__option[aria-selected]',
	      function (evt) {
	      var $this = $(this);

	      var data = $this.data('data');

	      if ($this.attr('aria-selected') === 'true') {
	        if (self.options.get('multiple')) {
	          self.trigger('unselect', {
	            originalEvent: evt,
	            data: data
	          });
	        } else {
	          self.trigger('close', {});
	        }

	        return;
	      }

	      self.trigger('select', {
	        originalEvent: evt,
	        data: data
	      });
	    });

	    this.$results.on('mouseenter', '.select2-results__option[aria-selected]',
	      function (evt) {
	      var data = $(this).data('data');

	      self.getHighlightedResults()
	          .removeClass('select2-results__option--highlighted');

	      self.trigger('results:focus', {
	        data: data,
	        element: $(this)
	      });
	    });
	  };

	  Results.prototype.getHighlightedResults = function () {
	    var $highlighted = this.$results
	    .find('.select2-results__option--highlighted');

	    return $highlighted;
	  };

	  Results.prototype.destroy = function () {
	    this.$results.remove();
	  };

	  Results.prototype.ensureHighlightVisible = function () {
	    var $highlighted = this.getHighlightedResults();

	    if ($highlighted.length === 0) {
	      return;
	    }

	    var $options = this.$results.find('[aria-selected]');

	    var currentIndex = $options.index($highlighted);

	    var currentOffset = this.$results.offset().top;
	    var nextTop = $highlighted.offset().top;
	    var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);

	    var offsetDelta = nextTop - currentOffset;
	    nextOffset -= $highlighted.outerHeight(false) * 2;

	    if (currentIndex <= 2) {
	      this.$results.scrollTop(0);
	    } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
	      this.$results.scrollTop(nextOffset);
	    }
	  };

	  Results.prototype.template = function (result, container) {
	    var template = this.options.get('templateResult');
	    var escapeMarkup = this.options.get('escapeMarkup');

	    var content = template(result, container);

	    if (content == null) {
	      container.style.display = 'none';
	    } else if (typeof content === 'string') {
	      container.innerHTML = escapeMarkup(content);
	    } else {
	      $(container).append(content);
	    }
	  };

	  return Results;
	});

	S2.define('select2/keys',[

	], function () {
	  var KEYS = {
	    BACKSPACE: 8,
	    TAB: 9,
	    ENTER: 13,
	    SHIFT: 16,
	    CTRL: 17,
	    ALT: 18,
	    ESC: 27,
	    SPACE: 32,
	    PAGE_UP: 33,
	    PAGE_DOWN: 34,
	    END: 35,
	    HOME: 36,
	    LEFT: 37,
	    UP: 38,
	    RIGHT: 39,
	    DOWN: 40,
	    DELETE: 46
	  };

	  return KEYS;
	});

	S2.define('select2/selection/base',[
	  'jquery',
	  '../utils',
	  '../keys'
	], function ($, Utils, KEYS) {
	  function BaseSelection ($element, options) {
	    this.$element = $element;
	    this.options = options;

	    BaseSelection.__super__.constructor.call(this);
	  }

	  Utils.Extend(BaseSelection, Utils.Observable);

	  BaseSelection.prototype.render = function () {
	    var $selection = $(
	      '<span class="select2-selection" role="combobox" ' +
	      ' aria-haspopup="true" aria-expanded="false">' +
	      '</span>'
	    );

	    this._tabindex = 0;

	    if (this.$element.data('old-tabindex') != null) {
	      this._tabindex = this.$element.data('old-tabindex');
	    } else if (this.$element.attr('tabindex') != null) {
	      this._tabindex = this.$element.attr('tabindex');
	    }

	    $selection.attr('title', this.$element.attr('title'));
	    $selection.attr('tabindex', this._tabindex);

	    this.$selection = $selection;

	    return $selection;
	  };

	  BaseSelection.prototype.bind = function (container, $container) {
	    var self = this;

	    var id = container.id + '-container';
	    var resultsId = container.id + '-results';

	    this.container = container;

	    this.$selection.on('focus', function (evt) {
	      self.trigger('focus', evt);
	    });

	    this.$selection.on('blur', function (evt) {
	      self._handleBlur(evt);
	    });

	    this.$selection.on('keydown', function (evt) {
	      self.trigger('keypress', evt);

	      if (evt.which === KEYS.SPACE) {
	        evt.preventDefault();
	      }
	    });

	    container.on('results:focus', function (params) {
	      self.$selection.attr('aria-activedescendant', params.data._resultId);
	    });

	    container.on('selection:update', function (params) {
	      self.update(params.data);
	    });

	    container.on('open', function () {
	      // When the dropdown is open, aria-expanded="true"
	      self.$selection.attr('aria-expanded', 'true');
	      self.$selection.attr('aria-owns', resultsId);

	      self._attachCloseHandler(container);
	    });

	    container.on('close', function () {
	      // When the dropdown is closed, aria-expanded="false"
	      self.$selection.attr('aria-expanded', 'false');
	      self.$selection.removeAttr('aria-activedescendant');
	      self.$selection.removeAttr('aria-owns');

	      self.$selection.focus();

	      self._detachCloseHandler(container);
	    });

	    container.on('enable', function () {
	      self.$selection.attr('tabindex', self._tabindex);
	    });

	    container.on('disable', function () {
	      self.$selection.attr('tabindex', '-1');
	    });
	  };

	  BaseSelection.prototype._handleBlur = function (evt) {
	    var self = this;

	    // This needs to be delayed as the active element is the body when the tab
	    // key is pressed, possibly along with others.
	    window.setTimeout(function () {
	      // Don't trigger `blur` if the focus is still in the selection
	      if (
	        (document.activeElement == self.$selection[0]) ||
	        ($.contains(self.$selection[0], document.activeElement))
	      ) {
	        return;
	      }

	      self.trigger('blur', evt);
	    }, 1);
	  };

	  BaseSelection.prototype._attachCloseHandler = function (container) {
	    var self = this;

	    $(document.body).on('mousedown.select2.' + container.id, function (e) {
	      var $target = $(e.target);

	      var $select = $target.closest('.select2');

	      var $all = $('.select2.select2-container--open');

	      $all.each(function () {
	        var $this = $(this);

	        if (this == $select[0]) {
	          return;
	        }

	        var $element = $this.data('element');

	        $element.select2('close');
	      });
	    });
	  };

	  BaseSelection.prototype._detachCloseHandler = function (container) {
	    $(document.body).off('mousedown.select2.' + container.id);
	  };

	  BaseSelection.prototype.position = function ($selection, $container) {
	    var $selectionContainer = $container.find('.selection');
	    $selectionContainer.append($selection);
	  };

	  BaseSelection.prototype.destroy = function () {
	    this._detachCloseHandler(this.container);
	  };

	  BaseSelection.prototype.update = function (data) {
	    throw new Error('The `update` method must be defined in child classes.');
	  };

	  return BaseSelection;
	});

	S2.define('select2/selection/single',[
	  'jquery',
	  './base',
	  '../utils',
	  '../keys'
	], function ($, BaseSelection, Utils, KEYS) {
	  function SingleSelection () {
	    SingleSelection.__super__.constructor.apply(this, arguments);
	  }

	  Utils.Extend(SingleSelection, BaseSelection);

	  SingleSelection.prototype.render = function () {
	    var $selection = SingleSelection.__super__.render.call(this);

	    $selection.addClass('select2-selection--single');

	    $selection.html(
	      '<span class="select2-selection__rendered"></span>' +
	      '<span class="select2-selection__arrow" role="presentation">' +
	        '<b role="presentation"></b>' +
	      '</span>'
	    );

	    return $selection;
	  };

	  SingleSelection.prototype.bind = function (container, $container) {
	    var self = this;

	    SingleSelection.__super__.bind.apply(this, arguments);

	    var id = container.id + '-container';

	    this.$selection.find('.select2-selection__rendered').attr('id', id);
	    this.$selection.attr('aria-labelledby', id);

	    this.$selection.on('mousedown', function (evt) {
	      // Only respond to left clicks
	      if (evt.which !== 1) {
	        return;
	      }

	      self.trigger('toggle', {
	        originalEvent: evt
	      });
	    });

	    this.$selection.on('focus', function (evt) {
	      // User focuses on the container
	    });

	    this.$selection.on('blur', function (evt) {
	      // User exits the container
	    });

	    container.on('focus', function (evt) {
	      if (!container.isOpen()) {
	        self.$selection.focus();
	      }
	    });

	    container.on('selection:update', function (params) {
	      self.update(params.data);
	    });
	  };

	  SingleSelection.prototype.clear = function () {
	    this.$selection.find('.select2-selection__rendered').empty();
	  };

	  SingleSelection.prototype.display = function (data, container) {
	    var template = this.options.get('templateSelection');
	    var escapeMarkup = this.options.get('escapeMarkup');

	    return escapeMarkup(template(data, container));
	  };

	  SingleSelection.prototype.selectionContainer = function () {
	    return $('<span></span>');
	  };

	  SingleSelection.prototype.update = function (data) {
	    if (data.length === 0) {
	      this.clear();
	      return;
	    }

	    var selection = data[0];

	    var $rendered = this.$selection.find('.select2-selection__rendered');
	    var formatted = this.display(selection, $rendered);

	    $rendered.empty().append(formatted);
	    $rendered.prop('title', selection.title || selection.text);
	  };

	  return SingleSelection;
	});

	S2.define('select2/selection/multiple',[
	  'jquery',
	  './base',
	  '../utils'
	], function ($, BaseSelection, Utils) {
	  function MultipleSelection ($element, options) {
	    MultipleSelection.__super__.constructor.apply(this, arguments);
	  }

	  Utils.Extend(MultipleSelection, BaseSelection);

	  MultipleSelection.prototype.render = function () {
	    var $selection = MultipleSelection.__super__.render.call(this);

	    $selection.addClass('select2-selection--multiple');

	    $selection.html(
	      '<ul class="select2-selection__rendered"></ul>'
	    );

	    return $selection;
	  };

	  MultipleSelection.prototype.bind = function (container, $container) {
	    var self = this;

	    MultipleSelection.__super__.bind.apply(this, arguments);

	    this.$selection.on('click', function (evt) {
	      self.trigger('toggle', {
	        originalEvent: evt
	      });
	    });

	    this.$selection.on(
	      'click',
	      '.select2-selection__choice__remove',
	      function (evt) {
	        // Ignore the event if it is disabled
	        if (self.options.get('disabled')) {
	          return;
	        }

	        var $remove = $(this);
	        var $selection = $remove.parent();

	        var data = $selection.data('data');

	        self.trigger('unselect', {
	          originalEvent: evt,
	          data: data
	        });
	      }
	    );
	  };

	  MultipleSelection.prototype.clear = function () {
	    this.$selection.find('.select2-selection__rendered').empty();
	  };

	  MultipleSelection.prototype.display = function (data, container) {
	    var template = this.options.get('templateSelection');
	    var escapeMarkup = this.options.get('escapeMarkup');

	    return escapeMarkup(template(data, container));
	  };

	  MultipleSelection.prototype.selectionContainer = function () {
	    var $container = $(
	      '<li class="select2-selection__choice">' +
	        '<span class="select2-selection__choice__remove" role="presentation">' +
	          '&times;' +
	        '</span>' +
	      '</li>'
	    );

	    return $container;
	  };

	  MultipleSelection.prototype.update = function (data) {
	    this.clear();

	    if (data.length === 0) {
	      return;
	    }

	    var $selections = [];

	    for (var d = 0; d < data.length; d++) {
	      var selection = data[d];

	      var $selection = this.selectionContainer();
	      var formatted = this.display(selection, $selection);

	      $selection.append(formatted);
	      $selection.prop('title', selection.title || selection.text);

	      $selection.data('data', selection);

	      $selections.push($selection);
	    }

	    var $rendered = this.$selection.find('.select2-selection__rendered');

	    Utils.appendMany($rendered, $selections);
	  };

	  return MultipleSelection;
	});

	S2.define('select2/selection/placeholder',[
	  '../utils'
	], function (Utils) {
	  function Placeholder (decorated, $element, options) {
	    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

	    decorated.call(this, $element, options);
	  }

	  Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
	    if (typeof placeholder === 'string') {
	      placeholder = {
	        id: '',
	        text: placeholder
	      };
	    }

	    return placeholder;
	  };

	  Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
	    var $placeholder = this.selectionContainer();

	    $placeholder.html(this.display(placeholder));
	    $placeholder.addClass('select2-selection__placeholder')
	                .removeClass('select2-selection__choice');

	    return $placeholder;
	  };

	  Placeholder.prototype.update = function (decorated, data) {
	    var singlePlaceholder = (
	      data.length == 1 && data[0].id != this.placeholder.id
	    );
	    var multipleSelections = data.length > 1;

	    if (multipleSelections || singlePlaceholder) {
	      return decorated.call(this, data);
	    }

	    this.clear();

	    var $placeholder = this.createPlaceholder(this.placeholder);

	    this.$selection.find('.select2-selection__rendered').append($placeholder);
	  };

	  return Placeholder;
	});

	S2.define('select2/selection/allowClear',[
	  'jquery',
	  '../keys'
	], function ($, KEYS) {
	  function AllowClear () { }

	  AllowClear.prototype.bind = function (decorated, container, $container) {
	    var self = this;

	    decorated.call(this, container, $container);

	    if (this.placeholder == null) {
	      if (this.options.get('debug') && window.console && console.error) {
	        console.error(
	          'Select2: The `allowClear` option should be used in combination ' +
	          'with the `placeholder` option.'
	        );
	      }
	    }

	    this.$selection.on('mousedown', '.select2-selection__clear',
	      function (evt) {
	        self._handleClear(evt);
	    });

	    container.on('keypress', function (evt) {
	      self._handleKeyboardClear(evt, container);
	    });
	  };

	  AllowClear.prototype._handleClear = function (_, evt) {
	    // Ignore the event if it is disabled
	    if (this.options.get('disabled')) {
	      return;
	    }

	    var $clear = this.$selection.find('.select2-selection__clear');

	    // Ignore the event if nothing has been selected
	    if ($clear.length === 0) {
	      return;
	    }

	    evt.stopPropagation();

	    var data = $clear.data('data');

	    for (var d = 0; d < data.length; d++) {
	      var unselectData = {
	        data: data[d]
	      };

	      // Trigger the `unselect` event, so people can prevent it from being
	      // cleared.
	      this.trigger('unselect', unselectData);

	      // If the event was prevented, don't clear it out.
	      if (unselectData.prevented) {
	        return;
	      }
	    }

	    this.$element.val(this.placeholder.id).trigger('change');

	    this.trigger('toggle', {});
	  };

	  AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
	    if (container.isOpen()) {
	      return;
	    }

	    if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
	      this._handleClear(evt);
	    }
	  };

	  AllowClear.prototype.update = function (decorated, data) {
	    decorated.call(this, data);

	    if (this.$selection.find('.select2-selection__placeholder').length > 0 ||
	        data.length === 0) {
	      return;
	    }

	    var $remove = $(
	      '<span class="select2-selection__clear">' +
	        '&times;' +
	      '</span>'
	    );
	    $remove.data('data', data);

	    this.$selection.find('.select2-selection__rendered').prepend($remove);
	  };

	  return AllowClear;
	});

	S2.define('select2/selection/search',[
	  'jquery',
	  '../utils',
	  '../keys'
	], function ($, Utils, KEYS) {
	  function Search (decorated, $element, options) {
	    decorated.call(this, $element, options);
	  }

	  Search.prototype.render = function (decorated) {
	    var $search = $(
	      '<li class="select2-search select2-search--inline">' +
	        '<input class="select2-search__field" type="search" tabindex="-1"' +
	        ' autocomplete="off" autocorrect="off" autocapitalize="off"' +
	        ' spellcheck="false" role="textbox" aria-autocomplete="list" />' +
	      '</li>'
	    );

	    this.$searchContainer = $search;
	    this.$search = $search.find('input');

	    var $rendered = decorated.call(this);

	    this._transferTabIndex();

	    return $rendered;
	  };

	  Search.prototype.bind = function (decorated, container, $container) {
	    var self = this;

	    decorated.call(this, container, $container);

	    container.on('open', function () {
	      self.$search.trigger('focus');
	    });

	    container.on('close', function () {
	      self.$search.val('');
	      self.$search.removeAttr('aria-activedescendant');
	      self.$search.trigger('focus');
	    });

	    container.on('enable', function () {
	      self.$search.prop('disabled', false);

	      self._transferTabIndex();
	    });

	    container.on('disable', function () {
	      self.$search.prop('disabled', true);
	    });

	    container.on('focus', function (evt) {
	      self.$search.trigger('focus');
	    });

	    container.on('results:focus', function (params) {
	      self.$search.attr('aria-activedescendant', params.id);
	    });

	    this.$selection.on('focusin', '.select2-search--inline', function (evt) {
	      self.trigger('focus', evt);
	    });

	    this.$selection.on('focusout', '.select2-search--inline', function (evt) {
	      self._handleBlur(evt);
	    });

	    this.$selection.on('keydown', '.select2-search--inline', function (evt) {
	      evt.stopPropagation();

	      self.trigger('keypress', evt);

	      self._keyUpPrevented = evt.isDefaultPrevented();

	      var key = evt.which;

	      if (key === KEYS.BACKSPACE && self.$search.val() === '') {
	        var $previousChoice = self.$searchContainer
	          .prev('.select2-selection__choice');

	        if ($previousChoice.length > 0) {
	          var item = $previousChoice.data('data');

	          self.searchRemoveChoice(item);

	          evt.preventDefault();
	        }
	      }
	    });

	    // Try to detect the IE version should the `documentMode` property that
	    // is stored on the document. This is only implemented in IE and is
	    // slightly cleaner than doing a user agent check.
	    // This property is not available in Edge, but Edge also doesn't have
	    // this bug.
	    var msie = document.documentMode;
	    var disableInputEvents = msie && msie <= 11;

	    // Workaround for browsers which do not support the `input` event
	    // This will prevent double-triggering of events for browsers which support
	    // both the `keyup` and `input` events.
	    this.$selection.on(
	      'input.searchcheck',
	      '.select2-search--inline',
	      function (evt) {
	        // IE will trigger the `input` event when a placeholder is used on a
	        // search box. To get around this issue, we are forced to ignore all
	        // `input` events in IE and keep using `keyup`.
	        if (disableInputEvents) {
	          self.$selection.off('input.search input.searchcheck');
	          return;
	        }

	        // Unbind the duplicated `keyup` event
	        self.$selection.off('keyup.search');
	      }
	    );

	    this.$selection.on(
	      'keyup.search input.search',
	      '.select2-search--inline',
	      function (evt) {
	        // IE will trigger the `input` event when a placeholder is used on a
	        // search box. To get around this issue, we are forced to ignore all
	        // `input` events in IE and keep using `keyup`.
	        if (disableInputEvents && evt.type === 'input') {
	          self.$selection.off('input.search input.searchcheck');
	          return;
	        }

	        var key = evt.which;

	        // We can freely ignore events from modifier keys
	        if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
	          return;
	        }

	        // Tabbing will be handled during the `keydown` phase
	        if (key == KEYS.TAB) {
	          return;
	        }

	        self.handleSearch(evt);
	      }
	    );
	  };

	  /**
	   * This method will transfer the tabindex attribute from the rendered
	   * selection to the search box. This allows for the search box to be used as
	   * the primary focus instead of the selection container.
	   *
	   * @private
	   */
	  Search.prototype._transferTabIndex = function (decorated) {
	    this.$search.attr('tabindex', this.$selection.attr('tabindex'));
	    this.$selection.attr('tabindex', '-1');
	  };

	  Search.prototype.createPlaceholder = function (decorated, placeholder) {
	    this.$search.attr('placeholder', placeholder.text);
	  };

	  Search.prototype.update = function (decorated, data) {
	    var searchHadFocus = this.$search[0] == document.activeElement;

	    this.$search.attr('placeholder', '');

	    decorated.call(this, data);

	    this.$selection.find('.select2-selection__rendered')
	                   .append(this.$searchContainer);

	    this.resizeSearch();
	    if (searchHadFocus) {
	      this.$search.focus();
	    }
	  };

	  Search.prototype.handleSearch = function () {
	    this.resizeSearch();

	    if (!this._keyUpPrevented) {
	      var input = this.$search.val();

	      this.trigger('query', {
	        term: input
	      });
	    }

	    this._keyUpPrevented = false;
	  };

	  Search.prototype.searchRemoveChoice = function (decorated, item) {
	    this.trigger('unselect', {
	      data: item
	    });

	    this.$search.val(item.text);
	    this.handleSearch();
	  };

	  Search.prototype.resizeSearch = function () {
	    this.$search.css('width', '25px');

	    var width = '';

	    if (this.$search.attr('placeholder') !== '') {
	      width = this.$selection.find('.select2-selection__rendered').innerWidth();
	    } else {
	      var minimumWidth = this.$search.val().length + 1;

	      width = (minimumWidth * 0.75) + 'em';
	    }

	    this.$search.css('width', width);
	  };

	  return Search;
	});

	S2.define('select2/selection/eventRelay',[
	  'jquery'
	], function ($) {
	  function EventRelay () { }

	  EventRelay.prototype.bind = function (decorated, container, $container) {
	    var self = this;
	    var relayEvents = [
	      'open', 'opening',
	      'close', 'closing',
	      'select', 'selecting',
	      'unselect', 'unselecting'
	    ];

	    var preventableEvents = ['opening', 'closing', 'selecting', 'unselecting'];

	    decorated.call(this, container, $container);

	    container.on('*', function (name, params) {
	      // Ignore events that should not be relayed
	      if ($.inArray(name, relayEvents) === -1) {
	        return;
	      }

	      // The parameters should always be an object
	      params = params || {};

	      // Generate the jQuery event for the Select2 event
	      var evt = $.Event('select2:' + name, {
	        params: params
	      });

	      self.$element.trigger(evt);

	      // Only handle preventable events if it was one
	      if ($.inArray(name, preventableEvents) === -1) {
	        return;
	      }

	      params.prevented = evt.isDefaultPrevented();
	    });
	  };

	  return EventRelay;
	});

	S2.define('select2/translation',[
	  'jquery',
	  'require'
	], function ($, require) {
	  function Translation (dict) {
	    this.dict = dict || {};
	  }

	  Translation.prototype.all = function () {
	    return this.dict;
	  };

	  Translation.prototype.get = function (key) {
	    return this.dict[key];
	  };

	  Translation.prototype.extend = function (translation) {
	    this.dict = $.extend({}, translation.all(), this.dict);
	  };

	  // Static functions

	  Translation._cache = {};

	  Translation.loadPath = function (path) {
	    if (!(path in Translation._cache)) {
	      var translations = require(path);

	      Translation._cache[path] = translations;
	    }

	    return new Translation(Translation._cache[path]);
	  };

	  return Translation;
	});

	S2.define('select2/diacritics',[

	], function () {
	  var diacritics = {
	    '\u24B6': 'A',
	    '\uFF21': 'A',
	    '\u00C0': 'A',
	    '\u00C1': 'A',
	    '\u00C2': 'A',
	    '\u1EA6': 'A',
	    '\u1EA4': 'A',
	    '\u1EAA': 'A',
	    '\u1EA8': 'A',
	    '\u00C3': 'A',
	    '\u0100': 'A',
	    '\u0102': 'A',
	    '\u1EB0': 'A',
	    '\u1EAE': 'A',
	    '\u1EB4': 'A',
	    '\u1EB2': 'A',
	    '\u0226': 'A',
	    '\u01E0': 'A',
	    '\u00C4': 'A',
	    '\u01DE': 'A',
	    '\u1EA2': 'A',
	    '\u00C5': 'A',
	    '\u01FA': 'A',
	    '\u01CD': 'A',
	    '\u0200': 'A',
	    '\u0202': 'A',
	    '\u1EA0': 'A',
	    '\u1EAC': 'A',
	    '\u1EB6': 'A',
	    '\u1E00': 'A',
	    '\u0104': 'A',
	    '\u023A': 'A',
	    '\u2C6F': 'A',
	    '\uA732': 'AA',
	    '\u00C6': 'AE',
	    '\u01FC': 'AE',
	    '\u01E2': 'AE',
	    '\uA734': 'AO',
	    '\uA736': 'AU',
	    '\uA738': 'AV',
	    '\uA73A': 'AV',
	    '\uA73C': 'AY',
	    '\u24B7': 'B',
	    '\uFF22': 'B',
	    '\u1E02': 'B',
	    '\u1E04': 'B',
	    '\u1E06': 'B',
	    '\u0243': 'B',
	    '\u0182': 'B',
	    '\u0181': 'B',
	    '\u24B8': 'C',
	    '\uFF23': 'C',
	    '\u0106': 'C',
	    '\u0108': 'C',
	    '\u010A': 'C',
	    '\u010C': 'C',
	    '\u00C7': 'C',
	    '\u1E08': 'C',
	    '\u0187': 'C',
	    '\u023B': 'C',
	    '\uA73E': 'C',
	    '\u24B9': 'D',
	    '\uFF24': 'D',
	    '\u1E0A': 'D',
	    '\u010E': 'D',
	    '\u1E0C': 'D',
	    '\u1E10': 'D',
	    '\u1E12': 'D',
	    '\u1E0E': 'D',
	    '\u0110': 'D',
	    '\u018B': 'D',
	    '\u018A': 'D',
	    '\u0189': 'D',
	    '\uA779': 'D',
	    '\u01F1': 'DZ',
	    '\u01C4': 'DZ',
	    '\u01F2': 'Dz',
	    '\u01C5': 'Dz',
	    '\u24BA': 'E',
	    '\uFF25': 'E',
	    '\u00C8': 'E',
	    '\u00C9': 'E',
	    '\u00CA': 'E',
	    '\u1EC0': 'E',
	    '\u1EBE': 'E',
	    '\u1EC4': 'E',
	    '\u1EC2': 'E',
	    '\u1EBC': 'E',
	    '\u0112': 'E',
	    '\u1E14': 'E',
	    '\u1E16': 'E',
	    '\u0114': 'E',
	    '\u0116': 'E',
	    '\u00CB': 'E',
	    '\u1EBA': 'E',
	    '\u011A': 'E',
	    '\u0204': 'E',
	    '\u0206': 'E',
	    '\u1EB8': 'E',
	    '\u1EC6': 'E',
	    '\u0228': 'E',
	    '\u1E1C': 'E',
	    '\u0118': 'E',
	    '\u1E18': 'E',
	    '\u1E1A': 'E',
	    '\u0190': 'E',
	    '\u018E': 'E',
	    '\u24BB': 'F',
	    '\uFF26': 'F',
	    '\u1E1E': 'F',
	    '\u0191': 'F',
	    '\uA77B': 'F',
	    '\u24BC': 'G',
	    '\uFF27': 'G',
	    '\u01F4': 'G',
	    '\u011C': 'G',
	    '\u1E20': 'G',
	    '\u011E': 'G',
	    '\u0120': 'G',
	    '\u01E6': 'G',
	    '\u0122': 'G',
	    '\u01E4': 'G',
	    '\u0193': 'G',
	    '\uA7A0': 'G',
	    '\uA77D': 'G',
	    '\uA77E': 'G',
	    '\u24BD': 'H',
	    '\uFF28': 'H',
	    '\u0124': 'H',
	    '\u1E22': 'H',
	    '\u1E26': 'H',
	    '\u021E': 'H',
	    '\u1E24': 'H',
	    '\u1E28': 'H',
	    '\u1E2A': 'H',
	    '\u0126': 'H',
	    '\u2C67': 'H',
	    '\u2C75': 'H',
	    '\uA78D': 'H',
	    '\u24BE': 'I',
	    '\uFF29': 'I',
	    '\u00CC': 'I',
	    '\u00CD': 'I',
	    '\u00CE': 'I',
	    '\u0128': 'I',
	    '\u012A': 'I',
	    '\u012C': 'I',
	    '\u0130': 'I',
	    '\u00CF': 'I',
	    '\u1E2E': 'I',
	    '\u1EC8': 'I',
	    '\u01CF': 'I',
	    '\u0208': 'I',
	    '\u020A': 'I',
	    '\u1ECA': 'I',
	    '\u012E': 'I',
	    '\u1E2C': 'I',
	    '\u0197': 'I',
	    '\u24BF': 'J',
	    '\uFF2A': 'J',
	    '\u0134': 'J',
	    '\u0248': 'J',
	    '\u24C0': 'K',
	    '\uFF2B': 'K',
	    '\u1E30': 'K',
	    '\u01E8': 'K',
	    '\u1E32': 'K',
	    '\u0136': 'K',
	    '\u1E34': 'K',
	    '\u0198': 'K',
	    '\u2C69': 'K',
	    '\uA740': 'K',
	    '\uA742': 'K',
	    '\uA744': 'K',
	    '\uA7A2': 'K',
	    '\u24C1': 'L',
	    '\uFF2C': 'L',
	    '\u013F': 'L',
	    '\u0139': 'L',
	    '\u013D': 'L',
	    '\u1E36': 'L',
	    '\u1E38': 'L',
	    '\u013B': 'L',
	    '\u1E3C': 'L',
	    '\u1E3A': 'L',
	    '\u0141': 'L',
	    '\u023D': 'L',
	    '\u2C62': 'L',
	    '\u2C60': 'L',
	    '\uA748': 'L',
	    '\uA746': 'L',
	    '\uA780': 'L',
	    '\u01C7': 'LJ',
	    '\u01C8': 'Lj',
	    '\u24C2': 'M',
	    '\uFF2D': 'M',
	    '\u1E3E': 'M',
	    '\u1E40': 'M',
	    '\u1E42': 'M',
	    '\u2C6E': 'M',
	    '\u019C': 'M',
	    '\u24C3': 'N',
	    '\uFF2E': 'N',
	    '\u01F8': 'N',
	    '\u0143': 'N',
	    '\u00D1': 'N',
	    '\u1E44': 'N',
	    '\u0147': 'N',
	    '\u1E46': 'N',
	    '\u0145': 'N',
	    '\u1E4A': 'N',
	    '\u1E48': 'N',
	    '\u0220': 'N',
	    '\u019D': 'N',
	    '\uA790': 'N',
	    '\uA7A4': 'N',
	    '\u01CA': 'NJ',
	    '\u01CB': 'Nj',
	    '\u24C4': 'O',
	    '\uFF2F': 'O',
	    '\u00D2': 'O',
	    '\u00D3': 'O',
	    '\u00D4': 'O',
	    '\u1ED2': 'O',
	    '\u1ED0': 'O',
	    '\u1ED6': 'O',
	    '\u1ED4': 'O',
	    '\u00D5': 'O',
	    '\u1E4C': 'O',
	    '\u022C': 'O',
	    '\u1E4E': 'O',
	    '\u014C': 'O',
	    '\u1E50': 'O',
	    '\u1E52': 'O',
	    '\u014E': 'O',
	    '\u022E': 'O',
	    '\u0230': 'O',
	    '\u00D6': 'O',
	    '\u022A': 'O',
	    '\u1ECE': 'O',
	    '\u0150': 'O',
	    '\u01D1': 'O',
	    '\u020C': 'O',
	    '\u020E': 'O',
	    '\u01A0': 'O',
	    '\u1EDC': 'O',
	    '\u1EDA': 'O',
	    '\u1EE0': 'O',
	    '\u1EDE': 'O',
	    '\u1EE2': 'O',
	    '\u1ECC': 'O',
	    '\u1ED8': 'O',
	    '\u01EA': 'O',
	    '\u01EC': 'O',
	    '\u00D8': 'O',
	    '\u01FE': 'O',
	    '\u0186': 'O',
	    '\u019F': 'O',
	    '\uA74A': 'O',
	    '\uA74C': 'O',
	    '\u01A2': 'OI',
	    '\uA74E': 'OO',
	    '\u0222': 'OU',
	    '\u24C5': 'P',
	    '\uFF30': 'P',
	    '\u1E54': 'P',
	    '\u1E56': 'P',
	    '\u01A4': 'P',
	    '\u2C63': 'P',
	    '\uA750': 'P',
	    '\uA752': 'P',
	    '\uA754': 'P',
	    '\u24C6': 'Q',
	    '\uFF31': 'Q',
	    '\uA756': 'Q',
	    '\uA758': 'Q',
	    '\u024A': 'Q',
	    '\u24C7': 'R',
	    '\uFF32': 'R',
	    '\u0154': 'R',
	    '\u1E58': 'R',
	    '\u0158': 'R',
	    '\u0210': 'R',
	    '\u0212': 'R',
	    '\u1E5A': 'R',
	    '\u1E5C': 'R',
	    '\u0156': 'R',
	    '\u1E5E': 'R',
	    '\u024C': 'R',
	    '\u2C64': 'R',
	    '\uA75A': 'R',
	    '\uA7A6': 'R',
	    '\uA782': 'R',
	    '\u24C8': 'S',
	    '\uFF33': 'S',
	    '\u1E9E': 'S',
	    '\u015A': 'S',
	    '\u1E64': 'S',
	    '\u015C': 'S',
	    '\u1E60': 'S',
	    '\u0160': 'S',
	    '\u1E66': 'S',
	    '\u1E62': 'S',
	    '\u1E68': 'S',
	    '\u0218': 'S',
	    '\u015E': 'S',
	    '\u2C7E': 'S',
	    '\uA7A8': 'S',
	    '\uA784': 'S',
	    '\u24C9': 'T',
	    '\uFF34': 'T',
	    '\u1E6A': 'T',
	    '\u0164': 'T',
	    '\u1E6C': 'T',
	    '\u021A': 'T',
	    '\u0162': 'T',
	    '\u1E70': 'T',
	    '\u1E6E': 'T',
	    '\u0166': 'T',
	    '\u01AC': 'T',
	    '\u01AE': 'T',
	    '\u023E': 'T',
	    '\uA786': 'T',
	    '\uA728': 'TZ',
	    '\u24CA': 'U',
	    '\uFF35': 'U',
	    '\u00D9': 'U',
	    '\u00DA': 'U',
	    '\u00DB': 'U',
	    '\u0168': 'U',
	    '\u1E78': 'U',
	    '\u016A': 'U',
	    '\u1E7A': 'U',
	    '\u016C': 'U',
	    '\u00DC': 'U',
	    '\u01DB': 'U',
	    '\u01D7': 'U',
	    '\u01D5': 'U',
	    '\u01D9': 'U',
	    '\u1EE6': 'U',
	    '\u016E': 'U',
	    '\u0170': 'U',
	    '\u01D3': 'U',
	    '\u0214': 'U',
	    '\u0216': 'U',
	    '\u01AF': 'U',
	    '\u1EEA': 'U',
	    '\u1EE8': 'U',
	    '\u1EEE': 'U',
	    '\u1EEC': 'U',
	    '\u1EF0': 'U',
	    '\u1EE4': 'U',
	    '\u1E72': 'U',
	    '\u0172': 'U',
	    '\u1E76': 'U',
	    '\u1E74': 'U',
	    '\u0244': 'U',
	    '\u24CB': 'V',
	    '\uFF36': 'V',
	    '\u1E7C': 'V',
	    '\u1E7E': 'V',
	    '\u01B2': 'V',
	    '\uA75E': 'V',
	    '\u0245': 'V',
	    '\uA760': 'VY',
	    '\u24CC': 'W',
	    '\uFF37': 'W',
	    '\u1E80': 'W',
	    '\u1E82': 'W',
	    '\u0174': 'W',
	    '\u1E86': 'W',
	    '\u1E84': 'W',
	    '\u1E88': 'W',
	    '\u2C72': 'W',
	    '\u24CD': 'X',
	    '\uFF38': 'X',
	    '\u1E8A': 'X',
	    '\u1E8C': 'X',
	    '\u24CE': 'Y',
	    '\uFF39': 'Y',
	    '\u1EF2': 'Y',
	    '\u00DD': 'Y',
	    '\u0176': 'Y',
	    '\u1EF8': 'Y',
	    '\u0232': 'Y',
	    '\u1E8E': 'Y',
	    '\u0178': 'Y',
	    '\u1EF6': 'Y',
	    '\u1EF4': 'Y',
	    '\u01B3': 'Y',
	    '\u024E': 'Y',
	    '\u1EFE': 'Y',
	    '\u24CF': 'Z',
	    '\uFF3A': 'Z',
	    '\u0179': 'Z',
	    '\u1E90': 'Z',
	    '\u017B': 'Z',
	    '\u017D': 'Z',
	    '\u1E92': 'Z',
	    '\u1E94': 'Z',
	    '\u01B5': 'Z',
	    '\u0224': 'Z',
	    '\u2C7F': 'Z',
	    '\u2C6B': 'Z',
	    '\uA762': 'Z',
	    '\u24D0': 'a',
	    '\uFF41': 'a',
	    '\u1E9A': 'a',
	    '\u00E0': 'a',
	    '\u00E1': 'a',
	    '\u00E2': 'a',
	    '\u1EA7': 'a',
	    '\u1EA5': 'a',
	    '\u1EAB': 'a',
	    '\u1EA9': 'a',
	    '\u00E3': 'a',
	    '\u0101': 'a',
	    '\u0103': 'a',
	    '\u1EB1': 'a',
	    '\u1EAF': 'a',
	    '\u1EB5': 'a',
	    '\u1EB3': 'a',
	    '\u0227': 'a',
	    '\u01E1': 'a',
	    '\u00E4': 'a',
	    '\u01DF': 'a',
	    '\u1EA3': 'a',
	    '\u00E5': 'a',
	    '\u01FB': 'a',
	    '\u01CE': 'a',
	    '\u0201': 'a',
	    '\u0203': 'a',
	    '\u1EA1': 'a',
	    '\u1EAD': 'a',
	    '\u1EB7': 'a',
	    '\u1E01': 'a',
	    '\u0105': 'a',
	    '\u2C65': 'a',
	    '\u0250': 'a',
	    '\uA733': 'aa',
	    '\u00E6': 'ae',
	    '\u01FD': 'ae',
	    '\u01E3': 'ae',
	    '\uA735': 'ao',
	    '\uA737': 'au',
	    '\uA739': 'av',
	    '\uA73B': 'av',
	    '\uA73D': 'ay',
	    '\u24D1': 'b',
	    '\uFF42': 'b',
	    '\u1E03': 'b',
	    '\u1E05': 'b',
	    '\u1E07': 'b',
	    '\u0180': 'b',
	    '\u0183': 'b',
	    '\u0253': 'b',
	    '\u24D2': 'c',
	    '\uFF43': 'c',
	    '\u0107': 'c',
	    '\u0109': 'c',
	    '\u010B': 'c',
	    '\u010D': 'c',
	    '\u00E7': 'c',
	    '\u1E09': 'c',
	    '\u0188': 'c',
	    '\u023C': 'c',
	    '\uA73F': 'c',
	    '\u2184': 'c',
	    '\u24D3': 'd',
	    '\uFF44': 'd',
	    '\u1E0B': 'd',
	    '\u010F': 'd',
	    '\u1E0D': 'd',
	    '\u1E11': 'd',
	    '\u1E13': 'd',
	    '\u1E0F': 'd',
	    '\u0111': 'd',
	    '\u018C': 'd',
	    '\u0256': 'd',
	    '\u0257': 'd',
	    '\uA77A': 'd',
	    '\u01F3': 'dz',
	    '\u01C6': 'dz',
	    '\u24D4': 'e',
	    '\uFF45': 'e',
	    '\u00E8': 'e',
	    '\u00E9': 'e',
	    '\u00EA': 'e',
	    '\u1EC1': 'e',
	    '\u1EBF': 'e',
	    '\u1EC5': 'e',
	    '\u1EC3': 'e',
	    '\u1EBD': 'e',
	    '\u0113': 'e',
	    '\u1E15': 'e',
	    '\u1E17': 'e',
	    '\u0115': 'e',
	    '\u0117': 'e',
	    '\u00EB': 'e',
	    '\u1EBB': 'e',
	    '\u011B': 'e',
	    '\u0205': 'e',
	    '\u0207': 'e',
	    '\u1EB9': 'e',
	    '\u1EC7': 'e',
	    '\u0229': 'e',
	    '\u1E1D': 'e',
	    '\u0119': 'e',
	    '\u1E19': 'e',
	    '\u1E1B': 'e',
	    '\u0247': 'e',
	    '\u025B': 'e',
	    '\u01DD': 'e',
	    '\u24D5': 'f',
	    '\uFF46': 'f',
	    '\u1E1F': 'f',
	    '\u0192': 'f',
	    '\uA77C': 'f',
	    '\u24D6': 'g',
	    '\uFF47': 'g',
	    '\u01F5': 'g',
	    '\u011D': 'g',
	    '\u1E21': 'g',
	    '\u011F': 'g',
	    '\u0121': 'g',
	    '\u01E7': 'g',
	    '\u0123': 'g',
	    '\u01E5': 'g',
	    '\u0260': 'g',
	    '\uA7A1': 'g',
	    '\u1D79': 'g',
	    '\uA77F': 'g',
	    '\u24D7': 'h',
	    '\uFF48': 'h',
	    '\u0125': 'h',
	    '\u1E23': 'h',
	    '\u1E27': 'h',
	    '\u021F': 'h',
	    '\u1E25': 'h',
	    '\u1E29': 'h',
	    '\u1E2B': 'h',
	    '\u1E96': 'h',
	    '\u0127': 'h',
	    '\u2C68': 'h',
	    '\u2C76': 'h',
	    '\u0265': 'h',
	    '\u0195': 'hv',
	    '\u24D8': 'i',
	    '\uFF49': 'i',
	    '\u00EC': 'i',
	    '\u00ED': 'i',
	    '\u00EE': 'i',
	    '\u0129': 'i',
	    '\u012B': 'i',
	    '\u012D': 'i',
	    '\u00EF': 'i',
	    '\u1E2F': 'i',
	    '\u1EC9': 'i',
	    '\u01D0': 'i',
	    '\u0209': 'i',
	    '\u020B': 'i',
	    '\u1ECB': 'i',
	    '\u012F': 'i',
	    '\u1E2D': 'i',
	    '\u0268': 'i',
	    '\u0131': 'i',
	    '\u24D9': 'j',
	    '\uFF4A': 'j',
	    '\u0135': 'j',
	    '\u01F0': 'j',
	    '\u0249': 'j',
	    '\u24DA': 'k',
	    '\uFF4B': 'k',
	    '\u1E31': 'k',
	    '\u01E9': 'k',
	    '\u1E33': 'k',
	    '\u0137': 'k',
	    '\u1E35': 'k',
	    '\u0199': 'k',
	    '\u2C6A': 'k',
	    '\uA741': 'k',
	    '\uA743': 'k',
	    '\uA745': 'k',
	    '\uA7A3': 'k',
	    '\u24DB': 'l',
	    '\uFF4C': 'l',
	    '\u0140': 'l',
	    '\u013A': 'l',
	    '\u013E': 'l',
	    '\u1E37': 'l',
	    '\u1E39': 'l',
	    '\u013C': 'l',
	    '\u1E3D': 'l',
	    '\u1E3B': 'l',
	    '\u017F': 'l',
	    '\u0142': 'l',
	    '\u019A': 'l',
	    '\u026B': 'l',
	    '\u2C61': 'l',
	    '\uA749': 'l',
	    '\uA781': 'l',
	    '\uA747': 'l',
	    '\u01C9': 'lj',
	    '\u24DC': 'm',
	    '\uFF4D': 'm',
	    '\u1E3F': 'm',
	    '\u1E41': 'm',
	    '\u1E43': 'm',
	    '\u0271': 'm',
	    '\u026F': 'm',
	    '\u24DD': 'n',
	    '\uFF4E': 'n',
	    '\u01F9': 'n',
	    '\u0144': 'n',
	    '\u00F1': 'n',
	    '\u1E45': 'n',
	    '\u0148': 'n',
	    '\u1E47': 'n',
	    '\u0146': 'n',
	    '\u1E4B': 'n',
	    '\u1E49': 'n',
	    '\u019E': 'n',
	    '\u0272': 'n',
	    '\u0149': 'n',
	    '\uA791': 'n',
	    '\uA7A5': 'n',
	    '\u01CC': 'nj',
	    '\u24DE': 'o',
	    '\uFF4F': 'o',
	    '\u00F2': 'o',
	    '\u00F3': 'o',
	    '\u00F4': 'o',
	    '\u1ED3': 'o',
	    '\u1ED1': 'o',
	    '\u1ED7': 'o',
	    '\u1ED5': 'o',
	    '\u00F5': 'o',
	    '\u1E4D': 'o',
	    '\u022D': 'o',
	    '\u1E4F': 'o',
	    '\u014D': 'o',
	    '\u1E51': 'o',
	    '\u1E53': 'o',
	    '\u014F': 'o',
	    '\u022F': 'o',
	    '\u0231': 'o',
	    '\u00F6': 'o',
	    '\u022B': 'o',
	    '\u1ECF': 'o',
	    '\u0151': 'o',
	    '\u01D2': 'o',
	    '\u020D': 'o',
	    '\u020F': 'o',
	    '\u01A1': 'o',
	    '\u1EDD': 'o',
	    '\u1EDB': 'o',
	    '\u1EE1': 'o',
	    '\u1EDF': 'o',
	    '\u1EE3': 'o',
	    '\u1ECD': 'o',
	    '\u1ED9': 'o',
	    '\u01EB': 'o',
	    '\u01ED': 'o',
	    '\u00F8': 'o',
	    '\u01FF': 'o',
	    '\u0254': 'o',
	    '\uA74B': 'o',
	    '\uA74D': 'o',
	    '\u0275': 'o',
	    '\u01A3': 'oi',
	    '\u0223': 'ou',
	    '\uA74F': 'oo',
	    '\u24DF': 'p',
	    '\uFF50': 'p',
	    '\u1E55': 'p',
	    '\u1E57': 'p',
	    '\u01A5': 'p',
	    '\u1D7D': 'p',
	    '\uA751': 'p',
	    '\uA753': 'p',
	    '\uA755': 'p',
	    '\u24E0': 'q',
	    '\uFF51': 'q',
	    '\u024B': 'q',
	    '\uA757': 'q',
	    '\uA759': 'q',
	    '\u24E1': 'r',
	    '\uFF52': 'r',
	    '\u0155': 'r',
	    '\u1E59': 'r',
	    '\u0159': 'r',
	    '\u0211': 'r',
	    '\u0213': 'r',
	    '\u1E5B': 'r',
	    '\u1E5D': 'r',
	    '\u0157': 'r',
	    '\u1E5F': 'r',
	    '\u024D': 'r',
	    '\u027D': 'r',
	    '\uA75B': 'r',
	    '\uA7A7': 'r',
	    '\uA783': 'r',
	    '\u24E2': 's',
	    '\uFF53': 's',
	    '\u00DF': 's',
	    '\u015B': 's',
	    '\u1E65': 's',
	    '\u015D': 's',
	    '\u1E61': 's',
	    '\u0161': 's',
	    '\u1E67': 's',
	    '\u1E63': 's',
	    '\u1E69': 's',
	    '\u0219': 's',
	    '\u015F': 's',
	    '\u023F': 's',
	    '\uA7A9': 's',
	    '\uA785': 's',
	    '\u1E9B': 's',
	    '\u24E3': 't',
	    '\uFF54': 't',
	    '\u1E6B': 't',
	    '\u1E97': 't',
	    '\u0165': 't',
	    '\u1E6D': 't',
	    '\u021B': 't',
	    '\u0163': 't',
	    '\u1E71': 't',
	    '\u1E6F': 't',
	    '\u0167': 't',
	    '\u01AD': 't',
	    '\u0288': 't',
	    '\u2C66': 't',
	    '\uA787': 't',
	    '\uA729': 'tz',
	    '\u24E4': 'u',
	    '\uFF55': 'u',
	    '\u00F9': 'u',
	    '\u00FA': 'u',
	    '\u00FB': 'u',
	    '\u0169': 'u',
	    '\u1E79': 'u',
	    '\u016B': 'u',
	    '\u1E7B': 'u',
	    '\u016D': 'u',
	    '\u00FC': 'u',
	    '\u01DC': 'u',
	    '\u01D8': 'u',
	    '\u01D6': 'u',
	    '\u01DA': 'u',
	    '\u1EE7': 'u',
	    '\u016F': 'u',
	    '\u0171': 'u',
	    '\u01D4': 'u',
	    '\u0215': 'u',
	    '\u0217': 'u',
	    '\u01B0': 'u',
	    '\u1EEB': 'u',
	    '\u1EE9': 'u',
	    '\u1EEF': 'u',
	    '\u1EED': 'u',
	    '\u1EF1': 'u',
	    '\u1EE5': 'u',
	    '\u1E73': 'u',
	    '\u0173': 'u',
	    '\u1E77': 'u',
	    '\u1E75': 'u',
	    '\u0289': 'u',
	    '\u24E5': 'v',
	    '\uFF56': 'v',
	    '\u1E7D': 'v',
	    '\u1E7F': 'v',
	    '\u028B': 'v',
	    '\uA75F': 'v',
	    '\u028C': 'v',
	    '\uA761': 'vy',
	    '\u24E6': 'w',
	    '\uFF57': 'w',
	    '\u1E81': 'w',
	    '\u1E83': 'w',
	    '\u0175': 'w',
	    '\u1E87': 'w',
	    '\u1E85': 'w',
	    '\u1E98': 'w',
	    '\u1E89': 'w',
	    '\u2C73': 'w',
	    '\u24E7': 'x',
	    '\uFF58': 'x',
	    '\u1E8B': 'x',
	    '\u1E8D': 'x',
	    '\u24E8': 'y',
	    '\uFF59': 'y',
	    '\u1EF3': 'y',
	    '\u00FD': 'y',
	    '\u0177': 'y',
	    '\u1EF9': 'y',
	    '\u0233': 'y',
	    '\u1E8F': 'y',
	    '\u00FF': 'y',
	    '\u1EF7': 'y',
	    '\u1E99': 'y',
	    '\u1EF5': 'y',
	    '\u01B4': 'y',
	    '\u024F': 'y',
	    '\u1EFF': 'y',
	    '\u24E9': 'z',
	    '\uFF5A': 'z',
	    '\u017A': 'z',
	    '\u1E91': 'z',
	    '\u017C': 'z',
	    '\u017E': 'z',
	    '\u1E93': 'z',
	    '\u1E95': 'z',
	    '\u01B6': 'z',
	    '\u0225': 'z',
	    '\u0240': 'z',
	    '\u2C6C': 'z',
	    '\uA763': 'z',
	    '\u0386': '\u0391',
	    '\u0388': '\u0395',
	    '\u0389': '\u0397',
	    '\u038A': '\u0399',
	    '\u03AA': '\u0399',
	    '\u038C': '\u039F',
	    '\u038E': '\u03A5',
	    '\u03AB': '\u03A5',
	    '\u038F': '\u03A9',
	    '\u03AC': '\u03B1',
	    '\u03AD': '\u03B5',
	    '\u03AE': '\u03B7',
	    '\u03AF': '\u03B9',
	    '\u03CA': '\u03B9',
	    '\u0390': '\u03B9',
	    '\u03CC': '\u03BF',
	    '\u03CD': '\u03C5',
	    '\u03CB': '\u03C5',
	    '\u03B0': '\u03C5',
	    '\u03C9': '\u03C9',
	    '\u03C2': '\u03C3'
	  };

	  return diacritics;
	});

	S2.define('select2/data/base',[
	  '../utils'
	], function (Utils) {
	  function BaseAdapter ($element, options) {
	    BaseAdapter.__super__.constructor.call(this);
	  }

	  Utils.Extend(BaseAdapter, Utils.Observable);

	  BaseAdapter.prototype.current = function (callback) {
	    throw new Error('The `current` method must be defined in child classes.');
	  };

	  BaseAdapter.prototype.query = function (params, callback) {
	    throw new Error('The `query` method must be defined in child classes.');
	  };

	  BaseAdapter.prototype.bind = function (container, $container) {
	    // Can be implemented in subclasses
	  };

	  BaseAdapter.prototype.destroy = function () {
	    // Can be implemented in subclasses
	  };

	  BaseAdapter.prototype.generateResultId = function (container, data) {
	    var id = container.id + '-result-';

	    id += Utils.generateChars(4);

	    if (data.id != null) {
	      id += '-' + data.id.toString();
	    } else {
	      id += '-' + Utils.generateChars(4);
	    }
	    return id;
	  };

	  return BaseAdapter;
	});

	S2.define('select2/data/select',[
	  './base',
	  '../utils',
	  'jquery'
	], function (BaseAdapter, Utils, $) {
	  function SelectAdapter ($element, options) {
	    this.$element = $element;
	    this.options = options;

	    SelectAdapter.__super__.constructor.call(this);
	  }

	  Utils.Extend(SelectAdapter, BaseAdapter);

	  SelectAdapter.prototype.current = function (callback) {
	    var data = [];
	    var self = this;

	    this.$element.find(':selected').each(function () {
	      var $option = $(this);

	      var option = self.item($option);

	      data.push(option);
	    });

	    callback(data);
	  };

	  SelectAdapter.prototype.select = function (data) {
	    var self = this;

	    data.selected = true;

	    // If data.element is a DOM node, use it instead
	    if ($(data.element).is('option')) {
	      data.element.selected = true;

	      this.$element.trigger('change');

	      return;
	    }

	    if (this.$element.prop('multiple')) {
	      this.current(function (currentData) {
	        var val = [];

	        data = [data];
	        data.push.apply(data, currentData);

	        for (var d = 0; d < data.length; d++) {
	          var id = data[d].id;

	          if ($.inArray(id, val) === -1) {
	            val.push(id);
	          }
	        }

	        self.$element.val(val);
	        self.$element.trigger('change');
	      });
	    } else {
	      var val = data.id;

	      this.$element.val(val);
	      this.$element.trigger('change');
	    }
	  };

	  SelectAdapter.prototype.unselect = function (data) {
	    var self = this;

	    if (!this.$element.prop('multiple')) {
	      return;
	    }

	    data.selected = false;

	    if ($(data.element).is('option')) {
	      data.element.selected = false;

	      this.$element.trigger('change');

	      return;
	    }

	    this.current(function (currentData) {
	      var val = [];

	      for (var d = 0; d < currentData.length; d++) {
	        var id = currentData[d].id;

	        if (id !== data.id && $.inArray(id, val) === -1) {
	          val.push(id);
	        }
	      }

	      self.$element.val(val);

	      self.$element.trigger('change');
	    });
	  };

	  SelectAdapter.prototype.bind = function (container, $container) {
	    var self = this;

	    this.container = container;

	    container.on('select', function (params) {
	      self.select(params.data);
	    });

	    container.on('unselect', function (params) {
	      self.unselect(params.data);
	    });
	  };

	  SelectAdapter.prototype.destroy = function () {
	    // Remove anything added to child elements
	    this.$element.find('*').each(function () {
	      // Remove any custom data set by Select2
	      $.removeData(this, 'data');
	    });
	  };

	  SelectAdapter.prototype.query = function (params, callback) {
	    var data = [];
	    var self = this;

	    var $options = this.$element.children();

	    $options.each(function () {
	      var $option = $(this);

	      if (!$option.is('option') && !$option.is('optgroup')) {
	        return;
	      }

	      var option = self.item($option);

	      var matches = self.matches(params, option);

	      if (matches !== null) {
	        data.push(matches);
	      }
	    });

	    callback({
	      results: data
	    });
	  };

	  SelectAdapter.prototype.addOptions = function ($options) {
	    Utils.appendMany(this.$element, $options);
	  };

	  SelectAdapter.prototype.option = function (data) {
	    var option;

	    if (data.children) {
	      option = document.createElement('optgroup');
	      option.label = data.text;
	    } else {
	      option = document.createElement('option');

	      if (option.textContent !== undefined) {
	        option.textContent = data.text;
	      } else {
	        option.innerText = data.text;
	      }
	    }

	    if (data.id) {
	      option.value = data.id;
	    }

	    if (data.disabled) {
	      option.disabled = true;
	    }

	    if (data.selected) {
	      option.selected = true;
	    }

	    if (data.title) {
	      option.title = data.title;
	    }

	    var $option = $(option);

	    var normalizedData = this._normalizeItem(data);
	    normalizedData.element = option;

	    // Override the option's data with the combined data
	    $.data(option, 'data', normalizedData);

	    return $option;
	  };

	  SelectAdapter.prototype.item = function ($option) {
	    var data = {};

	    data = $.data($option[0], 'data');

	    if (data != null) {
	      return data;
	    }

	    if ($option.is('option')) {
	      data = {
	        id: $option.val(),
	        text: $option.text(),
	        disabled: $option.prop('disabled'),
	        selected: $option.prop('selected'),
	        title: $option.prop('title')
	      };
	    } else if ($option.is('optgroup')) {
	      data = {
	        text: $option.prop('label'),
	        children: [],
	        title: $option.prop('title')
	      };

	      var $children = $option.children('option');
	      var children = [];

	      for (var c = 0; c < $children.length; c++) {
	        var $child = $($children[c]);

	        var child = this.item($child);

	        children.push(child);
	      }

	      data.children = children;
	    }

	    data = this._normalizeItem(data);
	    data.element = $option[0];

	    $.data($option[0], 'data', data);

	    return data;
	  };

	  SelectAdapter.prototype._normalizeItem = function (item) {
	    if (!$.isPlainObject(item)) {
	      item = {
	        id: item,
	        text: item
	      };
	    }

	    item = $.extend({}, {
	      text: ''
	    }, item);

	    var defaults = {
	      selected: false,
	      disabled: false
	    };

	    if (item.id != null) {
	      item.id = item.id.toString();
	    }

	    if (item.text != null) {
	      item.text = item.text.toString();
	    }

	    if (item._resultId == null && item.id && this.container != null) {
	      item._resultId = this.generateResultId(this.container, item);
	    }

	    return $.extend({}, defaults, item);
	  };

	  SelectAdapter.prototype.matches = function (params, data) {
	    var matcher = this.options.get('matcher');

	    return matcher(params, data);
	  };

	  return SelectAdapter;
	});

	S2.define('select2/data/array',[
	  './select',
	  '../utils',
	  'jquery'
	], function (SelectAdapter, Utils, $) {
	  function ArrayAdapter ($element, options) {
	    var data = options.get('data') || [];

	    ArrayAdapter.__super__.constructor.call(this, $element, options);

	    this.addOptions(this.convertToOptions(data));
	  }

	  Utils.Extend(ArrayAdapter, SelectAdapter);

	  ArrayAdapter.prototype.select = function (data) {
	    var $option = this.$element.find('option').filter(function (i, elm) {
	      return elm.value == data.id.toString();
	    });

	    if ($option.length === 0) {
	      $option = this.option(data);

	      this.addOptions($option);
	    }

	    ArrayAdapter.__super__.select.call(this, data);
	  };

	  ArrayAdapter.prototype.convertToOptions = function (data) {
	    var self = this;

	    var $existing = this.$element.find('option');
	    var existingIds = $existing.map(function () {
	      return self.item($(this)).id;
	    }).get();

	    var $options = [];

	    // Filter out all items except for the one passed in the argument
	    function onlyItem (item) {
	      return function () {
	        return $(this).val() == item.id;
	      };
	    }

	    for (var d = 0; d < data.length; d++) {
	      var item = this._normalizeItem(data[d]);

	      // Skip items which were pre-loaded, only merge the data
	      if ($.inArray(item.id, existingIds) >= 0) {
	        var $existingOption = $existing.filter(onlyItem(item));

	        var existingData = this.item($existingOption);
	        var newData = $.extend(true, {}, item, existingData);

	        var $newOption = this.option(newData);

	        $existingOption.replaceWith($newOption);

	        continue;
	      }

	      var $option = this.option(item);

	      if (item.children) {
	        var $children = this.convertToOptions(item.children);

	        Utils.appendMany($option, $children);
	      }

	      $options.push($option);
	    }

	    return $options;
	  };

	  return ArrayAdapter;
	});

	S2.define('select2/data/ajax',[
	  './array',
	  '../utils',
	  'jquery'
	], function (ArrayAdapter, Utils, $) {
	  function AjaxAdapter ($element, options) {
	    this.ajaxOptions = this._applyDefaults(options.get('ajax'));

	    if (this.ajaxOptions.processResults != null) {
	      this.processResults = this.ajaxOptions.processResults;
	    }

	    AjaxAdapter.__super__.constructor.call(this, $element, options);
	  }

	  Utils.Extend(AjaxAdapter, ArrayAdapter);

	  AjaxAdapter.prototype._applyDefaults = function (options) {
	    var defaults = {
	      data: function (params) {
	        return $.extend({}, params, {
	          q: params.term
	        });
	      },
	      transport: function (params, success, failure) {
	        var $request = $.ajax(params);

	        $request.then(success);
	        $request.fail(failure);

	        return $request;
	      }
	    };

	    return $.extend({}, defaults, options, true);
	  };

	  AjaxAdapter.prototype.processResults = function (results) {
	    return results;
	  };

	  AjaxAdapter.prototype.query = function (params, callback) {
	    var matches = [];
	    var self = this;

	    if (this._request != null) {
	      // JSONP requests cannot always be aborted
	      if ($.isFunction(this._request.abort)) {
	        this._request.abort();
	      }

	      this._request = null;
	    }

	    var options = $.extend({
	      type: 'GET'
	    }, this.ajaxOptions);

	    if (typeof options.url === 'function') {
	      options.url = options.url.call(this.$element, params);
	    }

	    if (typeof options.data === 'function') {
	      options.data = options.data.call(this.$element, params);
	    }

	    function request () {
	      var $request = options.transport(options, function (data) {
	        var results = self.processResults(data, params);

	        if (self.options.get('debug') && window.console && console.error) {
	          // Check to make sure that the response included a `results` key.
	          if (!results || !results.results || !$.isArray(results.results)) {
	            console.error(
	              'Select2: The AJAX results did not return an array in the ' +
	              '`results` key of the response.'
	            );
	          }
	        }

	        callback(results);
	      }, function () {
	        // Attempt to detect if a request was aborted
	        // Only works if the transport exposes a status property
	        if ($request.status && $request.status === '0') {
	          return;
	        }

	        self.trigger('results:message', {
	          message: 'errorLoading'
	        });
	      });

	      self._request = $request;
	    }

	    if (this.ajaxOptions.delay && params.term != null) {
	      if (this._queryTimeout) {
	        window.clearTimeout(this._queryTimeout);
	      }

	      this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
	    } else {
	      request();
	    }
	  };

	  return AjaxAdapter;
	});

	S2.define('select2/data/tags',[
	  'jquery'
	], function ($) {
	  function Tags (decorated, $element, options) {
	    var tags = options.get('tags');

	    var createTag = options.get('createTag');

	    if (createTag !== undefined) {
	      this.createTag = createTag;
	    }

	    var insertTag = options.get('insertTag');

	    if (insertTag !== undefined) {
	        this.insertTag = insertTag;
	    }

	    decorated.call(this, $element, options);

	    if ($.isArray(tags)) {
	      for (var t = 0; t < tags.length; t++) {
	        var tag = tags[t];
	        var item = this._normalizeItem(tag);

	        var $option = this.option(item);

	        this.$element.append($option);
	      }
	    }
	  }

	  Tags.prototype.query = function (decorated, params, callback) {
	    var self = this;

	    this._removeOldTags();

	    if (params.term == null || params.page != null) {
	      decorated.call(this, params, callback);
	      return;
	    }

	    function wrapper (obj, child) {
	      var data = obj.results;

	      for (var i = 0; i < data.length; i++) {
	        var option = data[i];

	        var checkChildren = (
	          option.children != null &&
	          !wrapper({
	            results: option.children
	          }, true)
	        );

	        var checkText = option.text === params.term;

	        if (checkText || checkChildren) {
	          if (child) {
	            return false;
	          }

	          obj.data = data;
	          callback(obj);

	          return;
	        }
	      }

	      if (child) {
	        return true;
	      }

	      var tag = self.createTag(params);

	      if (tag != null) {
	        var $option = self.option(tag);
	        $option.attr('data-select2-tag', true);

	        self.addOptions([$option]);

	        self.insertTag(data, tag);
	      }

	      obj.results = data;

	      callback(obj);
	    }

	    decorated.call(this, params, wrapper);
	  };

	  Tags.prototype.createTag = function (decorated, params) {
	    var term = $.trim(params.term);

	    if (term === '') {
	      return null;
	    }

	    return {
	      id: term,
	      text: term
	    };
	  };

	  Tags.prototype.insertTag = function (_, data, tag) {
	    data.unshift(tag);
	  };

	  Tags.prototype._removeOldTags = function (_) {
	    var tag = this._lastTag;

	    var $options = this.$element.find('option[data-select2-tag]');

	    $options.each(function () {
	      if (this.selected) {
	        return;
	      }

	      $(this).remove();
	    });
	  };

	  return Tags;
	});

	S2.define('select2/data/tokenizer',[
	  'jquery'
	], function ($) {
	  function Tokenizer (decorated, $element, options) {
	    var tokenizer = options.get('tokenizer');

	    if (tokenizer !== undefined) {
	      this.tokenizer = tokenizer;
	    }

	    decorated.call(this, $element, options);
	  }

	  Tokenizer.prototype.bind = function (decorated, container, $container) {
	    decorated.call(this, container, $container);

	    this.$search =  container.dropdown.$search || container.selection.$search ||
	      $container.find('.select2-search__field');
	  };

	  Tokenizer.prototype.query = function (decorated, params, callback) {
	    var self = this;

	    function createAndSelect (data) {
	      // Normalize the data object so we can use it for checks
	      var item = self._normalizeItem(data);

	      // Check if the data object already exists as a tag
	      // Select it if it doesn't
	      var $existingOptions = self.$element.find('option').filter(function () {
	        return $(this).val() === item.id;
	      });

	      // If an existing option wasn't found for it, create the option
	      if (!$existingOptions.length) {
	        var $option = self.option(item);
	        $option.attr('data-select2-tag', true);

	        self._removeOldTags();
	        self.addOptions([$option]);
	      }

	      // Select the item, now that we know there is an option for it
	      select(item);
	    }

	    function select (data) {
	      self.trigger('select', {
	        data: data
	      });
	    }

	    params.term = params.term || '';

	    var tokenData = this.tokenizer(params, this.options, createAndSelect);

	    if (tokenData.term !== params.term) {
	      // Replace the search term if we have the search box
	      if (this.$search.length) {
	        this.$search.val(tokenData.term);
	        this.$search.focus();
	      }

	      params.term = tokenData.term;
	    }

	    decorated.call(this, params, callback);
	  };

	  Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
	    var separators = options.get('tokenSeparators') || [];
	    var term = params.term;
	    var i = 0;

	    var createTag = this.createTag || function (params) {
	      return {
	        id: params.term,
	        text: params.term
	      };
	    };

	    while (i < term.length) {
	      var termChar = term[i];

	      if ($.inArray(termChar, separators) === -1) {
	        i++;

	        continue;
	      }

	      var part = term.substr(0, i);
	      var partParams = $.extend({}, params, {
	        term: part
	      });

	      var data = createTag(partParams);

	      if (data == null) {
	        i++;
	        continue;
	      }

	      callback(data);

	      // Reset the term to not include the tokenized portion
	      term = term.substr(i + 1) || '';
	      i = 0;
	    }

	    return {
	      term: term
	    };
	  };

	  return Tokenizer;
	});

	S2.define('select2/data/minimumInputLength',[

	], function () {
	  function MinimumInputLength (decorated, $e, options) {
	    this.minimumInputLength = options.get('minimumInputLength');

	    decorated.call(this, $e, options);
	  }

	  MinimumInputLength.prototype.query = function (decorated, params, callback) {
	    params.term = params.term || '';

	    if (params.term.length < this.minimumInputLength) {
	      this.trigger('results:message', {
	        message: 'inputTooShort',
	        args: {
	          minimum: this.minimumInputLength,
	          input: params.term,
	          params: params
	        }
	      });

	      return;
	    }

	    decorated.call(this, params, callback);
	  };

	  return MinimumInputLength;
	});

	S2.define('select2/data/maximumInputLength',[

	], function () {
	  function MaximumInputLength (decorated, $e, options) {
	    this.maximumInputLength = options.get('maximumInputLength');

	    decorated.call(this, $e, options);
	  }

	  MaximumInputLength.prototype.query = function (decorated, params, callback) {
	    params.term = params.term || '';

	    if (this.maximumInputLength > 0 &&
	        params.term.length > this.maximumInputLength) {
	      this.trigger('results:message', {
	        message: 'inputTooLong',
	        args: {
	          maximum: this.maximumInputLength,
	          input: params.term,
	          params: params
	        }
	      });

	      return;
	    }

	    decorated.call(this, params, callback);
	  };

	  return MaximumInputLength;
	});

	S2.define('select2/data/maximumSelectionLength',[

	], function (){
	  function MaximumSelectionLength (decorated, $e, options) {
	    this.maximumSelectionLength = options.get('maximumSelectionLength');

	    decorated.call(this, $e, options);
	  }

	  MaximumSelectionLength.prototype.query =
	    function (decorated, params, callback) {
	      var self = this;

	      this.current(function (currentData) {
	        var count = currentData != null ? currentData.length : 0;
	        if (self.maximumSelectionLength > 0 &&
	          count >= self.maximumSelectionLength) {
	          self.trigger('results:message', {
	            message: 'maximumSelected',
	            args: {
	              maximum: self.maximumSelectionLength
	            }
	          });
	          return;
	        }
	        decorated.call(self, params, callback);
	      });
	  };

	  return MaximumSelectionLength;
	});

	S2.define('select2/dropdown',[
	  'jquery',
	  './utils'
	], function ($, Utils) {
	  function Dropdown ($element, options) {
	    this.$element = $element;
	    this.options = options;

	    Dropdown.__super__.constructor.call(this);
	  }

	  Utils.Extend(Dropdown, Utils.Observable);

	  Dropdown.prototype.render = function () {
	    var $dropdown = $(
	      '<span class="select2-dropdown">' +
	        '<span class="select2-results"></span>' +
	      '</span>'
	    );

	    $dropdown.attr('dir', this.options.get('dir'));

	    this.$dropdown = $dropdown;

	    return $dropdown;
	  };

	  Dropdown.prototype.bind = function () {
	    // Should be implemented in subclasses
	  };

	  Dropdown.prototype.position = function ($dropdown, $container) {
	    // Should be implmented in subclasses
	  };

	  Dropdown.prototype.destroy = function () {
	    // Remove the dropdown from the DOM
	    this.$dropdown.remove();
	  };

	  return Dropdown;
	});

	S2.define('select2/dropdown/search',[
	  'jquery',
	  '../utils'
	], function ($, Utils) {
	  function Search () { }

	  Search.prototype.render = function (decorated) {
	    var $rendered = decorated.call(this);

	    var $search = $(
	      '<span class="select2-search select2-search--dropdown">' +
	        '<input class="select2-search__field" type="search" tabindex="-1"' +
	        ' autocomplete="off" autocorrect="off" autocapitalize="off"' +
	        ' spellcheck="false" role="textbox" />' +
	      '</span>'
	    );

	    this.$searchContainer = $search;
	    this.$search = $search.find('input');

	    $rendered.prepend($search);

	    return $rendered;
	  };

	  Search.prototype.bind = function (decorated, container, $container) {
	    var self = this;

	    decorated.call(this, container, $container);

	    this.$search.on('keydown', function (evt) {
	      self.trigger('keypress', evt);

	      self._keyUpPrevented = evt.isDefaultPrevented();
	    });

	    // Workaround for browsers which do not support the `input` event
	    // This will prevent double-triggering of events for browsers which support
	    // both the `keyup` and `input` events.
	    this.$search.on('input', function (evt) {
	      // Unbind the duplicated `keyup` event
	      $(this).off('keyup');
	    });

	    this.$search.on('keyup input', function (evt) {
	      self.handleSearch(evt);
	    });

	    container.on('open', function () {
	      self.$search.attr('tabindex', 0);

	      self.$search.focus();

	      window.setTimeout(function () {
	        self.$search.focus();
	      }, 0);
	    });

	    container.on('close', function () {
	      self.$search.attr('tabindex', -1);

	      self.$search.val('');
	    });

	    container.on('focus', function () {
	      if (container.isOpen()) {
	        self.$search.focus();
	      }
	    });

	    container.on('results:all', function (params) {
	      if (params.query.term == null || params.query.term === '') {
	        var showSearch = self.showSearch(params);

	        if (showSearch) {
	          self.$searchContainer.removeClass('select2-search--hide');
	        } else {
	          self.$searchContainer.addClass('select2-search--hide');
	        }
	      }
	    });
	  };

	  Search.prototype.handleSearch = function (evt) {
	    if (!this._keyUpPrevented) {
	      var input = this.$search.val();

	      this.trigger('query', {
	        term: input
	      });
	    }

	    this._keyUpPrevented = false;
	  };

	  Search.prototype.showSearch = function (_, params) {
	    return true;
	  };

	  return Search;
	});

	S2.define('select2/dropdown/hidePlaceholder',[

	], function () {
	  function HidePlaceholder (decorated, $element, options, dataAdapter) {
	    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

	    decorated.call(this, $element, options, dataAdapter);
	  }

	  HidePlaceholder.prototype.append = function (decorated, data) {
	    data.results = this.removePlaceholder(data.results);

	    decorated.call(this, data);
	  };

	  HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
	    if (typeof placeholder === 'string') {
	      placeholder = {
	        id: '',
	        text: placeholder
	      };
	    }

	    return placeholder;
	  };

	  HidePlaceholder.prototype.removePlaceholder = function (_, data) {
	    var modifiedData = data.slice(0);

	    for (var d = data.length - 1; d >= 0; d--) {
	      var item = data[d];

	      if (this.placeholder.id === item.id) {
	        modifiedData.splice(d, 1);
	      }
	    }

	    return modifiedData;
	  };

	  return HidePlaceholder;
	});

	S2.define('select2/dropdown/infiniteScroll',[
	  'jquery'
	], function ($) {
	  function InfiniteScroll (decorated, $element, options, dataAdapter) {
	    this.lastParams = {};

	    decorated.call(this, $element, options, dataAdapter);

	    this.$loadingMore = this.createLoadingMore();
	    this.loading = false;
	  }

	  InfiniteScroll.prototype.append = function (decorated, data) {
	    this.$loadingMore.remove();
	    this.loading = false;

	    decorated.call(this, data);

	    if (this.showLoadingMore(data)) {
	      this.$results.append(this.$loadingMore);
	    }
	  };

	  InfiniteScroll.prototype.bind = function (decorated, container, $container) {
	    var self = this;

	    decorated.call(this, container, $container);

	    container.on('query', function (params) {
	      self.lastParams = params;
	      self.loading = true;
	    });

	    container.on('query:append', function (params) {
	      self.lastParams = params;
	      self.loading = true;
	    });

	    this.$results.on('scroll', function () {
	      var isLoadMoreVisible = $.contains(
	        document.documentElement,
	        self.$loadingMore[0]
	      );

	      if (self.loading || !isLoadMoreVisible) {
	        return;
	      }

	      var currentOffset = self.$results.offset().top +
	        self.$results.outerHeight(false);
	      var loadingMoreOffset = self.$loadingMore.offset().top +
	        self.$loadingMore.outerHeight(false);

	      if (currentOffset + 50 >= loadingMoreOffset) {
	        self.loadMore();
	      }
	    });
	  };

	  InfiniteScroll.prototype.loadMore = function () {
	    this.loading = true;

	    var params = $.extend({}, {page: 1}, this.lastParams);

	    params.page++;

	    this.trigger('query:append', params);
	  };

	  InfiniteScroll.prototype.showLoadingMore = function (_, data) {
	    return data.pagination && data.pagination.more;
	  };

	  InfiniteScroll.prototype.createLoadingMore = function () {
	    var $option = $(
	      '<li ' +
	      'class="select2-results__option select2-results__option--load-more"' +
	      'role="treeitem" aria-disabled="true"></li>'
	    );

	    var message = this.options.get('translations').get('loadingMore');

	    $option.html(message(this.lastParams));

	    return $option;
	  };

	  return InfiniteScroll;
	});

	S2.define('select2/dropdown/attachBody',[
	  'jquery',
	  '../utils'
	], function ($, Utils) {
	  function AttachBody (decorated, $element, options) {
	    this.$dropdownParent = options.get('dropdownParent') || $(document.body);

	    decorated.call(this, $element, options);
	  }

	  AttachBody.prototype.bind = function (decorated, container, $container) {
	    var self = this;

	    var setupResultsEvents = false;

	    decorated.call(this, container, $container);

	    container.on('open', function () {
	      self._showDropdown();
	      self._attachPositioningHandler(container);

	      if (!setupResultsEvents) {
	        setupResultsEvents = true;

	        container.on('results:all', function () {
	          self._positionDropdown();
	          self._resizeDropdown();
	        });

	        container.on('results:append', function () {
	          self._positionDropdown();
	          self._resizeDropdown();
	        });
	      }
	    });

	    container.on('close', function () {
	      self._hideDropdown();
	      self._detachPositioningHandler(container);
	    });

	    this.$dropdownContainer.on('mousedown', function (evt) {
	      evt.stopPropagation();
	    });
	  };

	  AttachBody.prototype.destroy = function (decorated) {
	    decorated.call(this);

	    this.$dropdownContainer.remove();
	  };

	  AttachBody.prototype.position = function (decorated, $dropdown, $container) {
	    // Clone all of the container classes
	    $dropdown.attr('class', $container.attr('class'));

	    $dropdown.removeClass('select2');
	    $dropdown.addClass('select2-container--open');

	    $dropdown.css({
	      position: 'absolute',
	      top: -999999
	    });

	    this.$container = $container;
	  };

	  AttachBody.prototype.render = function (decorated) {
	    var $container = $('<span></span>');

	    var $dropdown = decorated.call(this);
	    $container.append($dropdown);

	    this.$dropdownContainer = $container;

	    return $container;
	  };

	  AttachBody.prototype._hideDropdown = function (decorated) {
	    this.$dropdownContainer.detach();
	  };

	  AttachBody.prototype._attachPositioningHandler =
	      function (decorated, container) {
	    var self = this;

	    var scrollEvent = 'scroll.select2.' + container.id;
	    var resizeEvent = 'resize.select2.' + container.id;
	    var orientationEvent = 'orientationchange.select2.' + container.id;

	    var $watchers = this.$container.parents().filter(Utils.hasScroll);
	    $watchers.each(function () {
	      $(this).data('select2-scroll-position', {
	        x: $(this).scrollLeft(),
	        y: $(this).scrollTop()
	      });
	    });

	    $watchers.on(scrollEvent, function (ev) {
	      var position = $(this).data('select2-scroll-position');
	      $(this).scrollTop(position.y);
	    });

	    $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,
	      function (e) {
	      self._positionDropdown();
	      self._resizeDropdown();
	    });
	  };

	  AttachBody.prototype._detachPositioningHandler =
	      function (decorated, container) {
	    var scrollEvent = 'scroll.select2.' + container.id;
	    var resizeEvent = 'resize.select2.' + container.id;
	    var orientationEvent = 'orientationchange.select2.' + container.id;

	    var $watchers = this.$container.parents().filter(Utils.hasScroll);
	    $watchers.off(scrollEvent);

	    $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
	  };

	  AttachBody.prototype._positionDropdown = function () {
	    var $window = $(window);

	    var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');
	    var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');

	    var newDirection = null;

	    var offset = this.$container.offset();

	    offset.bottom = offset.top + this.$container.outerHeight(false);

	    var container = {
	      height: this.$container.outerHeight(false)
	    };

	    container.top = offset.top;
	    container.bottom = offset.top + container.height;

	    var dropdown = {
	      height: this.$dropdown.outerHeight(false)
	    };

	    var viewport = {
	      top: $window.scrollTop(),
	      bottom: $window.scrollTop() + $window.height()
	    };

	    var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);
	    var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);

	    var css = {
	      left: offset.left,
	      top: container.bottom
	    };

	    // Determine what the parent element is to use for calciulating the offset
	    var $offsetParent = this.$dropdownParent;

	    // For statically positoned elements, we need to get the element
	    // that is determining the offset
	    if ($offsetParent.css('position') === 'static') {
	      $offsetParent = $offsetParent.offsetParent();
	    }

	    var parentOffset = $offsetParent.offset();

	    css.top -= parentOffset.top;
	    css.left -= parentOffset.left;

	    if (!isCurrentlyAbove && !isCurrentlyBelow) {
	      newDirection = 'below';
	    }

	    if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
	      newDirection = 'above';
	    } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
	      newDirection = 'below';
	    }

	    if (newDirection == 'above' ||
	      (isCurrentlyAbove && newDirection !== 'below')) {
	      css.top = container.top - parentOffset.top - dropdown.height;
	    }

	    if (newDirection != null) {
	      this.$dropdown
	        .removeClass('select2-dropdown--below select2-dropdown--above')
	        .addClass('select2-dropdown--' + newDirection);
	      this.$container
	        .removeClass('select2-container--below select2-container--above')
	        .addClass('select2-container--' + newDirection);
	    }

	    this.$dropdownContainer.css(css);
	  };

	  AttachBody.prototype._resizeDropdown = function () {
	    var css = {
	      width: this.$container.outerWidth(false) + 'px'
	    };

	    if (this.options.get('dropdownAutoWidth')) {
	      css.minWidth = css.width;
	      css.position = 'relative';
	      css.width = 'auto';
	    }

	    this.$dropdown.css(css);
	  };

	  AttachBody.prototype._showDropdown = function (decorated) {
	    this.$dropdownContainer.appendTo(this.$dropdownParent);

	    this._positionDropdown();
	    this._resizeDropdown();
	  };

	  return AttachBody;
	});

	S2.define('select2/dropdown/minimumResultsForSearch',[

	], function () {
	  function countResults (data) {
	    var count = 0;

	    for (var d = 0; d < data.length; d++) {
	      var item = data[d];

	      if (item.children) {
	        count += countResults(item.children);
	      } else {
	        count++;
	      }
	    }

	    return count;
	  }

	  function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {
	    this.minimumResultsForSearch = options.get('minimumResultsForSearch');

	    if (this.minimumResultsForSearch < 0) {
	      this.minimumResultsForSearch = Infinity;
	    }

	    decorated.call(this, $element, options, dataAdapter);
	  }

	  MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
	    if (countResults(params.data.results) < this.minimumResultsForSearch) {
	      return false;
	    }

	    return decorated.call(this, params);
	  };

	  return MinimumResultsForSearch;
	});

	S2.define('select2/dropdown/selectOnClose',[

	], function () {
	  function SelectOnClose () { }

	  SelectOnClose.prototype.bind = function (decorated, container, $container) {
	    var self = this;

	    decorated.call(this, container, $container);

	    container.on('close', function (params) {
	      self._handleSelectOnClose(params);
	    });
	  };

	  SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
	    if (params && params.originalSelect2Event != null) {
	      var event = params.originalSelect2Event;

	      // Don't select an item if the close event was triggered from a select or
	      // unselect event
	      if (event._type === 'select' || event._type === 'unselect') {
	        return;
	      }
	    }

	    var $highlightedResults = this.getHighlightedResults();

	    // Only select highlighted results
	    if ($highlightedResults.length < 1) {
	      return;
	    }

	    var data = $highlightedResults.data('data');

	    // Don't re-select already selected resulte
	    if (
	      (data.element != null && data.element.selected) ||
	      (data.element == null && data.selected)
	    ) {
	      return;
	    }

	    this.trigger('select', {
	        data: data
	    });
	  };

	  return SelectOnClose;
	});

	S2.define('select2/dropdown/closeOnSelect',[

	], function () {
	  function CloseOnSelect () { }

	  CloseOnSelect.prototype.bind = function (decorated, container, $container) {
	    var self = this;

	    decorated.call(this, container, $container);

	    container.on('select', function (evt) {
	      self._selectTriggered(evt);
	    });

	    container.on('unselect', function (evt) {
	      self._selectTriggered(evt);
	    });
	  };

	  CloseOnSelect.prototype._selectTriggered = function (_, evt) {
	    var originalEvent = evt.originalEvent;

	    // Don't close if the control key is being held
	    if (originalEvent && originalEvent.ctrlKey) {
	      return;
	    }

	    this.trigger('close', {
	      originalEvent: originalEvent,
	      originalSelect2Event: evt
	    });
	  };

	  return CloseOnSelect;
	});

	S2.define('select2/i18n/en',[],function () {
	  // English
	  return {
	    errorLoading: function () {
	      return 'The results could not be loaded.';
	    },
	    inputTooLong: function (args) {
	      var overChars = args.input.length - args.maximum;

	      var message = 'Please delete ' + overChars + ' character';

	      if (overChars != 1) {
	        message += 's';
	      }

	      return message;
	    },
	    inputTooShort: function (args) {
	      var remainingChars = args.minimum - args.input.length;

	      var message = 'Please enter ' + remainingChars + ' or more characters';

	      return message;
	    },
	    loadingMore: function () {
	      return 'Loading more results…';
	    },
	    maximumSelected: function (args) {
	      var message = 'You can only select ' + args.maximum + ' item';

	      if (args.maximum != 1) {
	        message += 's';
	      }

	      return message;
	    },
	    noResults: function () {
	      return 'No results found';
	    },
	    searching: function () {
	      return 'Searching…';
	    }
	  };
	});

	S2.define('select2/defaults',[
	  'jquery',
	  'require',

	  './results',

	  './selection/single',
	  './selection/multiple',
	  './selection/placeholder',
	  './selection/allowClear',
	  './selection/search',
	  './selection/eventRelay',

	  './utils',
	  './translation',
	  './diacritics',

	  './data/select',
	  './data/array',
	  './data/ajax',
	  './data/tags',
	  './data/tokenizer',
	  './data/minimumInputLength',
	  './data/maximumInputLength',
	  './data/maximumSelectionLength',

	  './dropdown',
	  './dropdown/search',
	  './dropdown/hidePlaceholder',
	  './dropdown/infiniteScroll',
	  './dropdown/attachBody',
	  './dropdown/minimumResultsForSearch',
	  './dropdown/selectOnClose',
	  './dropdown/closeOnSelect',

	  './i18n/en'
	], function ($, require,

	             ResultsList,

	             SingleSelection, MultipleSelection, Placeholder, AllowClear,
	             SelectionSearch, EventRelay,

	             Utils, Translation, DIACRITICS,

	             SelectData, ArrayData, AjaxData, Tags, Tokenizer,
	             MinimumInputLength, MaximumInputLength, MaximumSelectionLength,

	             Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,
	             AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,

	             EnglishTranslation) {
	  function Defaults () {
	    this.reset();
	  }

	  Defaults.prototype.apply = function (options) {
	    options = $.extend(true, {}, this.defaults, options);

	    if (options.dataAdapter == null) {
	      if (options.ajax != null) {
	        options.dataAdapter = AjaxData;
	      } else if (options.data != null) {
	        options.dataAdapter = ArrayData;
	      } else {
	        options.dataAdapter = SelectData;
	      }

	      if (options.minimumInputLength > 0) {
	        options.dataAdapter = Utils.Decorate(
	          options.dataAdapter,
	          MinimumInputLength
	        );
	      }

	      if (options.maximumInputLength > 0) {
	        options.dataAdapter = Utils.Decorate(
	          options.dataAdapter,
	          MaximumInputLength
	        );
	      }

	      if (options.maximumSelectionLength > 0) {
	        options.dataAdapter = Utils.Decorate(
	          options.dataAdapter,
	          MaximumSelectionLength
	        );
	      }

	      if (options.tags) {
	        options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
	      }

	      if (options.tokenSeparators != null || options.tokenizer != null) {
	        options.dataAdapter = Utils.Decorate(
	          options.dataAdapter,
	          Tokenizer
	        );
	      }

	      if (options.query != null) {
	        var Query = require(options.amdBase + 'compat/query');

	        options.dataAdapter = Utils.Decorate(
	          options.dataAdapter,
	          Query
	        );
	      }

	      if (options.initSelection != null) {
	        var InitSelection = require(options.amdBase + 'compat/initSelection');

	        options.dataAdapter = Utils.Decorate(
	          options.dataAdapter,
	          InitSelection
	        );
	      }
	    }

	    if (options.resultsAdapter == null) {
	      options.resultsAdapter = ResultsList;

	      if (options.ajax != null) {
	        options.resultsAdapter = Utils.Decorate(
	          options.resultsAdapter,
	          InfiniteScroll
	        );
	      }

	      if (options.placeholder != null) {
	        options.resultsAdapter = Utils.Decorate(
	          options.resultsAdapter,
	          HidePlaceholder
	        );
	      }

	      if (options.selectOnClose) {
	        options.resultsAdapter = Utils.Decorate(
	          options.resultsAdapter,
	          SelectOnClose
	        );
	      }
	    }

	    if (options.dropdownAdapter == null) {
	      if (options.multiple) {
	        options.dropdownAdapter = Dropdown;
	      } else {
	        var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);

	        options.dropdownAdapter = SearchableDropdown;
	      }

	      if (options.minimumResultsForSearch !== 0) {
	        options.dropdownAdapter = Utils.Decorate(
	          options.dropdownAdapter,
	          MinimumResultsForSearch
	        );
	      }

	      if (options.closeOnSelect) {
	        options.dropdownAdapter = Utils.Decorate(
	          options.dropdownAdapter,
	          CloseOnSelect
	        );
	      }

	      if (
	        options.dropdownCssClass != null ||
	        options.dropdownCss != null ||
	        options.adaptDropdownCssClass != null
	      ) {
	        var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');

	        options.dropdownAdapter = Utils.Decorate(
	          options.dropdownAdapter,
	          DropdownCSS
	        );
	      }

	      options.dropdownAdapter = Utils.Decorate(
	        options.dropdownAdapter,
	        AttachBody
	      );
	    }

	    if (options.selectionAdapter == null) {
	      if (options.multiple) {
	        options.selectionAdapter = MultipleSelection;
	      } else {
	        options.selectionAdapter = SingleSelection;
	      }

	      // Add the placeholder mixin if a placeholder was specified
	      if (options.placeholder != null) {
	        options.selectionAdapter = Utils.Decorate(
	          options.selectionAdapter,
	          Placeholder
	        );
	      }

	      if (options.allowClear) {
	        options.selectionAdapter = Utils.Decorate(
	          options.selectionAdapter,
	          AllowClear
	        );
	      }

	      if (options.multiple) {
	        options.selectionAdapter = Utils.Decorate(
	          options.selectionAdapter,
	          SelectionSearch
	        );
	      }

	      if (
	        options.containerCssClass != null ||
	        options.containerCss != null ||
	        options.adaptContainerCssClass != null
	      ) {
	        var ContainerCSS = require(options.amdBase + 'compat/containerCss');

	        options.selectionAdapter = Utils.Decorate(
	          options.selectionAdapter,
	          ContainerCSS
	        );
	      }

	      options.selectionAdapter = Utils.Decorate(
	        options.selectionAdapter,
	        EventRelay
	      );
	    }

	    if (typeof options.language === 'string') {
	      // Check if the language is specified with a region
	      if (options.language.indexOf('-') > 0) {
	        // Extract the region information if it is included
	        var languageParts = options.language.split('-');
	        var baseLanguage = languageParts[0];

	        options.language = [options.language, baseLanguage];
	      } else {
	        options.language = [options.language];
	      }
	    }

	    if ($.isArray(options.language)) {
	      var languages = new Translation();
	      options.language.push('en');

	      var languageNames = options.language;

	      for (var l = 0; l < languageNames.length; l++) {
	        var name = languageNames[l];
	        var language = {};

	        try {
	          // Try to load it with the original name
	          language = Translation.loadPath(name);
	        } catch (e) {
	          try {
	            // If we couldn't load it, check if it wasn't the full path
	            name = this.defaults.amdLanguageBase + name;
	            language = Translation.loadPath(name);
	          } catch (ex) {
	            // The translation could not be loaded at all. Sometimes this is
	            // because of a configuration problem, other times this can be
	            // because of how Select2 helps load all possible translation files.
	            if (options.debug && window.console && console.warn) {
	              console.warn(
	                'Select2: The language file for "' + name + '" could not be ' +
	                'automatically loaded. A fallback will be used instead.'
	              );
	            }

	            continue;
	          }
	        }

	        languages.extend(language);
	      }

	      options.translations = languages;
	    } else {
	      var baseTranslation = Translation.loadPath(
	        this.defaults.amdLanguageBase + 'en'
	      );
	      var customTranslation = new Translation(options.language);

	      customTranslation.extend(baseTranslation);

	      options.translations = customTranslation;
	    }

	    return options;
	  };

	  Defaults.prototype.reset = function () {
	    function stripDiacritics (text) {
	      // Used 'uni range + named function' from http://jsperf.com/diacritics/18
	      function match(a) {
	        return DIACRITICS[a] || a;
	      }

	      return text.replace(/[^\u0000-\u007E]/g, match);
	    }

	    function matcher (params, data) {
	      // Always return the object if there is nothing to compare
	      if ($.trim(params.term) === '') {
	        return data;
	      }

	      // Do a recursive check for options with children
	      if (data.children && data.children.length > 0) {
	        // Clone the data object if there are children
	        // This is required as we modify the object to remove any non-matches
	        var match = $.extend(true, {}, data);

	        // Check each child of the option
	        for (var c = data.children.length - 1; c >= 0; c--) {
	          var child = data.children[c];

	          var matches = matcher(params, child);

	          // If there wasn't a match, remove the object in the array
	          if (matches == null) {
	            match.children.splice(c, 1);
	          }
	        }

	        // If any children matched, return the new object
	        if (match.children.length > 0) {
	          return match;
	        }

	        // If there were no matching children, check just the plain object
	        return matcher(params, match);
	      }

	      var original = stripDiacritics(data.text).toUpperCase();
	      var term = stripDiacritics(params.term).toUpperCase();

	      // Check if the text contains the term
	      if (original.indexOf(term) > -1) {
	        return data;
	      }

	      // If it doesn't contain the term, don't return anything
	      return null;
	    }

	    this.defaults = {
	      amdBase: './',
	      amdLanguageBase: './i18n/',
	      closeOnSelect: true,
	      debug: false,
	      dropdownAutoWidth: false,
	      escapeMarkup: Utils.escapeMarkup,
	      language: EnglishTranslation,
	      matcher: matcher,
	      minimumInputLength: 0,
	      maximumInputLength: 0,
	      maximumSelectionLength: 0,
	      minimumResultsForSearch: 0,
	      selectOnClose: false,
	      sorter: function (data) {
	        return data;
	      },
	      templateResult: function (result) {
	        return result.text;
	      },
	      templateSelection: function (selection) {
	        return selection.text;
	      },
	      theme: 'default',
	      width: 'resolve'
	    };
	  };

	  Defaults.prototype.set = function (key, value) {
	    var camelKey = $.camelCase(key);

	    var data = {};
	    data[camelKey] = value;

	    var convertedData = Utils._convertData(data);

	    $.extend(this.defaults, convertedData);
	  };

	  var defaults = new Defaults();

	  return defaults;
	});

	S2.define('select2/options',[
	  'require',
	  'jquery',
	  './defaults',
	  './utils'
	], function (require, $, Defaults, Utils) {
	  function Options (options, $element) {
	    this.options = options;

	    if ($element != null) {
	      this.fromElement($element);
	    }

	    this.options = Defaults.apply(this.options);

	    if ($element && $element.is('input')) {
	      var InputCompat = require(this.get('amdBase') + 'compat/inputData');

	      this.options.dataAdapter = Utils.Decorate(
	        this.options.dataAdapter,
	        InputCompat
	      );
	    }
	  }

	  Options.prototype.fromElement = function ($e) {
	    var excludedData = ['select2'];

	    if (this.options.multiple == null) {
	      this.options.multiple = $e.prop('multiple');
	    }

	    if (this.options.disabled == null) {
	      this.options.disabled = $e.prop('disabled');
	    }

	    if (this.options.language == null) {
	      if ($e.prop('lang')) {
	        this.options.language = $e.prop('lang').toLowerCase();
	      } else if ($e.closest('[lang]').prop('lang')) {
	        this.options.language = $e.closest('[lang]').prop('lang');
	      }
	    }

	    if (this.options.dir == null) {
	      if ($e.prop('dir')) {
	        this.options.dir = $e.prop('dir');
	      } else if ($e.closest('[dir]').prop('dir')) {
	        this.options.dir = $e.closest('[dir]').prop('dir');
	      } else {
	        this.options.dir = 'ltr';
	      }
	    }

	    $e.prop('disabled', this.options.disabled);
	    $e.prop('multiple', this.options.multiple);

	    if ($e.data('select2Tags')) {
	      if (this.options.debug && window.console && console.warn) {
	        console.warn(
	          'Select2: The `data-select2-tags` attribute has been changed to ' +
	          'use the `data-data` and `data-tags="true"` attributes and will be ' +
	          'removed in future versions of Select2.'
	        );
	      }

	      $e.data('data', $e.data('select2Tags'));
	      $e.data('tags', true);
	    }

	    if ($e.data('ajaxUrl')) {
	      if (this.options.debug && window.console && console.warn) {
	        console.warn(
	          'Select2: The `data-ajax-url` attribute has been changed to ' +
	          '`data-ajax--url` and support for the old attribute will be removed' +
	          ' in future versions of Select2.'
	        );
	      }

	      $e.attr('ajax--url', $e.data('ajaxUrl'));
	      $e.data('ajax--url', $e.data('ajaxUrl'));
	    }

	    var dataset = {};

	    // Prefer the element's `dataset` attribute if it exists
	    // jQuery 1.x does not correctly handle data attributes with multiple dashes
	    if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
	      dataset = $.extend(true, {}, $e[0].dataset, $e.data());
	    } else {
	      dataset = $e.data();
	    }

	    var data = $.extend(true, {}, dataset);

	    data = Utils._convertData(data);

	    for (var key in data) {
	      if ($.inArray(key, excludedData) > -1) {
	        continue;
	      }

	      if ($.isPlainObject(this.options[key])) {
	        $.extend(this.options[key], data[key]);
	      } else {
	        this.options[key] = data[key];
	      }
	    }

	    return this;
	  };

	  Options.prototype.get = function (key) {
	    return this.options[key];
	  };

	  Options.prototype.set = function (key, val) {
	    this.options[key] = val;
	  };

	  return Options;
	});

	S2.define('select2/core',[
	  'jquery',
	  './options',
	  './utils',
	  './keys'
	], function ($, Options, Utils, KEYS) {
	  var Select2 = function ($element, options) {
	    if ($element.data('select2') != null) {
	      $element.data('select2').destroy();
	    }

	    this.$element = $element;

	    this.id = this._generateId($element);

	    options = options || {};

	    this.options = new Options(options, $element);

	    Select2.__super__.constructor.call(this);

	    // Set up the tabindex

	    var tabindex = $element.attr('tabindex') || 0;
	    $element.data('old-tabindex', tabindex);
	    $element.attr('tabindex', '-1');

	    // Set up containers and adapters

	    var DataAdapter = this.options.get('dataAdapter');
	    this.dataAdapter = new DataAdapter($element, this.options);

	    var $container = this.render();

	    this._placeContainer($container);

	    var SelectionAdapter = this.options.get('selectionAdapter');
	    this.selection = new SelectionAdapter($element, this.options);
	    this.$selection = this.selection.render();

	    this.selection.position(this.$selection, $container);

	    var DropdownAdapter = this.options.get('dropdownAdapter');
	    this.dropdown = new DropdownAdapter($element, this.options);
	    this.$dropdown = this.dropdown.render();

	    this.dropdown.position(this.$dropdown, $container);

	    var ResultsAdapter = this.options.get('resultsAdapter');
	    this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
	    this.$results = this.results.render();

	    this.results.position(this.$results, this.$dropdown);

	    // Bind events

	    var self = this;

	    // Bind the container to all of the adapters
	    this._bindAdapters();

	    // Register any DOM event handlers
	    this._registerDomEvents();

	    // Register any internal event handlers
	    this._registerDataEvents();
	    this._registerSelectionEvents();
	    this._registerDropdownEvents();
	    this._registerResultsEvents();
	    this._registerEvents();

	    // Set the initial state
	    this.dataAdapter.current(function (initialData) {
	      self.trigger('selection:update', {
	        data: initialData
	      });
	    });

	    // Hide the original select
	    $element.addClass('select2-hidden-accessible');
	    $element.attr('aria-hidden', 'true');

	    // Synchronize any monitored attributes
	    this._syncAttributes();

	    $element.data('select2', this);
	  };

	  Utils.Extend(Select2, Utils.Observable);

	  Select2.prototype._generateId = function ($element) {
	    var id = '';

	    if ($element.attr('id') != null) {
	      id = $element.attr('id');
	    } else if ($element.attr('name') != null) {
	      id = $element.attr('name') + '-' + Utils.generateChars(2);
	    } else {
	      id = Utils.generateChars(4);
	    }

	    id = id.replace(/(:|\.|\[|\]|,)/g, '');
	    id = 'select2-' + id;

	    return id;
	  };

	  Select2.prototype._placeContainer = function ($container) {
	    $container.insertAfter(this.$element);

	    var width = this._resolveWidth(this.$element, this.options.get('width'));

	    if (width != null) {
	      $container.css('width', width);
	    }
	  };

	  Select2.prototype._resolveWidth = function ($element, method) {
	    var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;

	    if (method == 'resolve') {
	      var styleWidth = this._resolveWidth($element, 'style');

	      if (styleWidth != null) {
	        return styleWidth;
	      }

	      return this._resolveWidth($element, 'element');
	    }

	    if (method == 'element') {
	      var elementWidth = $element.outerWidth(false);

	      if (elementWidth <= 0) {
	        return 'auto';
	      }

	      return elementWidth + 'px';
	    }

	    if (method == 'style') {
	      var style = $element.attr('style');

	      if (typeof(style) !== 'string') {
	        return null;
	      }

	      var attrs = style.split(';');

	      for (var i = 0, l = attrs.length; i < l; i = i + 1) {
	        var attr = attrs[i].replace(/\s/g, '');
	        var matches = attr.match(WIDTH);

	        if (matches !== null && matches.length >= 1) {
	          return matches[1];
	        }
	      }

	      return null;
	    }

	    return method;
	  };

	  Select2.prototype._bindAdapters = function () {
	    this.dataAdapter.bind(this, this.$container);
	    this.selection.bind(this, this.$container);

	    this.dropdown.bind(this, this.$container);
	    this.results.bind(this, this.$container);
	  };

	  Select2.prototype._registerDomEvents = function () {
	    var self = this;

	    this.$element.on('change.select2', function () {
	      self.dataAdapter.current(function (data) {
	        self.trigger('selection:update', {
	          data: data
	        });
	      });
	    });

	    this.$element.on('focus.select2', function (evt) {
	      self.trigger('focus', evt);
	    });

	    this._syncA = Utils.bind(this._syncAttributes, this);
	    this._syncS = Utils.bind(this._syncSubtree, this);

	    if (this.$element[0].attachEvent) {
	      this.$element[0].attachEvent('onpropertychange', this._syncA);
	    }

	    var observer = window.MutationObserver ||
	      window.WebKitMutationObserver ||
	      window.MozMutationObserver
	    ;

	    if (observer != null) {
	      this._observer = new observer(function (mutations) {
	        $.each(mutations, self._syncA);
	        $.each(mutations, self._syncS);
	      });
	      this._observer.observe(this.$element[0], {
	        attributes: true,
	        childList: true,
	        subtree: false
	      });
	    } else if (this.$element[0].addEventListener) {
	      this.$element[0].addEventListener(
	        'DOMAttrModified',
	        self._syncA,
	        false
	      );
	      this.$element[0].addEventListener(
	        'DOMNodeInserted',
	        self._syncS,
	        false
	      );
	      this.$element[0].addEventListener(
	        'DOMNodeRemoved',
	        self._syncS,
	        false
	      );
	    }
	  };

	  Select2.prototype._registerDataEvents = function () {
	    var self = this;

	    this.dataAdapter.on('*', function (name, params) {
	      self.trigger(name, params);
	    });
	  };

	  Select2.prototype._registerSelectionEvents = function () {
	    var self = this;
	    var nonRelayEvents = ['toggle', 'focus'];

	    this.selection.on('toggle', function () {
	      self.toggleDropdown();
	    });

	    this.selection.on('focus', function (params) {
	      self.focus(params);
	    });

	    this.selection.on('*', function (name, params) {
	      if ($.inArray(name, nonRelayEvents) !== -1) {
	        return;
	      }

	      self.trigger(name, params);
	    });
	  };

	  Select2.prototype._registerDropdownEvents = function () {
	    var self = this;

	    this.dropdown.on('*', function (name, params) {
	      self.trigger(name, params);
	    });
	  };

	  Select2.prototype._registerResultsEvents = function () {
	    var self = this;

	    this.results.on('*', function (name, params) {
	      self.trigger(name, params);
	    });
	  };

	  Select2.prototype._registerEvents = function () {
	    var self = this;

	    this.on('open', function () {
	      self.$container.addClass('select2-container--open');
	    });

	    this.on('close', function () {
	      self.$container.removeClass('select2-container--open');
	    });

	    this.on('enable', function () {
	      self.$container.removeClass('select2-container--disabled');
	    });

	    this.on('disable', function () {
	      self.$container.addClass('select2-container--disabled');
	    });

	    this.on('blur', function () {
	      self.$container.removeClass('select2-container--focus');
	    });

	    this.on('query', function (params) {
	      if (!self.isOpen()) {
	        self.trigger('open', {});
	      }

	      this.dataAdapter.query(params, function (data) {
	        self.trigger('results:all', {
	          data: data,
	          query: params
	        });
	      });
	    });

	    this.on('query:append', function (params) {
	      this.dataAdapter.query(params, function (data) {
	        self.trigger('results:append', {
	          data: data,
	          query: params
	        });
	      });
	    });

	    this.on('keypress', function (evt) {
	      var key = evt.which;

	      if (self.isOpen()) {
	        if (key === KEYS.ESC || key === KEYS.TAB ||
	            (key === KEYS.UP && evt.altKey)) {
	          self.close();

	          evt.preventDefault();
	        } else if (key === KEYS.ENTER) {
	          self.trigger('results:select', {});

	          evt.preventDefault();
	        } else if ((key === KEYS.SPACE && evt.ctrlKey)) {
	          self.trigger('results:toggle', {});

	          evt.preventDefault();
	        } else if (key === KEYS.UP) {
	          self.trigger('results:previous', {});

	          evt.preventDefault();
	        } else if (key === KEYS.DOWN) {
	          self.trigger('results:next', {});

	          evt.preventDefault();
	        }
	      } else {
	        if (key === KEYS.ENTER || key === KEYS.SPACE ||
	            (key === KEYS.DOWN && evt.altKey)) {
	          self.open();

	          evt.preventDefault();
	        }
	      }
	    });
	  };

	  Select2.prototype._syncAttributes = function () {
	    this.options.set('disabled', this.$element.prop('disabled'));

	    if (this.options.get('disabled')) {
	      if (this.isOpen()) {
	        this.close();
	      }

	      this.trigger('disable', {});
	    } else {
	      this.trigger('enable', {});
	    }
	  };

	  Select2.prototype._syncSubtree = function (evt, mutations) {
	    var changed = false;
	    var self = this;

	    // Ignore any mutation events raised for elements that aren't options or
	    // optgroups. This handles the case when the select element is destroyed
	    if (
	      evt && evt.target && (
	        evt.target.nodeName !== 'OPTION' && evt.target.nodeName !== 'OPTGROUP'
	      )
	    ) {
	      return;
	    }

	    if (!mutations) {
	      // If mutation events aren't supported, then we can only assume that the
	      // change affected the selections
	      changed = true;
	    } else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
	      for (var n = 0; n < mutations.addedNodes.length; n++) {
	        var node = mutations.addedNodes[n];

	        if (node.selected) {
	          changed = true;
	        }
	      }
	    } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
	      changed = true;
	    }

	    // Only re-pull the data if we think there is a change
	    if (changed) {
	      this.dataAdapter.current(function (currentData) {
	        self.trigger('selection:update', {
	          data: currentData
	        });
	      });
	    }
	  };

	  /**
	   * Override the trigger method to automatically trigger pre-events when
	   * there are events that can be prevented.
	   */
	  Select2.prototype.trigger = function (name, args) {
	    var actualTrigger = Select2.__super__.trigger;
	    var preTriggerMap = {
	      'open': 'opening',
	      'close': 'closing',
	      'select': 'selecting',
	      'unselect': 'unselecting'
	    };

	    if (args === undefined) {
	      args = {};
	    }

	    if (name in preTriggerMap) {
	      var preTriggerName = preTriggerMap[name];
	      var preTriggerArgs = {
	        prevented: false,
	        name: name,
	        args: args
	      };

	      actualTrigger.call(this, preTriggerName, preTriggerArgs);

	      if (preTriggerArgs.prevented) {
	        args.prevented = true;

	        return;
	      }
	    }

	    actualTrigger.call(this, name, args);
	  };

	  Select2.prototype.toggleDropdown = function () {
	    if (this.options.get('disabled')) {
	      return;
	    }

	    if (this.isOpen()) {
	      this.close();
	    } else {
	      this.open();
	    }
	  };

	  Select2.prototype.open = function () {
	    if (this.isOpen()) {
	      return;
	    }

	    this.trigger('query', {});
	  };

	  Select2.prototype.close = function () {
	    if (!this.isOpen()) {
	      return;
	    }

	    this.trigger('close', {});
	  };

	  Select2.prototype.isOpen = function () {
	    return this.$container.hasClass('select2-container--open');
	  };

	  Select2.prototype.hasFocus = function () {
	    return this.$container.hasClass('select2-container--focus');
	  };

	  Select2.prototype.focus = function (data) {
	    // No need to re-trigger focus events if we are already focused
	    if (this.hasFocus()) {
	      return;
	    }

	    this.$container.addClass('select2-container--focus');
	    this.trigger('focus', {});
	  };

	  Select2.prototype.enable = function (args) {
	    if (this.options.get('debug') && window.console && console.warn) {
	      console.warn(
	        'Select2: The `select2("enable")` method has been deprecated and will' +
	        ' be removed in later Select2 versions. Use $element.prop("disabled")' +
	        ' instead.'
	      );
	    }

	    if (args == null || args.length === 0) {
	      args = [true];
	    }

	    var disabled = !args[0];

	    this.$element.prop('disabled', disabled);
	  };

	  Select2.prototype.data = function () {
	    if (this.options.get('debug') &&
	        arguments.length > 0 && window.console && console.warn) {
	      console.warn(
	        'Select2: Data can no longer be set using `select2("data")`. You ' +
	        'should consider setting the value instead using `$element.val()`.'
	      );
	    }

	    var data = [];

	    this.dataAdapter.current(function (currentData) {
	      data = currentData;
	    });

	    return data;
	  };

	  Select2.prototype.val = function (args) {
	    if (this.options.get('debug') && window.console && console.warn) {
	      console.warn(
	        'Select2: The `select2("val")` method has been deprecated and will be' +
	        ' removed in later Select2 versions. Use $element.val() instead.'
	      );
	    }

	    if (args == null || args.length === 0) {
	      return this.$element.val();
	    }

	    var newVal = args[0];

	    if ($.isArray(newVal)) {
	      newVal = $.map(newVal, function (obj) {
	        return obj.toString();
	      });
	    }

	    this.$element.val(newVal).trigger('change');
	  };

	  Select2.prototype.destroy = function () {
	    this.$container.remove();

	    if (this.$element[0].detachEvent) {
	      this.$element[0].detachEvent('onpropertychange', this._syncA);
	    }

	    if (this._observer != null) {
	      this._observer.disconnect();
	      this._observer = null;
	    } else if (this.$element[0].removeEventListener) {
	      this.$element[0]
	        .removeEventListener('DOMAttrModified', this._syncA, false);
	      this.$element[0]
	        .removeEventListener('DOMNodeInserted', this._syncS, false);
	      this.$element[0]
	        .removeEventListener('DOMNodeRemoved', this._syncS, false);
	    }

	    this._syncA = null;
	    this._syncS = null;

	    this.$element.off('.select2');
	    this.$element.attr('tabindex', this.$element.data('old-tabindex'));

	    this.$element.removeClass('select2-hidden-accessible');
	    this.$element.attr('aria-hidden', 'false');
	    this.$element.removeData('select2');

	    this.dataAdapter.destroy();
	    this.selection.destroy();
	    this.dropdown.destroy();
	    this.results.destroy();

	    this.dataAdapter = null;
	    this.selection = null;
	    this.dropdown = null;
	    this.results = null;
	  };

	  Select2.prototype.render = function () {
	    var $container = $(
	      '<span class="select2 select2-container">' +
	        '<span class="selection"></span>' +
	        '<span class="dropdown-wrapper" aria-hidden="true"></span>' +
	      '</span>'
	    );

	    $container.attr('dir', this.options.get('dir'));

	    this.$container = $container;

	    this.$container.addClass('select2-container--' + this.options.get('theme'));

	    $container.data('element', this.$element);

	    return $container;
	  };

	  return Select2;
	});

	S2.define('jquery-mousewheel',[
	  'jquery'
	], function ($) {
	  // Used to shim jQuery.mousewheel for non-full builds.
	  return $;
	});

	S2.define('jquery.select2',[
	  'jquery',
	  'jquery-mousewheel',

	  './select2/core',
	  './select2/defaults'
	], function ($, _, Select2, Defaults) {
	  if ($.fn.select2 == null) {
	    // All methods that should return the element
	    var thisMethods = ['open', 'close', 'destroy'];

	    $.fn.select2 = function (options) {
	      options = options || {};

	      if (typeof options === 'object') {
	        this.each(function () {
	          var instanceOptions = $.extend(true, {}, options);

	          var instance = new Select2($(this), instanceOptions);
	        });

	        return this;
	      } else if (typeof options === 'string') {
	        var ret;
	        var args = Array.prototype.slice.call(arguments, 1);

	        this.each(function () {
	          var instance = $(this).data('select2');

	          if (instance == null && window.console && console.error) {
	            console.error(
	              'The select2(\'' + options + '\') method was called on an ' +
	              'element that is not using Select2.'
	            );
	          }

	          ret = instance[options].apply(instance, args);
	        });

	        // Check if we should be returning `this`
	        if ($.inArray(options, thisMethods) > -1) {
	          return this;
	        }

	        return ret;
	      } else {
	        throw new Error('Invalid arguments for Select2: ' + options);
	      }
	    };
	  }

	  if ($.fn.select2.defaults == null) {
	    $.fn.select2.defaults = Defaults;
	  }

	  return Select2;
	});

	  // Return the AMD loader configuration so it can be used outside of this file
	  return {
	    define: S2.define,
	    require: S2.require
	  };
	}());

	  // Autoload the jQuery bindings
	  // We know that all of the modules exist above this, so we're safe
	  var select2 = S2.require('jquery.select2');

	  // Hold the AMD module references on the jQuery function that was just loaded
	  // This allows Select2 to use the internal loader outside of this file, such
	  // as in the language files.
	  jQuery.fn.select2.amd = S2;

	  // Return the Select2 instance for anyone who is importing it.
	  return select2;
	}));


/***/ },
/* 568 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var StatementUI = __webpack_require__(569);
	var ViewPopup = __webpack_require__(435);
	var BinarySocket = __webpack_require__(427);
	var getLanguage = __webpack_require__(424).get;
	var localize = __webpack_require__(428).localize;
	var showLocalTimeOnHover = __webpack_require__(463).showLocalTimeOnHover;
	var addTooltip = __webpack_require__(513).addTooltip;
	var buildOauthApps = __webpack_require__(513).buildOauthApps;
	var dateValueChanged = __webpack_require__(430).dateValueChanged;
	var jpClient = __webpack_require__(425).jpClient;
	var toISOFormat = __webpack_require__(449).toISOFormat;
	var DatePicker = __webpack_require__(519);

	var StatementInit = function () {
	    'use strict';

	    // Batch refer to number of data get from ws service per request
	    // chunk refer to number of data populate to ui for each append
	    // receive means receive from ws service
	    // consume means consume by UI and displayed to page

	    var batch_size = void 0,
	        chunk_size = void 0,
	        no_more_data = void 0,
	        pending = void 0,
	        current_batch = void 0,
	        transactions_received = void 0,
	        transactions_consumed = void 0;

	    var tableExist = function tableExist() {
	        return document.getElementById('statement-table');
	    };

	    var finishedConsumed = function finishedConsumed() {
	        return transactions_consumed === transactions_received;
	    };

	    var getStatement = function getStatement(opts) {
	        var req = { statement: 1, description: 1 };

	        if (opts) $.extend(true, req, opts);

	        var jump_to_val = $('#jump-to').attr('data-value');
	        if (jump_to_val && jump_to_val !== '') {
	            req.date_to = moment.utc(jump_to_val).unix() + (jpClient() ? 15 : 24) * (60 * 60);
	            req.date_from = 0;
	        }
	        BinarySocket.send(req).then(function (response) {
	            statementHandler(response);
	        });
	    };

	    var getNextBatchStatement = function getNextBatchStatement() {
	        getStatement({ offset: transactions_received, limit: batch_size });
	        pending = true;
	    };

	    var getNextChunkStatement = function getNextChunkStatement() {
	        var chunk = current_batch.splice(0, chunk_size);
	        transactions_consumed += chunk.length;
	        $('#rows_count').text(transactions_consumed);
	        return chunk;
	    };

	    var statementHandler = function statementHandler(response) {
	        if (response.error) {
	            StatementUI.errorMessage(response.error.message);
	            return;
	        }

	        pending = false;

	        var statement = response.statement;
	        current_batch = statement.transactions;
	        transactions_received += current_batch.length;

	        if (current_batch.length < batch_size) {
	            no_more_data = true;
	        }

	        if (!tableExist()) {
	            var $header = StatementUI.createEmptyStatementTable();
	            headerEventHandler();
	            $header.appendTo('#statement-container');
	            $('#statement-container').css('padding-left', '1%');
	            $('#statement-container').css('padding-right', '1%');
	            $('.act, .credit').addClass('nowrap');
	            StatementUI.updateStatementTable(getNextChunkStatement());

	            // Show a message when the table is empty
	            if (transactions_received === 0 && current_batch.length === 0) {
	                $('#statement-table').find('tbody').append($('<tr/>', { class: 'flex-tr' }).append($('<td/>', { colspan: 7 }).append($('<p/>', { class: 'notice-msg center-text', text: localize('Your account has no trading activity.') }))));
	            } else {
	                $('#util_row').setVisibility(1);
	                if (getLanguage() === 'JA') {
	                    $('#download_csv').setVisibility(1).find('a').unbind('click').click(function () {
	                        StatementUI.exportCSV();
	                    });
	                }
	            }
	            uniqueActionList();
	        }

	        showLocalTimeOnHover('td.date');
	    };

	    var uniqueActionList = function uniqueActionList() {
	        var action_list = ['All'];
	        $('#statement-table > tbody > tr').each(function () {
	            var action = String($(this).find('.act').html());
	            if (action_list.indexOf(action) === -1) {
	                action_list.push(action);
	            }
	        });
	        var opts = $('#action-list')[0].options;
	        console.log(opts);
	        $.each(action_list, function (i, action) {
	            $('#action-list').append($('<option>', {
	                value: action.toLowerCase(),
	                text: localize(action)
	            }));
	        });
	    };

	    var headerEventHandler = function headerEventHandler() {
	        $(document.body).find('#reference-input').on('keyup', function () {
	            filterTable();
	        });
	        $(document.body).find('#debit-credit-list').on('change', function () {
	            filterTable();
	        });
	        $(document.body).find('#action-list').on('change', function () {
	            filterTable();
	        });
	    };

	    var filterTable = function filterTable() {
	        var foundRow = false;
	        var input_ref = $('#reference-input').val();
	        var input_selected = $('#debit-credit-list').val();
	        var input_action = $('#action-list').val();
	        $('#statement-table > tbody > tr').each(function () {
	            var ref_id = $(this).find('.ref > span').html();
	            var profit_loss_class = $(this).find('.credit').attr('class');
	            var action = $(this).find('.act').html();
	            if ($(this).attr('class').indexOf('details') > -1 && findRef(input_ref, ref_id) && findPL(input_selected, profit_loss_class) && findAction(input_action, action)) {
	                $(this).css('display', '');
	                foundRow = true;
	            } else {
	                $(this).css('display', 'none');
	            }
	        });
	        if (!foundRow) {
	            if ($('.no-record')) {
	                $('#statement-table').find('tbody').append($('<tr/>', { class: 'flex-tr' }).append($('<td/>', { colspan: 7 }).append($('<p/>', { class: 'no-record center-text', text: localize('No Search Results found.') }))));
	            }

	            $('flex-tr').css('display', '');
	        } else {
	            $('flex-tr').css('display', 'none');
	        }
	    };

	    var findRef = function findRef(input_ref, ref_id) {
	        if (ref_id.indexOf(input_ref) > -1) {
	            return true;
	        }
	        return false;
	    };

	    var findPL = function findPL(input_selected, profit_loss_class) {
	        if (profit_loss_class.indexOf(input_selected) > -1 || input_selected === 'all') {
	            return true;
	        }
	        return false;
	    };

	    var findAction = function findAction(input_action, action) {
	        if (action.toLowerCase() === input_action || input_action === 'all') {
	            return true;
	        }
	        return false;
	    };

	    var loadStatementChunkWhenScroll = function loadStatementChunkWhenScroll() {
	        $(document).scroll(function () {
	            var hidableHeight = function hidableHeight(percentage) {
	                var total_hideable = $(document).height() - $(window).height();
	                return Math.floor(total_hideable * percentage / 100);
	            };

	            var p_from_top = $(document).scrollTop();

	            if (!tableExist() || p_from_top < hidableHeight(70)) return;

	            if (finishedConsumed() && !no_more_data && !pending) {
	                getNextBatchStatement();
	                return;
	            }

	            if (!finishedConsumed()) StatementUI.updateStatementTable(getNextChunkStatement());
	            filterTable();
	        });
	    };

	    var onUnload = function onUnload() {
	        pending = false;
	        no_more_data = false;

	        current_batch = [];

	        transactions_received = 0;
	        transactions_consumed = 0;

	        StatementUI.errorMessage(null);
	        StatementUI.clearTableContent();
	    };

	    var initPage = function initPage() {
	        batch_size = 20;
	        chunk_size = batch_size / 2;
	        no_more_data = false;
	        pending = false; // serve as a lock to prevent ws request is sequential
	        current_batch = [];
	        transactions_received = 0;
	        transactions_consumed = 0;

	        BinarySocket.send({ oauth_apps: 1 }).then(function (response) {
	            addTooltip(StatementUI.setOauthApps(buildOauthApps(response)));
	            $('.barspinner').setVisibility(0);
	        });
	        getNextBatchStatement();
	        loadStatementChunkWhenScroll();
	    };

	    var attachDatePicker = function attachDatePicker() {
	        var jump_to = '#jump-to';
	        $(jump_to).attr('data-value', toISOFormat(moment())).change(function () {
	            if (!dateValueChanged(this, 'date')) {
	                return false;
	            }
	            $('.table-container').remove();
	            StatementUI.clearTableContent();
	            initPage();
	            return true;
	        });
	        DatePicker.init({
	            selector: jump_to,
	            maxDate: 0
	        });
	        if ($(jump_to).attr('data-picker') !== 'native') $(jump_to).val(localize('Today'));
	    };

	    var onLoad = function onLoad() {
	        initPage();
	        attachDatePicker();
	        ViewPopup.viewOnClick('#statement-container');
	    };

	    return {
	        init: initPage,
	        statementHandler: statementHandler,
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = StatementInit;

/***/ },
/* 569 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Statement = __webpack_require__(570);
	var Client = __webpack_require__(420);
	var downloadCSV = __webpack_require__(417).downloadCSV;
	var localize = __webpack_require__(428).localize;
	var toJapanTimeIfNeeded = __webpack_require__(463).toJapanTimeIfNeeded;
	var jpClient = __webpack_require__(425).jpClient;
	var showTooltip = __webpack_require__(513).showTooltip;
	var Table = __webpack_require__(516);

	var StatementUI = function () {
	    'use strict';

	    var all_data = [],
	        oauth_apps = {};

	    var table_id = 'statement-table';
	    var columns = ['date', 'ref', 'payout', 'act', 'desc', 'credit', 'bal'];

	    var createEmptyStatementTable = function createEmptyStatementTable() {
	        var header = [localize('Date'), localize('Ref.'), localize('Potential Payout'), localize('Action'), localize('Description'), localize('Credit/Debit'), localize('Balance')];

	        var jp_client = jpClient();
	        var currency = Client.get('currency');

	        header[6] += jp_client || !currency ? '' : ' (' + currency + ')';

	        var metadata = {
	            id: table_id,
	            cols: columns
	        };
	        var data = [];
	        return Table.createFlexTable(data, metadata, header);
	    };

	    var clearTableContent = function clearTableContent() {
	        Table.clearTableBody(table_id);
	        all_data = [];
	        $('#' + table_id + ' > tfoot').hide();
	    };

	    var createStatementRow = function createStatementRow(transaction) {
	        var statement_data = Statement.getStatementData(transaction, Client.get('currency'), jpClient());
	        all_data.push($.extend({}, statement_data, {
	            action: localize(statement_data.action),
	            desc: localize(statement_data.desc)
	        }));
	        var credit_debit_type = parseFloat(transaction.amount) >= 0 ? 'profit' : 'loss';

	        var $statement_row = Table.createFlexTableRow([statement_data.date, '<span ' + showTooltip(statement_data.app_id, oauth_apps[statement_data.app_id]) + '>' + statement_data.ref + '</span>', statement_data.payout, localize(statement_data.action), '', statement_data.amount, statement_data.balance], columns, 'data');
	        var class_name = 'open_contract_details';
	        if (statement_data.action === 'Deposit') {
	            class_name = 'deposit_details';
	        }
	        $statement_row.attr('class', class_name);
	        $statement_row.attr('contract_id', statement_data.id);

	        $statement_row.children('.credit').addClass(credit_debit_type);
	        $statement_row.children('.date').addClass('pre');
	        $statement_row.children('.desc').html(localize(statement_data.desc) + '<br>');

	        $statement_row.hover(function () {
	            var class_row = $(this).children('.act').html();
	            if (class_row === 'Buy' || class_row === 'Sell') {
	                $(this).css('background-color', '#E98024');
	                $(this).css('cursor', 'pointer');
	            }
	        }, function () {
	            $(this).css('background-color', 'white');
	            $(this).css('cursor', 'auto');
	        });

	        return $statement_row[0]; // return DOM instead of jquery object
	    };

	    var updateStatementTable = function updateStatementTable(transactions) {
	        Table.appendTableBody(table_id, transactions, createStatementRow);
	    };

	    var errorMessage = function errorMessage(msg) {
	        var $err = $('#statement-container').find('#error-msg');
	        if (msg) {
	            $err.setVisibility(1).text(msg);
	        } else {
	            $err.setVisibility(0).text('');
	        }
	    };

	    var exportCSV = function exportCSV() {
	        downloadCSV(Statement.generateCSV(all_data, jpClient()), 'Statement_' + Client.get('loginid') + '_latest' + $('#rows_count').text() + '_' + toJapanTimeIfNeeded(window.time).replace(/\s/g, '_').replace(/:/g, '') + '.csv');
	    };

	    return {
	        clearTableContent: clearTableContent,
	        createEmptyStatementTable: createEmptyStatementTable,
	        updateStatementTable: updateStatementTable,
	        errorMessage: errorMessage,
	        exportCSV: exportCSV,
	        setOauthApps: function setOauthApps(values) {
	            return oauth_apps = values;
	        }
	    };
	}();

	module.exports = StatementUI;

/***/ },
/* 570 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var toJapanTimeIfNeeded = __webpack_require__(463).toJapanTimeIfNeeded;
	var formatMoney = __webpack_require__(433).formatMoney;
	var toTitleCase = __webpack_require__(449).toTitleCase;

	var Statement = function () {
	    'use strict';

	    var getStatementData = function getStatementData(statement, currency, jp_client) {
	        var date_obj = new Date(statement.transaction_time * 1000);
	        var moment_obj = moment.utc(date_obj);
	        var date_str = moment_obj.format('YYYY-MM-DD');
	        var time_str = moment_obj.format('HH:mm:ss') + ' GMT';
	        var payout = parseFloat(statement.payout);
	        var amount = parseFloat(statement.amount);
	        var balance = parseFloat(statement.balance_after);

	        return {
	            date: jp_client ? toJapanTimeIfNeeded(statement.transaction_time) : date_str + '\n' + time_str,
	            ref: statement.transaction_id,
	            payout: isNaN(payout) ? '-' : formatMoney(currency, payout, !jp_client),
	            action: toTitleCase(statement.action_type),
	            amount: isNaN(amount) ? '-' : formatMoney(currency, amount, !jp_client),
	            balance: isNaN(balance) ? '-' : formatMoney(currency, balance, !jp_client),
	            desc: statement.longcode.replace(/\n/g, '<br />'),
	            id: statement.contract_id,
	            app_id: statement.app_id
	        };
	    };

	    var generateCSV = function generateCSV(all_data, jp_client) {
	        var columns = ['date', 'ref', 'payout', 'action', 'desc', 'amount', 'balance'];
	        var header = ['Date', 'Reference ID', 'Potential Payout', 'Action', 'Description', 'Credit/Debit'].map(function (str) {
	            return localize(str);
	        });
	        var currency = Client.get('currency');
	        header.push(localize('Balance') + (jp_client || !currency ? '' : ' (' + currency + ')'));
	        var sep = ',';
	        var csv = [header.join(sep)];
	        if (all_data && all_data.length > 0) {
	            // eslint-disable-next-line no-control-regex
	            csv = csv.concat(all_data.map(function (data) {
	                return columns.map(function (key) {
	                    return data[key] ? data[key].replace(new RegExp(sep, 'g'), '').replace(new RegExp('\n|<br />', 'g'), ' ') : '';
	                }).join(sep);
	            }));
	        }
	        return csv.join('\r\n');
	    };

	    return {
	        getStatementData: getStatementData,
	        generateCSV: generateCSV
	    };
	}();

	module.exports = Statement;

/***/ },
/* 571 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;

	var TopUpVirtual = function () {
	    'use strict';

	    var $views = void 0;

	    var view_ids = {
	        error: '#viewError',
	        success: '#viewSuccess'
	    };

	    var onLoad = function onLoad() {
	        $views = $('#topup_virtual .viewItem');
	        $views.setVisibility(0);

	        BinarySocket.send({ topup_virtual: '1' }).then(function (response) {
	            if (response.error) {
	                showMessage(localize(response.error.message), false);
	            } else {
	                showMessage(localize('[_1] [_2] has been credited to your Virtual money account [_3]', [response.topup_virtual.currency, response.topup_virtual.amount, Client.get('loginid')]), true);
	            }
	            $('.barspinner').setVisibility(0);
	        });
	    };

	    var showMessage = function showMessage(message, is_success) {
	        var view_id = is_success ? view_ids.success : view_ids.error;
	        setActiveView(view_id);
	        $(view_id + ' > p').html(message);
	    };

	    var setActiveView = function setActiveView(view_id) {
	        $views.setVisibility(0);
	        $(view_id).setVisibility(1);
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = TopUpVirtual;

/***/ },
/* 572 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinaryPjax = __webpack_require__(467);
	var localize = __webpack_require__(428).localize;
	var FormManager = __webpack_require__(483);

	var LostPassword = function () {
	    'use strict';

	    var responseHandler = function responseHandler(response) {
	        if (response.verify_email) {
	            BinaryPjax.load('user/reset_passwordws');
	        } else if (response.error) {
	            $('#form_error').setVisibility(1).text(localize(response.error.message));
	        }
	    };

	    var onLoad = function onLoad() {
	        var form_id = '#frm_lost_password';
	        FormManager.init(form_id, [{ selector: '#email', validations: ['req', 'email'], request_field: 'verify_email' }, { request_field: 'type', value: 'reset_password' }]);
	        FormManager.handleSubmit({
	            form_selector: form_id,
	            fnc_response_handler: responseHandler
	        });
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = LostPassword;

/***/ },
/* 573 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var BinarySocket = __webpack_require__(427);
	var BinaryPjax = __webpack_require__(467);
	var Client = __webpack_require__(420);
	var State = __webpack_require__(421).State;
	var defaultRedirectUrl = __webpack_require__(423).defaultRedirectUrl;
	var isEmptyObject = __webpack_require__(417).isEmptyObject;
	var AccountOpening = __webpack_require__(574);
	var FormManager = __webpack_require__(483);
	var toISOFormat = __webpack_require__(449).toISOFormat;

	var FinancialAccOpening = function () {
	    'use strict';

	    var form_id = '#financial-form';

	    var onLoad = function onLoad() {
	        State.set('is_financial_opening', 1);
	        if (Client.get('has_financial') || !Client.get('residence')) {
	            BinaryPjax.load('trading');
	            return;
	        } else if (Client.get('has_gaming')) {
	            $('.security').hide();
	        }

	        BinarySocket.wait('landing_company').then(function (response) {
	            var landing_company = response.landing_company;
	            if (Client.get('is_virtual')) {
	                if (Client.canUpgradeVirtualToJapan(landing_company)) {
	                    BinaryPjax.load('new_account/japanws');
	                } else if (!Client.canUpgradeVirtualToFinancial(landing_company)) {
	                    BinaryPjax.load('new_account/realws');
	                }
	            } else if (!Client.canUpgradeGamingToFinancial(landing_company)) {
	                BinaryPjax.load(defaultRedirectUrl());
	            }
	        });

	        if (AccountOpening.redirectAccount()) return;
	        AccountOpening.populateForm(form_id, getValidations);

	        BinarySocket.send({ get_financial_assessment: 1 }).then(function (response) {
	            if (!isEmptyObject(response.get_financial_assessment)) {
	                var keys = Object.keys(response.get_financial_assessment);
	                keys.forEach(function (key) {
	                    var val = response.get_financial_assessment[key];
	                    $('#' + key).val(val);
	                });
	            }
	        });

	        BinarySocket.wait('get_settings').then(function (response) {
	            var get_settings = response.get_settings;
	            var $element = void 0,
	                value = void 0;
	            Object.keys(get_settings).forEach(function (key) {
	                $element = $('#' + key);
	                value = get_settings[key];
	                if (key === 'date_of_birth') {
	                    var moment_val = moment.utc(value * 1000);
	                    value = moment_val.format('DD MMM, YYYY');
	                    $element.attr('data-value', toISOFormat(moment_val));
	                    $('.input-disabled').attr('disabled', 'disabled');
	                }
	                if (value) $element.val(value);
	            });
	        });

	        FormManager.handleSubmit({
	            form_selector: form_id,
	            obj_request: { new_account_maltainvest: 1, accept_risk: 0 },
	            fnc_response_handler: handleResponse
	        });
	    };

	    var getValidations = function getValidations() {
	        return AccountOpening.commonValidations().concat(AccountOpening.selectCheckboxValidation(form_id), [{ selector: '#tax_identification_number', validations: ['req', 'postcode', ['length', { min: 1, max: 20 }]] }]);
	    };

	    var handleResponse = function handleResponse(response) {
	        if ('error' in response && response.error.code === 'show risk disclaimer') {
	            $('#financial-form').setVisibility(0);
	            var $financial_risk = $('#financial-risk');
	            $financial_risk.setVisibility(1);
	            $.scrollTo($financial_risk, 500, { offset: -10 });

	            var risk_form_id = '#financial-risk';
	            FormManager.init(risk_form_id, []);

	            var echo_req = $.extend({}, response.echo_req);
	            echo_req.accept_risk = 1;
	            FormManager.handleSubmit({
	                form_selector: risk_form_id,
	                obj_request: echo_req,
	                fnc_response_handler: handleResponse
	            });
	        } else {
	            AccountOpening.handleNewAccount(response, response.msg_type);
	        }
	    };

	    var onUnload = function onUnload() {
	        State.set('is_financial_opening', 0);
	    };

	    return {
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = FinancialAccOpening;

/***/ },
/* 574 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var generateBirthDate = __webpack_require__(575);
	var BinaryPjax = __webpack_require__(467);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var State = __webpack_require__(421).State;
	var makeOption = __webpack_require__(430).makeOption;
	var FormManager = __webpack_require__(483);
	var BinarySocket = __webpack_require__(427);
	var Cookies = __webpack_require__(422);
	__webpack_require__(567);

	var AccountOpening = function () {
	    'use strict';

	    var redirectCookie = function redirectCookie() {
	        if (Client.get('has_real')) {
	            BinaryPjax.load('trading');
	            return true;
	        }
	        return false;
	    };

	    var redirectAccount = function redirectAccount() {
	        BinarySocket.wait('landing_company').then(function (response) {
	            var is_virtual = Client.get('is_virtual');
	            var landing_company = response.landing_company;

	            // redirect client to correct account opening page if needed
	            if (!State.get('is_financial_opening') && (!is_virtual && Client.canUpgradeGamingToFinancial(landing_company) || Client.canUpgradeVirtualToFinancial(landing_company))) {
	                BinaryPjax.load('new_account/maltainvestws');
	                return false;
	            }
	            if (!State.get('is_japan_opening') && is_virtual && Client.canUpgradeVirtualToJapan(landing_company)) {
	                BinaryPjax.load('new_account/japanws');
	                return false;
	            }
	            return true;
	        });
	    };

	    var populateForm = function populateForm(form_id, getValidations) {
	        getResidence();
	        BinarySocket.send({ states_list: Client.get('residence') }).then(function (data) {
	            return handleState(data.states_list, form_id, getValidations);
	        });
	        generateBirthDate();
	    };

	    var getResidence = function getResidence() {
	        BinarySocket.send({ residence_list: 1 }).then(function (response) {
	            return handleResidenceList(response.residence_list);
	        });
	    };

	    var handleResidenceList = function handleResidenceList(residence_list) {
	        if (residence_list.length > 0) {
	            var $place_of_birth = $('#place_of_birth');
	            var $tax_residence = $('#tax_residence');
	            var $phone = $('#phone');
	            var residence_value = Client.get('residence') || '';
	            var residence_text = '';

	            var $options = $('<div/>');
	            residence_list.forEach(function (res) {
	                $options.append(makeOption(res.text, res.value));

	                if (residence_value === res.value) {
	                    residence_text = res.text;
	                    if (residence_value !== 'jp' && res.phone_idd && !$phone.val()) {
	                        $phone.val('+' + res.phone_idd);
	                    }
	                }
	            });

	            $('#lbl_residence').html($('<strong/>', { text: residence_text }));
	            $place_of_birth.html($options.html()).val(residence_value);
	            if ($tax_residence) {
	                $tax_residence.html($options.html()).promise().done(function () {
	                    setTimeout(function () {
	                        $tax_residence.select2().val(getTaxResidence() || residence_value).trigger('change').setVisibility(1);
	                    }, 500);
	                });
	            }
	        }
	    };

	    var getTaxResidence = function getTaxResidence() {
	        var tax_residence = State.get(['response', 'get_settings', 'get_settings'] || {}).tax_residence;
	        return tax_residence ? tax_residence.split(',') : '';
	    };

	    var handleState = function handleState(states_list, form_id, getValidations) {
	        var address_state_id = '#address_state';
	        BinarySocket.wait('get_settings').then(function (response) {
	            var $address_state = $(address_state_id);

	            $address_state.empty();

	            var client_state = response.get_settings.address_state;

	            if (states_list && states_list.length > 0) {
	                $address_state.append($('<option/>', { value: '', text: localize('Please select') }));
	                states_list.forEach(function (state) {
	                    $address_state.append($('<option/>', { value: state.value, text: state.text }));
	                });
	                if (client_state) {
	                    $address_state.val(client_state);
	                }
	            } else {
	                $address_state.replaceWith($('<input/>', { id: 'address_state', name: 'address_state', type: 'text', maxlength: '35' }));
	                $address_state = $(address_state_id);
	                if (client_state) {
	                    $address_state.text(client_state);
	                }
	            }
	            $address_state.parent().parent().setVisibility(1);

	            if (form_id && typeof getValidations === 'function') {
	                FormManager.init(form_id, getValidations());
	            }
	        });
	    };

	    var handleNewAccount = function handleNewAccount(response, message_type) {
	        if (response.error) {
	            var errorMessage = response.error.message;
	            $('#submit-message').empty();
	            $('#client_message').find('.notice-msg').text(response.msg_type === 'sanity_check' ? localize('There was some invalid character in an input field.') : errorMessage).end().setVisibility(1);
	        } else {
	            Client.processNewAccount(Client.get('email'), response[message_type].client_id, response[message_type].oauth_token, false);
	        }
	    };

	    var commonValidations = function commonValidations() {
	        var req = [{ selector: '#salutation', validations: ['req'] }, { selector: '#first_name', validations: ['req', 'letter_symbol', ['length', { min: 2, max: 30 }]] }, { selector: '#last_name', validations: ['req', 'letter_symbol', ['length', { min: 2, max: 30 }]] }, { selector: '#date_of_birth', validations: ['req'] }, { selector: '#address_line_1', validations: ['req', 'address', ['length', { min: 1, max: 70 }]] }, { selector: '#address_line_2', validations: ['address', ['length', { min: 0, max: 70 }]] }, { selector: '#address_city', validations: ['req', 'letter_symbol', ['length', { min: 1, max: 35 }]] }, { selector: '#address_state', validations: $('#address_state').prop('nodeName') === 'SELECT' ? '' : ['general', ['length', { min: 0, max: 35 }]] }, { selector: '#address_postcode', validations: [Client.get('residence') === 'gb' ? 'req' : '', 'postcode', ['length', { min: 0, max: 20 }]] }, { selector: '#phone', validations: ['req', 'phone', ['length', { min: 6, max: 35 }]] }, { selector: '#secret_question', validations: ['req'] }, { selector: '#secret_answer', validations: ['req', 'general', ['length', { min: 4, max: 50 }]] }, { selector: '#tnc', validations: [['req', { message: 'Please accept the terms and conditions.' }]], exclude_request: 1 }, { request_field: 'residence', value: Client.get('residence') }];

	        if (Cookies.get('affiliate_tracking')) {
	            req.push({ request_field: 'affiliate_token', value: Cookies.getJSON('affiliate_tracking').t });
	        }

	        return req;
	    };

	    var selectCheckboxValidation = function selectCheckboxValidation(form_id) {
	        var validations = [];
	        var validation = void 0,
	            id = void 0;
	        $(form_id).find('select, input[type=checkbox]').each(function () {
	            id = $(this).attr('id');
	            if (!/^(tnc|address_state)$/.test(id)) {
	                validation = { selector: '#' + id, validations: ['req'] };
	                if (id === 'not_pep') {
	                    validation.exclude_request = 1;
	                }
	                validations.push(validation);
	            }
	        });
	        return validations;
	    };

	    return {
	        redirectAccount: redirectAccount,
	        populateForm: populateForm,
	        redirectCookie: redirectCookie,
	        handleNewAccount: handleNewAccount,

	        commonValidations: commonValidations,
	        selectCheckboxValidation: selectCheckboxValidation
	    };
	}();

	module.exports = AccountOpening;

/***/ },
/* 575 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var dateValueChanged = __webpack_require__(430).dateValueChanged;
	var toISOFormat = __webpack_require__(449).toISOFormat;
	var DatePicker = __webpack_require__(519);

	var generateBirthDate = function generateBirthDate() {
	    var date_of_birth = '#date_of_birth';
	    DatePicker.init({
	        selector: date_of_birth,
	        minDate: -100 * 365,
	        maxDate: -18 * 365 - 5,
	        yearRange: '-100:-18'
	    });
	    $(date_of_birth).attr('data-value', toISOFormat(moment())).change(function () {
	        return dateValueChanged(this, 'date');
	    }).val('');
	};

	module.exports = generateBirthDate;

/***/ },
/* 576 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var BinaryPjax = __webpack_require__(467);
	var Client = __webpack_require__(420);
	var State = __webpack_require__(421).State;
	var AccountOpening = __webpack_require__(574);
	var detectHedging = __webpack_require__(430).detectHedging;
	var FormManager = __webpack_require__(483);

	var JapanAccOpening = function () {
	    'use strict';

	    var onLoad = function onLoad() {
	        if (AccountOpening.redirectCookie()) return;
	        BinarySocket.wait('authorize').then(function () {
	            if (Client.get('residence') !== 'jp') {
	                BinaryPjax.load('trading');
	                return;
	            }
	            State.set('is_japan_opening', 1);
	            if (AccountOpening.redirectAccount()) return;
	            AccountOpening.populateForm();
	            var form_id = '#japan-form';

	            FormManager.init(form_id, [{ selector: '#first_name', validations: ['req', 'letter_symbol'] }, { selector: '#last_name', validations: ['req', 'letter_symbol'] }, { selector: '#date_of_birth', validations: ['req'] }, { selector: '#address_line_1', validations: ['req', 'address'] }, { selector: '#address_line_2', validations: ['address'] }, { selector: '#address_city', validations: ['req', 'letter_symbol'] }, { selector: '#address_state', validations: ['req'] }, { selector: '#address_postcode', validations: ['req', ['regular', { regex: /^\d{3}-\d{4}$/, message: 'Please follow the pattern 3 numbers, a dash, followed by 4 numbers.' }]] }, { selector: '#phone', validations: ['req', ['regular', { regex: /^\+?[0-9\s-]+$/, message: 'Only numbers, space, and hyphen are allowed.' }], ['min', { min: 6, max: 35 }]] }, { selector: '#secret_answer', validations: ['req', ['min', { min: 1, max: 50 }]] }, { selector: '#daily_loss_limit', validations: ['req', 'number'] }, { selector: '#hedge_asset_amount', validations: ['req', 'number'] }, { request_field: 'residence', value: Client.get('residence') }, { request_field: 'new_account_japan', value: 1 }].concat(AccountOpening.selectCheckboxValidation(form_id)));

	            detectHedging($('#trading_purpose'), $('.hedging-assets'));

	            FormManager.handleSubmit({
	                form_selector: form_id,
	                fnc_response_handler: handleResponse
	            });
	        });
	    };

	    var handleResponse = function handleResponse(response) {
	        if ('error' in response) {
	            AccountOpening.handleNewAccount(response, response.msg_type);
	        } else {
	            BinaryPjax.load('new_account/knowledge_testws');
	            $('#topbar-msg').children('a').setVisibility(0);
	        }
	    };

	    var onUnload = function onUnload() {
	        State.set('is_japan_opening', 0);
	    };

	    return {
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = JapanAccOpening;

/***/ },
/* 577 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinaryPjax = __webpack_require__(467);
	var Client = __webpack_require__(420);
	var AccountOpening = __webpack_require__(574);
	var FormManager = __webpack_require__(483);

	var RealAccOpening = function () {
	    'use strict';

	    var onLoad = function onLoad() {
	        if (AccountOpening.redirectCookie()) return;

	        if (Client.get('residence')) {
	            if (AccountOpening.redirectAccount()) return;

	            var form_id = '#frm_real';
	            AccountOpening.populateForm(form_id, function () {
	                return AccountOpening.commonValidations().concat(AccountOpening.selectCheckboxValidation(form_id));
	            });
	            FormManager.handleSubmit({
	                form_selector: form_id,
	                obj_request: { new_account_real: 1 },
	                fnc_response_handler: handleResponse
	            });
	        } else {
	            BinaryPjax.load('trading');
	        }
	    };

	    var handleResponse = function handleResponse(response) {
	        return AccountOpening.handleNewAccount(response, response.msg_type);
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = RealAccOpening;

/***/ },
/* 578 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;
	var urlFor = __webpack_require__(423).urlFor;
	var makeOption = __webpack_require__(430).makeOption;
	var jpClient = __webpack_require__(425).jpClient;
	var FormManager = __webpack_require__(483);
	var TrafficSource = __webpack_require__(579);
	var Cookies = __webpack_require__(422);

	var VirtualAccOpening = function () {
	    'use strict';

	    var form = '#virtual-form';

	    var onLoad = function onLoad() {
	        if (jpClient()) {
	            handleJPForm();
	        } else {
	            BinarySocket.send({ residence_list: 1 }).then(function (response) {
	                return handleResidenceList(response.residence_list);
	            });
	            $('#residence').setVisibility(1);
	            bindValidation();
	        }

	        FormManager.handleSubmit({
	            form_selector: form,
	            fnc_response_handler: handleNewAccount
	        });
	    };

	    var handleResidenceList = function handleResidenceList(residence_list) {
	        if (residence_list.length > 0) {
	            var $residence = $('#residence');
	            var residence_value = Client.get('residence') || '';

	            var $options_with_disabled = $('<div/>');
	            residence_list.forEach(function (res) {
	                $options_with_disabled.append(makeOption(res.text, res.value, res.disabled));
	            });
	            $residence.html($options_with_disabled.html());

	            if (!residence_value) {
	                BinarySocket.wait('website_status').then(function (data) {
	                    return handleWebsiteStatus(data.website_status);
	                });
	            }
	        }
	    };

	    var handleWebsiteStatus = function handleWebsiteStatus(website_status) {
	        var clients_country = (website_status || {}).clients_country;
	        if (!clients_country) return;
	        var $residence = $('#residence');

	        // set residence value to client's country, detected by IP address from back-end
	        var $clients_country = $residence.find('option[value="' + clients_country + '"]');
	        if (!$clients_country.attr('disabled')) {
	            $clients_country.prop('selected', true);
	        }
	        $residence.setVisibility(1);
	    };

	    var bindValidation = function bindValidation() {
	        // Add TrafficSource parameters
	        var utm_data = TrafficSource.getData();

	        var req = [{ selector: '#verification_code', validations: ['req', 'email_token'] }, { selector: '#client_password', validations: ['req', 'password'], re_check_field: '#repeat_password' }, { selector: '#repeat_password', validations: ['req', ['compare', { to: '#client_password' }]], exclude_request: 1 }, { selector: '#residence' }, { selector: '#email_consent' }, { request_field: 'utm_source', value: TrafficSource.getSource(utm_data) }, { request_field: 'new_account_virtual', value: 1 }];

	        if (utm_data.utm_medium) req.push({ request_field: 'utm_medium', value: utm_data.utm_medium });
	        if (utm_data.utm_campaign) req.push({ request_field: 'utm_campaign', value: utm_data.utm_campaign });

	        var gclid = Client.get('gclid');
	        if (gclid) req.push({ request_field: 'gclid_url', value: gclid });

	        if (Cookies.get('affiliate_tracking')) req.push({ request_field: 'affiliate_token', value: Cookies.getJSON('affiliate_tracking').t });

	        FormManager.init(form, req);
	    };

	    var handleJPForm = function handleJPForm() {
	        // show email consent field for japanese accounts
	        // and don't allow them to change residence
	        var $residence = $('#residence');
	        $residence.replaceWith($('<label/>', { id: 'residence', 'data-value': 'jp', text: localize('Japan') }));
	        $('#email_consent').parent().parent().setVisibility(1);
	        bindValidation();
	    };

	    var handleNewAccount = function handleNewAccount(response) {
	        if (!response) return false;
	        var error = response.error;
	        if (!error) {
	            var new_account = response.new_account_virtual;
	            Client.setCookie('residence', response.echo_req.residence);
	            return Client.processNewAccount(new_account.email, new_account.client_id, new_account.oauth_token, true);
	        }

	        switch (error.code) {
	            case 'InvalidToken':
	                {
	                    var message = 'Your token has expired. Please click <a href="[_1]">here</a> to restart the verification process.';
	                    return showFormError(message, '');
	                }
	            case 'duplicate email':
	                {
	                    var _message = 'The email address provided is already in use. If you forgot your password, please try our <a href="[_1]">password recovery tool</a> or contact our customer service.';
	                    return showFormError(_message, 'user/lost_passwordws');
	                }
	            case 'PasswordError':
	                {
	                    return showError('Password is not strong enough.');
	                }
	            default:
	                {
	                    return showError(error.message);
	                }
	        }
	    };

	    var showFormError = function showFormError(message, url) {
	        $('.notice-message').remove();
	        $('#virtual-form').html($('<p/>', { html: localize(message, [urlFor(url)]) }));
	    };

	    var showError = function showError(message) {
	        $('#error-account-opening').setVisibility(1).text(localize(message));
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = VirtualAccOpening;

/***/ },
/* 579 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);
	var CookieStorage = __webpack_require__(421).CookieStorage;
	var Url = __webpack_require__(423);

	/*
	 * Handles utm parameters/referrer to use on signup
	 *
	 * Priorities:
	 * 1. Cookie having utm data (utm_source, utm_medium, utm_campaign) [Expires in 3 months]
	 * 2. Query string utm parameters
	 * 3. document.referrer
	 *
	 */

	var TrafficSource = function () {
	    'use strict';

	    var cookie = void 0;

	    var initCookie = function initCookie() {
	        if (!cookie) {
	            cookie = new CookieStorage('utm_data');
	            cookie.read();
	            // expiration date is used when writing cookie
	            var now = new Date();
	            cookie.expires = now.setMonth(now.getMonth() + 3);
	        }
	    };

	    var getData = function getData() {
	        initCookie();
	        var data = cookie.value;
	        Object.keys(data).map(function (key) {
	            data[key] = (data[key] || '').replace(/[^a-zA-Z0-9\s\-\.\_]/gi, '').substring(0, 100);
	        });
	        return data;
	    };

	    var getSource = function getSource(utm_data) {
	        if (!utm_data) utm_data = getData();
	        return utm_data.utm_source || utm_data.referrer || 'direct'; // in order of precedence
	    };

	    var setData = function setData() {
	        if (Client.isLoggedIn()) {
	            clearData();
	            return;
	        }

	        var current_values = getData();
	        var params = Url.paramsHash();
	        var param_keys = ['utm_source', 'utm_medium', 'utm_campaign'];

	        if (params.utm_source) {
	            // url params can be stored only if utm_source is available
	            param_keys.map(function (key) {
	                if (params[key] && !current_values[key]) {
	                    cookie.set(key, params[key]);
	                }
	            });
	        }

	        // Store gclid
	        if (params.gclid && !Client.isLoggedIn()) {
	            Client.set('gclid', params.gclid);
	        }

	        var doc_ref = document.referrer;
	        var referrer = localStorage.getItem('index_referrer') || doc_ref;
	        localStorage.removeItem('index_referrer');
	        if (doc_ref && !new RegExp(window.location.hostname, 'i').test(doc_ref)) {
	            referrer = doc_ref;
	        }
	        if (referrer && !current_values.referrer && !params.utm_source && !current_values.utm_source) {
	            cookie.set('referrer', Url.getLocation(referrer).hostname);
	        }
	    };

	    var clearData = function clearData() {
	        initCookie();
	        cookie.remove();
	    };

	    return {
	        getData: getData,
	        setData: setData,
	        clearData: clearData,
	        getSource: getSource
	    };
	}();

	module.exports = TrafficSource;

/***/ },
/* 580 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var localize = __webpack_require__(428).localize;
	var Login = __webpack_require__(465);
	var generateBirthDate = __webpack_require__(575);
	var FormManager = __webpack_require__(483);

	var ResetPassword = function () {
	    'use strict';

	    var responseHandler = function responseHandler(response) {
	        $('#container_reset_password').setVisibility(0);
	        if (response.error) {
	            var $form_error = $('#form_error');
	            var reset_error_template = '[_1] Please click the link below to restart the password recovery process. If you require further assistance, please contact our Customer Support.';
	            var error_code = response.error.code;

	            $('#msg_reset_password').setVisibility(0);

	            var err_msg = void 0;
	            if (error_code === 'SocialBased') {
	                err_msg = localize(response.error.message);
	                $form_error.find('a').setVisibility(0);
	            } else {
	                // special handling as backend return inconsistent format
	                err_msg = localize(reset_error_template, [error_code === 'InputValidationFailed' ? localize('There was some invalid character in an input field.') : localize(response.error.message)]);
	            }

	            $('#form_error_msg').text(err_msg);
	            $form_error.setVisibility(1);
	        } else {
	            $('#msg_reset_password').text(localize('Your password has been successfully reset. Please log into your account using your new password.'));
	            setTimeout(function () {
	                Login.redirectToLogin();
	            }, 5000);
	        }
	    };

	    var onLoad = function onLoad() {
	        generateBirthDate();

	        $('#have_real_account').off('click').on('click', function () {
	            if ($(this).is(':checked')) {
	                $('#dob_field').setVisibility(1);
	            } else {
	                $('#dob_field').setVisibility(0);
	            }
	        });

	        var form_id = '#frm_reset_password';
	        FormManager.init(form_id, [{ selector: '#verification_code', validations: ['req', 'email_token'] }, { selector: '#new_password', validations: ['req', 'password'], re_check_field: '#repeat_password' }, { selector: '#repeat_password', validations: ['req', ['compare', { to: '#new_password' }]], exclude_request: 1 }, { selector: '#date_of_birth', validations: ['req'] }, { request_field: 'reset_password', value: 1 }]);

	        FormManager.handleSubmit({
	            form_selector: form_id,
	            fnc_response_handler: responseHandler
	        });
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = ResetPassword;

/***/ },
/* 581 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var KnowledgeTestUI = __webpack_require__(582);
	var BinaryPjax = __webpack_require__(467);
	var toJapanTimeIfNeeded = __webpack_require__(463).toJapanTimeIfNeeded;
	var Header = __webpack_require__(494);
	var localize = __webpack_require__(428).localize;
	var Url = __webpack_require__(423);
	var BinarySocket = __webpack_require__(427);

	var KnowledgeTest = function () {
	    'use strict';

	    var submitted = {};
	    var submit_completed = false;
	    var random_picks = [];
	    var obj_random_picks = {};
	    var result_score = 0;

	    var msg_pass = '{JAPAN ONLY}Congratulations, you have pass the test, our Customer Support will contact you shortly.';
	    var msg_fail = '{JAPAN ONLY}Sorry, you have failed the test, please try again after 24 hours.';

	    var questionAnswerHandler = function questionAnswerHandler(ev) {
	        submitted[ev.target.name] = +ev.target.value === 1;
	    };

	    var submitHandler = function submitHandler() {
	        if (submit_completed) return;

	        var answered_qid = Object.keys(submitted).map(function (k) {
	            return +k;
	        });
	        if (answered_qid.length !== 20) {
	            $('#knowledge-test-instructions').setVisibility(0);
	            $('#knowledge-test-msg').addClass('notice-msg').text(localize('You need to finish all 20 questions.'));

	            var unanswered = random_picks.reduce(function (a, b) {
	                return a.concat(b);
	            }).find(function (q) {
	                return answered_qid.indexOf(q.id) === -1;
	            }).id;

	            $.scrollTo('a[name="' + unanswered + '"]', 500, { offset: -10 });
	            return;
	        }

	        // compute score
	        var questions = [];
	        Object.keys(submitted).forEach(function (k) {
	            var question_info = obj_random_picks[k];
	            var score = submitted[k] === question_info.correct_answer ? 1 : 0;
	            result_score += score;
	            question_info.answer = submitted[k];
	            questions.push({
	                category: question_info.category,
	                id: question_info.id,
	                question: question_info.question,
	                answer: question_info.answer ? 1 : 0,
	                pass: score
	            });
	        });
	        sendResult(questions);
	        submit_completed = true;
	    };

	    var showQuestionsTable = function showQuestionsTable() {
	        for (var j = 0; j < random_picks.length; j++) {
	            var table = KnowledgeTestUI.createQuestionTable(random_picks[j]);
	            $('#section' + (j + 1) + '-question').append(table);
	        }

	        var $questions = $('#knowledge-test-questions');
	        $questions.find('input[type=radio]').click(questionAnswerHandler);
	        $('#knowledge-test-submit').click(submitHandler);
	        $questions.setVisibility(1);
	        $('#knowledge-test-msg').text(localize('{JAPAN ONLY}Please complete the following questions.'));
	        $('#knowledge-test-instructions').setVisibility(1);
	    };

	    var showResult = function showResult(score, time) {
	        $('#knowledge-test-instructions').setVisibility(0);
	        $('#knowledge-test-header').text(localize('{JAPAN ONLY}Knowledge Test Result'));
	        var msg = score >= 14 ? msg_pass : msg_fail;
	        $('#knowledge-test-msg').text(localize(msg));

	        var $result_table = KnowledgeTestUI.createResultUI(score, time);

	        $('#knowledge-test-container').append($result_table);
	        $('#knowledge-test-questions').setVisibility(0);
	    };

	    var showMsgOnly = function showMsgOnly(msg) {
	        $('#knowledge-test-questions').setVisibility(0);
	        $('#knowledge-test-msg').text(localize(msg));
	        $('#knowledge-test-instructions').setVisibility(0);
	    };

	    var showDisallowedMsg = function showDisallowedMsg(jp_status) {
	        return showMsgOnly(localize('{JAPAN ONLY}Dear customer, you are not allowed to take knowledge test until [_1]. Last test taken at [_2].', [toJapanTimeIfNeeded(jp_status.next_test_epoch), toJapanTimeIfNeeded(jp_status.last_test_epoch)]));
	    };

	    var populateQuestions = function populateQuestions() {
	        random_picks = randomPick20();
	        random_picks.reduce(function (a, b) {
	            return a.concat(b);
	        }).forEach(function (question) {
	            obj_random_picks[question.id] = question;
	        });

	        showQuestionsTable();
	    };

	    var onLoad = function onLoad() {
	        // need to send get_settings because client status needs to be checked against latest available data
	        BinarySocket.send({ get_settings: 1 }, { forced: true }).then(function (response) {
	            var jp_status = response.get_settings.jp_account_status;

	            if (!jp_status) {
	                BinaryPjax.load(Url.defaultRedirectUrl());
	                return;
	            }

	            // show knowledge test link in header after updated get_settings call
	            Header.upgradeMessageVisibility();

	            switch (jp_status.status) {
	                case 'jp_knowledge_test_pending':
	                    populateQuestions();
	                    break;
	                case 'jp_knowledge_test_fail':
	                    {
	                        if (Date.now() >= jp_status.next_test_epoch * 1000) {
	                            // show Knowledge Test cannot be taken
	                            populateQuestions();
	                        } else {
	                            showDisallowedMsg(jp_status);
	                        }
	                        break;
	                    }
	                default:
	                    {
	                        window.location.href = Url.defaultRedirectUrl(); // needs to be loaded without pjax
	                    }
	            }
	        });
	    };

	    var answers = {
	        /* eslint-disable */
	        1: false, 2: true, 3: true, 4: true, 5: true, 6: true, 7: true, 8: true, 9: false, 10: true,
	        11: false, 12: true, 13: false, 14: true, 15: true, 16: true, 17: false, 18: true, 19: true, 20: true,
	        21: true, 22: false, 23: true, 24: false, 25: false, 26: true, 27: true, 28: true, 29: true, 30: true,
	        31: false, 32: true, 33: false, 34: true, 35: false, 36: true, 37: true, 38: false, 39: true, 40: false,
	        41: false, 42: true, 43: true, 44: true, 45: true, 46: true, 47: true, 48: false, 49: false, 50: true,
	        51: false, 52: true, 53: true, 54: false, 55: true, 56: true, 57: true, 58: true, 59: true, 60: true,
	        61: true, 62: false, 63: true, 64: true, 65: true, 66: false, 67: true, 68: true, 69: true, 70: true,
	        71: true, 72: true, 73: true, 74: false, 75: false, 76: true, 77: false, 78: true, 79: true, 80: true,
	        81: true, 82: true, 83: true, 84: true, 85: true, 86: true, 87: true, 88: false, 89: true, 90: true,
	        91: true, 92: true, 93: true, 94: true, 95: false, 96: true, 97: true, 98: false, 99: true, 100: true
	    };

	    var randomPick4 = function randomPick4(obj_questions) {
	        var availables = Object.keys(obj_questions);

	        var random_picks_four = [];
	        for (var i = 0; i < 4; i++) {
	            var random_index = Math.floor(Math.random() * 100) % availables.length;
	            random_picks_four.push(obj_questions[availables[random_index]]);
	            availables.splice(random_index, 1);
	        }

	        return random_picks_four;
	    };

	    var randomPick20 = function randomPick20() {
	        var questions = {};
	        // retrieve questions text from html
	        $('#data-questions').find('> div').each(function () {
	            // sections
	            var category = +$(this).attr('data-section-id');
	            questions['section' + category] = [];

	            $(this).find('> div').each(function () {
	                // questions
	                var question_id = +$(this).attr('data-question-id');
	                questions['section' + category].push({
	                    category: category,
	                    id: question_id,
	                    question: $(this).attr('data-question-en'),
	                    question_localized: $(this).text(),
	                    correct_answer: answers[question_id],
	                    tooltip: $(this).attr('data-tip')
	                });
	            });
	        });

	        var picked_questions = [];
	        Object.keys(questions).forEach(function (section) {
	            return picked_questions.push(randomPick4(questions[section]));
	        });
	        return picked_questions;
	    };

	    var sendResult = function sendResult(questions) {
	        BinarySocket.send({
	            jp_knowledge_test: 1,
	            score: result_score,
	            status: result_score >= 14 ? 'pass' : 'fail',
	            questions: questions
	        }).then(function (response) {
	            if (!response.error) {
	                showResult(result_score, response.jp_knowledge_test.test_taken_epoch * 1000);
	                $('html, body').animate({ scrollTop: 0 }, 'slow');
	                BinarySocket.send({ get_settings: 1 }, { forced: true }).then(function () {
	                    Header.upgradeMessageVisibility();
	                });
	            } else if (response.error.code === 'TestUnavailableNow') {
	                showMsgOnly('{JAPAN ONLY}The test is unavailable now, test can only be taken again on next business day with respect of most recent test.');
	            } else {
	                $('#form-msg').html(response.error.message).setVisibility(1);
	                submit_completed = false;
	            }
	        });
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = KnowledgeTest;

/***/ },
/* 582 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var localize = __webpack_require__(428).localize;
	var urlForStatic = __webpack_require__(423).urlForStatic;

	var KnowledgeTestUI = function () {
	    'use strict';

	    var createTrueFalseBox = function createTrueFalseBox(question, show_answer) {
	        var qid = question.id;
	        var true_id = qid + 'true';
	        var false_id = qid + 'false';

	        var $true_button = $('<input />', {
	            type: 'radio',
	            name: qid,
	            id: true_id,
	            value: '1'
	        });
	        var $true_td = $('<td></td>').append($true_button);

	        var $false_button = $('<input />', {
	            type: 'radio',
	            name: qid,
	            id: false_id,
	            value: '0'
	        });
	        var $false_td = $('<td></td>').append($false_button);

	        if (show_answer) {
	            if (question.correct_answer) {
	                $true_button.prop('checked', true);
	            } else {
	                $false_button.prop('checked', true);
	            }
	            $true_button.attr('disabled', true);
	            $false_button.attr('disabled', true);
	        }

	        return [$true_td, $false_td];
	    };

	    var createQuestionRow = function createQuestionRow(question_no, question, show_answer) {
	        var $question_row = $('<tr></tr>', { id: question_no, class: 'question' });
	        var $question_data = $('<td></td>').text(localize(question.question_localized));
	        var $question_link = $('<a></a>', {
	            name: question.id,
	            class: 'no-underline'
	        });
	        var $question_icon = $('<img>', { src: urlForStatic('/images/common/question_1.png'), class: 'invisible' });
	        $question_data.append($question_link.append($question_icon));

	        var true_false = createTrueFalseBox(question, show_answer);

	        return $question_row.append($question_data).append(true_false[0]).append(true_false[1]);
	    };

	    var createQuestionTable = function createQuestionTable(questions, show_answer) {
	        var $header = $('<tr></tr>');
	        var $question_col_header = $('<th></th>', { id: 'question-header', class: 'question-col' }).text(localize('Questions'));

	        var $true_col_header = $('<th></th>', { id: 'true-header', class: 'true-col' }).text(localize('True'));

	        var $false_col_header = $('<th></th>', { id: 'fasle-header', class: 'false-col' }).text(localize('False'));

	        $header.append($question_col_header).append($true_col_header).append($false_col_header);

	        var $table_container = $('<table></table>', { id: 'knowledge-test' });

	        $table_container.append($header);
	        var qr = void 0;
	        questions.forEach(function (question, question_no) {
	            qr = createQuestionRow(question_no, question, show_answer);
	            $table_container.append(qr);
	        });

	        return $table_container;
	    };

	    var createResultUI = function createResultUI(score) {
	        var $result_table = $('<table></table>', { class: 'kv-pairs' });
	        var $score_row = $('<tr/>').append($('<td/>', { text: localize('Score') })).append($('<td/>', { text: score }));

	        var date = moment();
	        var submit_date = '' + moment.utc(date).format('YYYY') + localize('Year') + moment.utc(date).format('MM') + localize('Month') + moment.utc(date).format('DD') + localize('Day') + ' (' + localize('Weekday') + ')';

	        var $date_row = $('<tr/>').append($('<td/>', { text: localize('Date') })).append($('<td/>', { text: submit_date }));

	        $result_table.append($score_row).append($date_row);

	        return $result_table;
	    };

	    return {
	        createQuestionTable: createQuestionTable,
	        createResultUI: createResultUI
	    };
	}();

	module.exports = KnowledgeTestUI;

/***/ },
/* 583 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);
	var Contents = __webpack_require__(584);
	var Header = __webpack_require__(494);
	var Language = __webpack_require__(424);
	var Localize = __webpack_require__(428);
	var localize = __webpack_require__(428).localize;
	var Login = __webpack_require__(465);
	var Menu = __webpack_require__(585);
	var LocalStore = __webpack_require__(421).LocalStore;
	var State = __webpack_require__(421).State;
	var Url = __webpack_require__(423);
	var checkLanguage = __webpack_require__(425).checkLanguage;
	var scrollToTop = __webpack_require__(491).scrollToTop;
	var TrafficSource = __webpack_require__(579);
	var BinarySocket = __webpack_require__(427);
	var RealityCheck = __webpack_require__(587);
	var AffiliatePopup = __webpack_require__(591);
	var Cookies = __webpack_require__(422);
	var PushNotification = __webpack_require__(592);
	__webpack_require__(589);
	__webpack_require__(590);

	var Page = function () {
	    'use strict';

	    var init = function init() {
	        State.set('is_loaded_by_pjax', false);
	        Url.init();
	        PushNotification.init();
	        onDocumentReady();
	    };

	    var onDocumentReady = function onDocumentReady() {
	        // LocalStorage can be used as a means of communication among
	        // different windows. The problem that is solved here is what
	        // happens if the user logs out or switches loginid in one
	        // window while keeping another window or tab open. This can
	        // lead to unintended trades. The solution is to reload the
	        // page in all windows after switching loginid or after logout.

	        // onLoad.queue does not work on the home page.
	        // jQuery's ready function works always.
	        $(document).ready(function () {
	            // Cookies is not always available.
	            // So, fall back to a more basic solution.
	            var match = document.cookie.match(/\bloginid=(\w+)/);
	            match = match ? match[1] : '';
	            $(window).on('storage', function (jq_event) {
	                switch (jq_event.originalEvent.key) {
	                    case 'active_loginid':
	                        if (jq_event.originalEvent.newValue === match) return;
	                        if (jq_event.originalEvent.newValue === '') {
	                            // logged out
	                            reload();
	                        } else if (!window.is_logging_in) {
	                            // loginid switch
	                            reload();
	                        }
	                        break;
	                    case 'new_release_reload_time':
	                        if (jq_event.originalEvent.newValue !== jq_event.originalEvent.oldValue) {
	                            reload(true);
	                        }
	                        break;
	                    // no default
	                }
	            });
	            scrollToTop();
	            LocalStore.set('active_loginid', match);
	        });
	    };

	    var onLoad = function onLoad() {
	        if (State.get('is_loaded_by_pjax')) {
	            Url.reset();
	        } else {
	            init();
	            Localize.forLang(Language.get());
	            Header.onLoad();
	            Language.setCookie();
	            Menu.makeMobileMenu();
	            recordAffiliateExposure();
	            endpointNotification();
	            showNotificationOutdatedBrowser();
	        }
	        Menu.init();
	        Contents.onLoad();
	        if (sessionStorage.getItem('showLoginPage')) {
	            sessionStorage.removeItem('showLoginPage');
	            Login.redirectToLogin();
	        }
	        if (Client.isLoggedIn()) {
	            BinarySocket.wait('authorize').then(function () {
	                checkLanguage();
	                RealityCheck.onLoad();
	            });
	        } else {
	            checkLanguage();
	        }
	        TrafficSource.setData();
	    };

	    var onUnload = function onUnload() {
	        Menu.onUnload();
	    };

	    var recordAffiliateExposure = function recordAffiliateExposure() {
	        var token = Url.param('t');
	        if (!token || token.length !== 32) {
	            return false;
	        }

	        AffiliatePopup.show();

	        var token_length = token.length;
	        var is_subsidiary = /\w{1}/.test(Url.param('s'));

	        var cookie_token = Cookies.getJSON('affiliate_tracking');
	        if (cookie_token) {
	            // Already exposed to some other affiliate.
	            if (is_subsidiary && cookie_token && cookie_token.t) {
	                return false;
	            }
	        }

	        // Record the affiliate exposure. Overwrite existing cookie, if any.
	        var cookie_hash = {};
	        if (token_length === 32) {
	            cookie_hash.t = token.toString();
	        }
	        if (is_subsidiary) {
	            cookie_hash.s = '1';
	        }

	        Cookies.set('affiliate_tracking', cookie_hash, {
	            expires: 365, // expires in 365 days
	            path: '/',
	            domain: '.' + location.hostname.split('.').slice(-2).join('.')
	        });
	        return true;
	    };

	    var reload = function reload(forced_reload) {
	        window.location.reload(!!forced_reload);
	    };

	    var endpointNotification = function endpointNotification() {
	        var server = localStorage.getItem('config.server_url');
	        if (server && server.length > 0) {
	            var message = (/www\.binary\.com/i.test(window.location.hostname) ? '' : localize('This is a staging server - For testing purposes only') + ' - ') + '\n                ' + localize('The server <a href="[_1]">endpoint</a> is: [_2]', [Url.urlFor('endpoint'), server]);
	            var $end_note = $('#end-note');
	            $end_note.html(message).setVisibility(1);
	            $('#footer').css('padding-bottom', $end_note.height());
	        }
	    };

	    var showNotificationOutdatedBrowser = function showNotificationOutdatedBrowser() {
	        var src = '//browser-update.org/update.min.js';
	        if ($('script[src*="' + src + '"]').length) return;
	        window.$buoop = {
	            vs: { i: 11, f: -4, o: -4, s: 9, c: -4 },
	            api: 4,
	            l: Language.get().toLowerCase(),
	            url: 'https://whatbrowser.org/',
	            noclose: true };
	        $(document).ready(function () {
	            $('body').append($('<script/>', { src: src }));
	        });
	    };

	    return {
	        onLoad: onLoad,
	        onUnload: onUnload
	    };
	}();

	module.exports = Page;

/***/ },
/* 584 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);

	var Contents = function () {
	    'use strict';

	    var onLoad = function onLoad() {
	        Client.activateByClientType('#header');
	        // This is required for our css to work.
	        $('#content').removeClass().addClass($('#content_class').text());
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = Contents;

/***/ },
/* 585 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);
	__webpack_require__(586);

	var Menu = function () {
	    'use strict';

	    var $main_menu = void 0;

	    var init = function init() {
	        $main_menu = $('#main-menu');

	        $('#menu-top').find('li').removeClass('active');
	        hideMainMenu();

	        var active = activeMenuTop();
	        if (active) active.addClass('active');

	        if (Client.isLoggedIn() || /\/(cashier|resources|trading|trading_beta|multi_barriers_trading)/i.test(window.location.pathname)) {
	            showMainMenu();
	        }
	    };

	    var showMainMenu = function showMainMenu() {
	        $main_menu.setVisibility(1);
	        activateMainMenu();
	    };

	    var hideMainMenu = function hideMainMenu() {
	        $main_menu.setVisibility(0);
	    };

	    var activateMainMenu = function activateMainMenu() {
	        // First unset everything.
	        $main_menu.find('li.item').removeClass('active hover').end().find('li.sub_item a').removeClass('a-active');

	        var active = activeMainMenu();
	        var active_item = active.item;
	        var active_subitem = active.subitem;
	        if (active_subitem) {
	            active_subitem.addClass('a-active');
	        }

	        if (active_item) {
	            active_item.addClass('active hover');
	            onMouseHover(active_item);
	        }
	    };

	    var onUnload = function onUnload() {
	        $main_menu.unbind().find('.item').unbind();
	    };

	    var removeHover = function removeHover() {
	        $main_menu.find('li.item').removeClass('hover');
	    };

	    var onMouseHover = function onMouseHover(active_item) {
	        $main_menu.on('mouseleave', function () {
	            removeHover();
	            if (active_item) active_item.addClass('hover');
	        }).find('.item').on('mouseenter', function () {
	            removeHover();
	            $(this).addClass('hover');
	        });
	    };

	    var activeMenuTop = function activeMenuTop() {
	        var active = '';
	        var path = window.location.pathname;
	        $('#menu-top').find('li a').each(function () {
	            if (path.indexOf(this.pathname.replace(/\.html/i, '')) >= 0) {
	                active = $(this).closest('li');
	            }
	        });
	        return active;
	    };

	    var activeMainMenu = function activeMainMenu() {
	        var pathname = window.location.pathname;
	        if (/cashier/i.test(pathname) && !/(cashier_password|payment_methods)/.test(pathname)) {
	            pathname = $('#topMenuCashier').find('a').attr('href');
	        }
	        var $item = void 0,
	            $subitem = void 0;
	        // Is something selected in main items list
	        $item = $main_menu.find('a[href*="' + pathname + '"]');
	        var $parent = $item.closest('li');
	        if ($parent.hasClass('sub_item')) {
	            $subitem = $item;
	            $item = $subitem.closest('.item');
	        } else {
	            $item = $parent;
	        }
	        return { item: $item, subitem: $subitem };
	    };

	    var makeMobileMenu = function makeMobileMenu() {
	        if ($('#mobile-menu-container').is(':visible')) {
	            $('#mobile-menu').mmenu({
	                position: 'right',
	                zposition: 'front',
	                slidingSubmenus: false,
	                searchfield: true,
	                onClick: { close: true }
	            }, { selectedClass: 'active' });
	        }
	    };

	    return {
	        init: init,
	        onUnload: onUnload,
	        makeMobileMenu: makeMobileMenu
	    };
	}();

	module.exports = Menu;

/***/ },
/* 586 */
/***/ function(module, exports) {

	"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/*	
	 * jQuery mmenu v4.2.2
	 * @requires jQuery 1.7.0 or later
	 *
	 * mmenu.frebsite.nl
	 *	
	 * Copyright (c) Fred Heusschen
	 * www.frebsite.nl
	 *
	 * Dual licensed under the MIT and GPL licenses.
	 * http://en.wikipedia.org/wiki/MIT_License
	 * http://en.wikipedia.org/wiki/GNU_General_Public_License
	 */
	!function (e) {
	  function t(t, n, s) {
	    if (s) {
	      if ("object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && (t = {}), "boolean" != typeof t.isMenu) {
	        var o = s.children();t.isMenu = 1 == o.length && o.is(n.panelNodetype);
	      }return t;
	    }return t = e.extend(!0, {}, e[a].defaults, t), ("top" == t.position || "bottom" == t.position) && ("back" == t.zposition || "next" == t.zposition) && (e[a].deprecated('Using position "' + t.position + '" in combination with zposition "' + t.zposition + '"', 'zposition "front"'), t.zposition = "front"), t;
	  }function n(t) {
	    return t = e.extend(!0, {}, e[a].configuration, t), "string" != typeof t.pageSelector && (t.pageSelector = "> " + t.pageNodetype), t;
	  }function s() {
	    r.$wndw = e(window), r.$html = e("html"), r.$body = e("body"), r.$allMenus = e(), e.each([d, c, u], function (e, t) {
	      t.add = function (e) {
	        e = e.split(" ");for (var n in e) {
	          t[e[n]] = t.mm(e[n]);
	        }
	      };
	    }), d.mm = function (e) {
	      return "mm-" + e;
	    }, d.add("menu ismenu panel list subtitle selected label spacer current highest hidden page blocker modal background opened opening subopened subopen fullsubopen subclose"), d.umm = function (e) {
	      return "mm-" == e.slice(0, 3) && (e = e.slice(3)), e;
	    }, c.mm = function (e) {
	      return "mm-" + e;
	    }, c.add("parent style"), u.mm = function (e) {
	      return e + ".mm";
	    }, u.add("toggle open opening opened close closing closed update setPage setSelected transitionend webkitTransitionEnd mousedown touchstart mouseup touchend scroll touchmove click keydown keyup resize"), r.$wndw.on(u.keydown, function (e) {
	      return r.$html.hasClass(d.opened) && 9 == e.keyCode ? (e.preventDefault(), !1) : void 0;
	    });var t = 0;r.$wndw.on(u.resize, function (e, n) {
	      if (n || r.$html.hasClass(d.opened)) {
	        var s = r.$wndw.height();(n || s != t) && (t = s, r.$page.css("minHeight", s));
	      }
	    }), e[a]._c = d, e[a]._d = c, e[a]._e = u, e[a].glbl = r;
	  }function o(t, n) {
	    if (t.hasClass(d.current)) return !1;var s = e("." + d.panel, n),
	        o = s.filter("." + d.current);return s.removeClass(d.highest).removeClass(d.current).not(t).not(o).addClass(d.hidden), t.hasClass(d.opened) ? o.addClass(d.highest).removeClass(d.opened).removeClass(d.subopened) : (t.addClass(d.highest), o.addClass(d.subopened)), t.removeClass(d.hidden).removeClass(d.subopened).addClass(d.current).addClass(d.opened), "open";
	  }function i(e, t, n) {
	    var s = !1,
	        o = function o() {
	      s || t.call(e[0]), s = !0;
	    };e.one(u.transitionend, o), e.one(u.webkitTransitionEnd, o), setTimeout(o, 1.1 * n);
	  }var a = "mmenu",
	      l = "4.2.2";if (!e[a]) {
	    var r = { $wndw: null, $html: null, $body: null, $page: null, $blck: null, $allMenus: null },
	        d = {},
	        c = {},
	        u = {},
	        p = 0,
	        h = 0;e[a] = function (e, t, n) {
	      return r.$allMenus = r.$allMenus.add(e), this.$menu = e, this.opts = t, this.conf = n, this.serialnr = p++, this._init(), this;
	    }, e[a].prototype = { open: function open() {
	        var e = this;return this._openSetup(), setTimeout(function () {
	          e._openFinish();
	        }, 50), "open";
	      }, _openSetup: function _openSetup() {
	        h = r.$wndw.scrollTop(), this.$menu.addClass(d.current), r.$allMenus.not(this.$menu).trigger(u.close), r.$page.data(c.style, r.$page.attr("style") || ""), r.$wndw.trigger(u.resize, [!0]), this.opts.modal && r.$html.addClass(d.modal), this.opts.moveBackground && r.$html.addClass(d.background), "left" != this.opts.position && r.$html.addClass(d.mm(this.opts.position)), "back" != this.opts.zposition && r.$html.addClass(d.mm(this.opts.zposition)), this.opts.classes && r.$html.addClass(this.opts.classes), r.$html.addClass(d.opened), this.$menu.addClass(d.opened);
	      }, _openFinish: function _openFinish() {
	        var e = this;i(r.$page, function () {
	          e.$menu.trigger(u.opened);
	        }, this.conf.transitionDuration), r.$html.addClass(d.opening), this.$menu.trigger(u.opening);
	      }, close: function close() {
	        var e = this;return i(r.$page, function () {
	          e.$menu.removeClass(d.current).removeClass(d.opened), r.$html.removeClass(d.opened).removeClass(d.modal).removeClass(d.background).removeClass(d.mm(e.opts.position)).removeClass(d.mm(e.opts.zposition)), e.opts.classes && r.$html.removeClass(e.opts.classes), r.$page.attr("style", r.$page.data(c.style)), e.$menu.trigger(u.closed);
	        }, this.conf.transitionDuration), r.$html.removeClass(d.opening), this.$menu.trigger(u.closing), "close";
	      }, _init: function _init() {
	        if (this.opts = t(this.opts, this.conf, this.$menu), this.direction = this.opts.slidingSubmenus ? "horizontal" : "vertical", this._initPage(r.$page), this._initMenu(), this._initBlocker(), this._initPanles(), this._initLinks(), this._initOpenClose(), this._bindCustomEvents(), e[a].addons) for (var n = 0; n < e[a].addons.length; n++) {
	          "function" == typeof this["_addon_" + e[a].addons[n]] && this["_addon_" + e[a].addons[n]]();
	        }
	      }, _bindCustomEvents: function _bindCustomEvents() {
	        var t = this;this.$menu.off(u.open + " " + u.close + " " + u.setPage + " " + u.update).on(u.open + " " + u.close + " " + u.setPage + " " + u.update, function (e) {
	          e.stopPropagation();
	        }), this.$menu.on(u.open, function (n) {
	          return e(this).hasClass(d.current) ? (n.stopImmediatePropagation(), !1) : t.open();
	        }).on(u.close, function (n) {
	          return e(this).hasClass(d.current) ? t.close() : (n.stopImmediatePropagation(), !1);
	        }).on(u.setPage, function (e, n) {
	          t._initPage(n), t._initOpenClose();
	        });var n = this.$menu.find(this.opts.isMenu && "horizontal" != this.direction ? "ul, ol" : "." + d.panel);n.off(u.toggle + " " + u.open + " " + u.close).on(u.toggle + " " + u.open + " " + u.close, function (e) {
	          e.stopPropagation();
	        }), "horizontal" == this.direction ? n.on(u.open, function () {
	          return o(e(this), t.$menu);
	        }) : n.on(u.toggle, function () {
	          var t = e(this);return t.triggerHandler(t.parent().hasClass(d.opened) ? u.close : u.open);
	        }).on(u.open, function () {
	          return e(this).parent().addClass(d.opened), "open";
	        }).on(u.close, function () {
	          return e(this).parent().removeClass(d.opened), "close";
	        });
	      }, _initBlocker: function _initBlocker() {
	        var t = this;r.$blck || (r.$blck = e('<div id="' + d.blocker + '" />').appendTo(r.$body)), r.$blck.off(u.touchstart).on(u.touchstart, function (e) {
	          e.preventDefault(), e.stopPropagation(), r.$blck.trigger(u.mousedown);
	        }).on(u.mousedown, function (e) {
	          e.preventDefault(), r.$html.hasClass(d.modal) || t.$menu.trigger(u.close);
	        });
	      }, _initPage: function _initPage(t) {
	        t || (t = e(this.conf.pageSelector, r.$body), t.length > 1 && (e[a].debug("Multiple nodes found for the page-node, all nodes are wrapped in one <" + this.conf.pageNodetype + ">."), t = t.wrapAll("<" + this.conf.pageNodetype + " />").parent())), t.addClass(d.page), r.$page = t;
	      }, _initMenu: function _initMenu() {
	        this.conf.clone && (this.$menu = this.$menu.clone(!0), this.$menu.add(this.$menu.find("*")).filter("[id]").each(function () {
	          e(this).attr("id", d.mm(e(this).attr("id")));
	        })), this.$menu.contents().each(function () {
	          3 == e(this)[0].nodeType && e(this).remove();
	        }), this.$menu.prependTo("body").addClass(d.menu), this.$menu.addClass(d.mm(this.direction)), this.opts.classes && this.$menu.addClass(this.opts.classes), this.opts.isMenu && this.$menu.addClass(d.ismenu), "left" != this.opts.position && this.$menu.addClass(d.mm(this.opts.position)), "back" != this.opts.zposition && this.$menu.addClass(d.mm(this.opts.zposition));
	      }, _initPanles: function _initPanles() {
	        var t = this;this.__refactorClass(e("." + this.conf.listClass, this.$menu), "list"), this.opts.isMenu && e("ul, ol", this.$menu).not(".mm-nolist").addClass(d.list);var n = e("." + d.list + " > li", this.$menu);this.__refactorClass(n.filter("." + this.conf.selectedClass), "selected"), this.__refactorClass(n.filter("." + this.conf.labelClass), "label"), this.__refactorClass(n.filter("." + this.conf.spacerClass), "spacer"), n.off(u.setSelected).on(u.setSelected, function (t, s) {
	          t.stopPropagation(), n.removeClass(d.selected), "boolean" != typeof s && (s = !0), s && e(this).addClass(d.selected);
	        }), this.__refactorClass(e("." + this.conf.panelClass, this.$menu), "panel"), this.$menu.children().filter(this.conf.panelNodetype).add(this.$menu.find("." + d.list).children().children().filter(this.conf.panelNodetype)).addClass(d.panel);var s = e("." + d.panel, this.$menu);s.each(function (n) {
	          var s = e(this),
	              o = s.attr("id") || d.mm("m" + t.serialnr + "-p" + n);s.attr("id", o);
	        }), s.find("." + d.panel).each(function () {
	          var n = e(this),
	              s = n.is("ul, ol") ? n : n.find("ul ,ol").first(),
	              o = n.parent(),
	              i = o.find("> a, > span"),
	              a = o.closest("." + d.panel);if (n.data(c.parent, o), o.parent().is("." + d.list)) {
	            var l = e('<a class="' + d.subopen + '" href="#' + n.attr("id") + '" />').insertBefore(i);i.is("a") || l.addClass(d.fullsubopen), "horizontal" == t.direction && s.prepend('<li class="' + d.subtitle + '"><a class="' + d.subclose + '" href="#' + a.attr("id") + '">' + i.text() + "</a></li>");
	          }
	        });var o = "horizontal" == this.direction ? u.open : u.toggle;if (s.each(function () {
	          var n = e(this),
	              s = n.attr("id");e('a[href="#' + s + '"]', t.$menu).off(u.click).on(u.click, function (e) {
	            e.preventDefault(), n.trigger(o);
	          });
	        }), "horizontal" == this.direction) {
	          var i = e("." + d.list + " > li." + d.selected, this.$menu);i.add(i.parents("li")).parents("li").removeClass(d.selected).end().each(function () {
	            var t = e(this),
	                n = t.find("> ." + d.panel);n.length && (t.parents("." + d.panel).addClass(d.subopened), n.addClass(d.opened));
	          }).closest("." + d.panel).addClass(d.opened).parents("." + d.panel).addClass(d.subopened);
	        } else e("li." + d.selected, this.$menu).addClass(d.opened).parents("." + d.selected).removeClass(d.selected);var a = s.filter("." + d.opened);a.length || (a = s.first()), a.addClass(d.opened).last().addClass(d.current), "horizontal" == this.direction && s.find("." + d.panel).appendTo(this.$menu);
	      }, _initLinks: function _initLinks() {
	        var t = this;e("." + d.list + " > li > a", this.$menu).not("." + d.subopen).not("." + d.subclose).not('[rel="external"]').not('[target="_blank"]').off(u.click).on(u.click, function (n) {
	          var s = e(this),
	              o = s.attr("href");t.__valueOrFn(t.opts.onClick.setSelected, s) && s.parent().trigger(u.setSelected);var i = t.__valueOrFn(t.opts.onClick.preventDefault, s, "#" == o.slice(0, 1));i && n.preventDefault(), t.__valueOrFn(t.opts.onClick.blockUI, s, !i) && r.$html.addClass(d.blocking), t.__valueOrFn(t.opts.onClick.close, s, i) && t.$menu.triggerHandler(u.close);
	        });
	      }, _initOpenClose: function _initOpenClose() {
	        var t = this,
	            n = this.$menu.attr("id");n && n.length && (this.conf.clone && (n = d.umm(n)), e('a[href="#' + n + '"]').off(u.click).on(u.click, function (e) {
	          e.preventDefault(), t.$menu.trigger(u.open);
	        }));var n = r.$page.attr("id");n && n.length && e('a[href="#' + n + '"]').off(u.click).on(u.click, function (e) {
	          e.preventDefault(), t.$menu.trigger(u.close);
	        });
	      }, __valueOrFn: function __valueOrFn(e, t, n) {
	        return "function" == typeof e ? e.call(t[0]) : "undefined" == typeof e && "undefined" != typeof n ? n : e;
	      }, __refactorClass: function __refactorClass(e, t) {
	        e.removeClass(this.conf[t + "Class"]).addClass(d[t]);
	      } }, e.fn[a] = function (o, i) {
	      return r.$wndw || s(), o = t(o, i), i = n(i), this.each(function () {
	        var t = e(this);t.data(a) || t.data(a, new e[a](t, o, i));
	      });
	    }, e[a].version = l, e[a].defaults = { position: "left", zposition: "back", moveBackground: !0, slidingSubmenus: !0, modal: !1, classes: "", onClick: { setSelected: !0 } }, e[a].configuration = { preventTabbing: !0, panelClass: "Panel", listClass: "List", selectedClass: "Selected", labelClass: "Label", spacerClass: "Spacer", pageNodetype: "div", panelNodetype: "ul, ol, div", transitionDuration: 400 }, function () {
	      var t = window.document,
	          n = window.navigator.userAgent,
	          s = (document.createElement("div").style, "ontouchstart" in t),
	          o = "WebkitOverflowScrolling" in t.documentElement.style,
	          i = function () {
	        return n.indexOf("Android") >= 0 ? 2.4 > parseFloat(n.slice(n.indexOf("Android") + 8)) : !1;
	      }();e[a].support = { touch: s, oldAndroidBrowser: i, overflowscrolling: function () {
	          return s ? o ? !0 : i ? !1 : !0 : !0;
	        }() };
	    }(), e[a].debug = function () {}, e[a].deprecated = function (e, t) {
	      "undefined" != typeof console && "undefined" != typeof console.warn && console.warn("MMENU: " + e + " is deprecated, use " + t + " instead.");
	    };
	  }
	}(jQuery);
	/*	
	 * jQuery mmenu counters addon
	 * @requires mmenu 4.0.0 or later
	 *
	 * mmenu.frebsite.nl
	 *	
	 * Copyright (c) Fred Heusschen
	 * www.frebsite.nl
	 *
	 * Dual licensed under the MIT and GPL licenses.
	 * http://en.wikipedia.org/wiki/MIT_License
	 * http://en.wikipedia.org/wiki/GNU_General_Public_License
	 */
	!function (t) {
	  var e = "mmenu",
	      n = "counters";t[e].prototype["_addon_" + n] = function () {
	    var o = this,
	        u = this.opts[n],
	        a = t[e]._c,
	        r = t[e]._d,
	        d = t[e]._e;a.add("counter noresults"), d.add("updatecounters"), "boolean" == typeof u && (u = { add: u, update: u }), "object" != (typeof u === "undefined" ? "undefined" : _typeof(u)) && (u = {}), u = t.extend(!0, {}, t[e].defaults[n], u), u.count && (t[e].deprecated('the option "count" for counters, the option "update"'), u.update = u.count), this.__refactorClass(t("em." + this.conf.counterClass, this.$menu), "counter");var s = t("." + a.panel, this.$menu);if (u.add && s.each(function () {
	      var e = t(this),
	          n = e.data(r.parent);if (n) {
	        var o = t('<em class="' + a.counter + '" />'),
	            u = n.find("> a." + a.subopen);u.parent().find("em." + a.counter).length || u.before(o);
	      }
	    }), u.update) {
	      var c = t("em." + a.counter, this.$menu);c.off(d.updatecounters).on(d.updatecounters, function (t) {
	        t.stopPropagation();
	      }).each(function () {
	        var e = t(this),
	            n = t(e.next().attr("href"), o.$menu);n.is("." + a.list) || (n = n.find("> ." + a.list)), n.length && e.on(d.updatecounters, function () {
	          var t = n.children().not("." + a.label).not("." + a.subtitle).not("." + a.hidden).not("." + a.noresults);e.html(t.length);
	        });
	      }).trigger(d.updatecounters), this.$menu.on(d.update, function () {
	        c.trigger(d.updatecounters);
	      });
	    }
	  }, t[e].defaults[n] = { add: !1, update: !1 }, t[e].configuration.counterClass = "Counter", t[e].addons = t[e].addons || [], t[e].addons.push(n);
	}(jQuery);
	/*	
	 * jQuery mmenu dragOpen addon
	 * @requires mmenu 4.0.0 or later
	 *
	 * mmenu.frebsite.nl
	 *	
	 * Copyright (c) Fred Heusschen
	 * www.frebsite.nl
	 *
	 * Dual licensed under the MIT and GPL licenses.
	 * http://en.wikipedia.org/wiki/MIT_License
	 * http://en.wikipedia.org/wiki/GNU_General_Public_License
	 */
	!function (e) {
	  function t(e, t, a) {
	    return t > e && (e = t), e > a && (e = a), e;
	  }var a = "mmenu",
	      o = "dragOpen";e[a].prototype["_addon_" + o] = function () {
	    var n = this,
	        r = this.opts[o];if (e.fn.hammer) {
	      var i = e[a]._c,
	          s = (e[a]._d, e[a]._e);i.add("dragging"), s.add("dragleft dragright dragup dragdown dragend");var d = e[a].glbl;if ("boolean" == typeof r && (r = { open: r }), "object" != (typeof r === "undefined" ? "undefined" : _typeof(r)) && (r = {}), "number" != typeof r.maxStartPos && (r.maxStartPos = "left" == this.opts.position || "right" == this.opts.position ? 150 : 75), r = e.extend(!0, {}, e[a].defaults[o], r), r.open) {
	        var p = 0,
	            g = !1,
	            c = 0,
	            h = 0,
	            l = "width";switch (this.opts.position) {case "left":case "right":
	            l = "width";break;default:
	            l = "height";}switch (this.opts.position) {case "left":
	            var f = { events: s.dragleft + " " + s.dragright, open_dir: "right", close_dir: "left", delta: "deltaX", page: "pageX", negative: !1 };break;case "right":
	            var f = { events: s.dragleft + " " + s.dragright, open_dir: "left", close_dir: "right", delta: "deltaX", page: "pageX", negative: !0 };break;case "top":
	            var f = { events: s.dragup + " " + s.dragdown, open_dir: "down", close_dir: "up", delta: "deltaY", page: "pageY", negative: !1 };break;case "bottom":
	            var f = { events: s.dragup + " " + s.dragdown, open_dir: "up", close_dir: "down", delta: "deltaY", page: "pageY", negative: !0 };}var u = this.__valueOrFn(r.pageNode, this.$menu, d.$page);"string" == typeof u && (u = e(u));var m = d.$page.find("." + i.mm("fixed-top") + ", ." + i.mm("fixed-bottom")),
	            v = d.$page;switch (n.opts.zposition) {case "back":
	            v = v.add(m);break;case "front":
	            v = n.$menu;break;case "next":
	            v = v.add(n.$menu).add(m);}u.hammer().on(s.touchstart + " " + s.mousedown, function (e) {
	          if ("touchstart" == e.type) var t = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0],
	              a = t[f.page];else if ("mousedown" == e.type) var a = e[f.page];switch (n.opts.position) {case "right":case "bottom":
	              a >= d.$wndw[l]() - r.maxStartPos && (p = 1);break;default:
	              a <= r.maxStartPos && (p = 1);}
	        }).on(f.events + " " + s.dragend, function (e) {
	          p > 0 && (e.gesture.preventDefault(), e.stopPropagation());
	        }).on(f.events, function (e) {
	          var a = f.negative ? -e.gesture[f.delta] : e.gesture[f.delta];if (g = a > c ? f.open_dir : f.close_dir, c = a, c > r.threshold && 1 == p) {
	            if (d.$html.hasClass(i.opened)) return;p = 2, n._openSetup(), d.$html.addClass(i.dragging), h = t(d.$wndw[l]() * n.conf[o][l].perc, n.conf[o][l].min, n.conf[o][l].max);
	          }2 == p && v.css(n.opts.position, t(c, 10, h) - ("front" == n.opts.zposition ? h : 0));
	        }).on(s.dragend, function () {
	          2 == p && (d.$html.removeClass(i.dragging), v.css(n.opts.position, ""), g == f.open_dir ? n._openFinish() : n.close()), p = 0;
	        });
	      }
	    }
	  }, e[a].defaults[o] = { open: !1, threshold: 50 }, e[a].configuration[o] = { width: { perc: .8, min: 140, max: 440 }, height: { perc: .8, min: 140, max: 880 } }, e[a].addons = e[a].addons || [], e[a].addons.push(o);
	}(jQuery);
	/*	
	 * jQuery mmenu header addon
	 * @requires mmenu 4.0.0 or later
	 *
	 * mmenu.frebsite.nl
	 *	
	 * Copyright (c) Fred Heusschen
	 * www.frebsite.nl
	 *
	 * Dual licensed under the MIT and GPL licenses.
	 * http://en.wikipedia.org/wiki/MIT_License
	 * http://en.wikipedia.org/wiki/GNU_General_Public_License
	 */
	!function (e) {
	  var t = "mmenu",
	      a = "header";e[t].prototype["_addon_" + a] = function () {
	    var n = this,
	        r = this.opts[a],
	        d = this.conf[a],
	        s = e[t]._c,
	        i = (e[t]._d, e[t]._e);s.add("header hasheader prev next title titletext"), i.add("updateheader");var o = e[t].glbl;if ("boolean" == typeof r && (r = { add: r, update: r }), "object" != (typeof r === "undefined" ? "undefined" : _typeof(r)) && (r = {}), r = e.extend(!0, {}, e[t].defaults[a], r), r.add) {
	      var h = r.content ? r.content : '<a class="' + s.prev + '" href="javascript:;"></a><span class="' + s.title + '"></span><a class="' + s.next + '" href="javascript:;"></a>';e('<div class="' + s.header + '" />').prependTo(this.$menu).append(h);
	    }var p = e("div." + s.header, this.$menu);if (p.length && this.$menu.addClass(s.hasheader), r.update && p.length) {
	      var l = p.find("." + s.title),
	          u = p.find("." + s.prev),
	          f = p.find("." + s.next),
	          c = "#" + o.$page.attr("id");u.add(f).on(i.click, function (t) {
	        t.preventDefault(), t.stopPropagation();var a = e(this).attr("href");"#" !== a && (a == c ? n.$menu.trigger(i.close) : e(a, n.$menu).trigger(i.open));
	      }), e("." + s.panel, this.$menu).each(function () {
	        var t = e(this),
	            a = e("." + d.panelHeaderClass, t).text(),
	            n = e("." + d.panelPrevClass, t).attr("href"),
	            o = e("." + d.panelNextClass, t).attr("href");a || (a = e("." + s.subclose, t).text()), a || (a = r.title), n || (n = e("." + s.subclose, t).attr("href")), t.off(i.updateheader).on(i.updateheader, function (e) {
	          e.stopPropagation(), l[a ? "show" : "hide"]().text(a), u[n ? "show" : "hide"]().attr("href", n), f[o ? "show" : "hide"]().attr("href", o);
	        }), t.on(i.open, function () {
	          e(this).trigger(i.updateheader);
	        });
	      }).filter("." + s.current).trigger(i.updateheader);
	    }
	  }, e[t].defaults[a] = { add: !1, content: !1, update: !1, title: "Menu" }, e[t].configuration[a] = { panelHeaderClass: "Header", panelNextClass: "Next", panelPrevClass: "Prev" }, e[t].addons = e[t].addons || [], e[t].addons.push(a);
	}(jQuery);
	/*	
	 * jQuery mmenu labels addon
	 * @requires mmenu 4.1.0 or later
	 *
	 * mmenu.frebsite.nl
	 *	
	 * Copyright (c) Fred Heusschen
	 * www.frebsite.nl
	 *
	 * Dual licensed under the MIT and GPL licenses.
	 * http://en.wikipedia.org/wiki/MIT_License
	 * http://en.wikipedia.org/wiki/GNU_General_Public_License
	 */
	!function (e) {
	  var l = "mmenu",
	      s = "labels";e[l].prototype["_addon_" + s] = function () {
	    function a() {
	      var e = t.hassearch && o.$menu.hasClass(t.hassearch),
	          l = t.hasheader && o.$menu.hasClass(t.hasheader);return e ? l ? 100 : 50 : l ? 60 : 0;
	    }var o = this,
	        n = this.opts[s],
	        t = e[l]._c,
	        i = (e[l]._d, e[l]._e);if (t.add("collapsed"), t.add("fixedlabels original clone"), i.add("updatelabels position scroll"), e[l].support.touch && (i.scroll += " " + i.mm("touchmove")), "boolean" == typeof n && (n = { collapse: n }), "object" != (typeof n === "undefined" ? "undefined" : _typeof(n)) && (n = {}), n = e.extend(!0, {}, e[l].defaults[s], n), n.collapse) {
	      this.__refactorClass(e("li." + this.conf.collapsedClass, this.$menu), "collapsed");var d = e("." + t.label, this.$menu);d.each(function () {
	        var l = e(this),
	            s = l.nextUntil("." + t.label, "all" == n.collapse ? null : "." + t.collapsed);"all" == n.collapse && (l.addClass(t.opened), s.removeClass(t.collapsed)), s.length && (l.wrapInner("<span />"), e('<a href="javascript:;" class="' + t.subopen + " " + t.fullsubopen + '" />').prependTo(l).on(i.click, function (e) {
	          e.preventDefault(), l.toggleClass(t.opened), s[l.hasClass(t.opened) ? "removeClass" : "addClass"](t.collapsed);
	        }));
	      });
	    } else if (n.fixed) {
	      if ("horizontal" != this.direction) return;this.$menu.addClass(t.fixedlabels);var r = e("." + t.panel, this.$menu),
	          d = e("." + t.label, this.$menu);r.add(d).off(i.updatelabels + " " + i.position + " " + i.scroll).on(i.updatelabels + " " + i.position + " " + i.scroll, function (e) {
	        e.stopPropagation();
	      });var p = a();r.each(function () {
	        var l = e(this),
	            s = l.find("." + t.label);if (s.length) {
	          var o = l.scrollTop();s.each(function () {
	            var s = e(this);s.wrapInner("<div />").wrapInner("<div />");var a,
	                n,
	                d,
	                r = s.find("> div"),
	                c = e();s.on(i.updatelabels, function () {
	              o = l.scrollTop(), s.hasClass(t.hidden) || (c = s.nextAll("." + t.label).not("." + t.hidden).first(), a = s.offset().top + o, n = c.length ? c.offset().top + o : !1, d = r.height(), s.trigger(i.position));
	            }), s.on(i.position, function () {
	              var e = 0;n && o + p > n - d ? e = n - a - d : o + p > a && (e = o - a + p), r.css("top", e);
	            });
	          }), l.on(i.updatelabels, function () {
	            o = l.scrollTop(), p = a(), s.trigger(i.position);
	          }).on(i.scroll, function () {
	            s.trigger(i.updatelabels);
	          });
	        }
	      }), this.$menu.on(i.update, function () {
	        r.trigger(i.updatelabels);
	      }).on(i.opening, function () {
	        r.trigger(i.updatelabels).trigger(i.scroll);
	      });
	    }
	  }, e[l].defaults[s] = { fixed: !1, collapse: !1 }, e[l].configuration.collapsedClass = "Collapsed", e[l].addons = e[l].addons || [], e[l].addons.push(s);
	}(jQuery);
	/*	
	 * jQuery mmenu searchfield addon
	 * @requires mmenu 4.0.0 or later
	 *
	 * mmenu.frebsite.nl
	 *	
	 * Copyright (c) Fred Heusschen
	 * www.frebsite.nl
	 *
	 * Dual licensed under the MIT and GPL licenses.
	 * http://en.wikipedia.org/wiki/MIT_License
	 * http://en.wikipedia.org/wiki/GNU_General_Public_License
	 */
	!function (e) {
	  function s(e) {
	    switch (e) {case 9:case 16:case 17:case 18:case 37:case 38:case 39:case 40:
	        return !0;}return !1;
	  }var n = "mmenu",
	      t = "searchfield";e[n].prototype["_addon_" + t] = function () {
	    var a = this,
	        r = this.opts[t],
	        o = e[n]._c,
	        l = e[n]._d,
	        d = e[n]._e;if (o.add("search hassearch noresults nosubresults counter"), d.add("search reset change"), "boolean" == typeof r && (r = { add: r, search: r }), "object" != (typeof r === "undefined" ? "undefined" : _typeof(r)) && (r = {}), r = e.extend(!0, {}, e[n].defaults[t], r), r.add && (e('<div class="' + o.search + '" />').prependTo(this.$menu).append('<input placeholder="' + r.placeholder + '" type="text" autocomplete="off" />'), r.noResults && e("ul, ol", this.$menu).first().append('<li class="' + o.noresults + '">' + r.noResults + "</li>")), e("div." + o.search, this.$menu).length && this.$menu.addClass(o.hassearch), r.search) {
	      var i = e("div." + o.search, this.$menu).find("input");if (i.length) {
	        var u = e("." + o.panel, this.$menu),
	            h = e("." + o.list + "> li." + o.label, this.$menu),
	            c = e("." + o.list + "> li", this.$menu).not("." + o.subtitle).not("." + o.label).not("." + o.noresults),
	            f = "> a";r.showLinksOnly || (f += ", > span"), i.off(d.keyup + " " + d.change).on(d.keyup, function (e) {
	          s(e.keyCode) || a.$menu.trigger(d.search);
	        }).on(d.change, function () {
	          a.$menu.trigger(d.search);
	        }), this.$menu.off(d.reset + " " + d.search).on(d.reset + " " + d.search, function (e) {
	          e.stopPropagation();
	        }).on(d.reset, function () {
	          a.$menu.trigger(d.search, [""]);
	        }).on(d.search, function (s, n) {
	          "string" == typeof n ? i.val(n) : n = i.val(), n = n.toLowerCase(), u.scrollTop(0), c.add(h).addClass(o.hidden), c.each(function () {
	            var s = e(this);e(f, s).text().toLowerCase().indexOf(n) > -1 && s.add(s.prevAll("." + o.label).first()).removeClass(o.hidden);
	          }), e(u.get().reverse()).each(function () {
	            var s = e(this),
	                n = s.data(l.parent);if (n) {
	              var t = s.add(s.find("> ." + o.list)).find("> li").not("." + o.subtitle).not("." + o.label).not("." + o.hidden);t.length ? n.removeClass(o.hidden).removeClass(o.nosubresults).prevAll("." + o.label).first().removeClass(o.hidden) : (s.hasClass(o.current) && n.trigger(d.open), n.addClass(o.nosubresults));
	            }
	          }), a.$menu[c.not("." + o.hidden).length ? "removeClass" : "addClass"](o.noresults), a.$menu.trigger(d.update);
	        });
	      }
	    }
	  }, e[n].defaults[t] = { add: !1, search: !1, showLinksOnly: !0, placeholder: "Search", noResults: "No results found." }, e[n].addons = e[n].addons || [], e[n].addons.push(t);
	}(jQuery);

/***/ },
/* 587 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var RealityCheckData = __webpack_require__(432);
	var RealityCheckUI = __webpack_require__(588);
	var BinarySocket = __webpack_require__(427);
	var Client = __webpack_require__(420);

	var RealityCheck = function () {
	    'use strict';

	    var storageHandler = function storageHandler(ev) {
	        var key = ev.key;
	        var new_value = ev.newValue;
	        if (key === 'client.reality_check.ack' && +new_value === 1 || key === 'client.reality_check.keep_open' && +new_value === 0) {
	            RealityCheckUI.closePopUp();
	        }
	    };

	    var onLoad = function onLoad() {
	        if (RealityCheckUI.shouldShowPopup()) {
	            BinarySocket.wait('landing_company').then(function () {
	                if ((Client.currentLandingCompany() || {}).has_reality_check) {
	                    RealityCheckUI.setLoginTime(Client.get('session_start') * 1000);
	                    window.addEventListener('storage', storageHandler, false);

	                    RealityCheckData.resetInvalid();

	                    if (!RealityCheckData.get('ack')) {
	                        RealityCheckUI.renderFrequencyPopUp();
	                    } else if (RealityCheckData.get('keep_open')) {
	                        RealityCheckUI.getSummaryAsync();
	                    } else {
	                        RealityCheckUI.startSummaryTimer();
	                    }
	                }
	            });
	        }
	    };

	    return {
	        onLoad: onLoad
	    };
	}();

	module.exports = RealityCheck;

/***/ },
/* 588 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var RealityCheckData = __webpack_require__(432);
	var BinarySocket = __webpack_require__(427);
	var showLocalTimeOnHover = __webpack_require__(463).showLocalTimeOnHover;
	var urlFor = __webpack_require__(423).urlFor;
	var FormManager = __webpack_require__(483);
	__webpack_require__(589);
	__webpack_require__(590);

	var RealityCheckUI = function () {
	    'use strict';

	    var summary_url = urlFor('user/reality_check_summary');
	    var frequency_url = urlFor('user/reality_check_frequency');
	    var form = {
	        selector: '#frm_reality_check',
	        num_reality_duration: '#num_reality_duration'
	    };

	    var login_time = void 0; // milliseconds

	    var getAjax = function getAjax(summary) {
	        $.ajax({
	            url: summary ? summary_url : frequency_url,
	            dataType: 'html',
	            method: 'GET',
	            success: function success(reality_check_text) {
	                ajaxSuccess(reality_check_text, summary);
	            }
	        });
	    };

	    var ajaxSuccess = function ajaxSuccess(reality_check_text, summary) {
	        var content = 'reality_check_content';
	        if (reality_check_text.includes(content) && $('#reality_check').length === 0) {
	            $('body').append($('<div/>', { id: 'reality_check', class: 'lightbox' }).append($(reality_check_text).find('#' + content)));
	            $(form.num_reality_duration).val(Math.floor(+RealityCheckData.get('interval') / 60 / 1000));
	            $('#statement').off('click').on('click dblclick', onStatementClick);
	            $('#logout').off('click').on('click dblclick', onLogoutClick);
	            if (summary) {
	                updateSummary(summary);
	            }
	            bindValidation();
	        }
	    };

	    var updateSummary = function updateSummary(summary) {
	        $('#start_time').text(summary.start_time_string);
	        $('#login_time').text(summary.login_time);
	        $('#current_time').text(summary.current_time);
	        $('#session_duration').text(summary.session_duration);

	        $('#loginid').text(summary.loginid);
	        $('#rc_currency').text(summary.currency);
	        $('#turnover').text(summary.turnover);
	        $('#profit_loss').text(summary.profit_loss);
	        $('#bought').text(summary.contracts_bought);
	        $('#sold').text(summary.contracts_sold);
	        $('#open').text(summary.open_contracts);
	        $('#potential').text(summary.potential_profit);

	        showLocalTimeOnHover('#start_time, #login_time, #current_time');
	    };

	    var handleKeypress = function handleKeypress(ev) {
	        var char = String.fromCharCode(ev.which);
	        if (!/[0-9]/.test(char) && [8, 37, 39].indexOf(ev.keyCode) < 0 || /['%]/.test(char)) {
	            // similarity to arrows key code in some browsers
	            ev.returnValue = false;
	            ev.preventDefault();
	        }
	    };

	    var bindValidation = function bindValidation() {
	        $(form.num_reality_duration).off('keypress').on('keypress', handleKeypress);
	        FormManager.init(form.selector, [{ selector: form.num_reality_duration, validations: ['req', ['number', { min: 10, max: 60 }]], exclude_request: 1, no_scroll: 1 }]);
	        FormManager.handleSubmit({
	            form_selector: form.selector,
	            fnc_response_handler: responseHandler
	        });
	    };

	    var responseHandler = function responseHandler() {
	        var interval_minute = +$(form.num_reality_duration).val();
	        RealityCheckData.set('interval', interval_minute * 60 * 1000);
	        RealityCheckData.set('keep_open', 0);
	        RealityCheckData.set('ack', 1);
	        closePopUp();
	    };

	    var onStatementClick = function onStatementClick() {
	        var win = window.open(urlFor('user/statementws') + '#no-reality-check', '_blank');
	        if (win) {
	            win.focus();
	        }
	    };

	    var onLogoutClick = function onLogoutClick() {
	        BinarySocket.send({ logout: '1' });
	    };

	    var closePopUp = function closePopUp() {
	        $('#reality_check').remove();
	        startSummaryTimer();
	    };

	    var startSummaryTimer = function startSummaryTimer() {
	        var interval = +RealityCheckData.get('interval');
	        var toWait = interval - (Date.now() - login_time) % interval;

	        setTimeout(function () {
	            RealityCheckData.set('keep_open', 1);
	            getSummaryAsync();
	        }, toWait);
	    };

	    var shouldShowPopup = function shouldShowPopup() {
	        var location = window.location;
	        return !(/no-reality-check/.test(location.hash) && /statementws/.test(location.pathname));
	    };

	    var getSummaryAsync = function getSummaryAsync() {
	        if (RealityCheckUI.shouldShowPopup()) {
	            BinarySocket.send({ reality_check: 1 }).then(function (response) {
	                getAjax(RealityCheckData.summaryData(response.reality_check));
	            });
	        }
	    };

	    return {
	        renderFrequencyPopUp: function renderFrequencyPopUp() {
	            getAjax();
	        },
	        closePopUp: closePopUp,
	        startSummaryTimer: startSummaryTimer,
	        getSummaryAsync: getSummaryAsync,
	        setLoginTime: function setLoginTime(time) {
	            login_time = time;
	        },
	        shouldShowPopup: shouldShowPopup
	    };
	}();

	module.exports = RealityCheckUI;

/***/ },
/* 589 */
/***/ function(module, exports) {

	'use strict';

	if (!('includes' in Array.prototype)) {
	    Array.prototype.includes = function includes(searchElement /*, fromIndex*/) {
	        'use strict';

	        var O = Object(this);
	        var len = parseInt(O.length) || 0;
	        if (len === 0) {
	            return false;
	        }
	        var n = parseInt(arguments[1]) || 0;
	        var k;
	        if (n >= 0) {
	            k = n;
	        } else {
	            k = len + n;
	            if (k < 0) {
	                k = 0;
	            }
	        }
	        var currentElement;
	        while (k < len) {
	            currentElement = O[k];
	            if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
	                return true;
	            }
	            k++;
	        }
	        return false;
	    };
	}

/***/ },
/* 590 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	if (!('includes' in String.prototype)) {
	    String.prototype.includes = function (string, index) {
	        if ((typeof string === 'undefined' ? 'undefined' : _typeof(string)) === 'object' && string instanceof RegExp) throw new TypeError("First argument to String.prototype.includes must not be a regular expression");
	        return this.indexOf(string, index) !== -1;
	    };
	}

/***/ },
/* 591 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var urlFor = __webpack_require__(423).urlFor;
	var Client = __webpack_require__(420);
	var jpClient = __webpack_require__(425).jpClient;
	var BinarySocket = __webpack_require__(427);

	var AffiliatePopup = function () {
	    'use strict';

	    var container_id = 'affiliate_disclaimer_popup';

	    var show = function show() {
	        if (Client.isLoggedIn()) return;
	        BinarySocket.wait('website_status').then(function (response) {
	            if (jpClient() || response.website_status.clients_country === 'jp') {
	                $.ajax({
	                    url: urlFor('affiliate_disclaimer'),
	                    dataType: 'html',
	                    method: 'GET',
	                    success: function success(contents) {
	                        $('body').append($('<div/>', { id: container_id, class: 'lightbox' }).append($('<div/>').append($(contents))));
	                        $('#btn_affiliate_proceed').off('click').on('click', close);
	                    }
	                });
	            }
	        });
	    };

	    var close = function close() {
	        $('#' + container_id).remove();
	    };

	    return {
	        show: show
	    };
	}();

	module.exports = AffiliatePopup;

/***/ },
/* 592 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Client = __webpack_require__(420);
	var getLanguage = __webpack_require__(424).get;
	var urlForStatic = __webpack_require__(423).urlForStatic;
	var Pushwoosh = __webpack_require__(593).Pushwoosh;

	var BinaryPushwoosh = function () {
	    var pw = new Pushwoosh();

	    var initialised = false;

	    var init = function init() {
	        if (!/^(www|staging)\.binary\.com$/.test(window.location.hostname)) return;

	        if (!initialised) {
	            pw.push(['init', {
	                logLevel: 'none', // or debug
	                applicationCode: 'D04E6-FA474',
	                safariWebsitePushID: 'web.com.binary',
	                defaultNotificationTitle: 'Binary.com',
	                defaultNotificationImage: 'https://style.binary.com/images/logo/logomark.png',
	                serviceWorkerUrl: urlForStatic('/') + 'pushwoosh-service-worker-light.js'
	            }]);
	            initialised = true;
	            sendTags();
	        }
	    };

	    var sendTags = function sendTags() {
	        pw.push(function (api) {
	            api.getTags().then(function (result) {
	                if (!result.result['Login ID'] || !result.result['Site Language']) {
	                    // send login id and site language
	                    return api.setTags({
	                        'Login ID': Client.get('loginid'),
	                        'Site Language': getLanguage()
	                    });
	                }
	                return null;
	            }).catch(function (e) {
	                return; // do nothing
	            });
	        });
	    };

	    return {
	        init: init
	    };
	}();

	module.exports = BinaryPushwoosh;

/***/ },
/* 593 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _Global = __webpack_require__(594);

	Object.defineProperty(exports, 'Pushwoosh', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Global).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 594 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _storage = __webpack_require__(595),
	    _functions = __webpack_require__(596),
	    _Logger = __webpack_require__(597),
	    _Logger2 = _interopRequireDefault(_Logger),
	    _SafariInit = __webpack_require__(598),
	    _SafariInit2 = _interopRequireDefault(_SafariInit),
	    _WorkerInit = __webpack_require__(605),
	    _WorkerInit2 = _interopRequireDefault(_WorkerInit),
	    _API = __webpack_require__(603),
	    _constants = __webpack_require__(604);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var isSafari = (0, _functions.isSafariBrowser)(),
	    canUseSW = (0, _functions.canUseServiceWorkers)();


	function findHeader(headers, fh) {
	  var val = '';
	  for (var _iterator = headers.entries(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	    var _ref;

	    if (_isArray) {
	      if (_i >= _iterator.length) break;
	      _ref = _iterator[_i++];
	    } else {
	      _i = _iterator.next();
	      if (_i.done) break;
	      _ref = _i.value;
	    }

	    var h = _ref;

	    if (h[0].toLowerCase() === fh) {
	      val = h[1];
	    }
	  }
	  return val;
	}

	var PushwooshGlobal = function () {
	  function PushwooshGlobal() {
	    _classCallCheck(this, PushwooshGlobal);

	    this._commands = [];
	    this._keyValue = _storage.keyValue;
	  }

	  PushwooshGlobal.prototype._init = function _init() {
	    var _this = this,
	        initPromise = this._auto ? this._initer.initSubscribe() : this._initer.initApi();

	    this._initPromise = initPromise.catch(function (err) {
	      _this._logger.debug('Error was caught in browser init', err);
	      return (0, _API.createErrorAPI)(err);
	    }).then(function (api) {
	      return _this.api = api;
	    }) // eslint-disable-line no-return-assign
	    .then(function () {
	      // eslint-disable-line consistent-return
	      var lastSentTime = Number(localStorage.getItem(_constants.keyLastSentAppOpen)),
	          curTime = Date.now();

	      if (curTime - lastSentTime > 3600000) {
	        localStorage.setItem(_constants.keyLastSentAppOpen, curTime);
	        return _this.api.applicationOpen().then(function () {
	          return _this._logger.debug('applicationOpen sent successfully');
	        }, function (err) {
	          return _this._logger.debug('applicationOpen sent with error', err);
	        });
	      }
	    }).then(function () {
	      return _this._commands.forEach(function (cmd) {
	        return _this._runCmd(cmd);
	      });
	    });
	  };

	  PushwooshGlobal.prototype.init = function init(params) {
	    var applicationCode = params.applicationCode,
	        safariWebsitePushID = params.safariWebsitePushID,
	        _params$serviceWorker = params.serviceWorkerUrl,
	        serviceWorkerUrl = _params$serviceWorker === undefined ? _constants.defaultWorkerUrl : _params$serviceWorker,
	        _params$serviceWorker2 = params.serviceWorkerSecondUrl,
	        serviceWorkerSecondUrl = _params$serviceWorker2 === undefined ? _constants.defaultWorkerSecondUrl : _params$serviceWorker2,
	        logLevel = params.logLevel,
	        _params$pushwooshUrl = params.pushwooshUrl,
	        pushwooshUrl = _params$pushwooshUrl === undefined ? (0, _functions.getPushwooshUrl)(applicationCode) : _params$pushwooshUrl,
	        defaultNotificationTitle = params.defaultNotificationTitle,
	        defaultNotificationImage = params.defaultNotificationImage,
	        defaultNotificationUrl = params.defaultNotificationUrl,
	        _params$autoSubscribe = params.autoSubscribe,
	        autoSubscribe = _params$autoSubscribe === undefined ? true : _params$autoSubscribe;

	    this._initParams = params;
	    this._auto = autoSubscribe;
	    this._logger = new _Logger2.default(logLevel);
	    if (!(isSafari && (0, _functions.getDeviceName)() === 'PC' || canUseSW)) {
	      this._logger.info('This browser does not support pushes');
	      return;
	    }
	    if (!applicationCode) {
	      throw new Error('no application code');
	    }

	    if (isSafari) {
	      if (safariWebsitePushID) {
	        this._initer = new _SafariInit2.default({
	          webSitePushID: safariWebsitePushID,
	          pushwooshUrl: pushwooshUrl,
	          applicationCode: applicationCode,
	          logger: this._logger
	        });
	      }
	    } else if (canUseSW) {
	      if (serviceWorkerUrl) {
	        this._initer = new _WorkerInit2.default({
	          workerUrl: serviceWorkerUrl,
	          workerSecondUrl: serviceWorkerSecondUrl,
	          pushwooshUrl: pushwooshUrl,
	          applicationCode: applicationCode,
	          defaultNotificationTitle: defaultNotificationTitle,
	          defaultNotificationImage: defaultNotificationImage,
	          defaultNotificationUrl: defaultNotificationUrl,
	          logger: this._logger
	        });
	      }
	    }
	    if (this._initer) {
	      this._init();
	    } else {
	      this._logger.info('Browser has not been configured');
	    }
	  };

	  PushwooshGlobal.prototype._runCmd = function _runCmd(func) {
	    return this._initPromise.then(func);
	  };

	  PushwooshGlobal.prototype._cmdInit = function _cmdInit(params) {
	    var _this2 = this;

	    if (document.readyState === 'complete') {
	      this.init(params);
	    } else {
	      window.addEventListener('load', function () {
	        return _this2.init(params);
	      });
	    }
	  };

	  PushwooshGlobal.prototype._runOrPush = function _runOrPush(clb) {
	    if (this._initPromise) {
	      this._runCmd(clb);
	    } else {
	      this._commands.push(clb);
	    }
	  };

	  PushwooshGlobal.prototype.push = function push(cmd) {
	    var _this3 = this;

	    if (typeof cmd === 'function') {
	      this._runOrPush(function () {
	        return cmd(_this3.api);
	      });
	    } else if (Array.isArray(cmd)) {
	      switch (cmd[0]) {
	        case 'init':
	          this._cmdInit(cmd[1]);
	          break;
	        case 'subscribe':
	          this._runOrPush(function () {
	            cmd[1](_this3._initer.initSubscribe());
	          });
	          break;
	        case 'unsubscribe':
	          this._runOrPush(function () {
	            cmd[1](_this3._initer.unsubscribe());
	          });
	          break;
	        default:
	          throw new Error('unknown command');
	      }
	    } else {
	      throw new Error('invalid command');
	    }
	  };

	  PushwooshGlobal.prototype._debug = function _debug() {
	    var debugFn = console.info.bind(console),
	        initerParams = this._initer._params,
	        jsContentType = 'application/javascript',
	        links = document.getElementsByTagName('link'),
	        checkUrlFn = function checkUrlFn(text, url, type) {
	      fetch(url).then(function (resp) {
	        if (resp.status === 200) {
	          var contentType = findHeader(resp.headers, 'content-type');
	          debugFn(text, contentType.indexOf(type) > -1 ? 'url ' + url + ' is ok' : 'url ' + url + ' has WRONG Content-Type \'' + contentType + '\'');
	        } else {
	          debugFn(text, 'error: url ' + url + ' loaded with status ' + resp.status);
	        }
	      }).catch(function (e) {
	        return debugFn(text, e);
	      });
	    },
	        manifestFounded = false; // eslint-disable-line
	    // eslint-disable-line


	    debugFn('version', (0, _functions.getVersion)());
	    debugFn('initer params', initerParams);
	    checkUrlFn('workerUrl', '' + location.origin + initerParams.workerUrl, jsContentType);
	    checkUrlFn('workerSecondUrl', '' + location.origin + initerParams.workerSecondUrl, jsContentType);
	    for (var i = 0; i < links.length; ++i) {
	      if (links[i].rel === 'manifest') {
	        checkUrlFn('manifest', links[i].href, 'application/json');
	        manifestFounded = true;
	      }
	    }
	    if (!manifestFounded) {
	      debugFn('Error: manifest not found.');
	    }
	    this._keyValue.getAll().then(function (res) {
	      return debugFn('keyValues', res);
	    });
	  };

	  return PushwooshGlobal;
	}();

	exports.default = PushwooshGlobal;

/***/ },
/* 595 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	var instance = void 0;

	function getInstance() {
	  return new Promise(function (resolve, reject) {
	    if (instance) {
	      resolve(instance);
	    } else {
	      var request = indexedDB.open('PUSHWOOSH_SDK_STORE', 2);
	      request.onsuccess = function (event) {
	        var database = event.target.result;
	        if (instance) {
	          database.close();
	          resolve(instance);
	        } else {
	          instance = database;
	          resolve(database);
	        }
	      };
	      request.onerror = function (event) {
	        reject(event);
	      };
	      request.onupgradeneeded = function (event) {
	        var database = event.target.result;
	        database.createObjectStore('keyValue', {
	          keyPath: 'key'
	        });
	      };
	      request.onversionchange = function (event) {
	        console.info('The database is about to be deleted.', event); // eslint-disable-line
	      };
	    }
	  });
	}

	function createKeyValue(name) {
	  return {
	    get: function get(key) {
	      return getInstance().then(function (database) {
	        return new Promise(function (resolve, reject) {
	          var request = database.transaction(name).objectStore(name).get(key);
	          request.onsuccess = function () {
	            var result = request.result;

	            resolve(result && result.value);
	          };
	          request.onerror = function () {
	            reject(request.errorCode);
	          };
	        });
	      });
	    },
	    getAll: function getAll() {
	      return getInstance().then(function (database) {
	        return new Promise(function (resolve, reject) {
	          var result = {},
	              cursor = database.transaction(name).objectStore(name).openCursor();

	          cursor.onsuccess = function (event) {
	            var cursorResult = event.target.result;
	            if (cursorResult) {
	              result[cursorResult.key] = cursorResult.value.value;
	              cursorResult.continue();
	            } else {
	              resolve(result);
	            }
	          };
	          cursor.onerror = function () {
	            reject(cursor.errorCode);
	          };
	        });
	      });
	    },
	    set: function set(key, value) {
	      return getInstance().then(function (database) {
	        return new Promise(function (resolve, reject) {
	          var request = database.transaction([name], 'readwrite').objectStore(name).put({ key: key, value: value });
	          request.onsuccess = function () {
	            resolve(key);
	          };
	          request.onerror = function (e) {
	            reject(e);
	          };
	        });
	      });
	    }
	  };
	}

	var keyValue = exports.keyValue = createKeyValue('keyValue');

/***/ },
/* 596 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.getGlobal = getGlobal;
	exports.getVersion = getVersion;
	exports.isSafariBrowser = isSafariBrowser;
	exports.canUseServiceWorkers = canUseServiceWorkers;
	exports.getBrowserType = getBrowserType;
	exports.getBrowserVersion = getBrowserVersion;
	exports.getDeviceName = getDeviceName;
	exports.createUUID = createUUID;
	exports.getPushToken = getPushToken;
	exports.generateHwid = generateHwid;
	exports.getAuthToken = getAuthToken;
	exports.getPublicKey = getPublicKey;
	exports.getPushwooshUrl = getPushwooshUrl;
	function getGlobal() {
	  return Function('return this')(); // eslint-disable-line no-new-func
	}

	function getVersion() {
	  return '2.10.1';
	}

	function isSafariBrowser() {
	  return typeof safari !== 'undefined' && navigator.userAgent.indexOf('Safari') > -1;
	}

	function canUseServiceWorkers() {
	  return navigator && navigator.serviceWorker && 'showNotification' in ServiceWorkerRegistration.prototype && 'PushManager' in window;
	}

	function getBrowserType() {
	  if (isSafariBrowser()) {
	    return 10;
	  }
	  return navigator.userAgent.toLowerCase().indexOf('firefox') > -1 ? 12 : 11;
	}

	function getBrowserVersion() {
	  var ua = navigator.userAgent,
	      tem = void 0,
	      M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];


	  if (/trident/i.test(M[1])) {
	    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
	    return 'IE ' + (tem[1] || '');
	  }

	  if (M[1] === 'Chrome') {
	    tem = ua.match(/\bOPR\/(\d+)/);
	    if (tem != null) {
	      return 'Opera ' + tem[1];
	    }
	  }

	  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
	  tem = ua.match(/version\/([.\d]+)/i);
	  if (tem != null) {
	    M.splice(1, 1, tem[1]);
	  }

	  return M.join(' ');
	}

	function getDeviceName() {
	  var userAgent = navigator.userAgent;
	  if (userAgent.match(/Android/i) || userAgent.match(/webOS/i) || userAgent.match(/iPhone/i) || userAgent.match(/iPad/i) || userAgent.match(/iPod/i) || userAgent.match(/BlackBerry/i) || userAgent.match(/Windows Phone/i)) {
	    return 'Phone';
	  }
	  return 'PC';
	}

	function createUUID(pushToken) {
	  var hexDigits = '0123456789abcdef',
	      s = [];

	  for (var i = 0; i < 32; i++) {
	    var charCode = '0';
	    if (pushToken.length - i - 1 >= 0) {
	      charCode = pushToken.charCodeAt(pushToken.length - i - 1);
	    }

	    s[i] = hexDigits.substr(charCode % hexDigits.length, 1);
	  }
	  return s.join('');
	}

	function getPushToken(pushSubscription) {
	  if (pushSubscription.subscriptionId) {
	    return pushSubscription.subscriptionId;
	  }

	  if (getBrowserType() === 12) {
	    return pushSubscription.endpoint;
	  }

	  return pushSubscription.endpoint.split('/').pop();
	}

	function generateHwid(applicationCode, pushToken) {
	  return applicationCode + '_' + createUUID(pushToken);
	}

	function getSubsKey(pushSubscription, key) {
	  var rawKey = pushSubscription.getKey && pushSubscription.getKey(key);
	  return rawKey ? btoa(String.fromCharCode.apply(String, new Uint8Array(rawKey))) : '';
	}

	function getAuthToken(pushSubscription) {
	  return getSubsKey(pushSubscription, 'auth');
	}

	function getPublicKey(pushSubscription) {
	  return getSubsKey(pushSubscription, 'p256dh');
	}

	function getPushwooshUrl(applicationCode) {
	  var subDomain = 'cp';
	  if (!isSafariBrowser() && applicationCode && !~applicationCode.indexOf('.')) {
	    subDomain = applicationCode + '.api';
	  }
	  return 'https://' + subDomain + '.pushwoosh.com/json/1.3/';
	}

/***/ },
/* 597 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var levels = {
	  error: 1,
	  info: 2,
	  debug: 3
	};

	var Logger = function () {
	  function Logger(level) {
	    var _this = this;

	    _classCallCheck(this, Logger);

	    this.setLevel(level);

	    Object.keys(levels).forEach(function (k) {
	      var n = levels[k];
	      _this[k] = function () {
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }

	        if (n <= _this.n) {
	          var _console;

	          (_console = console).info.apply(_console, [k].concat(args)); // eslint-disable-line no-console
	          console.trace('trace'); // eslint-disable-line no-console
	        }
	      };
	    });
	  }

	  Logger.prototype.setLevel = function setLevel(level) {
	    if (!levels[level]) {
	      level = 'info'; // eslint-disable-line no-param-reassign
	    }
	    this.n = levels[level];
	  };

	  return Logger;
	}();

	exports.default = Logger;

/***/ },
/* 598 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _BaseInit2 = __webpack_require__(599),
	    _BaseInit3 = _interopRequireDefault(_BaseInit2),
	    _createDoApiXHR = __webpack_require__(601),
	    _createDoApiXHR2 = _interopRequireDefault(_createDoApiXHR),
	    _API = __webpack_require__(603),
	    _API2 = _interopRequireDefault(_API),
	    _PushwooshError = __webpack_require__(602),
	    _PushwooshError2 = _interopRequireDefault(_PushwooshError),
	    _functions = __webpack_require__(596),
	    _constants = __webpack_require__(604);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var PushwooshSafari = function (_BaseInit) {
	  _inherits(PushwooshSafari, _BaseInit);

	  function PushwooshSafari() {
	    _classCallCheck(this, PushwooshSafari);

	    return _possibleConstructorReturn(this, _BaseInit.apply(this, arguments));
	  }

	  PushwooshSafari.prototype.getPermission = function getPermission() {
	    return window.safari.pushNotification.permission(this.webSitePushID);
	  };

	  PushwooshSafari.prototype.initSubscribe = function initSubscribe() {
	    var _this2 = this;

	    setTimeout(function () {
	      return _this2.checkRemotePermission(_this2.getPermission());
	    }, 0);
	    return new Promise(function (resolve, reject) {
	      _this2.ee.once('success', function () {
	        resolve(_this2.api);
	      });
	      _this2.ee.once('failure', reject);
	    });
	  };

	  PushwooshSafari.prototype.unsubscribe = function unsubscribe() {
	    return this.initApi().then(function (api) {
	      return api.unregisterDevice();
	    });
	  };

	  PushwooshSafari.prototype.initApi = function initApi() {
	    var _this3 = this;

	    return Promise.resolve().then(function () {
	      var permissionData = _this3.getPermission();
	      if (permissionData.permission === 'denied') {
	        var err = new _PushwooshError2.default('The user said no.', _PushwooshError2.default.codes.userDenied);
	        _this3.logger.error(err);
	        throw err;
	      }
	      if (!permissionData.deviceToken) {
	        throw new _PushwooshError2.default('permissionData.deviceToken is empty');
	      }
	      var hwid = permissionData.deviceToken.toLowerCase();
	      _this3.api = new _API2.default({
	        doPushwooshApiMethod: (0, _createDoApiXHR2.default)(_this3.pushwooshUrl, _this3.logger),
	        applicationCode: _this3.applicationCode,
	        hwid: hwid,
	        pushToken: hwid.toUpperCase()
	      });
	      _this3.sendPushStat();
	      return _this3.api;
	    });
	  };

	  PushwooshSafari.prototype.checkRemotePermission = function checkRemotePermission(permissionData) {
	    var _this4 = this;

	    this.logger.debug('permissionData', permissionData);

	    if (permissionData.permission === 'default') {
	      this.logger.debug('This is a new web service URL and its validity is unknown.');
	      window.safari.pushNotification.requestPermission(this.pushwooshUrl + 'safari', this.webSitePushID, { application: this.applicationCode }, function (perm) {
	        return _this4.checkRemotePermission(perm);
	      });
	    } else if (permissionData.permission === 'denied') {
	      var err = new _PushwooshError2.default('The user said no.', _PushwooshError2.default.codes.userDenied);
	      this.logger.error(err);
	      this.ee.emit('failure', err);
	    } else if (permissionData.permission === 'granted') {
	      this.logger.debug('The web service URL is a valid push provider, and the user said yes.');
	      this.initApi().then(function () {
	        return _this4.setDefaultTags();
	      }).then(function () {
	        return _this4.ee.emit('success');
	      });
	    }
	  };

	  PushwooshSafari.prototype.setDefaultTags = function setDefaultTags() {
	    var _this5 = this;

	    return Promise.resolve().then(function () {
	      // eslint-disable-line consistent-return
	      var keyTagsWasSettedValue = (0, _functions.getBrowserVersion)() + '_' + _this5.api.hwid + '_' + (0, _functions.getVersion)();
	      if (localStorage.getItem(_constants.keyTagsWasSetted) !== keyTagsWasSettedValue) {
	        localStorage.setItem(_constants.keyTagsWasSetted, keyTagsWasSettedValue);
	        return _this5.api.setTags({
	          // eslint-disable-next-line quote-props
	          'Language': navigator.language || 'en',
	          'Device Model': (0, _functions.getBrowserVersion)(),
	          'Device Name': (0, _functions.getDeviceName)()
	        });
	      }
	    });
	  };

	  PushwooshSafari.prototype.sendPushStat = function sendPushStat() {
	    var _this6 = this;

	    try {
	      var hashReg = /#P(.*)/,
	          hash = decodeURIComponent(document.location.hash);


	      if (hashReg.test(hash)) {
	        this.api.pushStat(hashReg.exec(hash)[1]).then(function () {
	          return _this6.logger.debug('Push stat sent successfully');
	        });
	      }
	    } catch (e) {
	      this.logger.info('error send push stat: ' + e);
	    }
	  };

	  return PushwooshSafari;
	}(_BaseInit3.default);

	exports.default = PushwooshSafari;

/***/ },
/* 599 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _eventemitter = __webpack_require__(600),
	    _eventemitter2 = _interopRequireDefault(_eventemitter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var BaseInit = function BaseInit(params) {
	  var _this = this;

	  _classCallCheck(this, BaseInit);

	  this._params = params;
	  this.ee = new _eventemitter2.default();
	  Object.keys(params).forEach(function (k) {
	    _this[k] = params[k];
	  });
	  this.logger.debug('inited with params', params);
	};

	exports.default = BaseInit;

/***/ },
/* 600 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var has = Object.prototype.hasOwnProperty;

	//
	// We store our EE objects in a plain object whose properties are event names.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// `~` to make sure that the built-in object properties are not overridden or
	// used as an attack vector.
	// We also assume that `Object.create(null)` is available when the event name
	// is an ES6 Symbol.
	//
	var prefix = typeof Object.create !== 'function' ? '~' : false;

	/**
	 * Representation of a single EventEmitter function.
	 *
	 * @param {Function} fn Event handler to be called.
	 * @param {Mixed} context Context for function execution.
	 * @param {Boolean} [once=false] Only emit once
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}

	/**
	 * Minimal EventEmitter interface that is molded against the Node.js
	 * EventEmitter interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() { /* Nothing to set */ }

	/**
	 * Hold the assigned EventEmitters by name.
	 *
	 * @type {Object}
	 * @private
	 */
	EventEmitter.prototype._events = undefined;

	/**
	 * Return an array listing the events for which the emitter has registered
	 * listeners.
	 *
	 * @returns {Array}
	 * @api public
	 */
	EventEmitter.prototype.eventNames = function eventNames() {
	  var events = this._events
	    , names = []
	    , name;

	  if (!events) return names;

	  for (name in events) {
	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	  }

	  if (Object.getOwnPropertySymbols) {
	    return names.concat(Object.getOwnPropertySymbols(events));
	  }

	  return names;
	};

	/**
	 * Return a list of assigned event listeners.
	 *
	 * @param {String} event The events that should be listed.
	 * @param {Boolean} exists We only need to know if there are listeners.
	 * @returns {Array|Boolean}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event, exists) {
	  var evt = prefix ? prefix + event : event
	    , available = this._events && this._events[evt];

	  if (exists) return !!available;
	  if (!available) return [];
	  if (available.fn) return [available.fn];

	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	    ee[i] = available[i].fn;
	  }

	  return ee;
	};

	/**
	 * Emit an event to all registered event listeners.
	 *
	 * @param {String} event The name of the event.
	 * @returns {Boolean} Indication if we've emitted an event.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events || !this._events[evt]) return false;

	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;

	  if ('function' === typeof listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }

	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }

	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;

	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }

	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }

	  return true;
	};

	/**
	 * Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} [context=this] The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this)
	    , evt = prefix ? prefix + event : event;

	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }

	  return this;
	};

	/**
	 * Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} [context=this] The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true)
	    , evt = prefix ? prefix + event : event;

	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }

	  return this;
	};

	/**
	 * Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {Function} fn The listener that we need to find.
	 * @param {Mixed} context Only remove listeners matching this context.
	 * @param {Boolean} once Only remove once listeners.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events || !this._events[evt]) return this;

	  var listeners = this._events[evt]
	    , events = [];

	  if (fn) {
	    if (listeners.fn) {
	      if (
	           listeners.fn !== fn
	        || (once && !listeners.once)
	        || (context && listeners.context !== context)
	      ) {
	        events.push(listeners);
	      }
	    } else {
	      for (var i = 0, length = listeners.length; i < length; i++) {
	        if (
	             listeners[i].fn !== fn
	          || (once && !listeners[i].once)
	          || (context && listeners[i].context !== context)
	        ) {
	          events.push(listeners[i]);
	        }
	      }
	    }
	  }

	  //
	  // Reset the array, or remove it completely if we have no more listeners.
	  //
	  if (events.length) {
	    this._events[evt] = events.length === 1 ? events[0] : events;
	  } else {
	    delete this._events[evt];
	  }

	  return this;
	};

	/**
	 * Remove all listeners or only the listeners for the specified event.
	 *
	 * @param {String} event The event want to remove all listeners for.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  if (!this._events) return this;

	  if (event) delete this._events[prefix ? prefix + event : event];
	  else this._events = prefix ? {} : Object.create(null);

	  return this;
	};

	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};

	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;

	//
	// Expose the module.
	//
	if (true) {
	  module.exports = EventEmitter;
	}


/***/ },
/* 601 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.default = createDoApiXHR;

	var _PushwooshError = __webpack_require__(602),
	    _PushwooshError2 = _interopRequireDefault(_PushwooshError);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function createDoApiXHR(pushwooshUrl, logger) {
	  return function doApiXHR(methodName, request) {
	    logger.debug('Performing ' + methodName + ' call to Pushwoosh with arguments: ' + JSON.stringify(request));
	    return new Promise(function (resolve, reject) {
	      try {
	        var xhr = new XMLHttpRequest(),
	            url = pushwooshUrl + methodName,
	            params = { request: request };


	        xhr.open('POST', url, true);
	        xhr.setRequestHeader('Content-Type', 'text/plain;charset=UTF-8');
	        xhr.onload = function xhrOnLoad() {
	          if (this.status == 200) {
	            // eslint-disable-line eqeqeq
	            var response = JSON.parse(this.responseText);
	            if (response.status_code == 200) {
	              // eslint-disable-line eqeqeq
	              logger.debug(methodName + ' call to Pushwoosh has been successful');
	              resolve(response.response);
	            } else {
	              var logText = new _PushwooshError2.default('Error occurred during the ' + methodName + ' call to Pushwoosh: ' + response.status_message);
	              logger.error(logText);
	              reject(logText);
	            }
	          } else {
	            var _logText = new _PushwooshError2.default('Error occurred, status code: ' + this.status);
	            logger.error(_logText);
	            reject(_logText);
	          }
	        };
	        xhr.onerror = function xhrOnError(e) {
	          var logText = new _PushwooshError2.default('Pushwoosh response to ' + methodName + ' call in not ok: ' + e);
	          logger.error(logText);
	          reject(logText);
	        };
	        xhr.send(JSON.stringify(params));
	      } catch (e) {
	        var logText = new _PushwooshError2.default('Exception while ' + methodName + ' the device: ' + e);
	        logger.error(logText);
	        reject(logText);
	      }
	    });
	  };
	}

/***/ },
/* 602 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var PushwooshError = function (_Error) {
	  _inherits(PushwooshError, _Error);

	  function PushwooshError(text, code) {
	    _classCallCheck(this, PushwooshError);

	    var _this = _possibleConstructorReturn(this, _Error.call(this, text));

	    _this.code = code;
	    return _this;
	  }

	  return PushwooshError;
	}(Error);

	PushwooshError.codes = {
	  userDenied: 'user_denied'
	};

	exports.default = PushwooshError;

/***/ },
/* 603 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.createErrorAPI = createErrorAPI;

	var _functions = __webpack_require__(596);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var methods = ['doPushwooshApiMethod', 'registerDevice', 'unregisterDevice', 'applicationOpen', 'setTags', 'getTags', 'pushStat'];

	function createErrorAPI(error) {
	  return methods.reduce(function (api, methodName) {
	    api[methodName] = function () {
	      return Promise.reject(error);
	    }; // eslint-disable-line no-param-reassign
	    return api;
	  }, {});
	}

	var PushwooshAPI = function () {
	  function PushwooshAPI(params) {
	    _classCallCheck(this, PushwooshAPI);

	    this.doPushwooshApiMethod = params.doPushwooshApiMethod;
	    this.applicationCode = params.applicationCode;
	    this.hwid = params.hwid;
	    this.pushToken = params.pushToken;
	    this.publicKey = params.publicKey;
	    this.authToken = params.authToken;
	    this.language = params.language;
	  }

	  PushwooshAPI.prototype.callAPI = function callAPI(methodName, methodParams) {
	    return this.doPushwooshApiMethod(methodName, _extends({}, methodParams, {
	      application: this.applicationCode,
	      hwid: this.hwid
	    }));
	  };

	  PushwooshAPI.prototype.registerDevice = function registerDevice() {
	    return this.callAPI('registerDevice', {
	      push_token: this.pushToken,
	      public_key: this.publicKey,
	      auth_token: this.authToken,
	      language: this.language || 'en',
	      timezone: -new Date().getTimezoneOffset() * 60,
	      device_model: (0, _functions.getBrowserVersion)(),
	      device_name: (0, _functions.getDeviceName)(),
	      device_type: (0, _functions.getBrowserType)()
	    });
	  };

	  PushwooshAPI.prototype.unregisterDevice = function unregisterDevice() {
	    return this.callAPI('unregisterDevice');
	  };

	  PushwooshAPI.prototype.applicationOpen = function applicationOpen() {
	    return this.callAPI('applicationOpen', {
	      push_token: this.pushToken,
	      timezone: -new Date().getTimezoneOffset() * 60,
	      device_type: (0, _functions.getBrowserType)()
	    });
	  };

	  PushwooshAPI.prototype.setTags = function setTags(tags) {
	    return this.callAPI('setTags', { tags: tags });
	  };

	  PushwooshAPI.prototype.getTags = function getTags() {
	    return this.callAPI('getTags');
	  };

	  PushwooshAPI.prototype.pushStat = function pushStat(hash) {
	    return this.callAPI('pushStat', { hash: hash });
	  };

	  PushwooshAPI.create = function create(subscription, applicationCode, doPushwooshApiMethod, language) {
	    var pushToken = (0, _functions.getPushToken)(subscription);

	    return new PushwooshAPI({
	      doPushwooshApiMethod: doPushwooshApiMethod,
	      applicationCode: applicationCode,
	      hwid: (0, _functions.generateHwid)(applicationCode, pushToken),
	      pushToken: pushToken,
	      publicKey: (0, _functions.getPublicKey)(subscription),
	      authToken: (0, _functions.getAuthToken)(subscription),
	      language: language
	    });
	  };

	  return PushwooshAPI;
	}();

	exports.default = PushwooshAPI;

/***/ },
/* 604 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	var keyTagsWasSetted = exports.keyTagsWasSetted = 'pushwooshDefaultTagsWasSetted';
	var keyWasRegistered = exports.keyWasRegistered = 'pushwooshWasRegistered';
	var keyApplicationCode = exports.keyApplicationCode = 'pushwooshApplicationCode';

	var defaultWorkerUrl = exports.defaultWorkerUrl = '/pushwoosh-service-worker-light.js';
	var defaultWorkerSecondUrl = exports.defaultWorkerSecondUrl = '/pushwoosh-service-worker-dark.js';

	var keyDefaultNotificationTitle = exports.keyDefaultNotificationTitle = 'pushwooshDefaultNotificationTitle';
	var keyDefaultNotificationImage = exports.keyDefaultNotificationImage = 'pushwooshDefaultNotificationImage';
	var keyDefaultNotificationUrl = exports.keyDefaultNotificationUrl = 'pushwooshDefaultNotificationUrl';
	var defaultNotificationTitle = exports.defaultNotificationTitle = 'Pushwoosh notification';
	var defaultNotificationImage = exports.defaultNotificationImage = 'https://cp.pushwoosh.com/img/logo-medium.png';
	var defaultNotificationUrl = exports.defaultNotificationUrl = '/';

	var keyWorkerSDKVersion = exports.keyWorkerSDKVersion = 'pushwooshWorkerSDKVersion';

	var keyLanguage = exports.keyLanguage = 'pushwooshLanguage';

	var keyLastSentAppOpen = exports.keyLastSentAppOpen = 'pushwooshLastSentAppOpen';

/***/ },
/* 605 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _storage = __webpack_require__(595),
	    _BaseInit2 = __webpack_require__(599),
	    _BaseInit3 = _interopRequireDefault(_BaseInit2),
	    _createDoApiXHR = __webpack_require__(601),
	    _createDoApiXHR2 = _interopRequireDefault(_createDoApiXHR),
	    _API = __webpack_require__(603),
	    _API2 = _interopRequireDefault(_API),
	    _PushwooshError = __webpack_require__(602),
	    _PushwooshError2 = _interopRequireDefault(_PushwooshError),
	    _functions = __webpack_require__(596),
	    _constants = __webpack_require__(604);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var PushwooshWorker = function (_BaseInit) {
	  _inherits(PushwooshWorker, _BaseInit);

	  function PushwooshWorker() {
	    _classCallCheck(this, PushwooshWorker);

	    return _possibleConstructorReturn(this, _BaseInit.apply(this, arguments));
	  }

	  PushwooshWorker.prototype.initSubscribe = function initSubscribe() {
	    var _this2 = this;

	    return navigator.serviceWorker.getRegistration().then(function (serviceWorkerRegistration) {
	      _this2.logger.debug('sw', serviceWorkerRegistration);
	      if (!serviceWorkerRegistration || serviceWorkerRegistration.installing == null) {
	        return _this2.registerSW();
	      }
	      return serviceWorkerRegistration;
	    }).then(function (serviceWorkerRegistration) {
	      return _this2.subscribeForPushes(serviceWorkerRegistration);
	    }).then(function () {
	      return _this2.api;
	    });
	  };

	  PushwooshWorker.prototype.unsubscribe = function unsubscribe() {
	    return Promise.all([this.initApi(), navigator.serviceWorker.getRegistration().then(function (reg) {
	      return reg.pushManager.getSubscription();
	    })]).then(function (_ref) {
	      var api = _ref[0],
	          subs = _ref[1];

	      return api.unregisterDevice().then(function () {
	        return subs.unsubscribe();
	      });
	    });
	  };

	  PushwooshWorker.prototype.initApi = function initApi() {
	    var _this3 = this;

	    return Promise.all([_storage.keyValue.set(_constants.keyApplicationCode, this.applicationCode), _storage.keyValue.set(_constants.keyDefaultNotificationTitle, this.defaultNotificationTitle), _storage.keyValue.set(_constants.keyDefaultNotificationImage, this.defaultNotificationImage), _storage.keyValue.set(_constants.keyDefaultNotificationUrl, this.defaultNotificationUrl), _storage.keyValue.set(_constants.keyLanguage, navigator.language)]).then(function () {
	      if (Notification.permission === 'denied') {
	        var err = new _PushwooshError2.default('The user has blocked notifications.', _PushwooshError2.default.codes.userDenied);
	        _this3.logger.error(err);
	        throw err;
	      }
	      return navigator.serviceWorker.getRegistration();
	    }).then(function (serviceWorkerRegistration) {
	      if (!serviceWorkerRegistration) {
	        var err = new _PushwooshError2.default('No serviceWorkerRegistration');
	        _this3.logger.error(err);
	        throw err;
	      }
	      if (_this3.workerSecondUrl && serviceWorkerRegistration.active) {
	        return _storage.keyValue.get(_constants.keyWorkerSDKVersion).then(function (workerSDKVersion) {
	          var curVersion = (0, _functions.getVersion)();
	          _this3.logger.debug('workerSDKVersion===curVersion', workerSDKVersion, curVersion);
	          if (workerSDKVersion !== curVersion) {
	            _this3.logger.debug('re-register for new version');
	            return _this3.registerSW(('' + serviceWorkerRegistration.active.scriptURL).indexOf(_this3.workerUrl) > -1);
	          }
	          return serviceWorkerRegistration;
	        });
	      }
	      return serviceWorkerRegistration;
	    }).then(function (serviceWorkerRegistration) {
	      _this3.logger.debug('sw', serviceWorkerRegistration);
	      return serviceWorkerRegistration.pushManager.getSubscription();
	    }).then(function (subscription) {
	      if (!subscription) {
	        var err = new _PushwooshError2.default('No subscription');
	        _this3.logger.error(err);
	        throw err;
	      }
	      _this3.api = _API2.default.create(subscription, _this3.applicationCode, (0, _createDoApiXHR2.default)(_this3.pushwooshUrl, _this3.logger), navigator.language);
	      return _this3.api;
	    });
	  };

	  PushwooshWorker.prototype.getWorkerUrl = function getWorkerUrl(second) {
	    return (second ? this.workerSecondUrl : this.workerUrl) + '?applicationCode=' + this.applicationCode;
	  };

	  PushwooshWorker.prototype.registerSW = function registerSW(second) {
	    this.logger.debug('register worker', second);
	    return navigator.serviceWorker.register(this.getWorkerUrl(second));
	  };

	  PushwooshWorker.prototype.subscribeForPushes = function subscribeForPushes() {
	    var _this4 = this;

	    return navigator.serviceWorker.ready.then(function (serviceWorkerRegistration) {
	      return serviceWorkerRegistration.pushManager.getSubscription().then(function (subscription) {
	        if (!subscription) {
	          return serviceWorkerRegistration.pushManager.subscribe({
	            userVisibleOnly: true
	          });
	        }
	        return subscription;
	      }).then(function () {
	        return _this4.register();
	      }).catch(function (e) {
	        var err = void 0;
	        if (Notification.permission === 'denied') {
	          err = new _PushwooshError2.default('Permission for Notifications was denied.', _PushwooshError2.default.codes.userDenied);
	        } else {
	          err = 'Unable to subscribe to push: ' + e;
	        }
	        _this4.logger.error(err);
	        throw err;
	      });
	    });
	  };

	  PushwooshWorker.prototype.register = function register() {
	    var _this5 = this;

	    return this.initApi().then(function () {
	      // eslint-disable-line consistent-return
	      var api = _this5.api,
	          keyWasRegisteredValue = api.hwid + '_' + (0, _functions.getVersion)();
	      if (localStorage.getItem(_constants.keyWasRegistered) !== keyWasRegisteredValue) {
	        localStorage.setItem(_constants.keyWasRegistered, keyWasRegisteredValue);
	        return api.registerDevice();
	      }
	    });
	  };

	  return PushwooshWorker;
	}(_BaseInit3.default);

	exports.default = PushwooshWorker;

/***/ },
/* 606 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var BinarySocket = __webpack_require__(427);
	var updateBalance = __webpack_require__(607);
	var Client = __webpack_require__(420);
	var Clock = __webpack_require__(463);
	var GTM = __webpack_require__(464);
	var Header = __webpack_require__(494);
	var Login = __webpack_require__(465);
	var getPropertyValue = __webpack_require__(417).getPropertyValue;
	var jpResidence = __webpack_require__(425).jpResidence;
	var SessionDurationLimit = __webpack_require__(608);
	var Cookies = __webpack_require__(422);

	var BinarySocketGeneral = function () {
	    'use strict';

	    var onOpen = function onOpen(is_ready) {
	        Header.hideNotification();
	        if (is_ready) {
	            if (!Login.isLoginPages()) {
	                Client.validateLoginid();
	                BinarySocket.send({ website_status: 1, subscribe: 1 });
	            }
	            Clock.startClock();
	        }
	    };

	    var onMessage = function onMessage(response) {
	        var is_available = void 0;
	        switch (response.msg_type) {
	            case 'website_status':
	                is_available = /^up$/i.test(response.website_status.site_status);
	                if (is_available && !BinarySocket.availability()) {
	                    window.location.reload();
	                } else if (!is_available) {
	                    Header.displayNotification(response.website_status.message, true);
	                }
	                BinarySocket.availability(is_available);
	                break;
	            case 'authorize':
	                if (response.error) {
	                    var is_active_tab = sessionStorage.getItem('active_tab') === '1';
	                    if (getPropertyValue(response, ['error', 'code']) === 'SelfExclusion' && is_active_tab) {
	                        sessionStorage.removeItem('active_tab');
	                        window.alert(response.error.message);
	                    }
	                    Client.sendLogoutRequest(is_active_tab);
	                } else if (response.authorize.loginid !== Cookies.get('loginid')) {
	                    Client.sendLogoutRequest(true);
	                } else {
	                    if (!Login.isLoginPages()) {
	                        Client.responseAuthorize(response);
	                        BinarySocket.send({ balance: 1, subscribe: 1 });
	                        BinarySocket.send({ get_settings: 1 });
	                        BinarySocket.send({ get_account_status: 1 });
	                        BinarySocket.send({ payout_currencies: 1 });
	                        setResidence(response.authorize.country || Cookies.get('residence'));
	                        if (!Client.get('is_virtual') && !jpResidence()) {
	                            BinarySocket.send({ get_self_exclusion: 1 });
	                            // TODO: remove this when back-end adds it as a status to get_account_status
	                            BinarySocket.send({ get_financial_assessment: 1 });
	                        }
	                    }
	                    BinarySocket.sendBuffered();
	                }
	                break;
	            case 'balance':
	                updateBalance(response);
	                break;
	            case 'logout':
	                Client.doLogout(response);
	                break;
	            case 'landing_company':
	                Header.upgradeMessageVisibility();
	                if (!response.error) {
	                    // Header.metatraderMenuItemVisibility(response); // to be uncommented once MetaTrader launched
	                    var company = Client.currentLandingCompany();
	                    if (company) {
	                        Client.set('default_currency', company.legal_default_currency);
	                    }
	                }
	                break;
	            case 'get_self_exclusion':
	                SessionDurationLimit.exclusionResponseHandler(response);
	                break;
	            case 'payout_currencies':
	                Client.set('currencies', response.payout_currencies.join(','));
	                break;
	            case 'get_settings':
	                if (response.get_settings) {
	                    setResidence(response.get_settings.country_code);
	                    GTM.eventHandler(response.get_settings);
	                    if (response.get_settings.is_authenticated_payment_agent) {
	                        $('#topMenuPaymentAgent').setVisibility(1);
	                    }
	                    Client.set('first_name', response.get_settings.first_name);
	                }
	                break;
	            // no default
	        }
	    };

	    var setResidence = function setResidence(residence) {
	        if (residence) {
	            Client.setCookie('residence', residence);
	            Client.set('residence', residence);
	            BinarySocket.send({ landing_company: residence });
	        }
	    };

	    var initOptions = function initOptions() {
	        return {
	            onOpen: onOpen,
	            onMessage: onMessage,
	            notify: Header.displayNotification,
	            is_logged_in: Client.isLoggedIn()
	        };
	    };

	    return {
	        initOptions: initOptions
	    };
	}();

	module.exports = BinarySocketGeneral;

/***/ },
/* 607 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var PortfolioInit = __webpack_require__(511);
	var updateContractBalance = __webpack_require__(461).updateContractBalance;
	var Client = __webpack_require__(420);
	var formatMoney = __webpack_require__(433).formatMoney;

	var updateBalance = function updateBalance(response) {
	    if (response.hasOwnProperty('error')) {
	        console.log(response.error.message);
	        return;
	    }
	    var balance = response.balance.balance;
	    Client.set('balance', balance);
	    PortfolioInit.updateBalance();
	    var currency = response.balance.currency;
	    if (!currency) {
	        return;
	    }
	    var view = formatMoney(currency, balance);
	    updateContractBalance(balance);
	    $('.topMenuBalance').text(view).css('visibility', 'visible');
	};

	module.exports = updateBalance;

/***/ },
/* 608 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var moment = __webpack_require__(305);
	var Client = __webpack_require__(420);
	var localize = __webpack_require__(428).localize;

	var SessionDurationLimit = function () {
	    'use strict';

	    var warning = void 0,
	        timeout_before = void 0,
	        timeout = void 0,
	        timeout_logout = void 0;

	    var init = function init() {
	        clearTimeout(timeout_before);
	        clearTimeout(timeout);
	        clearTimeout(timeout_logout);
	        $('#session_limit').remove();

	        warning = 10 * 1000; // milliseconds before limit to display the warning message

	        var limit = Client.get('session_duration_limit') * 1;
	        var now = moment().unix();
	        var start = Client.get('session_start') * 1;
	        var math_limit = Math.pow(2, 31) - 1;
	        var remained = (limit + start - now) * 1000;
	        if (remained < 0) remained = warning;

	        var setTimeOut = function setTimeOut() {
	            timeout = setTimeout(displayWarning, remained - warning);
	            timeout_logout = setTimeout(Client.sendLogoutRequest, remained);
	        };

	        // limit of setTimeout is this number
	        if (remained > math_limit) {
	            remained %= math_limit;
	            timeout_before = setTimeout(init, remained);
	        } else {
	            setTimeOut();
	        }
	    };

	    var exclusionResponseHandler = function exclusionResponseHandler(response) {
	        if (response.hasOwnProperty('error') || !response.hasOwnProperty('get_self_exclusion')) {
	            return;
	        }

	        var limit = response.get_self_exclusion.session_duration_limit * 60;
	        if (isNaN(limit) || limit <= 0) return;

	        Client.set('session_duration_limit', limit);
	        window.addEventListener('storage', init, false);

	        init();
	    };

	    var displayWarning = function displayWarning() {
	        $('body').append($('<div/>', { id: 'session_limit', class: 'lightbox' }).append($('<div/>', { class: 'gr-padding-10 gr-gutter', text: localize('Your session duration limit will end in [_1] seconds.', [warning / 1000]) })));
	        $('#session_limit').click(function () {
	            $(this).remove();
	        });
	    };

	    return {
	        exclusionResponseHandler: exclusionResponseHandler
	    };
	}();

	module.exports = SessionDurationLimit;

/***/ }
/******/ ]);
//# sourceMappingURL=binary.js.map